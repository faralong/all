// Generated by Construct, the game and app creator :: https://www.construct.net
"use strict";
(function(a, b) {
    "object" === typeof exports && "undefined" !== typeof module ? b(exports) : "function" === typeof define && define.amd ? define(["exports"], b) : (a = "undefined" !== typeof globalThis ? globalThis : a || self,
    b(a.glMatrix = {}))
}
)(this, function(a) {
    function b(g, k, n) {
        var q = k[0]
          , t = k[1]
          , u = k[2];
        k = k[3];
        var w = n[0]
          , y = n[1]
          , z = n[2];
        n = n[3];
        g[0] = q * w + u * y;
        g[1] = t * w + k * y;
        g[2] = q * z + u * n;
        g[3] = t * z + k * n;
        return g
    }
    function c(g, k, n) {
        g[0] = k[0] - n[0];
        g[1] = k[1] - n[1];
        g[2] = k[2] - n[2];
        g[3] = k[3] - n[3];
        return g
    }
    function d(g, k, n) {
        var q = k[0]
          , t = k[1]
          , u = k[2]
          , w = k[3]
          , y = k[4];
        k = k[5];
        var z = n[0]
          , C = n[1]
          , E = n[2]
          , G = n[3]
          , J = n[4];
        n = n[5];
        g[0] = q * z + u * C;
        g[1] = t * z + w * C;
        g[2] = q * E + u * G;
        g[3] = t * E + w * G;
        g[4] = q * J + u * n + y;
        g[5] = t * J + w * n + k;
        return g
    }
    function e(g, k, n) {
        g[0] = k[0] - n[0];
        g[1] = k[1] - n[1];
        g[2] = k[2] - n[2];
        g[3] = k[3] - n[3];
        g[4] = k[4] - n[4];
        g[5] = k[5] - n[5];
        return g
    }
    function f() {
        var g = new V(9);
        V != Float32Array && (g[1] = 0,
        g[2] = 0,
        g[3] = 0,
        g[5] = 0,
        g[6] = 0,
        g[7] = 0);
        g[0] = 1;
        g[4] = 1;
        g[8] = 1;
        return g
    }
    function h(g, k, n) {
        var q = k[0]
          , t = k[1]
          , u = k[2]
          , w = k[3]
          , y = k[4]
          , z = k[5]
          , C = k[6]
          , E = k[7];
        k = k[8];
        var G = n[0]
          , J = n[1]
          , H = n[2]
          , N = n[3]
          , O = n[4]
          , L = n[5]
          , R = n[6]
          , P = n[7];
        n = n[8];
        g[0] = G * q + J * w + H * C;
        g[1] = G * t + J * y + H * E;
        g[2] = G * u + J * z + H * k;
        g[3] = N * q + O * w + L * C;
        g[4] = N * t + O * y + L * E;
        g[5] = N * u + O * z + L * k;
        g[6] = R * q + P * w + n * C;
        g[7] = R * t + P * y + n * E;
        g[8] = R * u + P * z + n * k;
        return g
    }
    function l(g, k, n) {
        g[0] = k[0] - n[0];
        g[1] = k[1] - n[1];
        g[2] = k[2] - n[2];
        g[3] = k[3] - n[3];
        g[4] = k[4] - n[4];
        g[5] = k[5] - n[5];
        g[6] = k[6] - n[6];
        g[7] = k[7] - n[7];
        g[8] = k[8] - n[8];
        return g
    }
    function m(g) {
        g[0] = 1;
        g[1] = 0;
        g[2] = 0;
        g[3] = 0;
        g[4] = 0;
        g[5] = 1;
        g[6] = 0;
        g[7] = 0;
        g[8] = 0;
        g[9] = 0;
        g[10] = 1;
        g[11] = 0;
        g[12] = 0;
        g[13] = 0;
        g[14] = 0;
        g[15] = 1;
        return g
    }
    function p(g, k, n) {
        var q = k[0]
          , t = k[1]
          , u = k[2]
          , w = k[3]
          , y = k[4]
          , z = k[5]
          , C = k[6]
          , E = k[7]
          , G = k[8]
          , J = k[9]
          , H = k[10]
          , N = k[11]
          , O = k[12]
          , L = k[13]
          , R = k[14];
        k = k[15];
        var P = n[0]
          , T = n[1]
          , U = n[2]
          , S = n[3];
        g[0] = P * q + T * y + U * G + S * O;
        g[1] = P * t + T * z + U * J + S * L;
        g[2] = P * u + T * C + U * H + S * R;
        g[3] = P * w + T * E + U * N + S * k;
        P = n[4];
        T = n[5];
        U = n[6];
        S = n[7];
        g[4] = P * q + T * y + U * G + S * O;
        g[5] = P * t + T * z + U * J + S * L;
        g[6] = P * u + T * C + U * H + S * R;
        g[7] = P * w + T * E + U * N + S * k;
        P = n[8];
        T = n[9];
        U = n[10];
        S = n[11];
        g[8] = P * q + T * y + U * G + S * O;
        g[9] = P * t + T * z + U * J + S * L;
        g[10] = P * u + T * C + U * H + S * R;
        g[11] = P * w + T * E + U * N + S * k;
        P = n[12];
        T = n[13];
        U = n[14];
        S = n[15];
        g[12] = P * q + T * y + U * G + S * O;
        g[13] = P * t + T * z + U * J + S * L;
        g[14] = P * u + T * C + U * H + S * R;
        g[15] = P * w + T * E + U * N + S * k;
        return g
    }
    function r(g, k, n) {
        var q = k[0]
          , t = k[1]
          , u = k[2]
          , w = k[3]
          , y = q + q
          , z = t + t
          , C = u + u;
        k = q * y;
        var E = q * z;
        q *= C;
        var G = t * z;
        t *= C;
        u *= C;
        y *= w;
        z *= w;
        w *= C;
        g[0] = 1 - (G + u);
        g[1] = E + w;
        g[2] = q - z;
        g[3] = 0;
        g[4] = E - w;
        g[5] = 1 - (k + u);
        g[6] = t + y;
        g[7] = 0;
        g[8] = q + z;
        g[9] = t - y;
        g[10] = 1 - (k + G);
        g[11] = 0;
        g[12] = n[0];
        g[13] = n[1];
        g[14] = n[2];
        g[15] = 1;
        return g
    }
    function v(g, k) {
        g[0] = k[12];
        g[1] = k[13];
        g[2] = k[14];
        return g
    }
    function x(g, k) {
        var n = k[4]
          , q = k[5]
          , t = k[6]
          , u = k[8]
          , w = k[9]
          , y = k[10];
        g[0] = Math.hypot(k[0], k[1], k[2]);
        g[1] = Math.hypot(n, q, t);
        g[2] = Math.hypot(u, w, y);
        return g
    }
    function B(g, k) {
        var n = new V(3);
        x(n, k);
        var q = 1 / n[0]
          , t = 1 / n[1]
          , u = 1 / n[2]
          , w = k[0] * q;
        n = k[1] * t;
        var y = k[2] * u
          , z = k[4] * q
          , C = k[5] * t
          , E = k[6] * u;
        q *= k[8];
        t *= k[9];
        k = k[10] * u;
        u = w + C + k;
        0 < u ? (w = 2 * Math.sqrt(u + 1),
        g[3] = .25 * w,
        g[0] = (E - t) / w,
        g[1] = (q - y) / w,
        g[2] = (n - z) / w) : w > C && w > k ? (w = 2 * Math.sqrt(1 + w - C - k),
        g[3] = (E - t) / w,
        g[0] = .25 * w,
        g[1] = (n + z) / w,
        g[2] = (q + y) / w) : C > k ? (w = 2 * Math.sqrt(1 + C - w - k),
        g[3] = (q - y) / w,
        g[0] = (n + z) / w,
        g[1] = .25 * w,
        g[2] = (E + t) / w) : (w = 2 * Math.sqrt(1 + k - w - C),
        g[3] = (n - z) / w,
        g[0] = (q + y) / w,
        g[1] = (E + t) / w,
        g[2] = .25 * w);
        return g
    }
    function A(g, k, n, q, t) {
        k = 1 / Math.tan(k / 2);
        g[0] = k / n;
        g[1] = 0;
        g[2] = 0;
        g[3] = 0;
        g[4] = 0;
        g[5] = k;
        g[6] = 0;
        g[7] = 0;
        g[8] = 0;
        g[9] = 0;
        g[11] = -1;
        g[12] = 0;
        g[13] = 0;
        g[15] = 0;
        null != t && Infinity !== t ? (n = 1 / (q - t),
        g[10] = (t + q) * n,
        g[14] = 2 * t * q * n) : (g[10] = -1,
        g[14] = -2 * q);
        return g
    }
    function D(g, k, n, q, t, u, w) {
        var y = 1 / (k - n)
          , z = 1 / (q - t)
          , C = 1 / (u - w);
        g[0] = -2 * y;
        g[1] = 0;
        g[2] = 0;
        g[3] = 0;
        g[4] = 0;
        g[5] = -2 * z;
        g[6] = 0;
        g[7] = 0;
        g[8] = 0;
        g[9] = 0;
        g[10] = 2 * C;
        g[11] = 0;
        g[12] = (k + n) * y;
        g[13] = (t + q) * z;
        g[14] = (w + u) * C;
        g[15] = 1;
        return g
    }
    function F(g, k, n) {
        g[0] = k[0] - n[0];
        g[1] = k[1] - n[1];
        g[2] = k[2] - n[2];
        g[3] = k[3] - n[3];
        g[4] = k[4] - n[4];
        g[5] = k[5] - n[5];
        g[6] = k[6] - n[6];
        g[7] = k[7] - n[7];
        g[8] = k[8] - n[8];
        g[9] = k[9] - n[9];
        g[10] = k[10] - n[10];
        g[11] = k[11] - n[11];
        g[12] = k[12] - n[12];
        g[13] = k[13] - n[13];
        g[14] = k[14] - n[14];
        g[15] = k[15] - n[15];
        return g
    }
    function I() {
        var g = new V(3);
        V != Float32Array && (g[0] = 0,
        g[1] = 0,
        g[2] = 0);
        return g
    }
    function K(g) {
        return Math.hypot(g[0], g[1], g[2])
    }
    function M(g, k, n) {
        var q = new V(3);
        q[0] = g;
        q[1] = k;
        q[2] = n;
        return q
    }
    function Q(g, k, n) {
        g[0] = k[0] - n[0];
        g[1] = k[1] - n[1];
        g[2] = k[2] - n[2];
        return g
    }
    function W(g, k, n) {
        g[0] = k[0] * n[0];
        g[1] = k[1] * n[1];
        g[2] = k[2] * n[2];
        return g
    }
    function ca(g, k, n) {
        g[0] = k[0] / n[0];
        g[1] = k[1] / n[1];
        g[2] = k[2] / n[2];
        return g
    }
    function ia(g, k) {
        return Math.hypot(k[0] - g[0], k[1] - g[1], k[2] - g[2])
    }
    function ka(g, k) {
        var n = k[0] - g[0]
          , q = k[1] - g[1];
        g = k[2] - g[2];
        return n * n + q * q + g * g
    }
    function za(g) {
        var k = g[0]
          , n = g[1];
        g = g[2];
        return k * k + n * n + g * g
    }
    function Aa(g, k) {
        var n = k[0]
          , q = k[1]
          , t = k[2];
        n = n * n + q * q + t * t;
        0 < n && (n = 1 / Math.sqrt(n));
        g[0] = k[0] * n;
        g[1] = k[1] * n;
        g[2] = k[2] * n;
        return g
    }
    function oa(g, k) {
        return g[0] * k[0] + g[1] * k[1] + g[2] * k[2]
    }
    function pa(g, k, n) {
        var q = k[0]
          , t = k[1];
        k = k[2];
        var u = n[0]
          , w = n[1];
        n = n[2];
        g[0] = t * n - k * w;
        g[1] = k * u - q * n;
        g[2] = q * w - t * u;
        return g
    }
    function Ba() {
        var g = new V(4);
        V != Float32Array && (g[0] = 0,
        g[1] = 0,
        g[2] = 0,
        g[3] = 0);
        return g
    }
    function Ca(g) {
        var k = new V(4);
        k[0] = g[0];
        k[1] = g[1];
        k[2] = g[2];
        k[3] = g[3];
        return k
    }
    function Da(g, k, n, q) {
        var t = new V(4);
        t[0] = g;
        t[1] = k;
        t[2] = n;
        t[3] = q;
        return t
    }
    function qa(g, k) {
        g[0] = k[0];
        g[1] = k[1];
        g[2] = k[2];
        g[3] = k[3];
        return g
    }
    function Ea(g, k, n, q, t) {
        g[0] = k;
        g[1] = n;
        g[2] = q;
        g[3] = t;
        return g
    }
    function Fa(g, k, n) {
        g[0] = k[0] + n[0];
        g[1] = k[1] + n[1];
        g[2] = k[2] + n[2];
        g[3] = k[3] + n[3];
        return g
    }
    function Ga(g, k, n) {
        g[0] = k[0] - n[0];
        g[1] = k[1] - n[1];
        g[2] = k[2] - n[2];
        g[3] = k[3] - n[3];
        return g
    }
    function Ha(g, k, n) {
        g[0] = k[0] * n[0];
        g[1] = k[1] * n[1];
        g[2] = k[2] * n[2];
        g[3] = k[3] * n[3];
        return g
    }
    function Ia(g, k, n) {
        g[0] = k[0] / n[0];
        g[1] = k[1] / n[1];
        g[2] = k[2] / n[2];
        g[3] = k[3] / n[3];
        return g
    }
    function ua(g, k, n) {
        g[0] = k[0] * n;
        g[1] = k[1] * n;
        g[2] = k[2] * n;
        g[3] = k[3] * n;
        return g
    }
    function Ja(g, k) {
        return Math.hypot(k[0] - g[0], k[1] - g[1], k[2] - g[2], k[3] - g[3])
    }
    function Ka(g, k) {
        var n = k[0] - g[0]
          , q = k[1] - g[1]
          , t = k[2] - g[2];
        g = k[3] - g[3];
        return n * n + q * q + t * t + g * g
    }
    function la(g) {
        return Math.hypot(g[0], g[1], g[2], g[3])
    }
    function ja(g) {
        var k = g[0]
          , n = g[1]
          , q = g[2];
        g = g[3];
        return k * k + n * n + q * q + g * g
    }
    function ra(g, k) {
        var n = k[0]
          , q = k[1]
          , t = k[2];
        k = k[3];
        var u = n * n + q * q + t * t + k * k;
        0 < u && (u = 1 / Math.sqrt(u));
        g[0] = n * u;
        g[1] = q * u;
        g[2] = t * u;
        g[3] = k * u;
        return g
    }
    function ma(g, k) {
        return g[0] * k[0] + g[1] * k[1] + g[2] * k[2] + g[3] * k[3]
    }
    function La(g, k, n, q) {
        var t = k[0]
          , u = k[1]
          , w = k[2];
        k = k[3];
        g[0] = t + q * (n[0] - t);
        g[1] = u + q * (n[1] - u);
        g[2] = w + q * (n[2] - w);
        g[3] = k + q * (n[3] - k);
        return g
    }
    function Ma(g, k) {
        return g[0] === k[0] && g[1] === k[1] && g[2] === k[2] && g[3] === k[3]
    }
    function sa() {
        var g = new V(4);
        V != Float32Array && (g[0] = 0,
        g[1] = 0,
        g[2] = 0);
        g[3] = 1;
        return g
    }
    function Na(g, k, n) {
        n *= .5;
        var q = Math.sin(n);
        g[0] = q * k[0];
        g[1] = q * k[1];
        g[2] = q * k[2];
        g[3] = Math.cos(n);
        return g
    }
    function Oa(g, k, n) {
        var q = k[0]
          , t = k[1]
          , u = k[2];
        k = k[3];
        var w = n[0]
          , y = n[1]
          , z = n[2];
        n = n[3];
        g[0] = q * n + k * w + t * z - u * y;
        g[1] = t * n + k * y + u * w - q * z;
        g[2] = u * n + k * z + q * y - t * w;
        g[3] = k * n - q * w - t * y - u * z;
        return g
    }
    function Pa(g, k, n) {
        n *= .5;
        var q = k[0]
          , t = k[1]
          , u = k[2];
        k = k[3];
        var w = Math.sin(n);
        n = Math.cos(n);
        g[0] = q * n + k * w;
        g[1] = t * n + u * w;
        g[2] = u * n - t * w;
        g[3] = k * n - q * w;
        return g
    }
    function Qa(g, k, n) {
        n *= .5;
        var q = k[0]
          , t = k[1]
          , u = k[2];
        k = k[3];
        var w = Math.sin(n);
        n = Math.cos(n);
        g[0] = q * n - u * w;
        g[1] = t * n + k * w;
        g[2] = u * n + q * w;
        g[3] = k * n - t * w;
        return g
    }
    function Ra(g, k, n) {
        n *= .5;
        var q = k[0]
          , t = k[1]
          , u = k[2];
        k = k[3];
        var w = Math.sin(n);
        n = Math.cos(n);
        g[0] = q * n + t * w;
        g[1] = t * n - q * w;
        g[2] = u * n + k * w;
        g[3] = k * n - u * w;
        return g
    }
    function Sa(g, k) {
        var n = k[0]
          , q = k[1]
          , t = k[2]
          , u = Math.sqrt(n * n + q * q + t * t);
        k = Math.exp(k[3]);
        var w = 0 < u ? k * Math.sin(u) / u : 0;
        g[0] = n * w;
        g[1] = q * w;
        g[2] = t * w;
        g[3] = k * Math.cos(u);
        return g
    }
    function Ta(g, k) {
        var n = k[0]
          , q = k[1]
          , t = k[2];
        k = k[3];
        var u = Math.sqrt(n * n + q * q + t * t);
        u = 0 < u ? Math.atan2(u, k) / u : 0;
        g[0] = n * u;
        g[1] = q * u;
        g[2] = t * u;
        g[3] = .5 * Math.log(n * n + q * q + t * t + k * k);
        return g
    }
    function ta(g, k, n, q) {
        var t = k[0]
          , u = k[1]
          , w = k[2];
        k = k[3];
        var y = n[0]
          , z = n[1]
          , C = n[2];
        n = n[3];
        var E = t * y + u * z + w * C + k * n;
        0 > E && (E = -E,
        y = -y,
        z = -z,
        C = -C,
        n = -n);
        if (1E-6 < 1 - E) {
            var G = Math.acos(E);
            var J = Math.sin(G);
            E = Math.sin((1 - q) * G) / J;
            q = Math.sin(q * G) / J
        } else
            E = 1 - q;
        g[0] = E * t + q * y;
        g[1] = E * u + q * z;
        g[2] = E * w + q * C;
        g[3] = E * k + q * n;
        return g
    }
    function Ua(g, k) {
        var n = k[0] + k[4] + k[8];
        if (0 < n)
            n = Math.sqrt(n + 1),
            g[3] = .5 * n,
            n = .5 / n,
            g[0] = (k[5] - k[7]) * n,
            g[1] = (k[6] - k[2]) * n,
            g[2] = (k[1] - k[3]) * n;
        else {
            var q = 0;
            k[4] > k[0] && (q = 1);
            k[8] > k[3 * q + q] && (q = 2);
            var t = (q + 1) % 3
              , u = (q + 2) % 3;
            n = Math.sqrt(k[3 * q + q] - k[3 * t + t] - k[3 * u + u] + 1);
            g[q] = .5 * n;
            n = .5 / n;
            g[3] = (k[3 * t + u] - k[3 * u + t]) * n;
            g[t] = (k[3 * t + q] + k[3 * q + t]) * n;
            g[u] = (k[3 * u + q] + k[3 * q + u]) * n
        }
        return g
    }
    function Va(g, k, n) {
        var q = .5 * n[0]
          , t = .5 * n[1];
        n = .5 * n[2];
        var u = k[0]
          , w = k[1]
          , y = k[2];
        k = k[3];
        g[0] = u;
        g[1] = w;
        g[2] = y;
        g[3] = k;
        g[4] = q * k + t * y - n * w;
        g[5] = t * k + n * u - q * y;
        g[6] = n * k + q * w - t * u;
        g[7] = -q * u - t * w - n * y;
        return g
    }
    function Wa(g, k) {
        g[0] = k[0];
        g[1] = k[1];
        g[2] = k[2];
        g[3] = k[3];
        g[4] = k[4];
        g[5] = k[5];
        g[6] = k[6];
        g[7] = k[7];
        return g
    }
    function Xa(g, k, n) {
        var q = k[0]
          , t = k[1]
          , u = k[2]
          , w = k[3]
          , y = n[4]
          , z = n[5]
          , C = n[6]
          , E = n[7]
          , G = k[4]
          , J = k[5]
          , H = k[6];
        k = k[7];
        var N = n[0]
          , O = n[1]
          , L = n[2];
        n = n[3];
        g[0] = q * n + w * N + t * L - u * O;
        g[1] = t * n + w * O + u * N - q * L;
        g[2] = u * n + w * L + q * O - t * N;
        g[3] = w * n - q * N - t * O - u * L;
        g[4] = q * E + w * y + t * C - u * z + G * n + k * N + J * L - H * O;
        g[5] = t * E + w * z + u * y - q * C + J * n + k * O + H * N - G * L;
        g[6] = u * E + w * C + q * z - t * y + H * n + k * L + G * O - J * N;
        g[7] = w * E - q * y - t * z - u * C + k * n - G * N - J * O - H * L;
        return g
    }
    function Ya() {
        var g = new V(2);
        V != Float32Array && (g[0] = 0,
        g[1] = 0);
        return g
    }
    function Za(g, k, n) {
        g[0] = k[0] - n[0];
        g[1] = k[1] - n[1];
        return g
    }
    function $a(g, k, n) {
        g[0] = k[0] * n[0];
        g[1] = k[1] * n[1];
        return g
    }
    function ab(g, k, n) {
        g[0] = k[0] / n[0];
        g[1] = k[1] / n[1];
        return g
    }
    function bb(g, k) {
        return Math.hypot(k[0] - g[0], k[1] - g[1])
    }
    function cb(g, k) {
        var n = k[0] - g[0];
        g = k[1] - g[1];
        return n * n + g * g
    }
    function db(g) {
        return Math.hypot(g[0], g[1])
    }
    function eb(g) {
        var k = g[0];
        g = g[1];
        return k * k + g * g
    }
    var V = "undefined" !== typeof Float32Array ? Float32Array : Array
      , ha = Math.random
      , hb = Math.PI / 180;
    Math.hypot || (Math.hypot = function() {
        for (var g = 0, k = arguments.length; k--; )
            g += arguments[k] * arguments[k];
        return Math.sqrt(g)
    }
    );
    var ib = Object.freeze({
        __proto__: null,
        EPSILON: 1E-6,
        get ARRAY_TYPE() {
            return V
        },
        RANDOM: ha,
        ANGLE_ORDER: "zyx",
        setMatrixArrayType: function(g) {
            V = g
        },
        toRadian: function(g) {
            return g * hb
        },
        equals: function(g, k) {
            return Math.abs(g - k) <= 1E-6 * Math.max(1, Math.abs(g), Math.abs(k))
        }
    })
      , jb = Object.freeze({
        __proto__: null,
        create: function() {
            var g = new V(4);
            V != Float32Array && (g[1] = 0,
            g[2] = 0);
            g[0] = 1;
            g[3] = 1;
            return g
        },
        clone: function(g) {
            var k = new V(4);
            k[0] = g[0];
            k[1] = g[1];
            k[2] = g[2];
            k[3] = g[3];
            return k
        },
        copy: function(g, k) {
            g[0] = k[0];
            g[1] = k[1];
            g[2] = k[2];
            g[3] = k[3];
            return g
        },
        identity: function(g) {
            g[0] = 1;
            g[1] = 0;
            g[2] = 0;
            g[3] = 1;
            return g
        },
        fromValues: function(g, k, n, q) {
            var t = new V(4);
            t[0] = g;
            t[1] = k;
            t[2] = n;
            t[3] = q;
            return t
        },
        set: function(g, k, n, q, t) {
            g[0] = k;
            g[1] = n;
            g[2] = q;
            g[3] = t;
            return g
        },
        transpose: function(g, k) {
            if (g === k) {
                var n = k[1];
                g[1] = k[2];
                g[2] = n
            } else
                g[0] = k[0],
                g[1] = k[2],
                g[2] = k[1],
                g[3] = k[3];
            return g
        },
        invert: function(g, k) {
            var n = k[0]
              , q = k[1]
              , t = k[2];
            k = k[3];
            var u = n * k - t * q;
            if (!u)
                return null;
            u = 1 / u;
            g[0] = k * u;
            g[1] = -q * u;
            g[2] = -t * u;
            g[3] = n * u;
            return g
        },
        adjoint: function(g, k) {
            var n = k[0];
            g[0] = k[3];
            g[1] = -k[1];
            g[2] = -k[2];
            g[3] = n;
            return g
        },
        determinant: function(g) {
            return g[0] * g[3] - g[2] * g[1]
        },
        multiply: b,
        rotate: function(g, k, n) {
            var q = k[0]
              , t = k[1]
              , u = k[2];
            k = k[3];
            var w = Math.sin(n);
            n = Math.cos(n);
            g[0] = q * n + u * w;
            g[1] = t * n + k * w;
            g[2] = q * -w + u * n;
            g[3] = t * -w + k * n;
            return g
        },
        scale: function(g, k, n) {
            var q = k[1]
              , t = k[2]
              , u = k[3]
              , w = n[0];
            n = n[1];
            g[0] = k[0] * w;
            g[1] = q * w;
            g[2] = t * n;
            g[3] = u * n;
            return g
        },
        fromRotation: function(g, k) {
            var n = Math.sin(k);
            k = Math.cos(k);
            g[0] = k;
            g[1] = n;
            g[2] = -n;
            g[3] = k;
            return g
        },
        fromScaling: function(g, k) {
            g[0] = k[0];
            g[1] = 0;
            g[2] = 0;
            g[3] = k[1];
            return g
        },
        str: function(g) {
            return "mat2(" + g[0] + ", " + g[1] + ", " + g[2] + ", " + g[3] + ")"
        },
        frob: function(g) {
            return Math.hypot(g[0], g[1], g[2], g[3])
        },
        LDU: function(g, k, n, q) {
            g[2] = q[2] / q[0];
            n[0] = q[0];
            n[1] = q[1];
            n[3] = q[3] - g[2] * n[1];
            return [g, k, n]
        },
        add: function(g, k, n) {
            g[0] = k[0] + n[0];
            g[1] = k[1] + n[1];
            g[2] = k[2] + n[2];
            g[3] = k[3] + n[3];
            return g
        },
        subtract: c,
        exactEquals: function(g, k) {
            return g[0] === k[0] && g[1] === k[1] && g[2] === k[2] && g[3] === k[3]
        },
        equals: function(g, k) {
            var n = g[0]
              , q = g[1]
              , t = g[2];
            g = g[3];
            var u = k[0]
              , w = k[1]
              , y = k[2];
            k = k[3];
            return Math.abs(n - u) <= 1E-6 * Math.max(1, Math.abs(n), Math.abs(u)) && Math.abs(q - w) <= 1E-6 * Math.max(1, Math.abs(q), Math.abs(w)) && Math.abs(t - y) <= 1E-6 * Math.max(1, Math.abs(t), Math.abs(y)) && Math.abs(g - k) <= 1E-6 * Math.max(1, Math.abs(g), Math.abs(k))
        },
        multiplyScalar: function(g, k, n) {
            g[0] = k[0] * n;
            g[1] = k[1] * n;
            g[2] = k[2] * n;
            g[3] = k[3] * n;
            return g
        },
        multiplyScalarAndAdd: function(g, k, n, q) {
            g[0] = k[0] + n[0] * q;
            g[1] = k[1] + n[1] * q;
            g[2] = k[2] + n[2] * q;
            g[3] = k[3] + n[3] * q;
            return g
        },
        mul: b,
        sub: c
    })
      , kb = Object.freeze({
        __proto__: null,
        create: function() {
            var g = new V(6);
            V != Float32Array && (g[1] = 0,
            g[2] = 0,
            g[4] = 0,
            g[5] = 0);
            g[0] = 1;
            g[3] = 1;
            return g
        },
        clone: function(g) {
            var k = new V(6);
            k[0] = g[0];
            k[1] = g[1];
            k[2] = g[2];
            k[3] = g[3];
            k[4] = g[4];
            k[5] = g[5];
            return k
        },
        copy: function(g, k) {
            g[0] = k[0];
            g[1] = k[1];
            g[2] = k[2];
            g[3] = k[3];
            g[4] = k[4];
            g[5] = k[5];
            return g
        },
        identity: function(g) {
            g[0] = 1;
            g[1] = 0;
            g[2] = 0;
            g[3] = 1;
            g[4] = 0;
            g[5] = 0;
            return g
        },
        fromValues: function(g, k, n, q, t, u) {
            var w = new V(6);
            w[0] = g;
            w[1] = k;
            w[2] = n;
            w[3] = q;
            w[4] = t;
            w[5] = u;
            return w
        },
        set: function(g, k, n, q, t, u, w) {
            g[0] = k;
            g[1] = n;
            g[2] = q;
            g[3] = t;
            g[4] = u;
            g[5] = w;
            return g
        },
        invert: function(g, k) {
            var n = k[0]
              , q = k[1]
              , t = k[2]
              , u = k[3]
              , w = k[4];
            k = k[5];
            var y = n * u - q * t;
            if (!y)
                return null;
            y = 1 / y;
            g[0] = u * y;
            g[1] = -q * y;
            g[2] = -t * y;
            g[3] = n * y;
            g[4] = (t * k - u * w) * y;
            g[5] = (q * w - n * k) * y;
            return g
        },
        determinant: function(g) {
            return g[0] * g[3] - g[1] * g[2]
        },
        multiply: d,
        rotate: function(g, k, n) {
            var q = k[0]
              , t = k[1]
              , u = k[2]
              , w = k[3]
              , y = k[4];
            k = k[5];
            var z = Math.sin(n);
            n = Math.cos(n);
            g[0] = q * n + u * z;
            g[1] = t * n + w * z;
            g[2] = q * -z + u * n;
            g[3] = t * -z + w * n;
            g[4] = y;
            g[5] = k;
            return g
        },
        scale: function(g, k, n) {
            var q = k[1]
              , t = k[2]
              , u = k[3]
              , w = k[4]
              , y = k[5]
              , z = n[0];
            n = n[1];
            g[0] = k[0] * z;
            g[1] = q * z;
            g[2] = t * n;
            g[3] = u * n;
            g[4] = w;
            g[5] = y;
            return g
        },
        translate: function(g, k, n) {
            var q = k[0]
              , t = k[1]
              , u = k[2]
              , w = k[3]
              , y = k[4];
            k = k[5];
            var z = n[0];
            n = n[1];
            g[0] = q;
            g[1] = t;
            g[2] = u;
            g[3] = w;
            g[4] = q * z + u * n + y;
            g[5] = t * z + w * n + k;
            return g
        },
        fromRotation: function(g, k) {
            var n = Math.sin(k);
            k = Math.cos(k);
            g[0] = k;
            g[1] = n;
            g[2] = -n;
            g[3] = k;
            g[4] = 0;
            g[5] = 0;
            return g
        },
        fromScaling: function(g, k) {
            g[0] = k[0];
            g[1] = 0;
            g[2] = 0;
            g[3] = k[1];
            g[4] = 0;
            g[5] = 0;
            return g
        },
        fromTranslation: function(g, k) {
            g[0] = 1;
            g[1] = 0;
            g[2] = 0;
            g[3] = 1;
            g[4] = k[0];
            g[5] = k[1];
            return g
        },
        str: function(g) {
            return "mat2d(" + g[0] + ", " + g[1] + ", " + g[2] + ", " + g[3] + ", " + g[4] + ", " + g[5] + ")"
        },
        frob: function(g) {
            return Math.hypot(g[0], g[1], g[2], g[3], g[4], g[5], 1)
        },
        add: function(g, k, n) {
            g[0] = k[0] + n[0];
            g[1] = k[1] + n[1];
            g[2] = k[2] + n[2];
            g[3] = k[3] + n[3];
            g[4] = k[4] + n[4];
            g[5] = k[5] + n[5];
            return g
        },
        subtract: e,
        multiplyScalar: function(g, k, n) {
            g[0] = k[0] * n;
            g[1] = k[1] * n;
            g[2] = k[2] * n;
            g[3] = k[3] * n;
            g[4] = k[4] * n;
            g[5] = k[5] * n;
            return g
        },
        multiplyScalarAndAdd: function(g, k, n, q) {
            g[0] = k[0] + n[0] * q;
            g[1] = k[1] + n[1] * q;
            g[2] = k[2] + n[2] * q;
            g[3] = k[3] + n[3] * q;
            g[4] = k[4] + n[4] * q;
            g[5] = k[5] + n[5] * q;
            return g
        },
        exactEquals: function(g, k) {
            return g[0] === k[0] && g[1] === k[1] && g[2] === k[2] && g[3] === k[3] && g[4] === k[4] && g[5] === k[5]
        },
        equals: function(g, k) {
            var n = g[0]
              , q = g[1]
              , t = g[2]
              , u = g[3]
              , w = g[4];
            g = g[5];
            var y = k[0]
              , z = k[1]
              , C = k[2]
              , E = k[3]
              , G = k[4];
            k = k[5];
            return Math.abs(n - y) <= 1E-6 * Math.max(1, Math.abs(n), Math.abs(y)) && Math.abs(q - z) <= 1E-6 * Math.max(1, Math.abs(q), Math.abs(z)) && Math.abs(t - C) <= 1E-6 * Math.max(1, Math.abs(t), Math.abs(C)) && Math.abs(u - E) <= 1E-6 * Math.max(1, Math.abs(u), Math.abs(E)) && Math.abs(w - G) <= 1E-6 * Math.max(1, Math.abs(w), Math.abs(G)) && Math.abs(g - k) <= 1E-6 * Math.max(1, Math.abs(g), Math.abs(k))
        },
        mul: d,
        sub: e
    })
      , lb = Object.freeze({
        __proto__: null,
        create: f,
        fromMat4: function(g, k) {
            g[0] = k[0];
            g[1] = k[1];
            g[2] = k[2];
            g[3] = k[4];
            g[4] = k[5];
            g[5] = k[6];
            g[6] = k[8];
            g[7] = k[9];
            g[8] = k[10];
            return g
        },
        clone: function(g) {
            var k = new V(9);
            k[0] = g[0];
            k[1] = g[1];
            k[2] = g[2];
            k[3] = g[3];
            k[4] = g[4];
            k[5] = g[5];
            k[6] = g[6];
            k[7] = g[7];
            k[8] = g[8];
            return k
        },
        copy: function(g, k) {
            g[0] = k[0];
            g[1] = k[1];
            g[2] = k[2];
            g[3] = k[3];
            g[4] = k[4];
            g[5] = k[5];
            g[6] = k[6];
            g[7] = k[7];
            g[8] = k[8];
            return g
        },
        fromValues: function(g, k, n, q, t, u, w, y, z) {
            var C = new V(9);
            C[0] = g;
            C[1] = k;
            C[2] = n;
            C[3] = q;
            C[4] = t;
            C[5] = u;
            C[6] = w;
            C[7] = y;
            C[8] = z;
            return C
        },
        set: function(g, k, n, q, t, u, w, y, z, C) {
            g[0] = k;
            g[1] = n;
            g[2] = q;
            g[3] = t;
            g[4] = u;
            g[5] = w;
            g[6] = y;
            g[7] = z;
            g[8] = C;
            return g
        },
        identity: function(g) {
            g[0] = 1;
            g[1] = 0;
            g[2] = 0;
            g[3] = 0;
            g[4] = 1;
            g[5] = 0;
            g[6] = 0;
            g[7] = 0;
            g[8] = 1;
            return g
        },
        transpose: function(g, k) {
            if (g === k) {
                var n = k[1]
                  , q = k[2]
                  , t = k[5];
                g[1] = k[3];
                g[2] = k[6];
                g[3] = n;
                g[5] = k[7];
                g[6] = q;
                g[7] = t
            } else
                g[0] = k[0],
                g[1] = k[3],
                g[2] = k[6],
                g[3] = k[1],
                g[4] = k[4],
                g[5] = k[7],
                g[6] = k[2],
                g[7] = k[5],
                g[8] = k[8];
            return g
        },
        invert: function(g, k) {
            var n = k[0]
              , q = k[1]
              , t = k[2]
              , u = k[3]
              , w = k[4]
              , y = k[5]
              , z = k[6]
              , C = k[7];
            k = k[8];
            var E = k * w - y * C
              , G = -k * u + y * z
              , J = C * u - w * z
              , H = n * E + q * G + t * J;
            if (!H)
                return null;
            H = 1 / H;
            g[0] = E * H;
            g[1] = (-k * q + t * C) * H;
            g[2] = (y * q - t * w) * H;
            g[3] = G * H;
            g[4] = (k * n - t * z) * H;
            g[5] = (-y * n + t * u) * H;
            g[6] = J * H;
            g[7] = (-C * n + q * z) * H;
            g[8] = (w * n - q * u) * H;
            return g
        },
        adjoint: function(g, k) {
            var n = k[0]
              , q = k[1]
              , t = k[2]
              , u = k[3]
              , w = k[4]
              , y = k[5]
              , z = k[6]
              , C = k[7];
            k = k[8];
            g[0] = w * k - y * C;
            g[1] = t * C - q * k;
            g[2] = q * y - t * w;
            g[3] = y * z - u * k;
            g[4] = n * k - t * z;
            g[5] = t * u - n * y;
            g[6] = u * C - w * z;
            g[7] = q * z - n * C;
            g[8] = n * w - q * u;
            return g
        },
        determinant: function(g) {
            var k = g[3]
              , n = g[4]
              , q = g[5]
              , t = g[6]
              , u = g[7]
              , w = g[8];
            return g[0] * (w * n - q * u) + g[1] * (-w * k + q * t) + g[2] * (u * k - n * t)
        },
        multiply: h,
        translate: function(g, k, n) {
            var q = k[0]
              , t = k[1]
              , u = k[2]
              , w = k[3]
              , y = k[4]
              , z = k[5]
              , C = k[6]
              , E = k[7];
            k = k[8];
            var G = n[0];
            n = n[1];
            g[0] = q;
            g[1] = t;
            g[2] = u;
            g[3] = w;
            g[4] = y;
            g[5] = z;
            g[6] = G * q + n * w + C;
            g[7] = G * t + n * y + E;
            g[8] = G * u + n * z + k;
            return g
        },
        rotate: function(g, k, n) {
            var q = k[0]
              , t = k[1]
              , u = k[2]
              , w = k[3]
              , y = k[4]
              , z = k[5]
              , C = k[6]
              , E = k[7];
            k = k[8];
            var G = Math.sin(n);
            n = Math.cos(n);
            g[0] = n * q + G * w;
            g[1] = n * t + G * y;
            g[2] = n * u + G * z;
            g[3] = n * w - G * q;
            g[4] = n * y - G * t;
            g[5] = n * z - G * u;
            g[6] = C;
            g[7] = E;
            g[8] = k;
            return g
        },
        scale: function(g, k, n) {
            var q = n[0];
            n = n[1];
            g[0] = q * k[0];
            g[1] = q * k[1];
            g[2] = q * k[2];
            g[3] = n * k[3];
            g[4] = n * k[4];
            g[5] = n * k[5];
            g[6] = k[6];
            g[7] = k[7];
            g[8] = k[8];
            return g
        },
        fromTranslation: function(g, k) {
            g[0] = 1;
            g[1] = 0;
            g[2] = 0;
            g[3] = 0;
            g[4] = 1;
            g[5] = 0;
            g[6] = k[0];
            g[7] = k[1];
            g[8] = 1;
            return g
        },
        fromRotation: function(g, k) {
            var n = Math.sin(k);
            k = Math.cos(k);
            g[0] = k;
            g[1] = n;
            g[2] = 0;
            g[3] = -n;
            g[4] = k;
            g[5] = 0;
            g[6] = 0;
            g[7] = 0;
            g[8] = 1;
            return g
        },
        fromScaling: function(g, k) {
            g[0] = k[0];
            g[1] = 0;
            g[2] = 0;
            g[3] = 0;
            g[4] = k[1];
            g[5] = 0;
            g[6] = 0;
            g[7] = 0;
            g[8] = 1;
            return g
        },
        fromMat2d: function(g, k) {
            g[0] = k[0];
            g[1] = k[1];
            g[2] = 0;
            g[3] = k[2];
            g[4] = k[3];
            g[5] = 0;
            g[6] = k[4];
            g[7] = k[5];
            g[8] = 1;
            return g
        },
        fromQuat: function(g, k) {
            var n = k[0]
              , q = k[1]
              , t = k[2];
            k = k[3];
            var u = n + n
              , w = q + q
              , y = t + t;
            n *= u;
            var z = q * u;
            q *= w;
            var C = t * u
              , E = t * w;
            t *= y;
            u *= k;
            w *= k;
            k *= y;
            g[0] = 1 - q - t;
            g[3] = z - k;
            g[6] = C + w;
            g[1] = z + k;
            g[4] = 1 - n - t;
            g[7] = E - u;
            g[2] = C - w;
            g[5] = E + u;
            g[8] = 1 - n - q;
            return g
        },
        normalFromMat4: function(g, k) {
            var n = k[0]
              , q = k[1]
              , t = k[2]
              , u = k[3]
              , w = k[4]
              , y = k[5]
              , z = k[6]
              , C = k[7]
              , E = k[8]
              , G = k[9]
              , J = k[10]
              , H = k[11]
              , N = k[12]
              , O = k[13]
              , L = k[14];
            k = k[15];
            var R = n * y - q * w
              , P = n * z - t * w
              , T = n * C - u * w
              , U = q * z - t * y
              , S = q * C - u * y
              , X = t * C - u * z
              , Y = E * O - G * N
              , Z = E * L - J * N;
            E = E * k - H * N;
            var aa = G * L - J * O;
            G = G * k - H * O;
            J = J * k - H * L;
            H = R * J - P * G + T * aa + U * E - S * Z + X * Y;
            if (!H)
                return null;
            H = 1 / H;
            g[0] = (y * J - z * G + C * aa) * H;
            g[1] = (z * E - w * J - C * Z) * H;
            g[2] = (w * G - y * E + C * Y) * H;
            g[3] = (t * G - q * J - u * aa) * H;
            g[4] = (n * J - t * E + u * Z) * H;
            g[5] = (q * E - n * G - u * Y) * H;
            g[6] = (O * X - L * S + k * U) * H;
            g[7] = (L * T - N * X - k * P) * H;
            g[8] = (N * S - O * T + k * R) * H;
            return g
        },
        projection: function(g, k, n) {
            g[0] = 2 / k;
            g[1] = 0;
            g[2] = 0;
            g[3] = 0;
            g[4] = -2 / n;
            g[5] = 0;
            g[6] = -1;
            g[7] = 1;
            g[8] = 1;
            return g
        },
        str: function(g) {
            return "mat3(" + g[0] + ", " + g[1] + ", " + g[2] + ", " + g[3] + ", " + g[4] + ", " + g[5] + ", " + g[6] + ", " + g[7] + ", " + g[8] + ")"
        },
        frob: function(g) {
            return Math.hypot(g[0], g[1], g[2], g[3], g[4], g[5], g[6], g[7], g[8])
        },
        add: function(g, k, n) {
            g[0] = k[0] + n[0];
            g[1] = k[1] + n[1];
            g[2] = k[2] + n[2];
            g[3] = k[3] + n[3];
            g[4] = k[4] + n[4];
            g[5] = k[5] + n[5];
            g[6] = k[6] + n[6];
            g[7] = k[7] + n[7];
            g[8] = k[8] + n[8];
            return g
        },
        subtract: l,
        multiplyScalar: function(g, k, n) {
            g[0] = k[0] * n;
            g[1] = k[1] * n;
            g[2] = k[2] * n;
            g[3] = k[3] * n;
            g[4] = k[4] * n;
            g[5] = k[5] * n;
            g[6] = k[6] * n;
            g[7] = k[7] * n;
            g[8] = k[8] * n;
            return g
        },
        multiplyScalarAndAdd: function(g, k, n, q) {
            g[0] = k[0] + n[0] * q;
            g[1] = k[1] + n[1] * q;
            g[2] = k[2] + n[2] * q;
            g[3] = k[3] + n[3] * q;
            g[4] = k[4] + n[4] * q;
            g[5] = k[5] + n[5] * q;
            g[6] = k[6] + n[6] * q;
            g[7] = k[7] + n[7] * q;
            g[8] = k[8] + n[8] * q;
            return g
        },
        exactEquals: function(g, k) {
            return g[0] === k[0] && g[1] === k[1] && g[2] === k[2] && g[3] === k[3] && g[4] === k[4] && g[5] === k[5] && g[6] === k[6] && g[7] === k[7] && g[8] === k[8]
        },
        equals: function(g, k) {
            var n = g[0]
              , q = g[1]
              , t = g[2]
              , u = g[3]
              , w = g[4]
              , y = g[5]
              , z = g[6]
              , C = g[7];
            g = g[8];
            var E = k[0]
              , G = k[1]
              , J = k[2]
              , H = k[3]
              , N = k[4]
              , O = k[5]
              , L = k[6]
              , R = k[7];
            k = k[8];
            return Math.abs(n - E) <= 1E-6 * Math.max(1, Math.abs(n), Math.abs(E)) && Math.abs(q - G) <= 1E-6 * Math.max(1, Math.abs(q), Math.abs(G)) && Math.abs(t - J) <= 1E-6 * Math.max(1, Math.abs(t), Math.abs(J)) && Math.abs(u - H) <= 1E-6 * Math.max(1, Math.abs(u), Math.abs(H)) && Math.abs(w - N) <= 1E-6 * Math.max(1, Math.abs(w), Math.abs(N)) && Math.abs(y - O) <= 1E-6 * Math.max(1, Math.abs(y), Math.abs(O)) && Math.abs(z - L) <= 1E-6 * Math.max(1, Math.abs(z), Math.abs(L)) && Math.abs(C - R) <= 1E-6 * Math.max(1, Math.abs(C), Math.abs(R)) && Math.abs(g - k) <= 1E-6 * Math.max(1, Math.abs(g), Math.abs(k))
        },
        mul: h,
        sub: l
    })
      , mb = Object.freeze({
        __proto__: null,
        create: function() {
            var g = new V(16);
            V != Float32Array && (g[1] = 0,
            g[2] = 0,
            g[3] = 0,
            g[4] = 0,
            g[6] = 0,
            g[7] = 0,
            g[8] = 0,
            g[9] = 0,
            g[11] = 0,
            g[12] = 0,
            g[13] = 0,
            g[14] = 0);
            g[0] = 1;
            g[5] = 1;
            g[10] = 1;
            g[15] = 1;
            return g
        },
        clone: function(g) {
            var k = new V(16);
            k[0] = g[0];
            k[1] = g[1];
            k[2] = g[2];
            k[3] = g[3];
            k[4] = g[4];
            k[5] = g[5];
            k[6] = g[6];
            k[7] = g[7];
            k[8] = g[8];
            k[9] = g[9];
            k[10] = g[10];
            k[11] = g[11];
            k[12] = g[12];
            k[13] = g[13];
            k[14] = g[14];
            k[15] = g[15];
            return k
        },
        copy: function(g, k) {
            g[0] = k[0];
            g[1] = k[1];
            g[2] = k[2];
            g[3] = k[3];
            g[4] = k[4];
            g[5] = k[5];
            g[6] = k[6];
            g[7] = k[7];
            g[8] = k[8];
            g[9] = k[9];
            g[10] = k[10];
            g[11] = k[11];
            g[12] = k[12];
            g[13] = k[13];
            g[14] = k[14];
            g[15] = k[15];
            return g
        },
        fromValues: function(g, k, n, q, t, u, w, y, z, C, E, G, J, H, N, O) {
            var L = new V(16);
            L[0] = g;
            L[1] = k;
            L[2] = n;
            L[3] = q;
            L[4] = t;
            L[5] = u;
            L[6] = w;
            L[7] = y;
            L[8] = z;
            L[9] = C;
            L[10] = E;
            L[11] = G;
            L[12] = J;
            L[13] = H;
            L[14] = N;
            L[15] = O;
            return L
        },
        set: function(g, k, n, q, t, u, w, y, z, C, E, G, J, H, N, O, L) {
            g[0] = k;
            g[1] = n;
            g[2] = q;
            g[3] = t;
            g[4] = u;
            g[5] = w;
            g[6] = y;
            g[7] = z;
            g[8] = C;
            g[9] = E;
            g[10] = G;
            g[11] = J;
            g[12] = H;
            g[13] = N;
            g[14] = O;
            g[15] = L;
            return g
        },
        identity: m,
        transpose: function(g, k) {
            if (g === k) {
                var n = k[1]
                  , q = k[2]
                  , t = k[3]
                  , u = k[6]
                  , w = k[7]
                  , y = k[11];
                g[1] = k[4];
                g[2] = k[8];
                g[3] = k[12];
                g[4] = n;
                g[6] = k[9];
                g[7] = k[13];
                g[8] = q;
                g[9] = u;
                g[11] = k[14];
                g[12] = t;
                g[13] = w;
                g[14] = y
            } else
                g[0] = k[0],
                g[1] = k[4],
                g[2] = k[8],
                g[3] = k[12],
                g[4] = k[1],
                g[5] = k[5],
                g[6] = k[9],
                g[7] = k[13],
                g[8] = k[2],
                g[9] = k[6],
                g[10] = k[10],
                g[11] = k[14],
                g[12] = k[3],
                g[13] = k[7],
                g[14] = k[11],
                g[15] = k[15];
            return g
        },
        invert: function(g, k) {
            var n = k[0]
              , q = k[1]
              , t = k[2]
              , u = k[3]
              , w = k[4]
              , y = k[5]
              , z = k[6]
              , C = k[7]
              , E = k[8]
              , G = k[9]
              , J = k[10]
              , H = k[11]
              , N = k[12]
              , O = k[13]
              , L = k[14];
            k = k[15];
            var R = n * y - q * w
              , P = n * z - t * w
              , T = n * C - u * w
              , U = q * z - t * y
              , S = q * C - u * y
              , X = t * C - u * z
              , Y = E * O - G * N
              , Z = E * L - J * N
              , aa = E * k - H * N
              , da = G * L - J * O
              , ea = G * k - H * O
              , fa = J * k - H * L
              , ba = R * fa - P * ea + T * da + U * aa - S * Z + X * Y;
            if (!ba)
                return null;
            ba = 1 / ba;
            g[0] = (y * fa - z * ea + C * da) * ba;
            g[1] = (t * ea - q * fa - u * da) * ba;
            g[2] = (O * X - L * S + k * U) * ba;
            g[3] = (J * S - G * X - H * U) * ba;
            g[4] = (z * aa - w * fa - C * Z) * ba;
            g[5] = (n * fa - t * aa + u * Z) * ba;
            g[6] = (L * T - N * X - k * P) * ba;
            g[7] = (E * X - J * T + H * P) * ba;
            g[8] = (w * ea - y * aa + C * Y) * ba;
            g[9] = (q * aa - n * ea - u * Y) * ba;
            g[10] = (N * S - O * T + k * R) * ba;
            g[11] = (G * T - E * S - H * R) * ba;
            g[12] = (y * Z - w * da - z * Y) * ba;
            g[13] = (n * da - q * Z + t * Y) * ba;
            g[14] = (O * P - N * U - L * R) * ba;
            g[15] = (E * U - G * P + J * R) * ba;
            return g
        },
        adjoint: function(g, k) {
            var n = k[0]
              , q = k[1]
              , t = k[2]
              , u = k[3]
              , w = k[4]
              , y = k[5]
              , z = k[6]
              , C = k[7]
              , E = k[8]
              , G = k[9]
              , J = k[10]
              , H = k[11]
              , N = k[12]
              , O = k[13]
              , L = k[14];
            k = k[15];
            var R = n * y - q * w
              , P = n * z - t * w
              , T = n * C - u * w
              , U = q * z - t * y
              , S = q * C - u * y
              , X = t * C - u * z
              , Y = E * O - G * N
              , Z = E * L - J * N
              , aa = E * k - H * N
              , da = G * L - J * O
              , ea = G * k - H * O
              , fa = J * k - H * L;
            g[0] = y * fa - z * ea + C * da;
            g[1] = t * ea - q * fa - u * da;
            g[2] = O * X - L * S + k * U;
            g[3] = J * S - G * X - H * U;
            g[4] = z * aa - w * fa - C * Z;
            g[5] = n * fa - t * aa + u * Z;
            g[6] = L * T - N * X - k * P;
            g[7] = E * X - J * T + H * P;
            g[8] = w * ea - y * aa + C * Y;
            g[9] = q * aa - n * ea - u * Y;
            g[10] = N * S - O * T + k * R;
            g[11] = G * T - E * S - H * R;
            g[12] = y * Z - w * da - z * Y;
            g[13] = n * da - q * Z + t * Y;
            g[14] = O * P - N * U - L * R;
            g[15] = E * U - G * P + J * R;
            return g
        },
        determinant: function(g) {
            var k = g[0]
              , n = g[1]
              , q = g[2]
              , t = g[4]
              , u = g[5]
              , w = g[6]
              , y = g[8]
              , z = g[9]
              , C = g[10]
              , E = g[12]
              , G = g[13]
              , J = g[14]
              , H = k * u - n * t
              , N = k * w - q * t
              , O = n * w - q * u
              , L = y * G - z * E
              , R = y * J - C * E
              , P = z * J - C * G;
            return g[7] * (k * P - n * R + q * L) - g[3] * (t * P - u * R + w * L) + g[15] * (y * O - z * N + C * H) - g[11] * (E * O - G * N + J * H)
        },
        multiply: p,
        translate: function(g, k, n) {
            var q = n[0]
              , t = n[1];
            n = n[2];
            if (k === g)
                g[12] = k[0] * q + k[4] * t + k[8] * n + k[12],
                g[13] = k[1] * q + k[5] * t + k[9] * n + k[13],
                g[14] = k[2] * q + k[6] * t + k[10] * n + k[14],
                g[15] = k[3] * q + k[7] * t + k[11] * n + k[15];
            else {
                var u = k[0];
                var w = k[1];
                var y = k[2];
                var z = k[3];
                var C = k[4];
                var E = k[5];
                var G = k[6];
                var J = k[7];
                var H = k[8];
                var N = k[9];
                var O = k[10];
                var L = k[11];
                g[0] = u;
                g[1] = w;
                g[2] = y;
                g[3] = z;
                g[4] = C;
                g[5] = E;
                g[6] = G;
                g[7] = J;
                g[8] = H;
                g[9] = N;
                g[10] = O;
                g[11] = L;
                g[12] = u * q + C * t + H * n + k[12];
                g[13] = w * q + E * t + N * n + k[13];
                g[14] = y * q + G * t + O * n + k[14];
                g[15] = z * q + J * t + L * n + k[15]
            }
            return g
        },
        scale: function(g, k, n) {
            var q = n[0]
              , t = n[1];
            n = n[2];
            g[0] = k[0] * q;
            g[1] = k[1] * q;
            g[2] = k[2] * q;
            g[3] = k[3] * q;
            g[4] = k[4] * t;
            g[5] = k[5] * t;
            g[6] = k[6] * t;
            g[7] = k[7] * t;
            g[8] = k[8] * n;
            g[9] = k[9] * n;
            g[10] = k[10] * n;
            g[11] = k[11] * n;
            g[12] = k[12];
            g[13] = k[13];
            g[14] = k[14];
            g[15] = k[15];
            return g
        },
        rotate: function(g, k, n, q) {
            var t = q[0]
              , u = q[1];
            q = q[2];
            var w = Math.hypot(t, u, q);
            if (1E-6 > w)
                return null;
            w = 1 / w;
            t *= w;
            u *= w;
            q *= w;
            var y = Math.sin(n);
            var z = Math.cos(n);
            var C = 1 - z;
            n = k[0];
            w = k[1];
            var E = k[2];
            var G = k[3];
            var J = k[4];
            var H = k[5];
            var N = k[6];
            var O = k[7];
            var L = k[8];
            var R = k[9];
            var P = k[10];
            var T = k[11];
            var U = t * t * C + z;
            var S = u * t * C + q * y;
            var X = q * t * C - u * y;
            var Y = t * u * C - q * y;
            var Z = u * u * C + z;
            var aa = q * u * C + t * y;
            var da = t * q * C + u * y;
            t = u * q * C - t * y;
            u = q * q * C + z;
            g[0] = n * U + J * S + L * X;
            g[1] = w * U + H * S + R * X;
            g[2] = E * U + N * S + P * X;
            g[3] = G * U + O * S + T * X;
            g[4] = n * Y + J * Z + L * aa;
            g[5] = w * Y + H * Z + R * aa;
            g[6] = E * Y + N * Z + P * aa;
            g[7] = G * Y + O * Z + T * aa;
            g[8] = n * da + J * t + L * u;
            g[9] = w * da + H * t + R * u;
            g[10] = E * da + N * t + P * u;
            g[11] = G * da + O * t + T * u;
            k !== g && (g[12] = k[12],
            g[13] = k[13],
            g[14] = k[14],
            g[15] = k[15]);
            return g
        },
        rotateX: function(g, k, n) {
            var q = Math.sin(n);
            n = Math.cos(n);
            var t = k[4]
              , u = k[5]
              , w = k[6]
              , y = k[7]
              , z = k[8]
              , C = k[9]
              , E = k[10]
              , G = k[11];
            k !== g && (g[0] = k[0],
            g[1] = k[1],
            g[2] = k[2],
            g[3] = k[3],
            g[12] = k[12],
            g[13] = k[13],
            g[14] = k[14],
            g[15] = k[15]);
            g[4] = t * n + z * q;
            g[5] = u * n + C * q;
            g[6] = w * n + E * q;
            g[7] = y * n + G * q;
            g[8] = z * n - t * q;
            g[9] = C * n - u * q;
            g[10] = E * n - w * q;
            g[11] = G * n - y * q;
            return g
        },
        rotateY: function(g, k, n) {
            var q = Math.sin(n);
            n = Math.cos(n);
            var t = k[0]
              , u = k[1]
              , w = k[2]
              , y = k[3]
              , z = k[8]
              , C = k[9]
              , E = k[10]
              , G = k[11];
            k !== g && (g[4] = k[4],
            g[5] = k[5],
            g[6] = k[6],
            g[7] = k[7],
            g[12] = k[12],
            g[13] = k[13],
            g[14] = k[14],
            g[15] = k[15]);
            g[0] = t * n - z * q;
            g[1] = u * n - C * q;
            g[2] = w * n - E * q;
            g[3] = y * n - G * q;
            g[8] = t * q + z * n;
            g[9] = u * q + C * n;
            g[10] = w * q + E * n;
            g[11] = y * q + G * n;
            return g
        },
        rotateZ: function(g, k, n) {
            var q = Math.sin(n);
            n = Math.cos(n);
            var t = k[0]
              , u = k[1]
              , w = k[2]
              , y = k[3]
              , z = k[4]
              , C = k[5]
              , E = k[6]
              , G = k[7];
            k !== g && (g[8] = k[8],
            g[9] = k[9],
            g[10] = k[10],
            g[11] = k[11],
            g[12] = k[12],
            g[13] = k[13],
            g[14] = k[14],
            g[15] = k[15]);
            g[0] = t * n + z * q;
            g[1] = u * n + C * q;
            g[2] = w * n + E * q;
            g[3] = y * n + G * q;
            g[4] = z * n - t * q;
            g[5] = C * n - u * q;
            g[6] = E * n - w * q;
            g[7] = G * n - y * q;
            return g
        },
        fromTranslation: function(g, k) {
            g[0] = 1;
            g[1] = 0;
            g[2] = 0;
            g[3] = 0;
            g[4] = 0;
            g[5] = 1;
            g[6] = 0;
            g[7] = 0;
            g[8] = 0;
            g[9] = 0;
            g[10] = 1;
            g[11] = 0;
            g[12] = k[0];
            g[13] = k[1];
            g[14] = k[2];
            g[15] = 1;
            return g
        },
        fromScaling: function(g, k) {
            g[0] = k[0];
            g[1] = 0;
            g[2] = 0;
            g[3] = 0;
            g[4] = 0;
            g[5] = k[1];
            g[6] = 0;
            g[7] = 0;
            g[8] = 0;
            g[9] = 0;
            g[10] = k[2];
            g[11] = 0;
            g[12] = 0;
            g[13] = 0;
            g[14] = 0;
            g[15] = 1;
            return g
        },
        fromRotation: function(g, k, n) {
            var q = n[0]
              , t = n[1];
            n = n[2];
            var u = Math.hypot(q, t, n);
            if (1E-6 > u)
                return null;
            u = 1 / u;
            q *= u;
            t *= u;
            n *= u;
            u = Math.sin(k);
            k = Math.cos(k);
            var w = 1 - k;
            g[0] = q * q * w + k;
            g[1] = t * q * w + n * u;
            g[2] = n * q * w - t * u;
            g[3] = 0;
            g[4] = q * t * w - n * u;
            g[5] = t * t * w + k;
            g[6] = n * t * w + q * u;
            g[7] = 0;
            g[8] = q * n * w + t * u;
            g[9] = t * n * w - q * u;
            g[10] = n * n * w + k;
            g[11] = 0;
            g[12] = 0;
            g[13] = 0;
            g[14] = 0;
            g[15] = 1;
            return g
        },
        fromXRotation: function(g, k) {
            var n = Math.sin(k);
            k = Math.cos(k);
            g[0] = 1;
            g[1] = 0;
            g[2] = 0;
            g[3] = 0;
            g[4] = 0;
            g[5] = k;
            g[6] = n;
            g[7] = 0;
            g[8] = 0;
            g[9] = -n;
            g[10] = k;
            g[11] = 0;
            g[12] = 0;
            g[13] = 0;
            g[14] = 0;
            g[15] = 1;
            return g
        },
        fromYRotation: function(g, k) {
            var n = Math.sin(k);
            k = Math.cos(k);
            g[0] = k;
            g[1] = 0;
            g[2] = -n;
            g[3] = 0;
            g[4] = 0;
            g[5] = 1;
            g[6] = 0;
            g[7] = 0;
            g[8] = n;
            g[9] = 0;
            g[10] = k;
            g[11] = 0;
            g[12] = 0;
            g[13] = 0;
            g[14] = 0;
            g[15] = 1;
            return g
        },
        fromZRotation: function(g, k) {
            var n = Math.sin(k);
            k = Math.cos(k);
            g[0] = k;
            g[1] = n;
            g[2] = 0;
            g[3] = 0;
            g[4] = -n;
            g[5] = k;
            g[6] = 0;
            g[7] = 0;
            g[8] = 0;
            g[9] = 0;
            g[10] = 1;
            g[11] = 0;
            g[12] = 0;
            g[13] = 0;
            g[14] = 0;
            g[15] = 1;
            return g
        },
        fromRotationTranslation: r,
        fromQuat2: function(g, k) {
            var n = new V(3)
              , q = -k[0]
              , t = -k[1]
              , u = -k[2]
              , w = k[3]
              , y = k[4]
              , z = k[5]
              , C = k[6]
              , E = k[7]
              , G = q * q + t * t + u * u + w * w;
            0 < G ? (n[0] = 2 * (y * w + E * q + z * u - C * t) / G,
            n[1] = 2 * (z * w + E * t + C * q - y * u) / G,
            n[2] = 2 * (C * w + E * u + y * t - z * q) / G) : (n[0] = 2 * (y * w + E * q + z * u - C * t),
            n[1] = 2 * (z * w + E * t + C * q - y * u),
            n[2] = 2 * (C * w + E * u + y * t - z * q));
            r(g, k, n);
            return g
        },
        getTranslation: v,
        getScaling: x,
        getRotation: B,
        decompose: function(g, k, n, q) {
            k[0] = q[12];
            k[1] = q[13];
            k[2] = q[14];
            var t = q[0]
              , u = q[1]
              , w = q[2]
              , y = q[4]
              , z = q[5]
              , C = q[6]
              , E = q[8];
            k = q[9];
            q = q[10];
            n[0] = Math.hypot(t, u, w);
            n[1] = Math.hypot(y, z, C);
            n[2] = Math.hypot(E, k, q);
            var G = 1 / n[0]
              , J = 1 / n[1]
              , H = 1 / n[2];
            n = t * G;
            u *= J;
            w *= H;
            y *= G;
            z *= J;
            C *= H;
            E *= G;
            k *= J;
            q *= H;
            J = n + z + q;
            0 < J ? (q = 2 * Math.sqrt(J + 1),
            g[3] = .25 * q,
            g[0] = (C - k) / q,
            g[1] = (E - w) / q,
            g[2] = (u - y) / q) : n > z && n > q ? (q = 2 * Math.sqrt(1 + n - z - q),
            g[3] = (C - k) / q,
            g[0] = .25 * q,
            g[1] = (u + y) / q,
            g[2] = (E + w) / q) : z > q ? (q = 2 * Math.sqrt(1 + z - n - q),
            g[3] = (E - w) / q,
            g[0] = (u + y) / q,
            g[1] = .25 * q,
            g[2] = (C + k) / q) : (q = 2 * Math.sqrt(1 + q - n - z),
            g[3] = (u - y) / q,
            g[0] = (E + w) / q,
            g[1] = (C + k) / q,
            g[2] = .25 * q);
            return g
        },
        fromRotationTranslationScale: function(g, k, n, q) {
            var t = k[0]
              , u = k[1]
              , w = k[2]
              , y = k[3]
              , z = t + t
              , C = u + u
              , E = w + w;
            k = t * z;
            var G = t * C;
            t *= E;
            var J = u * C;
            u *= E;
            w *= E;
            z *= y;
            C *= y;
            y *= E;
            E = q[0];
            var H = q[1];
            q = q[2];
            g[0] = (1 - (J + w)) * E;
            g[1] = (G + y) * E;
            g[2] = (t - C) * E;
            g[3] = 0;
            g[4] = (G - y) * H;
            g[5] = (1 - (k + w)) * H;
            g[6] = (u + z) * H;
            g[7] = 0;
            g[8] = (t + C) * q;
            g[9] = (u - z) * q;
            g[10] = (1 - (k + J)) * q;
            g[11] = 0;
            g[12] = n[0];
            g[13] = n[1];
            g[14] = n[2];
            g[15] = 1;
            return g
        },
        fromRotationTranslationScaleOrigin: function(g, k, n, q, t) {
            var u = k[0]
              , w = k[1]
              , y = k[2]
              , z = k[3]
              , C = u + u
              , E = w + w
              , G = y + y;
            k = u * C;
            var J = u * E
              , H = u * G;
            u = w * E;
            w *= G;
            var N = y * G;
            y = z * C;
            E *= z;
            var O = z * G
              , L = q[0]
              , R = q[1];
            G = q[2];
            q = t[0];
            z = t[1];
            t = t[2];
            C = (1 - (u + N)) * L;
            var P = (J + O) * L;
            L *= H - E;
            J = (J - O) * R;
            N = (1 - (k + N)) * R;
            R *= w + y;
            H = (H + E) * G;
            w = (w - y) * G;
            k = (1 - (k + u)) * G;
            g[0] = C;
            g[1] = P;
            g[2] = L;
            g[3] = 0;
            g[4] = J;
            g[5] = N;
            g[6] = R;
            g[7] = 0;
            g[8] = H;
            g[9] = w;
            g[10] = k;
            g[11] = 0;
            g[12] = n[0] + q - (C * q + J * z + H * t);
            g[13] = n[1] + z - (P * q + N * z + w * t);
            g[14] = n[2] + t - (L * q + R * z + k * t);
            g[15] = 1;
            return g
        },
        fromQuat: function(g, k) {
            var n = k[0]
              , q = k[1]
              , t = k[2];
            k = k[3];
            var u = n + n
              , w = q + q
              , y = t + t;
            n *= u;
            var z = q * u;
            q *= w;
            var C = t * u
              , E = t * w;
            t *= y;
            u *= k;
            w *= k;
            k *= y;
            g[0] = 1 - q - t;
            g[1] = z + k;
            g[2] = C - w;
            g[3] = 0;
            g[4] = z - k;
            g[5] = 1 - n - t;
            g[6] = E + u;
            g[7] = 0;
            g[8] = C + w;
            g[9] = E - u;
            g[10] = 1 - n - q;
            g[11] = 0;
            g[12] = 0;
            g[13] = 0;
            g[14] = 0;
            g[15] = 1;
            return g
        },
        frustum: function(g, k, n, q, t, u, w) {
            var y = 1 / (n - k)
              , z = 1 / (t - q)
              , C = 1 / (u - w);
            g[0] = 2 * u * y;
            g[1] = 0;
            g[2] = 0;
            g[3] = 0;
            g[4] = 0;
            g[5] = 2 * u * z;
            g[6] = 0;
            g[7] = 0;
            g[8] = (n + k) * y;
            g[9] = (t + q) * z;
            g[10] = (w + u) * C;
            g[11] = -1;
            g[12] = 0;
            g[13] = 0;
            g[14] = w * u * 2 * C;
            g[15] = 0;
            return g
        },
        perspectiveNO: A,
        perspective: A,
        perspectiveZO: function(g, k, n, q, t) {
            k = 1 / Math.tan(k / 2);
            g[0] = k / n;
            g[1] = 0;
            g[2] = 0;
            g[3] = 0;
            g[4] = 0;
            g[5] = k;
            g[6] = 0;
            g[7] = 0;
            g[8] = 0;
            g[9] = 0;
            g[11] = -1;
            g[12] = 0;
            g[13] = 0;
            g[15] = 0;
            null != t && Infinity !== t ? (n = 1 / (q - t),
            g[10] = t * n,
            g[14] = t * q * n) : (g[10] = -1,
            g[14] = -q);
            return g
        },
        perspectiveFromFieldOfView: function(g, k, n, q) {
            var t = Math.tan(k.upDegrees * Math.PI / 180)
              , u = Math.tan(k.downDegrees * Math.PI / 180)
              , w = Math.tan(k.leftDegrees * Math.PI / 180);
            k = Math.tan(k.rightDegrees * Math.PI / 180);
            var y = 2 / (w + k)
              , z = 2 / (t + u);
            g[0] = y;
            g[1] = 0;
            g[2] = 0;
            g[3] = 0;
            g[4] = 0;
            g[5] = z;
            g[6] = 0;
            g[7] = 0;
            g[8] = -((w - k) * y * .5);
            g[9] = (t - u) * z * .5;
            g[10] = q / (n - q);
            g[11] = -1;
            g[12] = 0;
            g[13] = 0;
            g[14] = q * n / (n - q);
            g[15] = 0;
            return g
        },
        orthoNO: D,
        ortho: D,
        orthoZO: function(g, k, n, q, t, u, w) {
            var y = 1 / (k - n)
              , z = 1 / (q - t);
            w = 1 / (u - w);
            g[0] = -2 * y;
            g[1] = 0;
            g[2] = 0;
            g[3] = 0;
            g[4] = 0;
            g[5] = -2 * z;
            g[6] = 0;
            g[7] = 0;
            g[8] = 0;
            g[9] = 0;
            g[10] = w;
            g[11] = 0;
            g[12] = (k + n) * y;
            g[13] = (t + q) * z;
            g[14] = u * w;
            g[15] = 1;
            return g
        },
        lookAt: function(g, k, n, q) {
            var t = k[0]
              , u = k[1];
            k = k[2];
            var w = q[0];
            var y = q[1];
            var z = q[2];
            var C = n[0];
            q = n[1];
            var E = n[2];
            if (1E-6 > Math.abs(t - C) && 1E-6 > Math.abs(u - q) && 1E-6 > Math.abs(k - E))
                return m(g);
            n = t - C;
            q = u - q;
            C = k - E;
            var G = 1 / Math.hypot(n, q, C);
            n *= G;
            q *= G;
            C *= G;
            E = y * C - z * q;
            z = z * n - w * C;
            w = w * q - y * n;
            (G = Math.hypot(E, z, w)) ? (G = 1 / G,
            E *= G,
            z *= G,
            w *= G) : w = z = E = 0;
            y = q * w - C * z;
            var J = C * E - n * w;
            var H = n * z - q * E;
            (G = Math.hypot(y, J, H)) ? (G = 1 / G,
            y *= G,
            J *= G,
            H *= G) : H = J = y = 0;
            g[0] = E;
            g[1] = y;
            g[2] = n;
            g[3] = 0;
            g[4] = z;
            g[5] = J;
            g[6] = q;
            g[7] = 0;
            g[8] = w;
            g[9] = H;
            g[10] = C;
            g[11] = 0;
            g[12] = -(E * t + z * u + w * k);
            g[13] = -(y * t + J * u + H * k);
            g[14] = -(n * t + q * u + C * k);
            g[15] = 1;
            return g
        },
        targetTo: function(g, k, n, q) {
            var t = k[0]
              , u = k[1];
            k = k[2];
            var w = q[0]
              , y = q[1]
              , z = q[2];
            q = t - n[0];
            var C = u - n[1];
            n = k - n[2];
            var E = q * q + C * C + n * n;
            0 < E && (E = 1 / Math.sqrt(E),
            q *= E,
            C *= E,
            n *= E);
            var G = y * n - z * C;
            z = z * q - w * n;
            w = w * C - y * q;
            E = G * G + z * z + w * w;
            0 < E && (E = 1 / Math.sqrt(E),
            G *= E,
            z *= E,
            w *= E);
            g[0] = G;
            g[1] = z;
            g[2] = w;
            g[3] = 0;
            g[4] = C * w - n * z;
            g[5] = n * G - q * w;
            g[6] = q * z - C * G;
            g[7] = 0;
            g[8] = q;
            g[9] = C;
            g[10] = n;
            g[11] = 0;
            g[12] = t;
            g[13] = u;
            g[14] = k;
            g[15] = 1;
            return g
        },
        str: function(g) {
            return "mat4(" + g[0] + ", " + g[1] + ", " + g[2] + ", " + g[3] + ", " + g[4] + ", " + g[5] + ", " + g[6] + ", " + g[7] + ", " + g[8] + ", " + g[9] + ", " + g[10] + ", " + g[11] + ", " + g[12] + ", " + g[13] + ", " + g[14] + ", " + g[15] + ")"
        },
        frob: function(g) {
            return Math.hypot(g[0], g[1], g[2], g[3], g[4], g[5], g[6], g[7], g[8], g[9], g[10], g[11], g[12], g[13], g[14], g[15])
        },
        add: function(g, k, n) {
            g[0] = k[0] + n[0];
            g[1] = k[1] + n[1];
            g[2] = k[2] + n[2];
            g[3] = k[3] + n[3];
            g[4] = k[4] + n[4];
            g[5] = k[5] + n[5];
            g[6] = k[6] + n[6];
            g[7] = k[7] + n[7];
            g[8] = k[8] + n[8];
            g[9] = k[9] + n[9];
            g[10] = k[10] + n[10];
            g[11] = k[11] + n[11];
            g[12] = k[12] + n[12];
            g[13] = k[13] + n[13];
            g[14] = k[14] + n[14];
            g[15] = k[15] + n[15];
            return g
        },
        subtract: F,
        multiplyScalar: function(g, k, n) {
            g[0] = k[0] * n;
            g[1] = k[1] * n;
            g[2] = k[2] * n;
            g[3] = k[3] * n;
            g[4] = k[4] * n;
            g[5] = k[5] * n;
            g[6] = k[6] * n;
            g[7] = k[7] * n;
            g[8] = k[8] * n;
            g[9] = k[9] * n;
            g[10] = k[10] * n;
            g[11] = k[11] * n;
            g[12] = k[12] * n;
            g[13] = k[13] * n;
            g[14] = k[14] * n;
            g[15] = k[15] * n;
            return g
        },
        multiplyScalarAndAdd: function(g, k, n, q) {
            g[0] = k[0] + n[0] * q;
            g[1] = k[1] + n[1] * q;
            g[2] = k[2] + n[2] * q;
            g[3] = k[3] + n[3] * q;
            g[4] = k[4] + n[4] * q;
            g[5] = k[5] + n[5] * q;
            g[6] = k[6] + n[6] * q;
            g[7] = k[7] + n[7] * q;
            g[8] = k[8] + n[8] * q;
            g[9] = k[9] + n[9] * q;
            g[10] = k[10] + n[10] * q;
            g[11] = k[11] + n[11] * q;
            g[12] = k[12] + n[12] * q;
            g[13] = k[13] + n[13] * q;
            g[14] = k[14] + n[14] * q;
            g[15] = k[15] + n[15] * q;
            return g
        },
        exactEquals: function(g, k) {
            return g[0] === k[0] && g[1] === k[1] && g[2] === k[2] && g[3] === k[3] && g[4] === k[4] && g[5] === k[5] && g[6] === k[6] && g[7] === k[7] && g[8] === k[8] && g[9] === k[9] && g[10] === k[10] && g[11] === k[11] && g[12] === k[12] && g[13] === k[13] && g[14] === k[14] && g[15] === k[15]
        },
        equals: function(g, k) {
            var n = g[0]
              , q = g[1]
              , t = g[2]
              , u = g[3]
              , w = g[4]
              , y = g[5]
              , z = g[6]
              , C = g[7]
              , E = g[8]
              , G = g[9]
              , J = g[10]
              , H = g[11]
              , N = g[12]
              , O = g[13]
              , L = g[14];
            g = g[15];
            var R = k[0]
              , P = k[1]
              , T = k[2]
              , U = k[3]
              , S = k[4]
              , X = k[5]
              , Y = k[6]
              , Z = k[7]
              , aa = k[8]
              , da = k[9]
              , ea = k[10]
              , fa = k[11]
              , ba = k[12]
              , fb = k[13]
              , gb = k[14];
            k = k[15];
            return Math.abs(n - R) <= 1E-6 * Math.max(1, Math.abs(n), Math.abs(R)) && Math.abs(q - P) <= 1E-6 * Math.max(1, Math.abs(q), Math.abs(P)) && Math.abs(t - T) <= 1E-6 * Math.max(1, Math.abs(t), Math.abs(T)) && Math.abs(u - U) <= 1E-6 * Math.max(1, Math.abs(u), Math.abs(U)) && Math.abs(w - S) <= 1E-6 * Math.max(1, Math.abs(w), Math.abs(S)) && Math.abs(y - X) <= 1E-6 * Math.max(1, Math.abs(y), Math.abs(X)) && Math.abs(z - Y) <= 1E-6 * Math.max(1, Math.abs(z), Math.abs(Y)) && Math.abs(C - Z) <= 1E-6 * Math.max(1, Math.abs(C), Math.abs(Z)) && Math.abs(E - aa) <= 1E-6 * Math.max(1, Math.abs(E), Math.abs(aa)) && Math.abs(G - da) <= 1E-6 * Math.max(1, Math.abs(G), Math.abs(da)) && Math.abs(J - ea) <= 1E-6 * Math.max(1, Math.abs(J), Math.abs(ea)) && Math.abs(H - fa) <= 1E-6 * Math.max(1, Math.abs(H), Math.abs(fa)) && Math.abs(N - ba) <= 1E-6 * Math.max(1, Math.abs(N), Math.abs(ba)) && Math.abs(O - fb) <= 1E-6 * Math.max(1, Math.abs(O), Math.abs(fb)) && Math.abs(L - gb) <= 1E-6 * Math.max(1, Math.abs(L), Math.abs(gb)) && Math.abs(g - k) <= 1E-6 * Math.max(1, Math.abs(g), Math.abs(k))
        },
        mul: p,
        sub: F
    })
      , va = function() {
        var g = I();
        return function(k, n, q, t, u, w) {
            n || (n = 3);
            q || (q = 0);
            for (t = t ? Math.min(t * n + q, k.length) : k.length; q < t; q += n)
                g[0] = k[q],
                g[1] = k[q + 1],
                g[2] = k[q + 2],
                u(g, g, w),
                k[q] = g[0],
                k[q + 1] = g[1],
                k[q + 2] = g[2];
            return k
        }
    }();
    va = Object.freeze({
        __proto__: null,
        create: I,
        clone: function(g) {
            var k = new V(3);
            k[0] = g[0];
            k[1] = g[1];
            k[2] = g[2];
            return k
        },
        length: K,
        fromValues: M,
        copy: function(g, k) {
            g[0] = k[0];
            g[1] = k[1];
            g[2] = k[2];
            return g
        },
        set: function(g, k, n, q) {
            g[0] = k;
            g[1] = n;
            g[2] = q;
            return g
        },
        add: function(g, k, n) {
            g[0] = k[0] + n[0];
            g[1] = k[1] + n[1];
            g[2] = k[2] + n[2];
            return g
        },
        subtract: Q,
        multiply: W,
        divide: ca,
        ceil: function(g, k) {
            g[0] = Math.ceil(k[0]);
            g[1] = Math.ceil(k[1]);
            g[2] = Math.ceil(k[2]);
            return g
        },
        floor: function(g, k) {
            g[0] = Math.floor(k[0]);
            g[1] = Math.floor(k[1]);
            g[2] = Math.floor(k[2]);
            return g
        },
        min: function(g, k, n) {
            g[0] = Math.min(k[0], n[0]);
            g[1] = Math.min(k[1], n[1]);
            g[2] = Math.min(k[2], n[2]);
            return g
        },
        max: function(g, k, n) {
            g[0] = Math.max(k[0], n[0]);
            g[1] = Math.max(k[1], n[1]);
            g[2] = Math.max(k[2], n[2]);
            return g
        },
        round: function(g, k) {
            g[0] = Math.round(k[0]);
            g[1] = Math.round(k[1]);
            g[2] = Math.round(k[2]);
            return g
        },
        scale: function(g, k, n) {
            g[0] = k[0] * n;
            g[1] = k[1] * n;
            g[2] = k[2] * n;
            return g
        },
        scaleAndAdd: function(g, k, n, q) {
            g[0] = k[0] + n[0] * q;
            g[1] = k[1] + n[1] * q;
            g[2] = k[2] + n[2] * q;
            return g
        },
        distance: ia,
        squaredDistance: ka,
        squaredLength: za,
        negate: function(g, k) {
            g[0] = -k[0];
            g[1] = -k[1];
            g[2] = -k[2];
            return g
        },
        inverse: function(g, k) {
            g[0] = 1 / k[0];
            g[1] = 1 / k[1];
            g[2] = 1 / k[2];
            return g
        },
        normalize: Aa,
        dot: oa,
        cross: pa,
        lerp: function(g, k, n, q) {
            var t = k[0]
              , u = k[1];
            k = k[2];
            g[0] = t + q * (n[0] - t);
            g[1] = u + q * (n[1] - u);
            g[2] = k + q * (n[2] - k);
            return g
        },
        slerp: function(g, k, n, q) {
            var t = Math.acos(Math.min(Math.max(oa(k, n), -1), 1))
              , u = Math.sin(t)
              , w = Math.sin((1 - q) * t) / u;
            q = Math.sin(q * t) / u;
            g[0] = w * k[0] + q * n[0];
            g[1] = w * k[1] + q * n[1];
            g[2] = w * k[2] + q * n[2];
            return g
        },
        hermite: function(g, k, n, q, t, u) {
            var w = u * u
              , y = w * (2 * u - 3) + 1
              , z = w * (u - 2) + u
              , C = w * (u - 1);
            u = w * (3 - 2 * u);
            g[0] = k[0] * y + n[0] * z + q[0] * C + t[0] * u;
            g[1] = k[1] * y + n[1] * z + q[1] * C + t[1] * u;
            g[2] = k[2] * y + n[2] * z + q[2] * C + t[2] * u;
            return g
        },
        bezier: function(g, k, n, q, t, u) {
            var w = 1 - u
              , y = w * w
              , z = u * u
              , C = y * w;
            y *= 3 * u;
            w *= 3 * z;
            u *= z;
            g[0] = k[0] * C + n[0] * y + q[0] * w + t[0] * u;
            g[1] = k[1] * C + n[1] * y + q[1] * w + t[1] * u;
            g[2] = k[2] * C + n[2] * y + q[2] * w + t[2] * u;
            return g
        },
        random: function(g, k) {
            k = k || 1;
            var n = 2 * ha() * Math.PI
              , q = 2 * ha() - 1
              , t = Math.sqrt(1 - q * q) * k;
            g[0] = Math.cos(n) * t;
            g[1] = Math.sin(n) * t;
            g[2] = q * k;
            return g
        },
        transformMat4: function(g, k, n) {
            var q = k[0]
              , t = k[1];
            k = k[2];
            var u = n[3] * q + n[7] * t + n[11] * k + n[15];
            u = u || 1;
            g[0] = (n[0] * q + n[4] * t + n[8] * k + n[12]) / u;
            g[1] = (n[1] * q + n[5] * t + n[9] * k + n[13]) / u;
            g[2] = (n[2] * q + n[6] * t + n[10] * k + n[14]) / u;
            return g
        },
        transformMat3: function(g, k, n) {
            var q = k[0]
              , t = k[1];
            k = k[2];
            g[0] = q * n[0] + t * n[3] + k * n[6];
            g[1] = q * n[1] + t * n[4] + k * n[7];
            g[2] = q * n[2] + t * n[5] + k * n[8];
            return g
        },
        transformQuat: function(g, k, n) {
            var q = n[0]
              , t = n[1]
              , u = n[2]
              , w = k[0]
              , y = k[1];
            k = k[2];
            var z = t * k - u * y
              , C = u * w - q * k
              , E = q * y - t * w;
            n = 2 * n[3];
            g[0] = w + z * n + 2 * (t * E - u * C);
            g[1] = y + C * n + 2 * (u * z - q * E);
            g[2] = k + E * n + 2 * (q * C - t * z);
            return g
        },
        rotateX: function(g, k, n, q) {
            var t = []
              , u = [];
            t[0] = k[0] - n[0];
            t[1] = k[1] - n[1];
            t[2] = k[2] - n[2];
            u[0] = t[0];
            u[1] = t[1] * Math.cos(q) - t[2] * Math.sin(q);
            u[2] = t[1] * Math.sin(q) + t[2] * Math.cos(q);
            g[0] = u[0] + n[0];
            g[1] = u[1] + n[1];
            g[2] = u[2] + n[2];
            return g
        },
        rotateY: function(g, k, n, q) {
            var t = []
              , u = [];
            t[0] = k[0] - n[0];
            t[1] = k[1] - n[1];
            t[2] = k[2] - n[2];
            u[0] = t[2] * Math.sin(q) + t[0] * Math.cos(q);
            u[1] = t[1];
            u[2] = t[2] * Math.cos(q) - t[0] * Math.sin(q);
            g[0] = u[0] + n[0];
            g[1] = u[1] + n[1];
            g[2] = u[2] + n[2];
            return g
        },
        rotateZ: function(g, k, n, q) {
            var t = []
              , u = [];
            t[0] = k[0] - n[0];
            t[1] = k[1] - n[1];
            t[2] = k[2] - n[2];
            u[0] = t[0] * Math.cos(q) - t[1] * Math.sin(q);
            u[1] = t[0] * Math.sin(q) + t[1] * Math.cos(q);
            u[2] = t[2];
            g[0] = u[0] + n[0];
            g[1] = u[1] + n[1];
            g[2] = u[2] + n[2];
            return g
        },
        angle: function(g, k) {
            var n = g[0]
              , q = g[1]
              , t = g[2]
              , u = k[0]
              , w = k[1]
              , y = k[2];
            g = (n = Math.sqrt((n * n + q * q + t * t) * (u * u + w * w + y * y))) && oa(g, k) / n;
            return Math.acos(Math.min(Math.max(g, -1), 1))
        },
        zero: function(g) {
            g[0] = 0;
            g[1] = 0;
            g[2] = 0;
            return g
        },
        str: function(g) {
            return "vec3(" + g[0] + ", " + g[1] + ", " + g[2] + ")"
        },
        exactEquals: function(g, k) {
            return g[0] === k[0] && g[1] === k[1] && g[2] === k[2]
        },
        equals: function(g, k) {
            var n = g[0]
              , q = g[1];
            g = g[2];
            var t = k[0]
              , u = k[1];
            k = k[2];
            return Math.abs(n - t) <= 1E-6 * Math.max(1, Math.abs(n), Math.abs(t)) && Math.abs(q - u) <= 1E-6 * Math.max(1, Math.abs(q), Math.abs(u)) && Math.abs(g - k) <= 1E-6 * Math.max(1, Math.abs(g), Math.abs(k))
        },
        sub: Q,
        mul: W,
        div: ca,
        dist: ia,
        sqrDist: ka,
        len: K,
        sqrLen: za,
        forEach: va
    });
    var wa = function() {
        var g = Ba();
        return function(k, n, q, t, u, w) {
            n || (n = 4);
            q || (q = 0);
            for (t = t ? Math.min(t * n + q, k.length) : k.length; q < t; q += n)
                g[0] = k[q],
                g[1] = k[q + 1],
                g[2] = k[q + 2],
                g[3] = k[q + 3],
                u(g, g, w),
                k[q] = g[0],
                k[q + 1] = g[1],
                k[q + 2] = g[2],
                k[q + 3] = g[3];
            return k
        }
    }();
    wa = Object.freeze({
        __proto__: null,
        create: Ba,
        clone: Ca,
        fromValues: Da,
        copy: qa,
        set: Ea,
        add: Fa,
        subtract: Ga,
        multiply: Ha,
        divide: Ia,
        ceil: function(g, k) {
            g[0] = Math.ceil(k[0]);
            g[1] = Math.ceil(k[1]);
            g[2] = Math.ceil(k[2]);
            g[3] = Math.ceil(k[3]);
            return g
        },
        floor: function(g, k) {
            g[0] = Math.floor(k[0]);
            g[1] = Math.floor(k[1]);
            g[2] = Math.floor(k[2]);
            g[3] = Math.floor(k[3]);
            return g
        },
        min: function(g, k, n) {
            g[0] = Math.min(k[0], n[0]);
            g[1] = Math.min(k[1], n[1]);
            g[2] = Math.min(k[2], n[2]);
            g[3] = Math.min(k[3], n[3]);
            return g
        },
        max: function(g, k, n) {
            g[0] = Math.max(k[0], n[0]);
            g[1] = Math.max(k[1], n[1]);
            g[2] = Math.max(k[2], n[2]);
            g[3] = Math.max(k[3], n[3]);
            return g
        },
        round: function(g, k) {
            g[0] = Math.round(k[0]);
            g[1] = Math.round(k[1]);
            g[2] = Math.round(k[2]);
            g[3] = Math.round(k[3]);
            return g
        },
        scale: ua,
        scaleAndAdd: function(g, k, n, q) {
            g[0] = k[0] + n[0] * q;
            g[1] = k[1] + n[1] * q;
            g[2] = k[2] + n[2] * q;
            g[3] = k[3] + n[3] * q;
            return g
        },
        distance: Ja,
        squaredDistance: Ka,
        length: la,
        squaredLength: ja,
        negate: function(g, k) {
            g[0] = -k[0];
            g[1] = -k[1];
            g[2] = -k[2];
            g[3] = -k[3];
            return g
        },
        inverse: function(g, k) {
            g[0] = 1 / k[0];
            g[1] = 1 / k[1];
            g[2] = 1 / k[2];
            g[3] = 1 / k[3];
            return g
        },
        normalize: ra,
        dot: ma,
        cross: function(g, k, n, q) {
            var t = n[0] * q[1] - n[1] * q[0]
              , u = n[0] * q[2] - n[2] * q[0]
              , w = n[0] * q[3] - n[3] * q[0]
              , y = n[1] * q[2] - n[2] * q[1]
              , z = n[1] * q[3] - n[3] * q[1];
            n = n[2] * q[3] - n[3] * q[2];
            q = k[0];
            var C = k[1]
              , E = k[2];
            k = k[3];
            g[0] = C * n - E * z + k * y;
            g[1] = -(q * n) + E * w - k * u;
            g[2] = q * z - C * w + k * t;
            g[3] = -(q * y) + C * u - E * t;
            return g
        },
        lerp: La,
        random: function(g, k) {
            k = k || 1;
            do {
                var n = 2 * ha() - 1;
                var q = 2 * ha() - 1;
                var t = n * n + q * q
            } while (1 <= t);
            do {
                var u = 2 * ha() - 1;
                var w = 2 * ha() - 1;
                var y = u * u + w * w
            } while (1 <= y);
            t = Math.sqrt((1 - t) / y);
            g[0] = k * n;
            g[1] = k * q;
            g[2] = k * u * t;
            g[3] = k * w * t;
            return g
        },
        transformMat4: function(g, k, n) {
            var q = k[0]
              , t = k[1]
              , u = k[2];
            k = k[3];
            g[0] = n[0] * q + n[4] * t + n[8] * u + n[12] * k;
            g[1] = n[1] * q + n[5] * t + n[9] * u + n[13] * k;
            g[2] = n[2] * q + n[6] * t + n[10] * u + n[14] * k;
            g[3] = n[3] * q + n[7] * t + n[11] * u + n[15] * k;
            return g
        },
        transformQuat: function(g, k, n) {
            var q = k[0]
              , t = k[1]
              , u = k[2]
              , w = n[0]
              , y = n[1]
              , z = n[2];
            n = n[3];
            var C = n * q + y * u - z * t
              , E = n * t + z * q - w * u
              , G = n * u + w * t - y * q;
            q = -w * q - y * t - z * u;
            g[0] = C * n + q * -w + E * -z - G * -y;
            g[1] = E * n + q * -y + G * -w - C * -z;
            g[2] = G * n + q * -z + C * -y - E * -w;
            g[3] = k[3];
            return g
        },
        zero: function(g) {
            g[0] = 0;
            g[1] = 0;
            g[2] = 0;
            g[3] = 0;
            return g
        },
        str: function(g) {
            return "vec4(" + g[0] + ", " + g[1] + ", " + g[2] + ", " + g[3] + ")"
        },
        exactEquals: Ma,
        equals: function(g, k) {
            var n = g[0]
              , q = g[1]
              , t = g[2];
            g = g[3];
            var u = k[0]
              , w = k[1]
              , y = k[2];
            k = k[3];
            return Math.abs(n - u) <= 1E-6 * Math.max(1, Math.abs(n), Math.abs(u)) && Math.abs(q - w) <= 1E-6 * Math.max(1, Math.abs(q), Math.abs(w)) && Math.abs(t - y) <= 1E-6 * Math.max(1, Math.abs(t), Math.abs(y)) && Math.abs(g - k) <= 1E-6 * Math.max(1, Math.abs(g), Math.abs(k))
        },
        sub: Ga,
        mul: Ha,
        div: Ia,
        dist: Ja,
        sqrDist: Ka,
        len: la,
        sqrLen: ja,
        forEach: wa
    });
    var xa = function() {
        var g = I()
          , k = M(1, 0, 0)
          , n = M(0, 1, 0);
        return function(q, t, u) {
            var w = oa(t, u);
            if (-.999999 > w)
                return pa(g, k, t),
                1E-6 > K(g) && pa(g, n, t),
                Aa(g, g),
                Na(q, g, Math.PI),
                q;
            if (.999999 < w)
                return q[0] = 0,
                q[1] = 0,
                q[2] = 0,
                q[3] = 1,
                q;
            pa(g, t, u);
            q[0] = g[0];
            q[1] = g[1];
            q[2] = g[2];
            q[3] = 1 + w;
            return ra(q, q)
        }
    }()
      , ya = function() {
        var g = sa()
          , k = sa();
        return function(n, q, t, u, w, y) {
            ta(g, q, w, y);
            ta(k, t, u, y);
            ta(n, g, k, 2 * y * (1 - y));
            return n
        }
    }()
      , na = function() {
        var g = f();
        return function(k, n, q, t) {
            g[0] = q[0];
            g[3] = q[1];
            g[6] = q[2];
            g[1] = t[0];
            g[4] = t[1];
            g[7] = t[2];
            g[2] = -n[0];
            g[5] = -n[1];
            g[8] = -n[2];
            return ra(k, Ua(k, g))
        }
    }();
    xa = Object.freeze({
        __proto__: null,
        create: sa,
        identity: function(g) {
            g[0] = 0;
            g[1] = 0;
            g[2] = 0;
            g[3] = 1;
            return g
        },
        setAxisAngle: Na,
        getAxisAngle: function(g, k) {
            var n = 2 * Math.acos(k[3])
              , q = Math.sin(n / 2);
            1E-6 < q ? (g[0] = k[0] / q,
            g[1] = k[1] / q,
            g[2] = k[2] / q) : (g[0] = 1,
            g[1] = 0,
            g[2] = 0);
            return n
        },
        getAngle: function(g, k) {
            g = ma(g, k);
            return Math.acos(2 * g * g - 1)
        },
        multiply: Oa,
        rotateX: Pa,
        rotateY: Qa,
        rotateZ: Ra,
        calculateW: function(g, k) {
            var n = k[0]
              , q = k[1];
            k = k[2];
            g[0] = n;
            g[1] = q;
            g[2] = k;
            g[3] = Math.sqrt(Math.abs(1 - n * n - q * q - k * k));
            return g
        },
        exp: Sa,
        ln: Ta,
        pow: function(g, k, n) {
            Ta(g, k);
            ua(g, g, n);
            Sa(g, g);
            return g
        },
        slerp: ta,
        random: function(g) {
            var k = ha()
              , n = ha()
              , q = ha()
              , t = Math.sqrt(1 - k);
            k = Math.sqrt(k);
            g[0] = t * Math.sin(2 * Math.PI * n);
            g[1] = t * Math.cos(2 * Math.PI * n);
            g[2] = k * Math.sin(2 * Math.PI * q);
            g[3] = k * Math.cos(2 * Math.PI * q);
            return g
        },
        invert: function(g, k) {
            var n = k[0]
              , q = k[1]
              , t = k[2];
            k = k[3];
            var u = n * n + q * q + t * t + k * k;
            u = u ? 1 / u : 0;
            g[0] = -n * u;
            g[1] = -q * u;
            g[2] = -t * u;
            g[3] = k * u;
            return g
        },
        conjugate: function(g, k) {
            g[0] = -k[0];
            g[1] = -k[1];
            g[2] = -k[2];
            g[3] = k[3];
            return g
        },
        fromMat3: Ua,
        fromEuler: function(g, k, n, q) {
            var t = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : "zyx"
              , u = Math.PI / 360;
            k *= u;
            q *= u;
            n *= u;
            u = Math.sin(k);
            var w = Math.cos(k)
              , y = Math.sin(n)
              , z = Math.cos(n)
              , C = Math.sin(q)
              , E = Math.cos(q);
            switch (t) {
            case "xyz":
                g[0] = u * z * E + w * y * C;
                g[1] = w * y * E - u * z * C;
                g[2] = w * z * C + u * y * E;
                g[3] = w * z * E - u * y * C;
                break;
            case "xzy":
                g[0] = u * z * E - w * y * C;
                g[1] = w * y * E - u * z * C;
                g[2] = w * z * C + u * y * E;
                g[3] = w * z * E + u * y * C;
                break;
            case "yxz":
                g[0] = u * z * E + w * y * C;
                g[1] = w * y * E - u * z * C;
                g[2] = w * z * C - u * y * E;
                g[3] = w * z * E + u * y * C;
                break;
            case "yzx":
                g[0] = u * z * E + w * y * C;
                g[1] = w * y * E + u * z * C;
                g[2] = w * z * C - u * y * E;
                g[3] = w * z * E - u * y * C;
                break;
            case "zxy":
                g[0] = u * z * E - w * y * C;
                g[1] = w * y * E + u * z * C;
                g[2] = w * z * C + u * y * E;
                g[3] = w * z * E - u * y * C;
                break;
            case "zyx":
                g[0] = u * z * E - w * y * C;
                g[1] = w * y * E + u * z * C;
                g[2] = w * z * C - u * y * E;
                g[3] = w * z * E + u * y * C;
                break;
            default:
                throw Error("Unknown angle order " + t);
            }
            return g
        },
        str: function(g) {
            return "quat(" + g[0] + ", " + g[1] + ", " + g[2] + ", " + g[3] + ")"
        },
        clone: Ca,
        fromValues: Da,
        copy: qa,
        set: Ea,
        add: Fa,
        mul: Oa,
        scale: ua,
        dot: ma,
        lerp: La,
        length: la,
        len: la,
        squaredLength: ja,
        sqrLen: ja,
        normalize: ra,
        exactEquals: Ma,
        equals: function(g, k) {
            return .999999 <= Math.abs(ma(g, k))
        },
        rotationTo: xa,
        sqlerp: ya,
        setAxes: na
    });
    ya = Object.freeze({
        __proto__: null,
        create: function() {
            var g = new V(8);
            V != Float32Array && (g[0] = 0,
            g[1] = 0,
            g[2] = 0,
            g[4] = 0,
            g[5] = 0,
            g[6] = 0,
            g[7] = 0);
            g[3] = 1;
            return g
        },
        clone: function(g) {
            var k = new V(8);
            k[0] = g[0];
            k[1] = g[1];
            k[2] = g[2];
            k[3] = g[3];
            k[4] = g[4];
            k[5] = g[5];
            k[6] = g[6];
            k[7] = g[7];
            return k
        },
        fromValues: function(g, k, n, q, t, u, w, y) {
            var z = new V(8);
            z[0] = g;
            z[1] = k;
            z[2] = n;
            z[3] = q;
            z[4] = t;
            z[5] = u;
            z[6] = w;
            z[7] = y;
            return z
        },
        fromRotationTranslationValues: function(g, k, n, q, t, u, w) {
            var y = new V(8);
            y[0] = g;
            y[1] = k;
            y[2] = n;
            y[3] = q;
            t *= .5;
            u *= .5;
            w *= .5;
            y[4] = t * q + u * n - w * k;
            y[5] = u * q + w * g - t * n;
            y[6] = w * q + t * k - u * g;
            y[7] = -t * g - u * k - w * n;
            return y
        },
        fromRotationTranslation: Va,
        fromTranslation: function(g, k) {
            g[0] = 0;
            g[1] = 0;
            g[2] = 0;
            g[3] = 1;
            g[4] = .5 * k[0];
            g[5] = .5 * k[1];
            g[6] = .5 * k[2];
            g[7] = 0;
            return g
        },
        fromRotation: function(g, k) {
            g[0] = k[0];
            g[1] = k[1];
            g[2] = k[2];
            g[3] = k[3];
            g[4] = 0;
            g[5] = 0;
            g[6] = 0;
            g[7] = 0;
            return g
        },
        fromMat4: function(g, k) {
            var n = sa();
            B(n, k);
            var q = new V(3);
            v(q, k);
            Va(g, n, q);
            return g
        },
        copy: Wa,
        identity: function(g) {
            g[0] = 0;
            g[1] = 0;
            g[2] = 0;
            g[3] = 1;
            g[4] = 0;
            g[5] = 0;
            g[6] = 0;
            g[7] = 0;
            return g
        },
        set: function(g, k, n, q, t, u, w, y, z) {
            g[0] = k;
            g[1] = n;
            g[2] = q;
            g[3] = t;
            g[4] = u;
            g[5] = w;
            g[6] = y;
            g[7] = z;
            return g
        },
        getReal: qa,
        getDual: function(g, k) {
            g[0] = k[4];
            g[1] = k[5];
            g[2] = k[6];
            g[3] = k[7];
            return g
        },
        setReal: qa,
        setDual: function(g, k) {
            g[4] = k[0];
            g[5] = k[1];
            g[6] = k[2];
            g[7] = k[3];
            return g
        },
        getTranslation: function(g, k) {
            var n = k[4]
              , q = k[5]
              , t = k[6]
              , u = k[7]
              , w = -k[0]
              , y = -k[1]
              , z = -k[2];
            k = k[3];
            g[0] = 2 * (n * k + u * w + q * z - t * y);
            g[1] = 2 * (q * k + u * y + t * w - n * z);
            g[2] = 2 * (t * k + u * z + n * y - q * w);
            return g
        },
        translate: function(g, k, n) {
            var q = k[0]
              , t = k[1]
              , u = k[2]
              , w = k[3]
              , y = .5 * n[0]
              , z = .5 * n[1];
            n = .5 * n[2];
            var C = k[4]
              , E = k[5]
              , G = k[6];
            k = k[7];
            g[0] = q;
            g[1] = t;
            g[2] = u;
            g[3] = w;
            g[4] = w * y + t * n - u * z + C;
            g[5] = w * z + u * y - q * n + E;
            g[6] = w * n + q * z - t * y + G;
            g[7] = -q * y - t * z - u * n + k;
            return g
        },
        rotateX: function(g, k, n) {
            var q = -k[0]
              , t = -k[1]
              , u = -k[2]
              , w = k[3]
              , y = k[4]
              , z = k[5]
              , C = k[6]
              , E = k[7]
              , G = y * w + E * q + z * u - C * t
              , J = z * w + E * t + C * q - y * u
              , H = C * w + E * u + y * t - z * q;
            y = E * w - y * q - z * t - C * u;
            Pa(g, k, n);
            q = g[0];
            t = g[1];
            u = g[2];
            w = g[3];
            g[4] = G * w + y * q + J * u - H * t;
            g[5] = J * w + y * t + H * q - G * u;
            g[6] = H * w + y * u + G * t - J * q;
            g[7] = y * w - G * q - J * t - H * u;
            return g
        },
        rotateY: function(g, k, n) {
            var q = -k[0]
              , t = -k[1]
              , u = -k[2]
              , w = k[3]
              , y = k[4]
              , z = k[5]
              , C = k[6]
              , E = k[7]
              , G = y * w + E * q + z * u - C * t
              , J = z * w + E * t + C * q - y * u
              , H = C * w + E * u + y * t - z * q;
            y = E * w - y * q - z * t - C * u;
            Qa(g, k, n);
            q = g[0];
            t = g[1];
            u = g[2];
            w = g[3];
            g[4] = G * w + y * q + J * u - H * t;
            g[5] = J * w + y * t + H * q - G * u;
            g[6] = H * w + y * u + G * t - J * q;
            g[7] = y * w - G * q - J * t - H * u;
            return g
        },
        rotateZ: function(g, k, n) {
            var q = -k[0]
              , t = -k[1]
              , u = -k[2]
              , w = k[3]
              , y = k[4]
              , z = k[5]
              , C = k[6]
              , E = k[7]
              , G = y * w + E * q + z * u - C * t
              , J = z * w + E * t + C * q - y * u
              , H = C * w + E * u + y * t - z * q;
            y = E * w - y * q - z * t - C * u;
            Ra(g, k, n);
            q = g[0];
            t = g[1];
            u = g[2];
            w = g[3];
            g[4] = G * w + y * q + J * u - H * t;
            g[5] = J * w + y * t + H * q - G * u;
            g[6] = H * w + y * u + G * t - J * q;
            g[7] = y * w - G * q - J * t - H * u;
            return g
        },
        rotateByQuatAppend: function(g, k, n) {
            var q = n[0]
              , t = n[1]
              , u = n[2];
            n = n[3];
            var w = k[0]
              , y = k[1]
              , z = k[2]
              , C = k[3];
            g[0] = w * n + C * q + y * u - z * t;
            g[1] = y * n + C * t + z * q - w * u;
            g[2] = z * n + C * u + w * t - y * q;
            g[3] = C * n - w * q - y * t - z * u;
            w = k[4];
            y = k[5];
            z = k[6];
            C = k[7];
            g[4] = w * n + C * q + y * u - z * t;
            g[5] = y * n + C * t + z * q - w * u;
            g[6] = z * n + C * u + w * t - y * q;
            g[7] = C * n - w * q - y * t - z * u;
            return g
        },
        rotateByQuatPrepend: function(g, k, n) {
            var q = k[0]
              , t = k[1]
              , u = k[2];
            k = k[3];
            var w = n[0]
              , y = n[1]
              , z = n[2]
              , C = n[3];
            g[0] = q * C + k * w + t * z - u * y;
            g[1] = t * C + k * y + u * w - q * z;
            g[2] = u * C + k * z + q * y - t * w;
            g[3] = k * C - q * w - t * y - u * z;
            w = n[4];
            y = n[5];
            z = n[6];
            C = n[7];
            g[4] = q * C + k * w + t * z - u * y;
            g[5] = t * C + k * y + u * w - q * z;
            g[6] = u * C + k * z + q * y - t * w;
            g[7] = k * C - q * w - t * y - u * z;
            return g
        },
        rotateAroundAxis: function(g, k, n, q) {
            if (1E-6 > Math.abs(q))
                return Wa(g, k);
            var t = Math.hypot(n[0], n[1], n[2]);
            q *= .5;
            var u = Math.sin(q)
              , w = u * n[0] / t
              , y = u * n[1] / t;
            n = u * n[2] / t;
            q = Math.cos(q);
            t = k[0];
            u = k[1];
            var z = k[2]
              , C = k[3];
            g[0] = t * q + C * w + u * n - z * y;
            g[1] = u * q + C * y + z * w - t * n;
            g[2] = z * q + C * n + t * y - u * w;
            g[3] = C * q - t * w - u * y - z * n;
            t = k[4];
            u = k[5];
            z = k[6];
            k = k[7];
            g[4] = t * q + k * w + u * n - z * y;
            g[5] = u * q + k * y + z * w - t * n;
            g[6] = z * q + k * n + t * y - u * w;
            g[7] = k * q - t * w - u * y - z * n;
            return g
        },
        add: function(g, k, n) {
            g[0] = k[0] + n[0];
            g[1] = k[1] + n[1];
            g[2] = k[2] + n[2];
            g[3] = k[3] + n[3];
            g[4] = k[4] + n[4];
            g[5] = k[5] + n[5];
            g[6] = k[6] + n[6];
            g[7] = k[7] + n[7];
            return g
        },
        multiply: Xa,
        mul: Xa,
        scale: function(g, k, n) {
            g[0] = k[0] * n;
            g[1] = k[1] * n;
            g[2] = k[2] * n;
            g[3] = k[3] * n;
            g[4] = k[4] * n;
            g[5] = k[5] * n;
            g[6] = k[6] * n;
            g[7] = k[7] * n;
            return g
        },
        dot: ma,
        lerp: function(g, k, n, q) {
            var t = 1 - q;
            0 > ma(k, n) && (q = -q);
            g[0] = k[0] * t + n[0] * q;
            g[1] = k[1] * t + n[1] * q;
            g[2] = k[2] * t + n[2] * q;
            g[3] = k[3] * t + n[3] * q;
            g[4] = k[4] * t + n[4] * q;
            g[5] = k[5] * t + n[5] * q;
            g[6] = k[6] * t + n[6] * q;
            g[7] = k[7] * t + n[7] * q;
            return g
        },
        invert: function(g, k) {
            var n = ja(k);
            g[0] = -k[0] / n;
            g[1] = -k[1] / n;
            g[2] = -k[2] / n;
            g[3] = k[3] / n;
            g[4] = -k[4] / n;
            g[5] = -k[5] / n;
            g[6] = -k[6] / n;
            g[7] = k[7] / n;
            return g
        },
        conjugate: function(g, k) {
            g[0] = -k[0];
            g[1] = -k[1];
            g[2] = -k[2];
            g[3] = k[3];
            g[4] = -k[4];
            g[5] = -k[5];
            g[6] = -k[6];
            g[7] = k[7];
            return g
        },
        length: la,
        len: la,
        squaredLength: ja,
        sqrLen: ja,
        normalize: function(g, k) {
            var n = ja(k);
            if (0 < n) {
                n = Math.sqrt(n);
                var q = k[0] / n
                  , t = k[1] / n
                  , u = k[2] / n
                  , w = k[3] / n
                  , y = k[4]
                  , z = k[5]
                  , C = k[6];
                k = k[7];
                var E = q * y + t * z + u * C + w * k;
                g[0] = q;
                g[1] = t;
                g[2] = u;
                g[3] = w;
                g[4] = (y - q * E) / n;
                g[5] = (z - t * E) / n;
                g[6] = (C - u * E) / n;
                g[7] = (k - w * E) / n
            }
            return g
        },
        str: function(g) {
            return "quat2(" + g[0] + ", " + g[1] + ", " + g[2] + ", " + g[3] + ", " + g[4] + ", " + g[5] + ", " + g[6] + ", " + g[7] + ")"
        },
        exactEquals: function(g, k) {
            return g[0] === k[0] && g[1] === k[1] && g[2] === k[2] && g[3] === k[3] && g[4] === k[4] && g[5] === k[5] && g[6] === k[6] && g[7] === k[7]
        },
        equals: function(g, k) {
            var n = g[0]
              , q = g[1]
              , t = g[2]
              , u = g[3]
              , w = g[4]
              , y = g[5]
              , z = g[6];
            g = g[7];
            var C = k[0]
              , E = k[1]
              , G = k[2]
              , J = k[3]
              , H = k[4]
              , N = k[5]
              , O = k[6];
            k = k[7];
            return Math.abs(n - C) <= 1E-6 * Math.max(1, Math.abs(n), Math.abs(C)) && Math.abs(q - E) <= 1E-6 * Math.max(1, Math.abs(q), Math.abs(E)) && Math.abs(t - G) <= 1E-6 * Math.max(1, Math.abs(t), Math.abs(G)) && Math.abs(u - J) <= 1E-6 * Math.max(1, Math.abs(u), Math.abs(J)) && Math.abs(w - H) <= 1E-6 * Math.max(1, Math.abs(w), Math.abs(H)) && Math.abs(y - N) <= 1E-6 * Math.max(1, Math.abs(y), Math.abs(N)) && Math.abs(z - O) <= 1E-6 * Math.max(1, Math.abs(z), Math.abs(O)) && Math.abs(g - k) <= 1E-6 * Math.max(1, Math.abs(g), Math.abs(k))
        }
    });
    na = function() {
        var g = Ya();
        return function(k, n, q, t, u, w) {
            n || (n = 2);
            q || (q = 0);
            for (t = t ? Math.min(t * n + q, k.length) : k.length; q < t; q += n)
                g[0] = k[q],
                g[1] = k[q + 1],
                u(g, g, w),
                k[q] = g[0],
                k[q + 1] = g[1];
            return k
        }
    }();
    na = Object.freeze({
        __proto__: null,
        create: Ya,
        clone: function(g) {
            var k = new V(2);
            k[0] = g[0];
            k[1] = g[1];
            return k
        },
        fromValues: function(g, k) {
            var n = new V(2);
            n[0] = g;
            n[1] = k;
            return n
        },
        copy: function(g, k) {
            g[0] = k[0];
            g[1] = k[1];
            return g
        },
        set: function(g, k, n) {
            g[0] = k;
            g[1] = n;
            return g
        },
        add: function(g, k, n) {
            g[0] = k[0] + n[0];
            g[1] = k[1] + n[1];
            return g
        },
        subtract: Za,
        multiply: $a,
        divide: ab,
        ceil: function(g, k) {
            g[0] = Math.ceil(k[0]);
            g[1] = Math.ceil(k[1]);
            return g
        },
        floor: function(g, k) {
            g[0] = Math.floor(k[0]);
            g[1] = Math.floor(k[1]);
            return g
        },
        min: function(g, k, n) {
            g[0] = Math.min(k[0], n[0]);
            g[1] = Math.min(k[1], n[1]);
            return g
        },
        max: function(g, k, n) {
            g[0] = Math.max(k[0], n[0]);
            g[1] = Math.max(k[1], n[1]);
            return g
        },
        round: function(g, k) {
            g[0] = Math.round(k[0]);
            g[1] = Math.round(k[1]);
            return g
        },
        scale: function(g, k, n) {
            g[0] = k[0] * n;
            g[1] = k[1] * n;
            return g
        },
        scaleAndAdd: function(g, k, n, q) {
            g[0] = k[0] + n[0] * q;
            g[1] = k[1] + n[1] * q;
            return g
        },
        distance: bb,
        squaredDistance: cb,
        length: db,
        squaredLength: eb,
        negate: function(g, k) {
            g[0] = -k[0];
            g[1] = -k[1];
            return g
        },
        inverse: function(g, k) {
            g[0] = 1 / k[0];
            g[1] = 1 / k[1];
            return g
        },
        normalize: function(g, k) {
            var n = k[0]
              , q = k[1];
            n = n * n + q * q;
            0 < n && (n = 1 / Math.sqrt(n));
            g[0] = k[0] * n;
            g[1] = k[1] * n;
            return g
        },
        dot: function(g, k) {
            return g[0] * k[0] + g[1] * k[1]
        },
        cross: function(g, k, n) {
            k = k[0] * n[1] - k[1] * n[0];
            g[0] = g[1] = 0;
            g[2] = k;
            return g
        },
        lerp: function(g, k, n, q) {
            var t = k[0];
            k = k[1];
            g[0] = t + q * (n[0] - t);
            g[1] = k + q * (n[1] - k);
            return g
        },
        random: function(g, k) {
            k = k || 1;
            var n = 2 * ha() * Math.PI;
            g[0] = Math.cos(n) * k;
            g[1] = Math.sin(n) * k;
            return g
        },
        transformMat2: function(g, k, n) {
            var q = k[0];
            k = k[1];
            g[0] = n[0] * q + n[2] * k;
            g[1] = n[1] * q + n[3] * k;
            return g
        },
        transformMat2d: function(g, k, n) {
            var q = k[0];
            k = k[1];
            g[0] = n[0] * q + n[2] * k + n[4];
            g[1] = n[1] * q + n[3] * k + n[5];
            return g
        },
        transformMat3: function(g, k, n) {
            var q = k[0];
            k = k[1];
            g[0] = n[0] * q + n[3] * k + n[6];
            g[1] = n[1] * q + n[4] * k + n[7];
            return g
        },
        transformMat4: function(g, k, n) {
            var q = k[0];
            k = k[1];
            g[0] = n[0] * q + n[4] * k + n[12];
            g[1] = n[1] * q + n[5] * k + n[13];
            return g
        },
        rotate: function(g, k, n, q) {
            var t = k[0] - n[0];
            k = k[1] - n[1];
            var u = Math.sin(q);
            q = Math.cos(q);
            g[0] = t * q - k * u + n[0];
            g[1] = t * u + k * q + n[1];
            return g
        },
        angle: function(g, k) {
            var n = g[0];
            g = g[1];
            var q = k[0];
            k = k[1];
            var t = Math.sqrt((n * n + g * g) * (q * q + k * k));
            return Math.acos(Math.min(Math.max(t && (n * q + g * k) / t, -1), 1))
        },
        zero: function(g) {
            g[0] = 0;
            g[1] = 0;
            return g
        },
        str: function(g) {
            return "vec2(" + g[0] + ", " + g[1] + ")"
        },
        exactEquals: function(g, k) {
            return g[0] === k[0] && g[1] === k[1]
        },
        equals: function(g, k) {
            var n = g[0];
            g = g[1];
            var q = k[0];
            k = k[1];
            return Math.abs(n - q) <= 1E-6 * Math.max(1, Math.abs(n), Math.abs(q)) && Math.abs(g - k) <= 1E-6 * Math.max(1, Math.abs(g), Math.abs(k))
        },
        len: db,
        sub: Za,
        mul: $a,
        div: ab,
        dist: bb,
        sqrDist: cb,
        sqrLen: eb,
        forEach: na
    });
    a.glMatrix = ib;
    a.mat2 = jb;
    a.mat2d = kb;
    a.mat3 = lb;
    a.mat4 = mb;
    a.quat = xa;
    a.quat2 = ya;
    a.vec2 = na;
    a.vec3 = va;
    a.vec4 = wa;
    Object.defineProperty(a, "__esModule", {
        value: !0
    })
});
self.GraphemeSplitter = function() {
    function a(d, e) {
        void 0 === e && (e = 0);
        var f = d.charCodeAt(e);
        if (55296 <= f && 56319 >= f && e < d.length - 1) {
            var h = f;
            d = d.charCodeAt(e + 1);
            return 56320 <= d && 57343 >= d ? 1024 * (h - 55296) + (d - 56320) + 65536 : h
        }
        return 56320 <= f && 57343 >= f && 1 <= e ? (h = d.charCodeAt(e - 1),
        d = f,
        55296 <= h && 56319 >= h ? 1024 * (h - 55296) + (d - 56320) + 65536 : d) : f
    }
    function b(d, e, f) {
        var h = [d].concat(e).concat([f])
          , l = h[h.length - 2]
          , m = h.lastIndexOf(14);
        if (1 < m && h.slice(1, m).every(function(p) {
            return 3 == p
        }) && -1 == [3, 13, 17].indexOf(d))
            return 2;
        d = h.lastIndexOf(4);
        if (0 < d && h.slice(1, d).every(function(p) {
            return 4 == p
        }) && -1 == [12, 4].indexOf(l))
            return 1 == h.filter(function(p) {
                return 4 == p
            }).length % 2 ? 3 : 4;
        if (0 == l && 1 == f)
            return 0;
        if (2 == l || 0 == l || 1 == l)
            return 14 == f && e.every(function(p) {
                return 3 == p
            }) ? 2 : 1;
        if (2 == f || 0 == f || 1 == f)
            return 1;
        if (6 != l || 6 != f && 7 != f && 9 != f && 10 != f)
            if (9 != l && 7 != l || 7 != f && 8 != f)
                if (10 != l && 8 != l || 8 != f) {
                    if (3 == f || 15 == f || 5 == f || 12 == l)
                        return 0
                } else
                    return 0;
            else
                return 0;
        else
            return 0;
        d = -1 != h.indexOf(3) ? h.lastIndexOf(3) - 1 : h.length - 2;
        return -1 != [13, 17].indexOf(h[d]) && h.slice(d + 1, -1).every(function(p) {
            return 3 == p
        }) && 14 == f || 15 == l && -1 != [16, 17].indexOf(f) ? 0 : -1 != e.indexOf(4) ? 2 : 4 == l && 4 == f ? 0 : 1
    }
    function c(d) {
        return 1536 <= d && 1541 >= d || 1757 == d || 1807 == d || 2274 == d || 3406 == d || 69821 == d || 70082 <= d && 70083 >= d || 72250 == d || 72326 <= d && 72329 >= d || 73030 == d ? 12 : 13 == d ? 0 : 10 == d ? 1 : 0 <= d && 9 >= d || 11 <= d && 12 >= d || 14 <= d && 31 >= d || 127 <= d && 159 >= d || 173 == d || 1564 == d || 6158 == d || 8203 == d || 8206 <= d && 8207 >= d || 8232 == d || 8233 == d || 8234 <= d && 8238 >= d || 8288 <= d && 8292 >= d || 8293 == d || 8294 <= d && 8303 >= d || 55296 <= d && 57343 >= d || 65279 == d || 65520 <= d && 65528 >= d || 65529 <= d && 65531 >= d || 113824 <= d && 113827 >= d || 119155 <= d && 119162 >= d || 917504 == d || 917505 == d || 917506 <= d && 917535 >= d || 917632 <= d && 917759 >= d || 918E3 <= d && 921599 >= d ? 2 : 768 <= d && 879 >= d || 1155 <= d && 1159 >= d || 1160 <= d && 1161 >= d || 1425 <= d && 1469 >= d || 1471 == d || 1473 <= d && 1474 >= d || 1476 <= d && 1477 >= d || 1479 == d || 1552 <= d && 1562 >= d || 1611 <= d && 1631 >= d || 1648 == d || 1750 <= d && 1756 >= d || 1759 <= d && 1764 >= d || 1767 <= d && 1768 >= d || 1770 <= d && 1773 >= d || 1809 == d || 1840 <= d && 1866 >= d || 1958 <= d && 1968 >= d || 2027 <= d && 2035 >= d || 2070 <= d && 2073 >= d || 2075 <= d && 2083 >= d || 2085 <= d && 2087 >= d || 2089 <= d && 2093 >= d || 2137 <= d && 2139 >= d || 2260 <= d && 2273 >= d || 2275 <= d && 2306 >= d || 2362 == d || 2364 == d || 2369 <= d && 2376 >= d || 2381 == d || 2385 <= d && 2391 >= d || 2402 <= d && 2403 >= d || 2433 == d || 2492 == d || 2494 == d || 2497 <= d && 2500 >= d || 2509 == d || 2519 == d || 2530 <= d && 2531 >= d || 2561 <= d && 2562 >= d || 2620 == d || 2625 <= d && 2626 >= d || 2631 <= d && 2632 >= d || 2635 <= d && 2637 >= d || 2641 == d || 2672 <= d && 2673 >= d || 2677 == d || 2689 <= d && 2690 >= d || 2748 == d || 2753 <= d && 2757 >= d || 2759 <= d && 2760 >= d || 2765 == d || 2786 <= d && 2787 >= d || 2810 <= d && 2815 >= d || 2817 == d || 2876 == d || 2878 == d || 2879 == d || 2881 <= d && 2884 >= d || 2893 == d || 2902 == d || 2903 == d || 2914 <= d && 2915 >= d || 2946 == d || 3006 == d || 3008 == d || 3021 == d || 3031 == d || 3072 == d || 3134 <= d && 3136 >= d || 3142 <= d && 3144 >= d || 3146 <= d && 3149 >= d || 3157 <= d && 3158 >= d || 3170 <= d && 3171 >= d || 3201 == d || 3260 == d || 3263 == d || 3266 == d || 3270 == d || 3276 <= d && 3277 >= d || 3285 <= d && 3286 >= d || 3298 <= d && 3299 >= d || 3328 <= d && 3329 >= d || 3387 <= d && 3388 >= d || 3390 == d || 3393 <= d && 3396 >= d || 3405 == d || 3415 == d || 3426 <= d && 3427 >= d || 3530 == d || 3535 == d || 3538 <= d && 3540 >= d || 3542 == d || 3551 == d || 3633 == d || 3636 <= d && 3642 >= d || 3655 <= d && 3662 >= d || 3761 == d || 3764 <= d && 3769 >= d || 3771 <= d && 3772 >= d || 3784 <= d && 3789 >= d || 3864 <= d && 3865 >= d || 3893 == d || 3895 == d || 3897 == d || 3953 <= d && 3966 >= d || 3968 <= d && 3972 >= d || 3974 <= d && 3975 >= d || 3981 <= d && 3991 >= d || 3993 <= d && 4028 >= d || 4038 == d || 4141 <= d && 4144 >= d || 4146 <= d && 4151 >= d || 4153 <= d && 4154 >= d || 4157 <= d && 4158 >= d || 4184 <= d && 4185 >= d || 4190 <= d && 4192 >= d || 4209 <= d && 4212 >= d || 4226 == d || 4229 <= d && 4230 >= d || 4237 == d || 4253 == d || 4957 <= d && 4959 >= d || 5906 <= d && 5908 >= d || 5938 <= d && 5940 >= d || 5970 <= d && 5971 >= d || 6002 <= d && 6003 >= d || 6068 <= d && 6069 >= d || 6071 <= d && 6077 >= d || 6086 == d || 6089 <= d && 6099 >= d || 6109 == d || 6155 <= d && 6157 >= d || 6277 <= d && 6278 >= d || 6313 == d || 6432 <= d && 6434 >= d || 6439 <= d && 6440 >= d || 6450 == d || 6457 <= d && 6459 >= d || 6679 <= d && 6680 >= d || 6683 == d || 6742 == d || 6744 <= d && 6750 >= d || 6752 == d || 6754 == d || 6757 <= d && 6764 >= d || 6771 <= d && 6780 >= d || 6783 == d || 6832 <= d && 6845 >= d || 6846 == d || 6912 <= d && 6915 >= d || 6964 == d || 6966 <= d && 6970 >= d || 6972 == d || 6978 == d || 7019 <= d && 7027 >= d || 7040 <= d && 7041 >= d || 7074 <= d && 7077 >= d || 7080 <= d && 7081 >= d || 7083 <= d && 7085 >= d || 7142 == d || 7144 <= d && 7145 >= d || 7149 == d || 7151 <= d && 7153 >= d || 7212 <= d && 7219 >= d || 7222 <= d && 7223 >= d || 7376 <= d && 7378 >= d || 7380 <= d && 7392 >= d || 7394 <= d && 7400 >= d || 7405 == d || 7412 == d || 7416 <= d && 7417 >= d || 7616 <= d && 7673 >= d || 7675 <= d && 7679 >= d || 8204 == d || 8400 <= d && 8412 >= d || 8413 <= d && 8416 >= d || 8417 == d || 8418 <= d && 8420 >= d || 8421 <= d && 8432 >= d || 11503 <= d && 11505 >= d || 11647 == d || 11744 <= d && 11775 >= d || 12330 <= d && 12333 >= d || 12334 <= d && 12335 >= d || 12441 <= d && 12442 >= d || 42607 == d || 42608 <= d && 42610 >= d || 42612 <= d && 42621 >= d || 42654 <= d && 42655 >= d || 42736 <= d && 42737 >= d || 43010 == d || 43014 == d || 43019 == d || 43045 <= d && 43046 >= d || 43204 <= d && 43205 >= d || 43232 <= d && 43249 >= d || 43302 <= d && 43309 >= d || 43335 <= d && 43345 >= d || 43392 <= d && 43394 >= d || 43443 == d || 43446 <= d && 43449 >= d || 43452 == d || 43493 == d || 43561 <= d && 43566 >= d || 43569 <= d && 43570 >= d || 43573 <= d && 43574 >= d || 43587 == d || 43596 == d || 43644 == d || 43696 == d || 43698 <= d && 43700 >= d || 43703 <= d && 43704 >= d || 43710 <= d && 43711 >= d || 43713 == d || 43756 <= d && 43757 >= d || 43766 == d || 44005 == d || 44008 == d || 44013 == d || 64286 == d || 65024 <= d && 65039 >= d || 65056 <= d && 65071 >= d || 65438 <= d && 65439 >= d || 66045 == d || 66272 == d || 66422 <= d && 66426 >= d || 68097 <= d && 68099 >= d || 68101 <= d && 68102 >= d || 68108 <= d && 68111 >= d || 68152 <= d && 68154 >= d || 68159 == d || 68325 <= d && 68326 >= d || 69633 == d || 69688 <= d && 69702 >= d || 69759 <= d && 69761 >= d || 69811 <= d && 69814 >= d || 69817 <= d && 69818 >= d || 69888 <= d && 69890 >= d || 69927 <= d && 69931 >= d || 69933 <= d && 69940 >= d || 70003 == d || 70016 <= d && 70017 >= d || 70070 <= d && 70078 >= d || 70090 <= d && 70092 >= d || 70191 <= d && 70193 >= d || 70196 == d || 70198 <= d && 70199 >= d || 70206 == d || 70367 == d || 70371 <= d && 70378 >= d || 70400 <= d && 70401 >= d || 70460 == d || 70462 == d || 70464 == d || 70487 == d || 70502 <= d && 70508 >= d || 70512 <= d && 70516 >= d || 70712 <= d && 70719 >= d || 70722 <= d && 70724 >= d || 70726 == d || 70832 == d || 70835 <= d && 70840 >= d || 70842 == d || 70845 == d || 70847 <= d && 70848 >= d || 70850 <= d && 70851 >= d || 71087 == d || 71090 <= d && 71093 >= d || 71100 <= d && 71101 >= d || 71103 <= d && 71104 >= d || 71132 <= d && 71133 >= d || 71219 <= d && 71226 >= d || 71229 == d || 71231 <= d && 71232 >= d || 71339 == d || 71341 == d || 71344 <= d && 71349 >= d || 71351 == d || 71453 <= d && 71455 >= d || 71458 <= d && 71461 >= d || 71463 <= d && 71467 >= d || 72193 <= d && 72198 >= d || 72201 <= d && 72202 >= d || 72243 <= d && 72248 >= d || 72251 <= d && 72254 >= d || 72263 == d || 72273 <= d && 72278 >= d || 72281 <= d && 72283 >= d || 72330 <= d && 72342 >= d || 72344 <= d && 72345 >= d || 72752 <= d && 72758 >= d || 72760 <= d && 72765 >= d || 72767 == d || 72850 <= d && 72871 >= d || 72874 <= d && 72880 >= d || 72882 <= d && 72883 >= d || 72885 <= d && 72886 >= d || 73009 <= d && 73014 >= d || 73018 == d || 73020 <= d && 73021 >= d || 73023 <= d && 73029 >= d || 73031 == d || 92912 <= d && 92916 >= d || 92976 <= d && 92982 >= d || 94095 <= d && 94098 >= d || 113821 <= d && 113822 >= d || 119141 == d || 119143 <= d && 119145 >= d || 119150 <= d && 119154 >= d || 119163 <= d && 119170 >= d || 119173 <= d && 119179 >= d || 119210 <= d && 119213 >= d || 119362 <= d && 119364 >= d || 121344 <= d && 121398 >= d || 121403 <= d && 121452 >= d || 121461 == d || 121476 == d || 121499 <= d && 121503 >= d || 121505 <= d && 121519 >= d || 122880 <= d && 122886 >= d || 122888 <= d && 122904 >= d || 122907 <= d && 122913 >= d || 122915 <= d && 122916 >= d || 122918 <= d && 122922 >= d || 125136 <= d && 125142 >= d || 125252 <= d && 125258 >= d || 917536 <= d && 917631 >= d || 917760 <= d && 917999 >= d ? 3 : 127462 <= d && 127487 >= d ? 4 : 2307 == d || 2363 == d || 2366 <= d && 2368 >= d || 2377 <= d && 2380 >= d || 2382 <= d && 2383 >= d || 2434 <= d && 2435 >= d || 2495 <= d && 2496 >= d || 2503 <= d && 2504 >= d || 2507 <= d && 2508 >= d || 2563 == d || 2622 <= d && 2624 >= d || 2691 == d || 2750 <= d && 2752 >= d || 2761 == d || 2763 <= d && 2764 >= d || 2818 <= d && 2819 >= d || 2880 == d || 2887 <= d && 2888 >= d || 2891 <= d && 2892 >= d || 3007 == d || 3009 <= d && 3010 >= d || 3014 <= d && 3016 >= d || 3018 <= d && 3020 >= d || 3073 <= d && 3075 >= d || 3137 <= d && 3140 >= d || 3202 <= d && 3203 >= d || 3262 == d || 3264 <= d && 3265 >= d || 3267 <= d && 3268 >= d || 3271 <= d && 3272 >= d || 3274 <= d && 3275 >= d || 3330 <= d && 3331 >= d || 3391 <= d && 3392 >= d || 3398 <= d && 3400 >= d || 3402 <= d && 3404 >= d || 3458 <= d && 3459 >= d || 3536 <= d && 3537 >= d || 3544 <= d && 3550 >= d || 3570 <= d && 3571 >= d || 3635 == d || 3763 == d || 3902 <= d && 3903 >= d || 3967 == d || 4145 == d || 4155 <= d && 4156 >= d || 4182 <= d && 4183 >= d || 4228 == d || 6070 == d || 6078 <= d && 6085 >= d || 6087 <= d && 6088 >= d || 6435 <= d && 6438 >= d || 6441 <= d && 6443 >= d || 6448 <= d && 6449 >= d || 6451 <= d && 6456 >= d || 6681 <= d && 6682 >= d || 6741 == d || 6743 == d || 6765 <= d && 6770 >= d || 6916 == d || 6965 == d || 6971 == d || 6973 <= d && 6977 >= d || 6979 <= d && 6980 >= d || 7042 == d || 7073 == d || 7078 <= d && 7079 >= d || 7082 == d || 7143 == d || 7146 <= d && 7148 >= d || 7150 == d || 7154 <= d && 7155 >= d || 7204 <= d && 7211 >= d || 7220 <= d && 7221 >= d || 7393 == d || 7410 <= d && 7411 >= d || 7415 == d || 43043 <= d && 43044 >= d || 43047 == d || 43136 <= d && 43137 >= d || 43188 <= d && 43203 >= d || 43346 <= d && 43347 >= d || 43395 == d || 43444 <= d && 43445 >= d || 43450 <= d && 43451 >= d || 43453 <= d && 43456 >= d || 43567 <= d && 43568 >= d || 43571 <= d && 43572 >= d || 43597 == d || 43755 == d || 43758 <= d && 43759 >= d || 43765 == d || 44003 <= d && 44004 >= d || 44006 <= d && 44007 >= d || 44009 <= d && 44010 >= d || 44012 == d || 69632 == d || 69634 == d || 69762 == d || 69808 <= d && 69810 >= d || 69815 <= d && 69816 >= d || 69932 == d || 70018 == d || 70067 <= d && 70069 >= d || 70079 <= d && 70080 >= d || 70188 <= d && 70190 >= d || 70194 <= d && 70195 >= d || 70197 == d || 70368 <= d && 70370 >= d || 70402 <= d && 70403 >= d || 70463 == d || 70465 <= d && 70468 >= d || 70471 <= d && 70472 >= d || 70475 <= d && 70477 >= d || 70498 <= d && 70499 >= d || 70709 <= d && 70711 >= d || 70720 <= d && 70721 >= d || 70725 == d || 70833 <= d && 70834 >= d || 70841 == d || 70843 <= d && 70844 >= d || 70846 == d || 70849 == d || 71088 <= d && 71089 >= d || 71096 <= d && 71099 >= d || 71102 == d || 71216 <= d && 71218 >= d || 71227 <= d && 71228 >= d || 71230 == d || 71340 == d || 71342 <= d && 71343 >= d || 71350 == d || 71456 <= d && 71457 >= d || 71462 == d || 72199 <= d && 72200 >= d || 72249 == d || 72279 <= d && 72280 >= d || 72343 == d || 72751 == d || 72766 == d || 72873 == d || 72881 == d || 72884 == d || 94033 <= d && 94078 >= d || 119142 == d || 119149 == d ? 5 : 4352 <= d && 4447 >= d || 43360 <= d && 43388 >= d ? 6 : 4448 <= d && 4519 >= d || 55216 <= d && 55238 >= d ? 7 : 4520 <= d && 4607 >= d || 55243 <= d && 55291 >= d ? 8 : 44032 == d || 44060 == d || 44088 == d || 44116 == d || 44144 == d || 44172 == d || 44200 == d || 44228 == d || 44256 == d || 44284 == d || 44312 == d || 44340 == d || 44368 == d || 44396 == d || 44424 == d || 44452 == d || 44480 == d || 44508 == d || 44536 == d || 44564 == d || 44592 == d || 44620 == d || 44648 == d || 44676 == d || 44704 == d || 44732 == d || 44760 == d || 44788 == d || 44816 == d || 44844 == d || 44872 == d || 44900 == d || 44928 == d || 44956 == d || 44984 == d || 45012 == d || 45040 == d || 45068 == d || 45096 == d || 45124 == d || 45152 == d || 45180 == d || 45208 == d || 45236 == d || 45264 == d || 45292 == d || 45320 == d || 45348 == d || 45376 == d || 45404 == d || 45432 == d || 45460 == d || 45488 == d || 45516 == d || 45544 == d || 45572 == d || 45600 == d || 45628 == d || 45656 == d || 45684 == d || 45712 == d || 45740 == d || 45768 == d || 45796 == d || 45824 == d || 45852 == d || 45880 == d || 45908 == d || 45936 == d || 45964 == d || 45992 == d || 46020 == d || 46048 == d || 46076 == d || 46104 == d || 46132 == d || 46160 == d || 46188 == d || 46216 == d || 46244 == d || 46272 == d || 46300 == d || 46328 == d || 46356 == d || 46384 == d || 46412 == d || 46440 == d || 46468 == d || 46496 == d || 46524 == d || 46552 == d || 46580 == d || 46608 == d || 46636 == d || 46664 == d || 46692 == d || 46720 == d || 46748 == d || 46776 == d || 46804 == d || 46832 == d || 46860 == d || 46888 == d || 46916 == d || 46944 == d || 46972 == d || 47E3 == d || 47028 == d || 47056 == d || 47084 == d || 47112 == d || 47140 == d || 47168 == d || 47196 == d || 47224 == d || 47252 == d || 47280 == d || 47308 == d || 47336 == d || 47364 == d || 47392 == d || 47420 == d || 47448 == d || 47476 == d || 47504 == d || 47532 == d || 47560 == d || 47588 == d || 47616 == d || 47644 == d || 47672 == d || 47700 == d || 47728 == d || 47756 == d || 47784 == d || 47812 == d || 47840 == d || 47868 == d || 47896 == d || 47924 == d || 47952 == d || 47980 == d || 48008 == d || 48036 == d || 48064 == d || 48092 == d || 48120 == d || 48148 == d || 48176 == d || 48204 == d || 48232 == d || 48260 == d || 48288 == d || 48316 == d || 48344 == d || 48372 == d || 48400 == d || 48428 == d || 48456 == d || 48484 == d || 48512 == d || 48540 == d || 48568 == d || 48596 == d || 48624 == d || 48652 == d || 48680 == d || 48708 == d || 48736 == d || 48764 == d || 48792 == d || 48820 == d || 48848 == d || 48876 == d || 48904 == d || 48932 == d || 48960 == d || 48988 == d || 49016 == d || 49044 == d || 49072 == d || 49100 == d || 49128 == d || 49156 == d || 49184 == d || 49212 == d || 49240 == d || 49268 == d || 49296 == d || 49324 == d || 49352 == d || 49380 == d || 49408 == d || 49436 == d || 49464 == d || 49492 == d || 49520 == d || 49548 == d || 49576 == d || 49604 == d || 49632 == d || 49660 == d || 49688 == d || 49716 == d || 49744 == d || 49772 == d || 49800 == d || 49828 == d || 49856 == d || 49884 == d || 49912 == d || 49940 == d || 49968 == d || 49996 == d || 50024 == d || 50052 == d || 50080 == d || 50108 == d || 50136 == d || 50164 == d || 50192 == d || 50220 == d || 50248 == d || 50276 == d || 50304 == d || 50332 == d || 50360 == d || 50388 == d || 50416 == d || 50444 == d || 50472 == d || 50500 == d || 50528 == d || 50556 == d || 50584 == d || 50612 == d || 50640 == d || 50668 == d || 50696 == d || 50724 == d || 50752 == d || 50780 == d || 50808 == d || 50836 == d || 50864 == d || 50892 == d || 50920 == d || 50948 == d || 50976 == d || 51004 == d || 51032 == d || 51060 == d || 51088 == d || 51116 == d || 51144 == d || 51172 == d || 51200 == d || 51228 == d || 51256 == d || 51284 == d || 51312 == d || 51340 == d || 51368 == d || 51396 == d || 51424 == d || 51452 == d || 51480 == d || 51508 == d || 51536 == d || 51564 == d || 51592 == d || 51620 == d || 51648 == d || 51676 == d || 51704 == d || 51732 == d || 51760 == d || 51788 == d || 51816 == d || 51844 == d || 51872 == d || 51900 == d || 51928 == d || 51956 == d || 51984 == d || 52012 == d || 52040 == d || 52068 == d || 52096 == d || 52124 == d || 52152 == d || 52180 == d || 52208 == d || 52236 == d || 52264 == d || 52292 == d || 52320 == d || 52348 == d || 52376 == d || 52404 == d || 52432 == d || 52460 == d || 52488 == d || 52516 == d || 52544 == d || 52572 == d || 52600 == d || 52628 == d || 52656 == d || 52684 == d || 52712 == d || 52740 == d || 52768 == d || 52796 == d || 52824 == d || 52852 == d || 52880 == d || 52908 == d || 52936 == d || 52964 == d || 52992 == d || 53020 == d || 53048 == d || 53076 == d || 53104 == d || 53132 == d || 53160 == d || 53188 == d || 53216 == d || 53244 == d || 53272 == d || 53300 == d || 53328 == d || 53356 == d || 53384 == d || 53412 == d || 53440 == d || 53468 == d || 53496 == d || 53524 == d || 53552 == d || 53580 == d || 53608 == d || 53636 == d || 53664 == d || 53692 == d || 53720 == d || 53748 == d || 53776 == d || 53804 == d || 53832 == d || 53860 == d || 53888 == d || 53916 == d || 53944 == d || 53972 == d || 54E3 == d || 54028 == d || 54056 == d || 54084 == d || 54112 == d || 54140 == d || 54168 == d || 54196 == d || 54224 == d || 54252 == d || 54280 == d || 54308 == d || 54336 == d || 54364 == d || 54392 == d || 54420 == d || 54448 == d || 54476 == d || 54504 == d || 54532 == d || 54560 == d || 54588 == d || 54616 == d || 54644 == d || 54672 == d || 54700 == d || 54728 == d || 54756 == d || 54784 == d || 54812 == d || 54840 == d || 54868 == d || 54896 == d || 54924 == d || 54952 == d || 54980 == d || 55008 == d || 55036 == d || 55064 == d || 55092 == d || 55120 == d || 55148 == d || 55176 == d ? 9 : 44033 <= d && 44059 >= d || 44061 <= d && 44087 >= d || 44089 <= d && 44115 >= d || 44117 <= d && 44143 >= d || 44145 <= d && 44171 >= d || 44173 <= d && 44199 >= d || 44201 <= d && 44227 >= d || 44229 <= d && 44255 >= d || 44257 <= d && 44283 >= d || 44285 <= d && 44311 >= d || 44313 <= d && 44339 >= d || 44341 <= d && 44367 >= d || 44369 <= d && 44395 >= d || 44397 <= d && 44423 >= d || 44425 <= d && 44451 >= d || 44453 <= d && 44479 >= d || 44481 <= d && 44507 >= d || 44509 <= d && 44535 >= d || 44537 <= d && 44563 >= d || 44565 <= d && 44591 >= d || 44593 <= d && 44619 >= d || 44621 <= d && 44647 >= d || 44649 <= d && 44675 >= d || 44677 <= d && 44703 >= d || 44705 <= d && 44731 >= d || 44733 <= d && 44759 >= d || 44761 <= d && 44787 >= d || 44789 <= d && 44815 >= d || 44817 <= d && 44843 >= d || 44845 <= d && 44871 >= d || 44873 <= d && 44899 >= d || 44901 <= d && 44927 >= d || 44929 <= d && 44955 >= d || 44957 <= d && 44983 >= d || 44985 <= d && 45011 >= d || 45013 <= d && 45039 >= d || 45041 <= d && 45067 >= d || 45069 <= d && 45095 >= d || 45097 <= d && 45123 >= d || 45125 <= d && 45151 >= d || 45153 <= d && 45179 >= d || 45181 <= d && 45207 >= d || 45209 <= d && 45235 >= d || 45237 <= d && 45263 >= d || 45265 <= d && 45291 >= d || 45293 <= d && 45319 >= d || 45321 <= d && 45347 >= d || 45349 <= d && 45375 >= d || 45377 <= d && 45403 >= d || 45405 <= d && 45431 >= d || 45433 <= d && 45459 >= d || 45461 <= d && 45487 >= d || 45489 <= d && 45515 >= d || 45517 <= d && 45543 >= d || 45545 <= d && 45571 >= d || 45573 <= d && 45599 >= d || 45601 <= d && 45627 >= d || 45629 <= d && 45655 >= d || 45657 <= d && 45683 >= d || 45685 <= d && 45711 >= d || 45713 <= d && 45739 >= d || 45741 <= d && 45767 >= d || 45769 <= d && 45795 >= d || 45797 <= d && 45823 >= d || 45825 <= d && 45851 >= d || 45853 <= d && 45879 >= d || 45881 <= d && 45907 >= d || 45909 <= d && 45935 >= d || 45937 <= d && 45963 >= d || 45965 <= d && 45991 >= d || 45993 <= d && 46019 >= d || 46021 <= d && 46047 >= d || 46049 <= d && 46075 >= d || 46077 <= d && 46103 >= d || 46105 <= d && 46131 >= d || 46133 <= d && 46159 >= d || 46161 <= d && 46187 >= d || 46189 <= d && 46215 >= d || 46217 <= d && 46243 >= d || 46245 <= d && 46271 >= d || 46273 <= d && 46299 >= d || 46301 <= d && 46327 >= d || 46329 <= d && 46355 >= d || 46357 <= d && 46383 >= d || 46385 <= d && 46411 >= d || 46413 <= d && 46439 >= d || 46441 <= d && 46467 >= d || 46469 <= d && 46495 >= d || 46497 <= d && 46523 >= d || 46525 <= d && 46551 >= d || 46553 <= d && 46579 >= d || 46581 <= d && 46607 >= d || 46609 <= d && 46635 >= d || 46637 <= d && 46663 >= d || 46665 <= d && 46691 >= d || 46693 <= d && 46719 >= d || 46721 <= d && 46747 >= d || 46749 <= d && 46775 >= d || 46777 <= d && 46803 >= d || 46805 <= d && 46831 >= d || 46833 <= d && 46859 >= d || 46861 <= d && 46887 >= d || 46889 <= d && 46915 >= d || 46917 <= d && 46943 >= d || 46945 <= d && 46971 >= d || 46973 <= d && 46999 >= d || 47001 <= d && 47027 >= d || 47029 <= d && 47055 >= d || 47057 <= d && 47083 >= d || 47085 <= d && 47111 >= d || 47113 <= d && 47139 >= d || 47141 <= d && 47167 >= d || 47169 <= d && 47195 >= d || 47197 <= d && 47223 >= d || 47225 <= d && 47251 >= d || 47253 <= d && 47279 >= d || 47281 <= d && 47307 >= d || 47309 <= d && 47335 >= d || 47337 <= d && 47363 >= d || 47365 <= d && 47391 >= d || 47393 <= d && 47419 >= d || 47421 <= d && 47447 >= d || 47449 <= d && 47475 >= d || 47477 <= d && 47503 >= d || 47505 <= d && 47531 >= d || 47533 <= d && 47559 >= d || 47561 <= d && 47587 >= d || 47589 <= d && 47615 >= d || 47617 <= d && 47643 >= d || 47645 <= d && 47671 >= d || 47673 <= d && 47699 >= d || 47701 <= d && 47727 >= d || 47729 <= d && 47755 >= d || 47757 <= d && 47783 >= d || 47785 <= d && 47811 >= d || 47813 <= d && 47839 >= d || 47841 <= d && 47867 >= d || 47869 <= d && 47895 >= d || 47897 <= d && 47923 >= d || 47925 <= d && 47951 >= d || 47953 <= d && 47979 >= d || 47981 <= d && 48007 >= d || 48009 <= d && 48035 >= d || 48037 <= d && 48063 >= d || 48065 <= d && 48091 >= d || 48093 <= d && 48119 >= d || 48121 <= d && 48147 >= d || 48149 <= d && 48175 >= d || 48177 <= d && 48203 >= d || 48205 <= d && 48231 >= d || 48233 <= d && 48259 >= d || 48261 <= d && 48287 >= d || 48289 <= d && 48315 >= d || 48317 <= d && 48343 >= d || 48345 <= d && 48371 >= d || 48373 <= d && 48399 >= d || 48401 <= d && 48427 >= d || 48429 <= d && 48455 >= d || 48457 <= d && 48483 >= d || 48485 <= d && 48511 >= d || 48513 <= d && 48539 >= d || 48541 <= d && 48567 >= d || 48569 <= d && 48595 >= d || 48597 <= d && 48623 >= d || 48625 <= d && 48651 >= d || 48653 <= d && 48679 >= d || 48681 <= d && 48707 >= d || 48709 <= d && 48735 >= d || 48737 <= d && 48763 >= d || 48765 <= d && 48791 >= d || 48793 <= d && 48819 >= d || 48821 <= d && 48847 >= d || 48849 <= d && 48875 >= d || 48877 <= d && 48903 >= d || 48905 <= d && 48931 >= d || 48933 <= d && 48959 >= d || 48961 <= d && 48987 >= d || 48989 <= d && 49015 >= d || 49017 <= d && 49043 >= d || 49045 <= d && 49071 >= d || 49073 <= d && 49099 >= d || 49101 <= d && 49127 >= d || 49129 <= d && 49155 >= d || 49157 <= d && 49183 >= d || 49185 <= d && 49211 >= d || 49213 <= d && 49239 >= d || 49241 <= d && 49267 >= d || 49269 <= d && 49295 >= d || 49297 <= d && 49323 >= d || 49325 <= d && 49351 >= d || 49353 <= d && 49379 >= d || 49381 <= d && 49407 >= d || 49409 <= d && 49435 >= d || 49437 <= d && 49463 >= d || 49465 <= d && 49491 >= d || 49493 <= d && 49519 >= d || 49521 <= d && 49547 >= d || 49549 <= d && 49575 >= d || 49577 <= d && 49603 >= d || 49605 <= d && 49631 >= d || 49633 <= d && 49659 >= d || 49661 <= d && 49687 >= d || 49689 <= d && 49715 >= d || 49717 <= d && 49743 >= d || 49745 <= d && 49771 >= d || 49773 <= d && 49799 >= d || 49801 <= d && 49827 >= d || 49829 <= d && 49855 >= d || 49857 <= d && 49883 >= d || 49885 <= d && 49911 >= d || 49913 <= d && 49939 >= d || 49941 <= d && 49967 >= d || 49969 <= d && 49995 >= d || 49997 <= d && 50023 >= d || 50025 <= d && 50051 >= d || 50053 <= d && 50079 >= d || 50081 <= d && 50107 >= d || 50109 <= d && 50135 >= d || 50137 <= d && 50163 >= d || 50165 <= d && 50191 >= d || 50193 <= d && 50219 >= d || 50221 <= d && 50247 >= d || 50249 <= d && 50275 >= d || 50277 <= d && 50303 >= d || 50305 <= d && 50331 >= d || 50333 <= d && 50359 >= d || 50361 <= d && 50387 >= d || 50389 <= d && 50415 >= d || 50417 <= d && 50443 >= d || 50445 <= d && 50471 >= d || 50473 <= d && 50499 >= d || 50501 <= d && 50527 >= d || 50529 <= d && 50555 >= d || 50557 <= d && 50583 >= d || 50585 <= d && 50611 >= d || 50613 <= d && 50639 >= d || 50641 <= d && 50667 >= d || 50669 <= d && 50695 >= d || 50697 <= d && 50723 >= d || 50725 <= d && 50751 >= d || 50753 <= d && 50779 >= d || 50781 <= d && 50807 >= d || 50809 <= d && 50835 >= d || 50837 <= d && 50863 >= d || 50865 <= d && 50891 >= d || 50893 <= d && 50919 >= d || 50921 <= d && 50947 >= d || 50949 <= d && 50975 >= d || 50977 <= d && 51003 >= d || 51005 <= d && 51031 >= d || 51033 <= d && 51059 >= d || 51061 <= d && 51087 >= d || 51089 <= d && 51115 >= d || 51117 <= d && 51143 >= d || 51145 <= d && 51171 >= d || 51173 <= d && 51199 >= d || 51201 <= d && 51227 >= d || 51229 <= d && 51255 >= d || 51257 <= d && 51283 >= d || 51285 <= d && 51311 >= d || 51313 <= d && 51339 >= d || 51341 <= d && 51367 >= d || 51369 <= d && 51395 >= d || 51397 <= d && 51423 >= d || 51425 <= d && 51451 >= d || 51453 <= d && 51479 >= d || 51481 <= d && 51507 >= d || 51509 <= d && 51535 >= d || 51537 <= d && 51563 >= d || 51565 <= d && 51591 >= d || 51593 <= d && 51619 >= d || 51621 <= d && 51647 >= d || 51649 <= d && 51675 >= d || 51677 <= d && 51703 >= d || 51705 <= d && 51731 >= d || 51733 <= d && 51759 >= d || 51761 <= d && 51787 >= d || 51789 <= d && 51815 >= d || 51817 <= d && 51843 >= d || 51845 <= d && 51871 >= d || 51873 <= d && 51899 >= d || 51901 <= d && 51927 >= d || 51929 <= d && 51955 >= d || 51957 <= d && 51983 >= d || 51985 <= d && 52011 >= d || 52013 <= d && 52039 >= d || 52041 <= d && 52067 >= d || 52069 <= d && 52095 >= d || 52097 <= d && 52123 >= d || 52125 <= d && 52151 >= d || 52153 <= d && 52179 >= d || 52181 <= d && 52207 >= d || 52209 <= d && 52235 >= d || 52237 <= d && 52263 >= d || 52265 <= d && 52291 >= d || 52293 <= d && 52319 >= d || 52321 <= d && 52347 >= d || 52349 <= d && 52375 >= d || 52377 <= d && 52403 >= d || 52405 <= d && 52431 >= d || 52433 <= d && 52459 >= d || 52461 <= d && 52487 >= d || 52489 <= d && 52515 >= d || 52517 <= d && 52543 >= d || 52545 <= d && 52571 >= d || 52573 <= d && 52599 >= d || 52601 <= d && 52627 >= d || 52629 <= d && 52655 >= d || 52657 <= d && 52683 >= d || 52685 <= d && 52711 >= d || 52713 <= d && 52739 >= d || 52741 <= d && 52767 >= d || 52769 <= d && 52795 >= d || 52797 <= d && 52823 >= d || 52825 <= d && 52851 >= d || 52853 <= d && 52879 >= d || 52881 <= d && 52907 >= d || 52909 <= d && 52935 >= d || 52937 <= d && 52963 >= d || 52965 <= d && 52991 >= d || 52993 <= d && 53019 >= d || 53021 <= d && 53047 >= d || 53049 <= d && 53075 >= d || 53077 <= d && 53103 >= d || 53105 <= d && 53131 >= d || 53133 <= d && 53159 >= d || 53161 <= d && 53187 >= d || 53189 <= d && 53215 >= d || 53217 <= d && 53243 >= d || 53245 <= d && 53271 >= d || 53273 <= d && 53299 >= d || 53301 <= d && 53327 >= d || 53329 <= d && 53355 >= d || 53357 <= d && 53383 >= d || 53385 <= d && 53411 >= d || 53413 <= d && 53439 >= d || 53441 <= d && 53467 >= d || 53469 <= d && 53495 >= d || 53497 <= d && 53523 >= d || 53525 <= d && 53551 >= d || 53553 <= d && 53579 >= d || 53581 <= d && 53607 >= d || 53609 <= d && 53635 >= d || 53637 <= d && 53663 >= d || 53665 <= d && 53691 >= d || 53693 <= d && 53719 >= d || 53721 <= d && 53747 >= d || 53749 <= d && 53775 >= d || 53777 <= d && 53803 >= d || 53805 <= d && 53831 >= d || 53833 <= d && 53859 >= d || 53861 <= d && 53887 >= d || 53889 <= d && 53915 >= d || 53917 <= d && 53943 >= d || 53945 <= d && 53971 >= d || 53973 <= d && 53999 >= d || 54001 <= d && 54027 >= d || 54029 <= d && 54055 >= d || 54057 <= d && 54083 >= d || 54085 <= d && 54111 >= d || 54113 <= d && 54139 >= d || 54141 <= d && 54167 >= d || 54169 <= d && 54195 >= d || 54197 <= d && 54223 >= d || 54225 <= d && 54251 >= d || 54253 <= d && 54279 >= d || 54281 <= d && 54307 >= d || 54309 <= d && 54335 >= d || 54337 <= d && 54363 >= d || 54365 <= d && 54391 >= d || 54393 <= d && 54419 >= d || 54421 <= d && 54447 >= d || 54449 <= d && 54475 >= d || 54477 <= d && 54503 >= d || 54505 <= d && 54531 >= d || 54533 <= d && 54559 >= d || 54561 <= d && 54587 >= d || 54589 <= d && 54615 >= d || 54617 <= d && 54643 >= d || 54645 <= d && 54671 >= d || 54673 <= d && 54699 >= d || 54701 <= d && 54727 >= d || 54729 <= d && 54755 >= d || 54757 <= d && 54783 >= d || 54785 <= d && 54811 >= d || 54813 <= d && 54839 >= d || 54841 <= d && 54867 >= d || 54869 <= d && 54895 >= d || 54897 <= d && 54923 >= d || 54925 <= d && 54951 >= d || 54953 <= d && 54979 >= d || 54981 <= d && 55007 >= d || 55009 <= d && 55035 >= d || 55037 <= d && 55063 >= d || 55065 <= d && 55091 >= d || 55093 <= d && 55119 >= d || 55121 <= d && 55147 >= d || 55149 <= d && 55175 >= d || 55177 <= d && 55203 >= d ? 10 : 9757 == d || 9977 == d || 9994 <= d && 9997 >= d || 127877 == d || 127938 <= d && 127940 >= d || 127943 == d || 127946 <= d && 127948 >= d || 128066 <= d && 128067 >= d || 128070 <= d && 128080 >= d || 128110 == d || 128112 <= d && 128120 >= d || 128124 == d || 128129 <= d && 128131 >= d || 128133 <= d && 128135 >= d || 128170 == d || 128372 <= d && 128373 >= d || 128378 == d || 128400 == d || 128405 <= d && 128406 >= d || 128581 <= d && 128583 >= d || 128587 <= d && 128591 >= d || 128675 == d || 128692 <= d && 128694 >= d || 128704 == d || 128716 == d || 129304 <= d && 129308 >= d || 129310 <= d && 129311 >= d || 129318 == d || 129328 <= d && 129337 >= d || 129341 <= d && 129342 >= d || 129489 <= d && 129501 >= d ? 13 : 127995 <= d && 127999 >= d ? 14 : 8205 == d ? 15 : 9792 == d || 9794 == d || 9877 <= d && 9878 >= d || 9992 == d || 10084 == d || 127752 == d || 127806 == d || 127859 == d || 127891 == d || 127908 == d || 127912 == d || 127979 == d || 127981 == d || 128139 == d || 128187 <= d && 128188 >= d || 128295 == d || 128300 == d || 128488 == d || 128640 == d || 128658 == d ? 16 : 128102 <= d && 128105 >= d ? 17 : 11
    }
    this.nextBreak = function(d, e) {
        void 0 === e && (e = 0);
        if (0 > e)
            return 0;
        if (e >= d.length - 1)
            return d.length;
        var f = c(a(d, e))
          , h = [];
        for (e += 1; e < d.length; e++) {
            var l = d
              , m = e - 1;
            if (!(55296 <= l.charCodeAt(m) && 56319 >= l.charCodeAt(m) && 56320 <= l.charCodeAt(m + 1) && 57343 >= l.charCodeAt(m + 1))) {
                l = c(a(d, e));
                if (b(f, h, l))
                    return e;
                h.push(l)
            }
        }
        return d.length
    }
    ;
    this.splitGraphemes = function(d) {
        for (var e = [], f = 0, h; (h = this.nextBreak(d, f)) < d.length; )
            e.push(d.slice(f, h)),
            f = h;
        f < d.length && e.push(d.slice(f));
        return e
    }
    ;
    this.iterateGraphemes = function(d) {
        var e = 0
          , f = {
            next: function() {
                var h;
                if ((h = this.nextBreak(d, e)) < d.length) {
                    var l = d.slice(e, h);
                    e = h;
                    return {
                        value: l,
                        done: !1
                    }
                }
                return e < d.length ? (l = d.slice(e),
                e = d.length,
                {
                    value: l,
                    done: !1
                }) : {
                    value: void 0,
                    done: !0
                }
            }
            .bind(this)
        };
        "undefined" !== typeof Symbol && Symbol.iterator && (f[Symbol.iterator] = function() {
            return f
        }
        );
        return f
    }
    ;
    this.countGraphemes = function(d) {
        for (var e = 0, f = 0, h; (h = this.nextBreak(d, f)) < d.length; )
            f = h,
            e++;
        f < d.length && e++;
        return e
    }
    ;
    return this
}
;
"use strict";
function lineInt(a, b, c) {
    var d = [0, 0];
    var e = a[1][1] - a[0][1];
    var f = a[0][0] - a[1][0];
    a = e * a[0][0] + f * a[0][1];
    var h = b[1][1] - b[0][1];
    var l = b[0][0] - b[1][0];
    b = h * b[0][0] + l * b[0][1];
    var m = e * l - h * f;
    scalar_eq(m, 0, c || 0) || (d[0] = (l * a - f * b) / m,
    d[1] = (e * b - h * a) / m);
    return d
}
function lineSegmentsIntersect(a, b, c, d) {
    var e = b[0] - a[0];
    b = b[1] - a[1];
    var f = d[0] - c[0]
      , h = d[1] - c[1];
    if (0 === f * b - h * e)
        return !1;
    d = (e * (c[1] - a[1]) + b * (a[0] - c[0])) / (f * b - h * e);
    a = (f * (a[1] - c[1]) + h * (c[0] - a[0])) / (h * e - f * b);
    return 0 <= d && 1 >= d && 0 <= a && 1 >= a
}
function triangleArea(a, b, c) {
    return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1])
}
function isLeft(a, b, c) {
    return 0 < triangleArea(a, b, c)
}
function isLeftOn(a, b, c) {
    return 0 <= triangleArea(a, b, c)
}
function isRight(a, b, c) {
    return 0 > triangleArea(a, b, c)
}
function isRightOn(a, b, c) {
    return 0 >= triangleArea(a, b, c)
}
var tmpPoint1$$module$content$working$771029573$c3runtime = []
  , tmpPoint2$$module$content$working$771029573$c3runtime = [];
function collinear(a, b, c, d) {
    if (d) {
        var e = tmpPoint1$$module$content$working$771029573$c3runtime
          , f = tmpPoint2$$module$content$working$771029573$c3runtime;
        e[0] = b[0] - a[0];
        e[1] = b[1] - a[1];
        f[0] = c[0] - b[0];
        f[1] = c[1] - b[1];
        return Math.acos((e[0] * f[0] + e[1] * f[1]) / (Math.sqrt(e[0] * e[0] + e[1] * e[1]) * Math.sqrt(f[0] * f[0] + f[1] * f[1]))) < d
    }
    return 0 === triangleArea(a, b, c)
}
function sqdist(a, b) {
    var c = b[0] - a[0];
    a = b[1] - a[1];
    return c * c + a * a
}
function polygonAt(a, b) {
    var c = a.length;
    return a[0 > b ? b % c + c : b % c]
}
function polygonClear(a) {
    a.length = 0
}
function polygonAppend(a, b, c, d) {
    for (; c < d; c++)
        a.push(b[c])
}
function polygonReverse(a) {
    for (var b = [], c = a.length, d = 0; d !== c; d++)
        b.push(a.pop());
    for (d = 0; d !== c; d++)
        a[d] = b[d]
}
function polygonIsReflex(a, b) {
    return isRight(polygonAt(a, b - 1), polygonAt(a, b), polygonAt(a, b + 1))
}
var tmpLine1$$module$content$working$771029573$c3runtime = []
  , tmpLine2$$module$content$working$771029573$c3runtime = [];
function polygonCanSee(a, b, c) {
    var d = tmpLine1$$module$content$working$771029573$c3runtime
      , e = tmpLine2$$module$content$working$771029573$c3runtime;
    if (isLeftOn(polygonAt(a, b + 1), polygonAt(a, b), polygonAt(a, c)) && isRightOn(polygonAt(a, b - 1), polygonAt(a, b), polygonAt(a, c)))
        return !1;
    var f = sqdist(polygonAt(a, b), polygonAt(a, c));
    for (var h = 0; h !== a.length; ++h)
        if ((h + 1) % a.length !== b && h !== b && isLeftOn(polygonAt(a, b), polygonAt(a, c), polygonAt(a, h + 1)) && isRightOn(polygonAt(a, b), polygonAt(a, c), polygonAt(a, h))) {
            d[0] = polygonAt(a, b);
            d[1] = polygonAt(a, c);
            e[0] = polygonAt(a, h);
            e[1] = polygonAt(a, h + 1);
            var l = lineInt(d, e);
            if (sqdist(polygonAt(a, b), l) < f)
                return !1
        }
    return !0
}
function polygonCanSee2(a, b, c) {
    for (var d = 0; d !== a.length; ++d)
        if (d !== b && d !== c && (d + 1) % a.length !== b && (d + 1) % a.length !== c && lineSegmentsIntersect(polygonAt(a, b), polygonAt(a, c), polygonAt(a, d), polygonAt(a, d + 1)))
            return !1;
    return !0
}
function polygonCopy(a, b, c, d) {
    d = d || [];
    polygonClear(d);
    if (b < c)
        for (var e = b; e <= c; e++)
            d.push(a[e]);
    else {
        for (e = 0; e <= c; e++)
            d.push(a[e]);
        for (e = b; e < a.length; e++)
            d.push(a[e])
    }
    return d
}
function polygonGetCutEdges(a) {
    for (var b = [], c, d, e = [], f = Number.MAX_VALUE, h = 0; h < a.length; ++h)
        if (polygonIsReflex(a, h))
            for (var l = 0; l < a.length; ++l)
                if (polygonCanSee(a, h, l)) {
                    c = polygonGetCutEdges(polygonCopy(a, h, l, e));
                    d = polygonGetCutEdges(polygonCopy(a, l, h, e));
                    for (var m = 0; m < d.length; m++)
                        c.push(d[m]);
                    c.length < f && (b = c,
                    f = c.length,
                    b.push([polygonAt(a, h), polygonAt(a, l)]))
                }
    return b
}
function polygonSlice(a, b) {
    if (0 === b.length)
        return [a];
    if (b instanceof Array && b.length && b[0]instanceof Array && 2 === b[0].length && b[0][0]instanceof Array) {
        a = [a];
        for (var c = 0; c < b.length; c++)
            for (var d = b[c], e = 0; e < a.length; e++) {
                var f = polygonSlice(a[e], d);
                if (f) {
                    a.splice(e, 1);
                    a.push(f[0], f[1]);
                    break
                }
            }
        return a
    }
    d = b;
    c = a.indexOf(d[0]);
    e = a.indexOf(d[1]);
    return -1 !== c && -1 !== e ? [polygonCopy(a, c, e), polygonCopy(a, e, c)] : !1
}
function getIntersectionPoint(a, b, c, d, e) {
    var f = b[1] - a[1];
    b = a[0] - b[0];
    a = f * a[0] + b * a[1];
    var h = d[1] - c[1];
    d = c[0] - d[0];
    c = h * c[0] + d * c[1];
    var l = f * d - h * b;
    return scalar_eq(l, 0, e || 0) ? [0, 0] : [(d * a - b * c) / l, (f * c - h * a) / l]
}
function polygonQuickDecomp(a, b, c, d, e, f, h) {
    f = f || 100;
    h = h || 0;
    e = e || 25;
    b = "undefined" !== typeof b ? b : [];
    c = c || [];
    d = d || [];
    var l = [0, 0], m = [0, 0], p = [0, 0], r, v = 0, x = 0, B = 0, A = [], D = [];
    if (3 > a.length)
        return b;
    h++;
    if (h > f)
        return console.warn("quickDecomp: max level (" + f + ") reached."),
        b;
    for (var F = 0; F < a.length; ++F)
        if (polygonIsReflex(a, F)) {
            c.push(a[F]);
            var I = r = Number.MAX_VALUE;
            for (var K = 0; K < a.length; ++K) {
                if (isLeft(polygonAt(a, F - 1), polygonAt(a, F), polygonAt(a, K)) && isRightOn(polygonAt(a, F - 1), polygonAt(a, F), polygonAt(a, K - 1)) && (p = getIntersectionPoint(polygonAt(a, F - 1), polygonAt(a, F), polygonAt(a, K), polygonAt(a, K - 1)),
                isRight(polygonAt(a, F + 1), polygonAt(a, F), p))) {
                    var M = sqdist(a[F], p);
                    M < r && (r = M,
                    m = p,
                    x = K)
                }
                isLeft(polygonAt(a, F + 1), polygonAt(a, F), polygonAt(a, K + 1)) && isRightOn(polygonAt(a, F + 1), polygonAt(a, F), polygonAt(a, K)) && (p = getIntersectionPoint(polygonAt(a, F + 1), polygonAt(a, F), polygonAt(a, K), polygonAt(a, K + 1)),
                isLeft(polygonAt(a, F - 1), polygonAt(a, F), p) && (M = sqdist(a[F], p),
                M < I && (I = M,
                l = p,
                v = K)))
            }
            if (x === (v + 1) % a.length)
                p[0] = (m[0] + l[0]) / 2,
                p[1] = (m[1] + l[1]) / 2,
                d.push(p),
                F < v ? (polygonAppend(A, a, F, v + 1),
                A.push(p),
                D.push(p),
                0 !== x && polygonAppend(D, a, x, a.length),
                polygonAppend(D, a, 0, F + 1)) : (0 !== F && polygonAppend(A, a, F, a.length),
                polygonAppend(A, a, 0, v + 1),
                A.push(p),
                D.push(p),
                polygonAppend(D, a, x, F + 1));
            else {
                x > v && (v += a.length);
                l = Number.MAX_VALUE;
                if (v < x)
                    return b;
                for (K = x; K <= v; ++K)
                    isLeftOn(polygonAt(a, F - 1), polygonAt(a, F), polygonAt(a, K)) && isRightOn(polygonAt(a, F + 1), polygonAt(a, F), polygonAt(a, K)) && (M = sqdist(polygonAt(a, F), polygonAt(a, K)),
                    M < l && polygonCanSee2(a, F, K) && (l = M,
                    B = K % a.length));
                F < B ? (polygonAppend(A, a, F, B + 1),
                0 !== B && polygonAppend(D, a, B, a.length),
                polygonAppend(D, a, 0, F + 1)) : (0 !== F && polygonAppend(A, a, F, a.length),
                polygonAppend(A, a, 0, B + 1),
                polygonAppend(D, a, B, F + 1))
            }
            A.length < D.length ? (polygonQuickDecomp(A, b, c, d, e, f, h),
            polygonQuickDecomp(D, b, c, d, e, f, h)) : (polygonQuickDecomp(D, b, c, d, e, f, h),
            polygonQuickDecomp(A, b, c, d, e, f, h));
            return b
        }
    b.push(a);
    return b
}
function scalar_eq(a, b, c) {
    return Math.abs(a - b) <= (c || 0)
}
function points_eq(a, b, c) {
    return scalar_eq(a[0], b[0], c) && scalar_eq(a[1], b[1], c)
}
self.polyDecomp = {
    decomp: function(a) {
        var b = polygonGetCutEdges(a);
        return 0 < b.length ? polygonSlice(a, b) : [a]
    },
    quickDecomp: polygonQuickDecomp,
    isSimple: function(a) {
        var b;
        for (b = 0; b < a.length - 1; b++)
            for (var c = 0; c < b - 1; c++)
                if (lineSegmentsIntersect(a[b], a[b + 1], a[c], a[c + 1]))
                    return !1;
        for (b = 1; b < a.length - 2; b++)
            if (lineSegmentsIntersect(a[0], a[a.length - 1], a[b], a[b + 1]))
                return !1;
        return !0
    },
    removeCollinearPoints: function(a, b) {
        for (var c = 0, d = a.length - 1; 3 < a.length && 0 <= d; --d)
            collinear(polygonAt(a, d - 1), polygonAt(a, d), polygonAt(a, d + 1), b) && (a.splice(d % a.length, 1),
            c++);
        return c
    },
    removeDuplicatePoints: function(a, b) {
        for (var c = a.length - 1; 1 <= c; --c)
            for (var d = a[c], e = c - 1; 0 <= e; --e)
                points_eq(d, a[e], b) && a.splice(c, 1)
    },
    makeCCW: function(a) {
        for (var b = 0, c = 1; c < a.length; ++c)
            if (a[c][1] < a[b][1] || a[c][1] === a[b][1] && a[c][0] > a[b][0])
                b = c;
        if (isLeft(polygonAt(a, b - 1), polygonAt(a, b), polygonAt(a, b + 1)))
            return !1;
        polygonReverse(a);
        return !0
    }
};
"use strict";
let isReady = !1
  , hasAppStarted = !1
  , buildMode = "dev";
const internalApiToken = Symbol("Construct internal API token");
let internalApiTokenAccessesRemaining = 14;
const C3 = self.C3 = class {
    constructor() {
        throw TypeError("static class can't be instantiated");
    }
    static _GetInternalAPIToken() {
        if (0 >= internalApiTokenAccessesRemaining)
            throw Error("cannot obtain internal API token");
        --internalApiTokenAccessesRemaining;
        return internalApiToken
    }
    static SetReady() {
        isReady = !0
    }
    static IsReady() {
        return isReady
    }
    static SetAppStarted() {
        hasAppStarted = !0
    }
    static HasAppStarted() {
        return hasAppStarted
    }
    static SetBuildMode(a) {
        buildMode = a
    }
    static GetBuildMode() {
        return buildMode
    }
    static IsReleaseBuild() {
        return "final" === buildMode
    }
}
;
C3.isDebug = !1;
C3.isDebugDefend = !1;
C3.hardwareConcurrency = navigator.hardwareConcurrency || 2;
self.C3X = {};
"use strict";
const C3$jscomp$2 = self.C3;
C3$jscomp$2.QueryParser = class {
    constructor(a) {
        this._queryString = a;
        this._parameters = new Map;
        this._Parse()
    }
    _Parse() {
        var a = this._queryString;
        if (a.startsWith("?") || a.startsWith("#"))
            a = a.substr(1);
        a = a.split("&");
        for (const b of a)
            this._ParseParameter(b)
    }
    _ParseParameter(a) {
        if (a)
            if (a.includes("=")) {
                var b = a.indexOf("=")
                  , c = decodeURIComponent(a.substring(0, b));
                a = decodeURIComponent(a.substring(b + 1));
                this._parameters.set(c, a)
            } else
                this._parameters.set(a, null)
    }
    LogAll() {
        for (const a of this._parameters)
            console.log("[QueryParser] Parameter '" + a[0] + "' = " + (null === a[1] ? "null" : "'" + a[1] + "'"))
    }
    Has(a) {
        return this._parameters.has(a)
    }
    Get(a) {
        a = this._parameters.get(a);
        return "undefined" === typeof a ? null : a
    }
    ClearHash() {
        history.replaceState("", document.title, location.pathname + location.search)
    }
    Reparse(a) {
        this._queryString = a;
        this._parameters.clear();
        this._Parse()
    }
}
;
C3$jscomp$2.QueryString = new C3$jscomp$2.QueryParser(location.search);
C3$jscomp$2.LocationHashString = new C3$jscomp$2.QueryParser(location.hash);
C3$jscomp$2.QueryString.Has("perf") && (C3$jscomp$2.isPerformanceProfiling = !0);
"dev" !== C3$jscomp$2.QueryString.Get("mode") && C3$jscomp$2.SetBuildMode("final");
"use strict";
const C3$jscomp$3 = self.C3;
C3$jscomp$3.Platform = {
    OS: "(unknown)",
    OSVersion: "(unknown)",
    Browser: "(unknown)",
    BrowserVersion: "(unknown)",
    BrowserVersionNumber: NaN,
    BrowserEngine: "(unknown)",
    Context: "browser",
    IsDesktop: !0,
    IsMobile: !1,
    IsAppleOS: !1,
    IsIpadOS: !1,
    GetDetailedInfo: async () => {}
};
const windowsNTVerMap = new Map([[5, "2000"], [5.1, "XP"], [5.2, "XP"], [6, "Vista"], [6.1, "7"], [6.2, "8"], [6.3, "8.1"], [10, "10"]]);
function GetWindowsNTVersionName(a) {
    const b = parseFloat(a)
      , c = windowsNTVerMap.get(b);
    return c ? c : 13 <= b ? "11" : "NT " + a
}
const uaStr = navigator.userAgent
  , uaData = navigator.userAgentData;
if (uaData && 0 < uaData.brands.length) {
    C3$jscomp$3.Platform.OS = uaData.platform;
    C3$jscomp$3.Platform.IsMobile = uaData.mobile;
    C3$jscomp$3.Platform.IsDesktop = !C3$jscomp$3.Platform.IsMobile;
    const a = new Map([["Google Chrome", "Chrome"], ["Microsoft Edge", "Edge"], ["Opera", "Opera"], ["Opera GX", "Opera GX"], ["Mozilla Firefox", "Firefox"], ["Apple Safari", "Safari"], ["NW.js", "NW.js"]])
      , b = new Map([["Chromium", "Chromium"], ["Gecko", "Gecko"], ["WebKit", "WebKit"]]);
    function c(e) {
        let f = ""
          , h = ""
          , l = ""
          , m = "";
        for (const p of e)
            e = a.get(p.brand),
            !f && e && (f = e,
            h = p.version),
            e = b.get(p.brand),
            !l && e && (l = e,
            m = p.version);
        f || "Chromium" !== l || (C3$jscomp$3.Platform.Browser = "Chromium",
        C3$jscomp$3.Platform.BrowserVersion = m);
        C3$jscomp$3.Platform.Browser = f || "(unknown)";
        C3$jscomp$3.Platform.BrowserVersion = h || "(unknown)";
        C3$jscomp$3.Platform.BrowserEngine = l || "(unknown)"
    }
    c(uaData.brands);
    let d = !1;
    C3$jscomp$3.Platform.GetDetailedInfo = async () => {
        if (!d)
            try {
                const e = await navigator.userAgentData.getHighEntropyValues(["platformVersion", "fullVersionList"]);
                c(e.fullVersionList);
                C3$jscomp$3.Platform.OSVersion = "Windows" === C3$jscomp$3.Platform.OS ? GetWindowsNTVersionName(e.platformVersion) : e.platformVersion;
                d = !0
            } catch (e) {
                console.warn("Failed to get detailed user agent information: ", e)
            }
    }
} else {
    function a(p, r) {
        p = Array.isArray(p) ? p : [p];
        for (const v of p)
            if (p = v.exec(uaStr)) {
                r(p);
                break
            }
    }
    a(/windows\s+nt\s+([\d\.]+)/i, p => {
        C3$jscomp$3.Platform.OS = "Windows";
        C3$jscomp$3.Platform.OSVersion = GetWindowsNTVersionName(p[1])
    }
    );
    a(/mac\s+os\s+x\s+([\d\._]+)/i, p => {
        C3$jscomp$3.Platform.OS = "macOS";
        C3$jscomp$3.Platform.OSVersion = p[1].replace(/_/g, ".")
    }
    );
    a(/CrOS/, () => {
        C3$jscomp$3.Platform.OS = "Chrome OS"
    }
    );
    a(/linux|openbsd|freebsd|netbsd/i, () => {
        C3$jscomp$3.Platform.OS = "Linux"
    }
    );
    a(/android/i, () => {
        C3$jscomp$3.Platform.OS = "Android"
    }
    );
    a(/android\s+([\d\.]+)/i, p => {
        C3$jscomp$3.Platform.OS = "Android";
        C3$jscomp$3.Platform.OSVersion = p[1]
    }
    );
    "(unknown)" === C3$jscomp$3.Platform.OS && (a(/(iphone|ipod|ipad)/i, p => {
        C3$jscomp$3.Platform.OS = "iOS"
    }
    ),
    a([/iphone\s+os\s+([\d\._]+)/i, /ipad[^)]*os\s+([\d\._]+)/i], p => {
        C3$jscomp$3.Platform.OS = "iOS";
        C3$jscomp$3.Platform.OSVersion = p[1].replace(/_/g, ".")
    }
    ));
    const b = /chrome\//i.test(uaStr)
      , c = /chromium\//i.test(uaStr)
      , d = /edg\//i.test(uaStr)
      , e = /OPR\//.test(uaStr)
      , f = /nwjs/i.test(uaStr)
      , h = /safari\//i.test(uaStr)
      , l = /webkit/i.test(uaStr);
    d || e || a(/chrome\/([\d\.]+)/i, p => {
        C3$jscomp$3.Platform.Browser = "Chrome";
        C3$jscomp$3.Platform.BrowserVersion = p[1];
        C3$jscomp$3.Platform.BrowserEngine = "Chromium"
    }
    );
    a(/edg\/([\d\.]+)/i, p => {
        C3$jscomp$3.Platform.Browser = "Edge";
        C3$jscomp$3.Platform.BrowserVersion = p[1];
        C3$jscomp$3.Platform.BrowserEngine = "Chromium"
    }
    );
    a(/OPR\/([\d\.]+)/, p => {
        C3$jscomp$3.Platform.Browser = "Opera";
        C3$jscomp$3.Platform.BrowserVersion = p[1];
        C3$jscomp$3.Platform.BrowserEngine = "Chromium"
    }
    );
    a(/chromium\/([\d\.]+)/i, p => {
        C3$jscomp$3.Platform.Browser = "Chromium";
        C3$jscomp$3.Platform.BrowserVersion = p[1];
        C3$jscomp$3.Platform.BrowserEngine = "Chromium"
    }
    );
    a(/nwjs\/[0-9.]+/i, p => {
        C3$jscomp$3.Platform.Browser = "NW.js";
        C3$jscomp$3.Platform.BrowserVersion = p[1];
        C3$jscomp$3.Platform.BrowserEngine = "Chromium";
        C3$jscomp$3.Platform.Context = "nwjs"
    }
    );
    a(/firefox\/([\d\.]+)/i, p => {
        C3$jscomp$3.Platform.Browser = "Firefox";
        C3$jscomp$3.Platform.BrowserVersion = p[1];
        C3$jscomp$3.Platform.BrowserEngine = "Gecko"
    }
    );
    !h || b || c || d || e || f || (C3$jscomp$3.Platform.Browser = "Safari",
    C3$jscomp$3.Platform.BrowserEngine = "WebKit",
    a(/version\/([\d\.]+)/i, p => {
        C3$jscomp$3.Platform.BrowserVersion = p[1]
    }
    ),
    a(/crios\/([\d\.]+)/i, p => {
        C3$jscomp$3.Platform.Browser = "Chrome for iOS";
        C3$jscomp$3.Platform.BrowserVersion = p[1]
    }
    ),
    a(/fxios\/([\d\.]+)/i, p => {
        C3$jscomp$3.Platform.Browser = "Firefox for iOS";
        C3$jscomp$3.Platform.BrowserVersion = p[1]
    }
    ),
    a(/edgios\/([\d\.]+)/i, p => {
        C3$jscomp$3.Platform.Browser = "Edge for iOS";
        C3$jscomp$3.Platform.BrowserVersion = p[1]
    }
    ));
    "(unknown)" === C3$jscomp$3.Platform.BrowserEngine && l && (C3$jscomp$3.Platform.BrowserEngine = "WebKit");
    "Android" === C3$jscomp$3.Platform.OS && "Safari" === C3$jscomp$3.Platform.Browser && (C3$jscomp$3.Platform.Browser = "Stock");
    const m = (new Set(["Windows", "macOS", "Linux", "Chrome OS"])).has(C3$jscomp$3.Platform.OS) || "nwjs" === C3$jscomp$3.Platform.Context;
    C3$jscomp$3.Platform.IsDesktop = m;
    C3$jscomp$3.Platform.IsMobile = !m
}
"Chrome" === C3$jscomp$3.Platform.Browser && "browser" === C3$jscomp$3.Platform.Context && /wv\)/.test(uaStr) && (C3$jscomp$3.Platform.Context = "webview");
"nwjs" !== C3$jscomp$3.Platform.Context && "undefined" !== typeof window && (window.matchMedia && window.matchMedia("(display-mode: standalone)").matches || navigator.standalone) && (C3$jscomp$3.Platform.Context = "webapp");
C3$jscomp$3.Platform.BrowserVersionNumber = parseFloat(C3$jscomp$3.Platform.BrowserVersion);
"macOS" === C3$jscomp$3.Platform.OS && navigator.maxTouchPoints && 2 < navigator.maxTouchPoints && (C3$jscomp$3.Platform.OS = "iOS",
C3$jscomp$3.Platform.OSVersion = C3$jscomp$3.Platform.BrowserVersion,
C3$jscomp$3.Platform.IsDesktop = !1,
C3$jscomp$3.Platform.IsMobile = !0,
C3$jscomp$3.Platform.IsIpadOS = !0);
C3$jscomp$3.Platform.IsAppleOS = "macOS" === C3$jscomp$3.Platform.OS || "iOS" === C3$jscomp$3.Platform.OS;
"use strict";
const DATABASE_PROMISE_MAP = new Map
  , SUPPORTS_GETALL = "undefined" !== typeof IDBObjectStore && "function" === typeof IDBObjectStore.prototype.getAll
  , SUPPORTS_GETALLKEYS = "undefined" !== typeof IDBObjectStore && "function" === typeof IDBObjectStore.prototype.getAllKeys;
function asyncifyRequest(a) {
    return new Promise( (b, c) => {
        a.onsuccess = () => b(a.result);
        a.onerror = () => c(a.error)
    }
    )
}
function asyncifyTransaction(a) {
    return new Promise( (b, c) => {
        a.oncomplete = () => b();
        a.onerror = () => c(a.error);
        a.onabort = () => c(a.error)
    }
    )
}
function openReadOnlyTransaction(a, b) {
    return openTransaction(a, b)
}
function openWriteTransaction(a, b) {
    return openTransaction(a, b, !0)
}
async function openTransaction(a, b, c=!1, d=!0) {
    const e = await lazyOpenDatabase(a);
    try {
        const f = e.transaction(["keyvaluepairs"], c ? "readwrite" : "readonly");
        return b(f)
    } catch (f) {
        if (d && "InvalidStateError" === f.name)
            return DATABASE_PROMISE_MAP.delete(a),
            openTransaction(a, b, c, !1);
        throw f;
    }
}
function lazyOpenDatabase(a) {
    RequireString(a);
    let b = DATABASE_PROMISE_MAP.get(a);
    b instanceof Promise || (b = openDatabase$jscomp$1(a),
    DATABASE_PROMISE_MAP.set(a, b),
    b.catch(c => DATABASE_PROMISE_MAP.delete(a)));
    return b
}
async function openDatabase$jscomp$1(a) {
    RequireString(a);
    const b = indexedDB.open(a, 2);
    b.addEventListener("upgradeneeded", c => {
        try {
            c.target.result.createObjectStore("keyvaluepairs")
        } catch (d) {
            console.error(`Failed to create objectstore for database ${a}`, d)
        }
    }
    );
    return asyncifyRequest(b)
}
function RequireString(a) {
    if ("string" !== typeof a)
        throw new TypeError("expected string");
}
function getEntriesFromCursor(a, b) {
    const c = a.objectStore("keyvaluepairs").openCursor();
    return new Promise(d => {
        const e = [];
        c.onsuccess = f => {
            if (f = f.target.result) {
                switch (b) {
                case "entries":
                    e.push([f.key, f.value]);
                    break;
                case "keys":
                    e.push(f.key);
                    break;
                case "values":
                    e.push(f.value)
                }
                f.continue()
            } else
                d(e)
        }
    }
    )
}
class KVStorageContainer {
    constructor(a) {
        RequireString(a);
        this.name = a
    }
    async ready() {
        await lazyOpenDatabase(this.name)
    }
    set(a, b) {
        RequireString(a);
        return openWriteTransaction(this.name, async c => {
            var d = c.objectStore("keyvaluepairs").put(b, a);
            d = asyncifyRequest(d);
            c = asyncifyTransaction(c);
            await Promise.all([c, d])
        }
        )
    }
    get(a) {
        RequireString(a);
        return openReadOnlyTransaction(this.name, async b => {
            var c = b.objectStore("keyvaluepairs").get(a);
            c = asyncifyRequest(c);
            b = asyncifyTransaction(b);
            [,b] = await Promise.all([b, c]);
            return b
        }
        )
    }
    delete(a) {
        RequireString(a);
        return openWriteTransaction(this.name, async b => {
            var c = b.objectStore("keyvaluepairs").delete(a);
            c = asyncifyRequest(c);
            b = asyncifyTransaction(b);
            await Promise.all([b, c])
        }
        )
    }
    clear() {
        return openWriteTransaction(this.name, async a => {
            var b = a.objectStore("keyvaluepairs").clear();
            b = asyncifyRequest(b);
            a = asyncifyTransaction(a);
            await Promise.all([a, b])
        }
        )
    }
    keys() {
        return openReadOnlyTransaction(this.name, async a => {
            if (SUPPORTS_GETALLKEYS) {
                var b = a.objectStore("keyvaluepairs").getAllKeys();
                b = asyncifyRequest(b)
            } else
                b = getEntriesFromCursor(a, "keys");
            a = asyncifyTransaction(a);
            [,a] = await Promise.all([a, b]);
            return a
        }
        )
    }
    values() {
        return openReadOnlyTransaction(this.name, async a => {
            if (SUPPORTS_GETALL) {
                var b = a.objectStore("keyvaluepairs").getAll();
                b = asyncifyRequest(b)
            } else
                b = getEntriesFromCursor(a, "values");
            a = asyncifyTransaction(a);
            [,a] = await Promise.all([a, b]);
            return a
        }
        )
    }
    entries() {
        return openReadOnlyTransaction(this.name, async a => {
            var b = getEntriesFromCursor(a, "entries");
            a = asyncifyTransaction(a);
            [,b] = await Promise.all([a, b]);
            return b
        }
        )
    }
}
self.KVStorageContainer = KVStorageContainer;
"use strict";
const KVStorageContainer$jscomp$1 = self.KVStorageContainer
  , CRITICAL_ERRORS = [/no available storage method found/i, /an attempt was made to break through the security policy of the user agent/i, /the user denied permission to access the database/i, /a mutation operation was attempted on a database that did not allow mutations/i, /idbfactory\.open\(\) called in an invalid security context/i]
  , memoryStorage = new WeakMap;
let isInMemory = !1;
"undefined" === typeof indexedDB && (isInMemory = !0,
console.warn("Unable to use local storage because indexedDB is not defined"));
function NOT_IMPLEMENTED(a) {
    throw Error(`"${a}" is not implemented`);
}
function DISALLOW_CALLBACK(a) {
    if ("function" === typeof a)
        throw Error("localforage callback API is not implemented; please use the promise API instead");
}
function StructuredClone(a) {
    return "object" === typeof a ? new Promise(b => {
        const {port1: c, port2: d} = new MessageChannel;
        d.onmessage = e => b(e.data);
        c.postMessage(a)
    }
    ) : Promise.resolve(a)
}
class ForageAdaptor {
    constructor(a) {
        this._inst = a;
        memoryStorage.set(this, new Map)
    }
    _MaybeSwitchToMemoryFallback(a) {
        if (!isInMemory)
            for (const b of CRITICAL_ERRORS)
                if (a && b.test(a.message)) {
                    console.error("Unable to use local storage, reverting to in-memory store: ", a, a.message);
                    isInMemory = !0;
                    break
                }
    }
    async _getItemFallback(a) {
        a = memoryStorage.get(this).get(a);
        a = await StructuredClone(a);
        return "undefined" === typeof a ? null : a
    }
    async _setItemFallback(a, b) {
        b = await StructuredClone(b);
        memoryStorage.get(this).set(a, b)
    }
    _removeItemFallback(a) {
        memoryStorage.get(this).delete(a)
    }
    _clearFallback() {
        memoryStorage.get(this).clear()
    }
    _keysFallback() {
        return Array.from(memoryStorage.get(this).keys())
    }
    IsUsingFallback() {
        return isInMemory
    }
    async getItem(a, b) {
        DISALLOW_CALLBACK(b);
        if (isInMemory)
            return await this._getItemFallback(a);
        let c;
        try {
            c = await this._inst.get(a)
        } catch (d) {
            this._MaybeSwitchToMemoryFallback(d);
            if (isInMemory)
                return await this._getItemFallback(a);
            console.error(`Error reading '${a}' from storage, returning null: `, d);
            return null
        }
        return "undefined" === typeof c ? null : c
    }
    async setItem(a, b, c) {
        DISALLOW_CALLBACK(c);
        "undefined" === typeof b && (b = null);
        if (isInMemory)
            await this._setItemFallback(a, b);
        else
            try {
                await this._inst.set(a, b)
            } catch (d) {
                if (this._MaybeSwitchToMemoryFallback(d),
                isInMemory)
                    await this._setItemFallback(a, b);
                else
                    throw d;
            }
    }
    async removeItem(a, b) {
        DISALLOW_CALLBACK(b);
        if (isInMemory)
            this._removeItemFallback(a);
        else
            try {
                await this._inst.delete(a)
            } catch (c) {
                this._MaybeSwitchToMemoryFallback(c),
                isInMemory ? this._removeItemFallback(a) : console.error(`Error removing '${a}' from storage: `, c)
            }
    }
    async clear(a) {
        DISALLOW_CALLBACK(a);
        if (isInMemory)
            this._clearFallback();
        else
            try {
                await this._inst.clear()
            } catch (b) {
                this._MaybeSwitchToMemoryFallback(b),
                isInMemory ? this._clearFallback() : console.error("Error clearing storage: ", b)
            }
    }
    async keys(a) {
        DISALLOW_CALLBACK(a);
        if (isInMemory)
            return this._keysFallback();
        a = [];
        try {
            a = await this._inst.keys()
        } catch (b) {
            this._MaybeSwitchToMemoryFallback(b);
            if (isInMemory)
                return this._keysFallback();
            console.error("Error getting storage keys: ", b)
        }
        return a
    }
    ready(a) {
        DISALLOW_CALLBACK(a);
        return isInMemory ? Promise.resolve(!0) : this._inst.ready()
    }
    createInstance(a) {
        if ("object" !== typeof a)
            throw new TypeError("invalid options object");
        a = a.name;
        if ("string" !== typeof a)
            throw new TypeError("invalid store name");
        a = new KVStorageContainer$jscomp$1(a);
        return new ForageAdaptor(a)
    }
    length(a) {
        NOT_IMPLEMENTED("localforage.length()")
    }
    key(a, b) {
        NOT_IMPLEMENTED("localforage.key()")
    }
    iterate(a, b) {
        NOT_IMPLEMENTED("localforage.iterate()")
    }
    setDriver(a) {
        NOT_IMPLEMENTED("localforage.setDriver()")
    }
    config(a) {
        NOT_IMPLEMENTED("localforage.config()")
    }
    defineDriver(a) {
        NOT_IMPLEMENTED("localforage.defineDriver()")
    }
    driver() {
        NOT_IMPLEMENTED("localforage.driver()")
    }
    supports(a) {
        NOT_IMPLEMENTED("localforage.supports()")
    }
    dropInstance() {
        NOT_IMPLEMENTED("localforage.dropInstance()")
    }
    disableMemoryMode() {
        isInMemory = !1
    }
}
self.localforage = new ForageAdaptor(new KVStorageContainer$jscomp$1("localforage"));
"use strict";
const C3$jscomp$4 = self.C3;
C3$jscomp$4.Supports = {};
C3$jscomp$4.Supports.WebAnimations = ( () => {
    try {
        if ("undefined" === typeof document)
            return !1;
        const a = document.createElement("div");
        return "undefined" === typeof a.animate ? !1 : "undefined" !== typeof a.animate([{
            opacity: "0"
        }, {
            opacity: "1"
        }], 1E3).reverse
    } catch (a) {
        return !1
    }
}
)();
C3$jscomp$4.Supports.DialogElement = "undefined" !== typeof HTMLDialogElement;
C3$jscomp$4.Supports.RequestIdleCallback = !!self.requestIdleCallback;
C3$jscomp$4.Supports.ImageBitmap = !!self.createImageBitmap;
C3$jscomp$4.Supports.ImageBitmapOptions = !1;
C3$jscomp$4.Supports.ImageBitmapOptionsResize = !1;
if (C3$jscomp$4.Supports.ImageBitmap) {
    try {
        self.createImageBitmap(new ImageData(32,32), {
            premultiplyAlpha: "none"
        }).then( () => {
            C3$jscomp$4.Supports.ImageBitmapOptions = !0
        }
        ).catch( () => {
            C3$jscomp$4.Supports.ImageBitmapOptions = !1
        }
        )
    } catch (a) {
        C3$jscomp$4.Supports.ImageBitmapOptions = !1
    }
    try {
        self.createImageBitmap(new ImageData(32,32), {
            resizeWidth: 10,
            resizeHeight: 10
        }).then(a => {
            C3$jscomp$4.Supports.ImageBitmapOptionsResize = 10 === a.width && 10 === a.height
        }
        ).catch( () => {
            C3$jscomp$4.Supports.ImageBitmapOptionsResize = !1
        }
        )
    } catch (a) {
        C3$jscomp$4.Supports.ImageBitmapOptionsResize = !1
    }
}
C3$jscomp$4.Supports.ClipboardReadText = !(!navigator.clipboard || !navigator.clipboard.readText || "Firefox" === C3$jscomp$4.Platform.Browser);
C3$jscomp$4.Supports.PermissionsQuery = !(!navigator.permissions || !navigator.permissions.query);
C3$jscomp$4.Supports.ClipboardPermissionsQuery = !1;
C3$jscomp$4.Supports.PermissionsQuery && navigator.permissions.query({
    name: "clipboard-read"
}).then( () => {
    C3$jscomp$4.Supports.ClipboardPermissionsQuery = !0
}
).catch( () => {
    C3$jscomp$4.Supports.ClipboardPermissionsQuery = !1
}
);
C3$jscomp$4.Supports.AsyncClipboardApi = !!(navigator.permissions && navigator.clipboard && self.ClipboardItem);
C3$jscomp$4.Supports.Proxies = "undefined" !== typeof Proxy;
C3$jscomp$4.Supports.DownloadAttribute = ( () => "undefined" === typeof document ? !1 : "undefined" !== typeof document.createElement("a").download)();
C3$jscomp$4.Supports.Fetch = "function" === typeof fetch;
C3$jscomp$4.Supports.PersistentStorage = !!(self.isSecureContext && "Opera" !== C3$jscomp$4.Platform.Browser && navigator.storage && navigator.storage.persist);
C3$jscomp$4.Supports.StorageQuotaEstimate = !!(self.isSecureContext && navigator.storage && navigator.storage.estimate);
C3$jscomp$4.Supports.Fullscreen = ( () => {
    if ("undefined" === typeof document || "iOS" === C3$jscomp$4.Platform.OS)
        return !1;
    const a = document.documentElement;
    return !!(a.requestFullscreen || a.msRequestFullscreen || a.mozRequestFullScreen || a.webkitRequestFullscreen)
}
)();
C3$jscomp$4.Supports.ImageDecoder = "undefined" !== typeof self.ImageDecoder;
C3$jscomp$4.Supports.WebCodecs = !!self.VideoEncoder;
C3$jscomp$4.Supports.NativeFileSystemAPI = !!self.showOpenFilePicker;
C3$jscomp$4.Supports.QueryLocalFonts = !!self.queryLocalFonts;
C3$jscomp$4.Supports.UserActivation = !!navigator.userActivation;
C3$jscomp$4.Supports.CanvasToBlobWebP = !1;
(async () => {
    let a;
    "undefined" === typeof document ? a = new OffscreenCanvas(32,32) : (a = document.createElement("canvas"),
    a.width = 32,
    a.height = 32);
    var b = a.getContext("2d");
    b.fillStyle = "blue";
    b.fillRect(0, 0, 32, 32);
    b = null;
    try {
        a.convertToBlob ? b = await a.convertToBlob({
            type: "image/webp",
            quality: 1
        }) : a.toBlob && (b = await new Promise(c => a.toBlob(c, "image/webp", 1))),
        C3$jscomp$4.Supports.CanvasToBlobWebP = b && "image/webp" === b.type
    } catch (c) {
        C3$jscomp$4.Supports.CanvasToBlobWebP = !1
    }
}
)();
"use strict";
const C3$jscomp$5 = self.C3;
if (!String.prototype.trimStart) {
    const a = /^[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]*/;
    String.prototype.trimStart = function() {
        return this.replace(a, "")
    }
}
if (!String.prototype.trimEnd) {
    const a = /[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]*$/;
    String.prototype.trimEnd = function() {
        return this.replace(a, "")
    }
}
String.prototype.replaceAll || (String.prototype.replaceAll = function(a, b) {
    return this.replace(new RegExp(C3$jscomp$5.EscapeRegex(a),"g"), b)
}
);
Array.prototype.values || (Array.prototype.values = function*() {
    for (const a of this)
        yield a
}
);
if (!Array.prototype.flat) {
    function a(b, c) {
        return b.reduce( (d, e) => {
            0 < c && Array.isArray(e) ? Array.prototype.push.apply(d, a(e, c - 1)) : d.push(e);
            return d
        }
        , [])
    }
    Array.prototype.flat = function(b=1) {
        return a(this, b)
    }
}
Array.prototype.at || (Array.prototype.at = function(a) {
    a = Math.trunc(a) || 0;
    0 > a && (a += this.length);
    if (!(0 > a || a >= this.length))
        return this[a]
}
);
String.prototype.at || (String.prototype.at = function(a) {
    a = Math.trunc(a) || 0;
    0 > a && (a += this.length);
    if (!(0 > a || a >= this.length))
        return this[a]
}
);
RegExp.escape || (RegExp.escape = function(a) {
    return String(a).replace(/[\\^$*+?.()|[\]{}]/g, "\\$&")
}
);
navigator.storage && !navigator.storage.estimate && navigator.webkitTemporaryStorage && navigator.webkitTemporaryStorage.queryUsageAndQuota && (navigator.storage.estimate = function() {
    return new Promise( (a, b) => navigator.webkitTemporaryStorage.queryUsageAndQuota( (c, d) => a({
        usage: c,
        quota: d
    }), b))
}
);
"undefined" === typeof self.isSecureContext && (self.isSecureContext = "https:" === location.protocol);
"undefined" === typeof self.globalThis && (self.globalThis = self);
"use strict";
const C3$jscomp$6 = self.C3;
function assertFail(a) {
    let b = C3$jscomp$6.GetCallStack();
    console.error("Assertion failure: " + a + "\n\nStack trace:\n" + b)
}
self.assert = function(a, b) {
    a || assertFail(b)
}
;
"use strict";
const C3$jscomp$7 = self.C3
  , C3X = self.C3X;
C3$jscomp$7.IsNumber = function(a) {
    return "number" === typeof a
}
;
C3$jscomp$7.IsFiniteNumber = function(a) {
    return C3$jscomp$7.IsNumber(a) && isFinite(a)
}
;
C3$jscomp$7.RequireNumber = function(a) {
    if (!C3$jscomp$7.IsNumber(a))
        throw new TypeError("expected number");
}
;
C3$jscomp$7.RequireOptionalNumber = function(a) {
    C3$jscomp$7.IsNullOrUndefined(a)
}
;
C3$jscomp$7.RequireNumberInRange = function(a, b, c) {
    if (!C3$jscomp$7.IsNumber(a) || isNaN(a) || b > a || c < a)
        throw new RangeError("number outside of range");
}
;
C3$jscomp$7.RequireAllNumber = function(...a) {
    for (let b of a)
        ;
}
;
C3$jscomp$7.RequireFiniteNumber = function(a) {
    if (!C3$jscomp$7.IsFiniteNumber(a))
        throw new TypeError("expected finite number");
}
;
C3$jscomp$7.RequireOptionalFiniteNumber = function(a) {
    C3$jscomp$7.IsNullOrUndefined(a)
}
;
C3$jscomp$7.RequireAllFiniteNumber = function(...a) {
    for (let b of a)
        ;
}
;
C3$jscomp$7.IsString = function(a) {
    return "string" === typeof a
}
;
C3$jscomp$7.RequireString = function(a) {
    if (!C3$jscomp$7.IsString(a))
        throw new TypeError("expected string");
}
;
C3$jscomp$7.RequireOptionalString = function(a) {
    C3$jscomp$7.IsNullOrUndefined(a)
}
;
C3$jscomp$7.RequireAllString = function(...a) {
    for (let b of a)
        ;
}
;
C3$jscomp$7.IsSimpleObject = function(a) {
    return "object" !== typeof a || null === a ? !1 : (a = Object.getPrototypeOf(a)) ? a.constructor === Object : null === a
}
;
C3$jscomp$7.RequireSimpleObject = function(a) {
    if (!C3$jscomp$7.IsSimpleObject(a))
        throw new TypeError("expected simple object");
}
;
C3$jscomp$7.RequireOptionalSimpleObject = function(a) {
    if (!C3$jscomp$7.IsNullOrUndefined(a) && !C3$jscomp$7.IsSimpleObject(a))
        throw new TypeError("expected simple object");
}
;
C3$jscomp$7.IsObject = function(a) {
    return "object" === typeof a && null !== a && !Array.isArray(a)
}
;
C3$jscomp$7.RequireObject = function(a) {
    if (!C3$jscomp$7.IsObject(a))
        throw new TypeError("expected object");
}
;
C3$jscomp$7.RequireOptionalObject = function(a) {
    C3$jscomp$7.IsNullOrUndefined(a)
}
;
C3$jscomp$7.RequireAllObject = function(...a) {
    for (let b of a)
        ;
}
;
C3$jscomp$7.IsFileLike = function(a) {
    return C3$jscomp$7.WeakIsInstanceOf(a, Blob) && "string" === typeof a.name
}
;
C3$jscomp$7.RequireFileLike = function(a) {
    if (!C3$jscomp$7.IsFileLike(a))
        throw new TypeError("expected file");
}
;
C3$jscomp$7.RequireOptionalFileLike = function(a) {
    C3$jscomp$7.IsNullOrUndefined(a)
}
;
C3$jscomp$7.IsArray = function(a) {
    return Array.isArray(a)
}
;
C3$jscomp$7.RequireArray = function(a) {
    if (!C3$jscomp$7.IsArray(a))
        throw new TypeError("expected array");
}
;
C3$jscomp$7.RequireOptionalArray = function(a) {
    C3$jscomp$7.IsNullOrUndefined(a)
}
;
C3$jscomp$7.RequireAllArray = function(...a) {
    for (let b of a)
        ;
}
;
C3$jscomp$7.Is2DArray = function(a) {
    return C3$jscomp$7.IsArray(a) ? a.length ? C3$jscomp$7.IsArray(a[0]) ? !0 : !1 : !0 : !1
}
;
C3$jscomp$7.Require2DArray = function(a) {
    if (!C3$jscomp$7.Is2DArray(a))
        throw new TypeError("expected 2d array");
    for (let b of a)
        if (!C3$jscomp$7.IsArray(b))
            throw new TypeError("expected 2d array");
}
;
C3$jscomp$7.RequireOptional2DArray = function(a) {
    C3$jscomp$7.IsNullOrUndefined(a)
}
;
C3$jscomp$7.IsFunction = function(a) {
    return "function" === typeof a
}
;
C3$jscomp$7.RequireFunction = function(a, b) {
    if (!C3$jscomp$7.IsFunction(a))
        throw new TypeError("expected function");
    if (!C3$jscomp$7.IsNullOrUndefined(b) && a !== b)
        throw new TypeError("expected same function reference");
}
;
C3$jscomp$7.RequireOptionalFunction = function(a) {
    C3$jscomp$7.IsNullOrUndefined(a)
}
;
C3$jscomp$7.RequireAllFunction = function(...a) {
    for (let b of a)
        ;
}
;
C3$jscomp$7.RequireAnyFunction = function(a, ...b) {
    if (!C3$jscomp$7.IsFunction(a))
        throw new TypeError("expected function");
    if (!b.length)
        throw Error("missing comparison functions");
    for (let c of b)
        if (!C3$jscomp$7.IsNullOrUndefined(c) && a === c)
            return;
    throw new TypeError("expected same function reference");
}
;
C3$jscomp$7.RequireOptionalAllFunction = function(...a) {
    if (!C3$jscomp$7.IsNullOrUndefined(a))
        for (let b of a)
            ;
}
;
C3$jscomp$7.IsInstanceOf = function(a, b) {
    return a instanceof b
}
;
C3$jscomp$7.IsInstanceOfAny = function(a, ...b) {
    for (let c of b)
        if (C3$jscomp$7.IsInstanceOf(a, c))
            return !0;
    return !1
}
;
C3$jscomp$7.RequireInstanceOf = function(a, b) {
    if (!C3$jscomp$7.IsInstanceOf(a, b))
        throw new TypeError("unexpected type");
}
;
C3$jscomp$7.RequireOptionalInstanceOf = function(a, b) {
    C3$jscomp$7.IsNullOrUndefined(a)
}
;
C3$jscomp$7.RequireAllInstanceOf = function(a, ...b) {
    for (let c of b)
        ;
}
;
C3$jscomp$7.RequireAnyInstanceOf = function(a, ...b) {
    if (!C3$jscomp$7.IsInstanceOfAny(a, ...b))
        throw new TypeError("unexpected type");
}
;
C3$jscomp$7.RequireAnyOptionalInstanceOf = function(a, ...b) {
    if (!C3$jscomp$7.IsNullOrUndefined(a) && !C3$jscomp$7.IsInstanceOfAny(a, ...b))
        throw new TypeError("unexpected type");
}
;
C3$jscomp$7.IsArrayOf = function(a, b) {
    for (let c of a)
        if (!C3$jscomp$7.IsInstanceOf(c, b))
            return !1;
    return !0
}
;
C3$jscomp$7.IsArrayOfFiniteNumbers = function(a) {
    for (let b of a)
        if (!C3$jscomp$7.IsFiniteNumber(b))
            return !1;
    return !0
}
;
C3$jscomp$7.RequireArrayOf = function(a, b) {
    for (let c of a)
        ;
}
;
C3$jscomp$7.RequireOptionalArrayOf = function(a, b) {
    if (!C3$jscomp$7.IsNullOrUndefined(a))
        for (let c of a)
            ;
}
;
C3$jscomp$7.RequireArrayOfAny = function(a, ...b) {
    for (let c of a)
        ;
}
;
C3$jscomp$7.RequireOptionalArrayOfAny = function(a, ...b) {
    if (!C3$jscomp$7.IsNullOrUndefined(a))
        for (let c of a)
            ;
}
;
C3$jscomp$7.IsDOMNode = function(a, b) {
    return C3$jscomp$7.IsNullOrUndefined(a) || !C3$jscomp$7.IsString(a.nodeName) ? !1 : !b || C3$jscomp$7.equalsNoCase(a.nodeName, b)
}
;
C3$jscomp$7.RequireDOMNode = function(a, b) {
    if (C3$jscomp$7.IsNullOrUndefined(a) || !C3$jscomp$7.IsString(a.nodeName))
        throw new TypeError("expected DOM node");
    if (b && !C3$jscomp$7.equalsNoCase(a.nodeName, b))
        throw new TypeError(`expected DOM '${b}' node`);
}
;
C3$jscomp$7.RequireOptionalDOMNode = function(a, b) {
    C3$jscomp$7.IsNullOrUndefined(a)
}
;
C3$jscomp$7.IsHTMLElement = function(a, b) {
    return C3$jscomp$7.IsNullOrUndefined(a) || !C3$jscomp$7.IsString(a.tagName) ? !1 : !b || C3$jscomp$7.equalsNoCase(a.tagName, b)
}
;
C3$jscomp$7.RequireHTMLElement = function(a, b) {
    if (C3$jscomp$7.IsNullOrUndefined(a) || !C3$jscomp$7.IsString(a.tagName))
        throw new TypeError("expected HTML element");
    if (b && !C3$jscomp$7.equalsNoCase(a.tagName, b))
        throw new TypeError(`expected HTML '${b}' element`);
}
;
C3$jscomp$7.RequireOptionalHTMLElement = function(a, b) {
    C3$jscomp$7.IsNullOrUndefined(a)
}
;
C3$jscomp$7.IsDrawable = function(a) {
    return C3$jscomp$7.IsHTMLElement(a, "img") || C3$jscomp$7.IsHTMLElement(a, "canvas") || C3$jscomp$7.IsHTMLElement(a, "video") || "undefined" !== typeof OffscreenCanvas && a instanceof OffscreenCanvas || "undefined" !== typeof ImageBitmap && a instanceof ImageBitmap
}
;
C3$jscomp$7.RequireDrawable = function(a) {
    if (!C3$jscomp$7.IsDrawable(a))
        throw new TypeError("expected drawable");
}
;
C3$jscomp$7.RequireOptionalDrawable = function(a) {
    C3$jscomp$7.IsNullOrUndefined(a)
}
;
C3$jscomp$7.IsDrawableOrImageData = function(a) {
    return a instanceof ImageData ? !0 : C3$jscomp$7.IsDrawable(a)
}
;
C3$jscomp$7.RequireDrawableOrImageData = function(a) {
    if (!C3$jscomp$7.IsDrawableOrImageData(a))
        throw new TypeError("expected drawable or image data");
}
;
C3$jscomp$7.RequireOptionalDrawableOrImageData = function(a) {
    if (!C3$jscomp$7.IsNullOrUndefined(a) && !C3$jscomp$7.IsDrawableOrImageData(a))
        throw new TypeError("expected drawable or image data");
}
;
C3$jscomp$7.IsStringLike = function(a) {
    return "string" === typeof a || C3$jscomp$7.HtmlString && a instanceof C3$jscomp$7.HtmlString || a instanceof C3$jscomp$7.BBString
}
;
C3$jscomp$7.RequireStringLike = function(a) {
    if (!C3$jscomp$7.IsStringLike(a))
        throw new TypeError("expected string-like");
}
;
C3$jscomp$7.RequireOptionalStringLike = function(a) {
    C3$jscomp$7.IsNullOrUndefined(a)
}
;
C3$jscomp$7.RequireAllStringLike = function(...a) {
    for (let b of a)
        ;
}
;
C3$jscomp$7.RequireOverride = function() {
    throw Error("must be overridden");
}
;
C3$jscomp$7.NotYetImplemented = function() {
    throw Error("not yet implemented");
}
;
C3$jscomp$7.IsDefined = function(a, ...b) {
    if ("undefined" === typeof a)
        return !1;
    for (let c of b) {
        if ("undefined" === typeof a[c])
            return !1;
        a = a[c]
    }
    return !0
}
;
C3$jscomp$7.IsNullOrUndefined = function(a) {
    return "undefined" === typeof a || null === a
}
;
C3$jscomp$7.AreArrayElementsOfSameType = function(a) {
    let b = a[0].constructor;
    for (let c of a)
        if (c.constructor !== b)
            return !1;
    return b
}
;
C3$jscomp$7.AreArrayElementsOfType = function(a, b) {
    for (let c of a)
        if (!(c instanceof b))
            return !1;
    return !0
}
;
const TypedArray$jscomp$1 = Object.getPrototypeOf(Uint8Array);
C3$jscomp$7.IsTypedArray = function(a) {
    return C3$jscomp$7.IsInstanceOf(a, TypedArray$jscomp$1)
}
;
C3$jscomp$7.RequireTypedArray = function(a) {}
;
C3$jscomp$7.WeakRequireTypedArray = function(a) {
    C3$jscomp$7.WeakRequireInstanceOf(a, TypedArray$jscomp$1)
}
;
C3$jscomp$7.WeakRequireAnyInstanceOf = function(a, ...b) {
    if (!C3$jscomp$7.WeakIsAnyInstanceOf(a, ...b))
        throw new TypeError("unexpected type");
}
;
C3$jscomp$7.WeakIsAnyInstanceOf = function(a, ...b) {
    for (const c of b)
        if (C3$jscomp$7.WeakIsInstanceOf(a, c))
            return !0;
    return !1
}
;
C3$jscomp$7.WeakRequireInstanceOf = function(a, b) {
    if (!C3$jscomp$7.WeakIsInstanceOf(a, b))
        throw new TypeError("unexpected type");
}
;
C3$jscomp$7.WeakIsInstanceOf = function(a, b) {
    for (; a = Object.getPrototypeOf(a); )
        if (a.constructor.name === b.name)
            return !0;
    return !1
}
;
C3X.RequireNumber = C3$jscomp$7.RequireNumber;
C3X.RequireOptionalNumber = C3$jscomp$7.RequireOptionalNumber;
C3X.RequireFiniteNumber = C3$jscomp$7.RequireFiniteNumber;
C3X.RequireOptionalFiniteNumber = C3$jscomp$7.RequireOptionalFiniteNumber;
C3X.RequireString = C3$jscomp$7.RequireString;
C3X.RequireOptionalString = C3$jscomp$7.RequireOptionalString;
C3X.RequireObject = C3$jscomp$7.RequireObject;
C3X.RequireOptionalObject = C3$jscomp$7.RequireOptionalObject;
C3X.RequireArray = C3$jscomp$7.RequireArray;
C3X.RequireOptionalArray = C3$jscomp$7.RequireOptionalArray;
C3X.RequireFunction = C3$jscomp$7.RequireFunction;
C3X.RequireOptionalFunction = C3$jscomp$7.RequireOptionalFunction;
C3X.RequireInstanceOf = C3$jscomp$7.RequireInstanceOf;
C3X.RequireOptionalInstanceOf = C3$jscomp$7.RequireOptionalInstanceOf;
C3X.IsNullOrUndefined = C3$jscomp$7.IsNullOrUndefined;
"use strict";
const C3$jscomp$8 = self.C3
  , logRafIds = new Map;
C3$jscomp$8.ColorLog = function(a, b) {
    console.log(`%c${a}`, `font-weight: bold; color:${b}`)
}
;
C3$jscomp$8.RafLog = function(a, ...b) {
    logRafIds.has(a) || logRafIds.set(a, -1);
    -1 === logRafIds.get(a) && logRafIds.set(a, requestAnimationFrame( () => {
        console.log(`%c${a}`, "font-weight: bold", ...b);
        logRafIds.set(a, -1)
    }
    ))
}
;
let measures;
C3$jscomp$8.StartMeasure = function(a) {
    performance.mark(a);
    measures || (measures = new Map);
    measures.has(a) || measures.set(a, {
        current: 0,
        total: 0,
        average: 0,
        calls: 1,
        toString: function() {
            return `${a} :: current => ${this.current.toPrecision(3)} :: average => ${this.average.toPrecision(3)} :: calls => ${this.calls}`
        }
    })
}
;
C3$jscomp$8.EndMeasure = function(a) {
    performance.measure(`measure-${a}`, a);
    const b = performance.getEntriesByName(`measure-${a}`)[0]
      , c = measures.get(a);
    c.current = b.duration;
    c.total += c.current;
    c.average = c.total / c.calls;
    console.log(c.toString());
    c.calls++;
    performance.clearMarks(a);
    performance.clearMeasures(`measure-${a}`)
}
;
C3$jscomp$8.GetCallStack = function() {
    return Error().stack
}
;
C3$jscomp$8.Debugger = function() {
    debugger
}
;
C3$jscomp$8.cast = function(a, b) {
    return a && a instanceof b ? a : null
}
;
C3$jscomp$8.getName = function(a) {
    return "undefined" === typeof a ? "undefined" : null === a ? "null" : "boolean" === typeof a ? "<boolean>" : C3$jscomp$8.IsNumber(a) ? "<number>" : C3$jscomp$8.IsString(a) ? "<string>" : C3$jscomp$8.IsArray(a) ? "<array>" : "symbol" === typeof a ? "<" + a.toString() + ">" : C3$jscomp$8.IsFunction(a) ? a.name && "Function" !== a.name ? a.name : "<anonymous function>" : "object" === typeof a ? a.constructor && a.constructor.name && "Object" !== a.constructor.name ? a.constructor.name : "<anonymous object>" : "<unknown>"
}
;
C3$jscomp$8.getType = function(a) {
    return null === a ? "null" : Array.isArray(a) ? "array" : typeof a
}
;
C3$jscomp$8.range = function*(a, b) {
    if (!isFinite(Math.abs(a - b)))
        throw Error("Invalid parameters");
    if (a > b)
        for (--a; a >= b; a--)
            yield a;
    else
        for (; a < b; a++)
            yield a
}
;
function isValidTypeChange(a, b) {
    a = C3$jscomp$8.getType(a);
    b = C3$jscomp$8.getType(b);
    return "null" === a || "null" === b ? !0 : "undefined" === a || "undefined" === b ? !1 : a === b
}
let ctorObjectToProxy = new Map
  , ctorProxyToObject = new Map
  , proxyToObject = new WeakMap
  , releasedObjects = new WeakMap;
C3$jscomp$8.DefendHandler = {};
const VALID_GET_MISSING_KEYS = new Set(["then", "splice"]);
function logDefendedObjectWarning(a) {
    console.warn("[Defence] " + a + " @", C3$jscomp$8.GetCallStack())
}
C3$jscomp$8.DefendHandler.get = function(a, b) {
    b in a || "symbol" === typeof b || VALID_GET_MISSING_KEYS.has(b) || logDefendedObjectWarning(`Accessed missing property '${b}' from defended object '${C3$jscomp$8.getName(a)}', returning undefined`);
    releasedObjects.has(a) && "symbol" !== typeof b && !VALID_GET_MISSING_KEYS.has(b) && logDefendedObjectWarning(`Accessed property '${b}' on a released object '${C3$jscomp$8.getName(a)}'\nObject was originally released at: ${releasedObjects.get(a)})\nCall stack at access: `);
    return a[b]
}
;
C3$jscomp$8.DefendHandler.set = function(a, b, c) {
    b in a || ctorObjectToProxy.has(a) || logDefendedObjectWarning(`Set non-existent property '${b}' to '${c}' on defended object '${C3$jscomp$8.getName(a)}'`);
    isValidTypeChange(a[b], c) || ctorObjectToProxy.has(a) || logDefendedObjectWarning(`Set '${C3$jscomp$8.getType(a[b])}' property '${b}' to type '${C3$jscomp$8.getType(c)}' on defended object '${C3$jscomp$8.getName(a)}'`);
    releasedObjects.has(a) && logDefendedObjectWarning(`Set property '${b}' on a released object '${C3$jscomp$8.getName(a)}'\nObject was originally released at: ${releasedObjects.get(a)})\nCall stack at access: `);
    a[b] = c;
    return !0
}
;
C3$jscomp$8.DefendHandler.deleteProperty = function(a, b) {
    throw new ReferenceError(`Cannot delete property '${b}' from defended object '${C3$jscomp$8.getName(a)}'`);
}
;
C3$jscomp$8.DefendHandler.defineProperty = function(a, b, c) {
    throw new ReferenceError(`Cannot define property '${b}' on defended object '${C3$jscomp$8.getName(a)}'`);
}
;
C3$jscomp$8.DefendHandler.enumerate = function(a) {
    throw new ReferenceError(`Cannot enumerate defended object '${C3$jscomp$8.getName(a)}'`);
}
;
let checkRafId = -1;
function CheckDefendedObjectsUsedCorrectly() {
    checkRafId = -1;
    if (0 < ctorObjectToProxy.size || 0 < ctorProxyToObject.size) {
        let a = [...(new Set([...ctorObjectToProxy.keys()].map(b => C3$jscomp$8.getName(b))))].join();
        console.warn(`An object derived from DefendedBase was not protected with debugDefend(). This will disable some checks. See the coding guidelines! Possible affected class names: ${a}`);
        ctorObjectToProxy.clear();
        ctorProxyToObject.clear()
    }
}
C3$jscomp$8.DefendedBase = class {
    constructor() {
        if (C3$jscomp$8.isDebugDefend && C3$jscomp$8.Supports.Proxies) {
            var a = new.target;
            a = Object.create(a.prototype);
            var b = new Proxy(a,C3$jscomp$8.DefendHandler);
            ctorObjectToProxy.set(a, b);
            ctorProxyToObject.set(b, a);
            proxyToObject.set(b, a);
            -1 === checkRafId && (checkRafId = requestAnimationFrame(CheckDefendedObjectsUsedCorrectly));
            return b
        }
    }
}
;
C3$jscomp$8.debugDefend = function(a) {
    if (C3$jscomp$8.isDebugDefend && C3$jscomp$8.Supports.Proxies && a instanceof C3$jscomp$8.DefendedBase) {
        if (!ctorProxyToObject.has(a))
            return a;
        let b = ctorProxyToObject.get(a);
        ctorProxyToObject.delete(a);
        ctorObjectToProxy.delete(b);
        return a
    }
    return C3$jscomp$8.isDebug ? Object.seal(a) : a
}
;
C3$jscomp$8.New = function(a, ...b) {
    let c;
    try {
        c = new a(...b)
    } catch (d) {
        throw ctorProxyToObject.clear(),
        ctorObjectToProxy.clear(),
        d;
    }
    C3$jscomp$8.isDebugDefend && VerifyObjectPropertiesConsistent(a, c);
    return C3$jscomp$8.debugDefend(c)
}
;
C3$jscomp$8.Release = function(a) {
    (a = proxyToObject.get(a)) && releasedObjects.set(a, C3$jscomp$8.GetCallStack())
}
;
C3$jscomp$8.WasReleased = function(a) {
    return (a = proxyToObject.get(a)) ? !!releasedObjects.get(a) : !1
}
;
let typeProperties = new Map;
function getObjectPropertySet(a) {
    let b = new Set;
    for (let c in a)
        b.add(c);
    return b
}
function VerifyObjectPropertiesConsistent(a, b) {
    b = getObjectPropertySet(b);
    let c = typeProperties.get(a);
    if (c) {
        let d = [];
        for (let e of c.values())
            b.has(e) ? b.delete(e) : d.push(e);
        C3$jscomp$8.appendArray(d, [...b]);
        d.length && console.warn(`[Defence] '${C3$jscomp$8.getName(a)}' constructor creates inconsistent properties: ${d.join(", ")}`)
    } else
        typeProperties.set(a, b)
}
C3$jscomp$8.PerfMark = class {
    constructor(a) {
        this._name = "";
        a && this.start(a)
    }
    start(a) {
        C3$jscomp$8.isPerformanceProfiling && (this._name = a,
        performance.mark(this._name + "-Start"))
    }
    end() {
        C3$jscomp$8.isPerformanceProfiling && (performance.mark(this._name + "-End"),
        performance.measure(this._name, this._name + "-Start", this._name + "-End"))
    }
    next(a) {
        C3$jscomp$8.isPerformanceProfiling && (this.end(),
        this._name = a,
        performance.mark(this._name + "-Start"))
    }
}
;
"use strict";
const C3$jscomp$9 = self.C3
  , TWO_PI = 2 * Math.PI
  , D_TO_R = Math.PI / 180
  , R_TO_D = 180 / Math.PI;
C3$jscomp$9.wrap = function(a, b, c) {
    a = Math.floor(a);
    b = Math.floor(b);
    c = Math.floor(c);
    const d = c - b;
    return 0 === d ? c : a < b ? (a = c - (b - a) % d,
    a === c ? 0 : a) : b + (a - b) % d
}
;
C3$jscomp$9.mapToRange = function(a, b, c, d, e) {
    c -= b;
    return 0 === c && 0 === d ? a : (a - b) * (e - d) / c + d
}
;
C3$jscomp$9.normalize = function(a, b, c) {
    return 0 === b - c ? 1 : (a - b) / (c - b)
}
;
C3$jscomp$9.clamp = function(a, b, c) {
    return a < b ? b : a > c ? c : a
}
;
C3$jscomp$9.clampAngle = function(a) {
    a %= TWO_PI;
    0 > a && (a += TWO_PI);
    return a
}
;
C3$jscomp$9.toRadians = function(a) {
    return a * D_TO_R
}
;
C3$jscomp$9.toDegrees = function(a) {
    return a * R_TO_D
}
;
C3$jscomp$9.distanceTo = function(a, b, c, d) {
    return Math.hypot(c - a, d - b)
}
;
C3$jscomp$9.distanceSquared = function(a, b, c, d) {
    a = c - a;
    b = d - b;
    return a * a + b * b
}
;
C3$jscomp$9.angleTo = function(a, b, c, d) {
    return Math.atan2(d - b, c - a)
}
;
C3$jscomp$9.angleDiff = function(a, b) {
    if (a === b)
        return 0;
    a = Math.sin(a) * Math.sin(b) + Math.cos(a) * Math.cos(b);
    return 1 <= a ? 0 : -1 >= a ? Math.PI : Math.acos(a)
}
;
C3$jscomp$9.angleRotate = function(a, b, c) {
    let d = Math.sin(a)
      , e = Math.cos(a)
      , f = Math.sin(b)
      , h = Math.cos(b);
    return Math.acos(d * f + e * h) > c ? 0 < e * f - d * h ? C3$jscomp$9.clampAngle(a + c) : C3$jscomp$9.clampAngle(a - c) : C3$jscomp$9.clampAngle(b)
}
;
C3$jscomp$9.angleClockwise = function(a, b) {
    return 0 >= Math.cos(a) * Math.sin(b) - Math.sin(a) * Math.cos(b)
}
;
C3$jscomp$9.angleLerp = function(a, b, c, d=0) {
    let e = C3$jscomp$9.angleDiff(a, b);
    d *= TWO_PI;
    return C3$jscomp$9.angleClockwise(b, a) ? C3$jscomp$9.clampAngle(a + (e + d) * c) : C3$jscomp$9.clampAngle(a - (e + d) * c)
}
;
C3$jscomp$9.angleLerpClockwise = function(a, b, c, d=0) {
    const e = C3$jscomp$9.angleDiff(a, b);
    d *= TWO_PI;
    return C3$jscomp$9.angleClockwise(b, a) ? C3$jscomp$9.clampAngle(a + (e + d) * c) : C3$jscomp$9.clampAngle(a + (TWO_PI - e + d) * c)
}
;
C3$jscomp$9.angleLerpAntiClockwise = function(a, b, c, d=0) {
    const e = C3$jscomp$9.angleDiff(a, b);
    d *= TWO_PI;
    return C3$jscomp$9.angleClockwise(b, a) ? C3$jscomp$9.clampAngle(a - (-TWO_PI + e - d) * c) : C3$jscomp$9.clampAngle(a - (e + d) * c)
}
;
C3$jscomp$9.angleReflect = function(a, b) {
    const c = C3$jscomp$9.angleDiff(a, b);
    return C3$jscomp$9.angleClockwise(a, b) ? C3$jscomp$9.clampAngle(b - c) : C3$jscomp$9.clampAngle(b + c)
}
;
C3$jscomp$9.lerp = function(a, b, c) {
    return a + c * (b - a)
}
;
C3$jscomp$9.unlerp = function(a, b, c) {
    return a === b ? 0 : (c - a) / (b - a)
}
;
C3$jscomp$9.relerp = function(a, b, c, d, e) {
    return C3$jscomp$9.lerp(d, e, C3$jscomp$9.unlerp(a, b, c))
}
;
C3$jscomp$9.qarp = function(a, b, c, d) {
    return C3$jscomp$9.lerp(C3$jscomp$9.lerp(a, b, d), C3$jscomp$9.lerp(b, c, d), d)
}
;
C3$jscomp$9.cubic = function(a, b, c, d, e) {
    return C3$jscomp$9.lerp(C3$jscomp$9.qarp(a, b, c, e), C3$jscomp$9.qarp(b, c, d, e), e)
}
;
C3$jscomp$9.cosp = function(a, b, c) {
    return (a + b + (a - b) * Math.cos(c * Math.PI)) / 2
}
;
C3$jscomp$9.isPOT = function(a) {
    return 0 < a && 0 === (a - 1 & a)
}
;
C3$jscomp$9.nextHighestPowerOfTwo = function(a) {
    --a;
    for (let b = 1; 32 > b; b <<= 1)
        a |= a >> b;
    return a + 1
}
;
C3$jscomp$9.roundToNearestFraction = function(a, b) {
    return Math.round(a * b) / b
}
;
C3$jscomp$9.floorToNearestFraction = function(a, b) {
    return Math.floor(a * b) / b
}
;
C3$jscomp$9.roundToDp = function(a, b) {
    b = Math.max(Math.floor(b), 0);
    b = Math.pow(10, b);
    return Math.round(a * b) / b
}
;
C3$jscomp$9.countDecimals = function(a) {
    return Math.floor(a) !== a ? a.toString().split(".")[1].length || 0 : 0
}
;
C3$jscomp$9.toFixed = function(a, b) {
    a = a.toFixed(b);
    for (b = a.length - 1; 0 <= b && "0" === a.charAt(b); --b)
        ;
    0 <= b && "." === a.charAt(b) && --b;
    return 0 > b ? a : a.substr(0, b + 1)
}
;
C3$jscomp$9.PackRGB = function(a, b, c) {
    return C3$jscomp$9.clamp(a, 0, 255) | C3$jscomp$9.clamp(b, 0, 255) << 8 | C3$jscomp$9.clamp(c, 0, 255) << 16
}
;
C3$jscomp$9.PackRGBAEx = function(a, b, c, d) {
    a = C3$jscomp$9.clamp(Math.floor(1024 * a), -8192, 8191);
    b = C3$jscomp$9.clamp(Math.floor(1024 * b), -8192, 8191);
    c = C3$jscomp$9.clamp(Math.floor(1024 * c), -8192, 8191);
    d = C3$jscomp$9.clamp(Math.floor(1023 * d), 0, 1023);
    0 > a && (a += 16384);
    0 > b && (b += 16384);
    0 > c && (c += 16384);
    return -(274877906944 * a + 16777216 * b + 1024 * c + d)
}
;
C3$jscomp$9.PackRGBEx = function(a, b, c) {
    return C3$jscomp$9.PackRGBAEx(a, b, c, 1)
}
;
function isNegativeZero(a) {
    return 0 === a && 0 > 1 / a
}
C3$jscomp$9.GetRValue = function(a) {
    if (0 <= a)
        return (a & 255) / 255;
    a = Math.floor(-a / 274877906944);
    8191 < a && (a -= 16384);
    return a / 1024
}
;
C3$jscomp$9.GetGValue = function(a) {
    if (0 <= a)
        return ((a & 65280) >> 8) / 255;
    a = Math.floor(-a % 274877906944 / 16777216);
    8191 < a && (a -= 16384);
    return a / 1024
}
;
C3$jscomp$9.GetBValue = function(a) {
    if (0 <= a)
        return ((a & 16711680) >> 16) / 255;
    a = Math.floor(-a % 16777216 / 1024);
    8191 < a && (a -= 16384);
    return a / 1024
}
;
C3$jscomp$9.GetAValue = function(a) {
    return isNegativeZero(a) ? 0 : 0 <= a ? 1 : Math.floor(-a % 1024) / 1023
}
;
C3$jscomp$9.greatestCommonDivisor = function(a, b) {
    a = Math.floor(a);
    for (b = Math.floor(b); 0 !== b; ) {
        let c = b;
        b = a % b;
        a = c
    }
    return a
}
;
const COMMON_ASPECT_RATIOS = [[3, 2], [4, 3], [5, 4], [5, 3], [6, 5], [14, 9], [16, 9], [16, 10], [21, 9]];
C3$jscomp$9.getAspectRatio = function(a, b) {
    a = Math.floor(a);
    b = Math.floor(b);
    if (a === b)
        return [1, 1];
    for (var c of COMMON_ASPECT_RATIOS) {
        let d = a / c[0] * c[1];
        if (1 > Math.abs(b - d))
            return c.slice(0);
        d = a / c[1] * c[0];
        if (1 > Math.abs(b - d))
            return [c[1], c[0]]
    }
    c = C3$jscomp$9.greatestCommonDivisor(a, b);
    return [a / c, b / c]
}
;
C3$jscomp$9.segmentsIntersect = function(a, b, c, d, e, f, h, l) {
    var m = Math.min(a, c)
      , p = Math.max(e, h);
    if (Math.max(a, c) < Math.min(e, h) || m > p)
        return !1;
    m = Math.min(b, d);
    p = Math.max(f, l);
    if (Math.max(b, d) < Math.min(f, l) || m > p)
        return !1;
    m = e - a + h - c;
    p = f - b + l - d;
    a = c - a;
    b = d - b;
    e = h - e;
    f = l - f;
    l = Math.abs(b * e - f * a);
    return Math.abs(e * p - f * m) > l ? !1 : Math.abs(a * p - b * m) <= l
}
;
C3$jscomp$9.segmentsIntersectPreCalc = function(a, b, c, d, e, f, h, l, m, p, r, v) {
    const x = Math.max(m, r);
    if (f < Math.min(m, r) || e > x)
        return !1;
    e = Math.max(p, v);
    if (l < Math.min(p, v) || h > e)
        return !1;
    h = m - a + r - c;
    l = p - b + v - d;
    a = c - a;
    b = d - b;
    m = r - m;
    p = v - p;
    v = Math.abs(b * m - p * a);
    return Math.abs(m * l - p * h) > v ? !1 : Math.abs(a * l - b * h) <= v
}
;
C3$jscomp$9.segmentIntersectsQuad = function(a, b, c, d, e) {
    const f = Math.min(a, c)
      , h = Math.max(a, c)
      , l = Math.min(b, d)
      , m = Math.max(b, d)
      , p = e.getTlx()
      , r = e.getTly()
      , v = e.getTrx()
      , x = e.getTry()
      , B = e.getBrx()
      , A = e.getBry()
      , D = e.getBlx();
    e = e.getBly();
    return C3$jscomp$9.segmentsIntersectPreCalc(a, b, c, d, f, h, l, m, p, r, v, x) || C3$jscomp$9.segmentsIntersectPreCalc(a, b, c, d, f, h, l, m, v, x, B, A) || C3$jscomp$9.segmentsIntersectPreCalc(a, b, c, d, f, h, l, m, B, A, D, e) || C3$jscomp$9.segmentsIntersectPreCalc(a, b, c, d, f, h, l, m, D, e, p, r)
}
;
C3$jscomp$9.segmentIntersectsAnyN = function(a, b, c, d, e) {
    const f = Math.min(a, c)
      , h = Math.max(a, c)
      , l = Math.min(b, d)
      , m = Math.max(b, d);
    let p = 0;
    for (let r = e.length - 4; p <= r; p += 2)
        if (C3$jscomp$9.segmentsIntersectPreCalc(a, b, c, d, f, h, l, m, e[p], e[p + 1], e[p + 2], e[p + 3]))
            return !0;
    return C3$jscomp$9.segmentsIntersectPreCalc(a, b, c, d, f, h, l, m, e[p], e[p + 1], e[0], e[1])
}
;
C3$jscomp$9.rayIntersect = function(a, b, c, d, e, f, h, l) {
    c -= a;
    f = l - f;
    const m = c * f - (d - b) * (h - e);
    if (0 === m)
        return 2;
    d = ((b - d) * (h - a) + c * (l - b)) / m;
    return 0 < d && 1.000001 > d ? (f * (h - a) + (e - h) * (l - b)) / m : 2
}
;
C3$jscomp$9.rayIntersectExtended = function(a, b, c, d, e, f, h, l, m) {
    const p = (h - e) * m;
    m *= l - f;
    return C3$jscomp$9.rayIntersect(a, b, c, d, e - p, f - m, h + p, l + m)
}
;
C3$jscomp$9.isPointInTriangleInclusive = function(a, b, c, d, e, f, h, l) {
    e -= c;
    f -= d;
    h -= c;
    l -= d;
    a -= c;
    c = b - d;
    b = e * e + f * f;
    d = e * h + f * l;
    e = e * a + f * c;
    f = h * h + l * l;
    h = h * a + l * c;
    l = 1 / (b * f - d * d);
    f = (f * e - d * h) * l;
    e = (b * h - d * e) * l;
    return 0 <= f && 0 <= e && 1 >= f + e
}
;
C3$jscomp$9.triangleCartesianToBarycentric = function(a, b, c, d, e, f, h, l) {
    e -= c;
    f -= d;
    h -= c;
    l -= d;
    a -= c;
    const m = b - d;
    b = e * e + f * f;
    d = e * h + f * l;
    c = h * h + l * l;
    e = a * e + m * f;
    f = a * h + m * l;
    h = b * c - d * d;
    l = (c * e - d * f) / h;
    e = (b * f - d * e) / h;
    return [1 - l - e, l, e]
}
;
C3$jscomp$9.triangleBarycentricToCartesian3d = function(a, b, c, d, e, f, h, l, m, p, r, v) {
    return [a * d + b * h + c * p, a * e + b * l + c * r, a * f + b * m + c * v]
}
;
"use strict";
const C3$jscomp$10 = self.C3;
let mainDocument = null
  , baseHref = "";
if ("undefined" !== typeof document) {
    mainDocument = document;
    const a = document.querySelector("base");
    if (baseHref = a && a.hasAttribute("href") ? a.getAttribute("href") : "")
        baseHref.startsWith("/") && (baseHref = baseHref.substr(1)),
        baseHref.endsWith("/") || (baseHref += "/")
}
C3$jscomp$10.GetBaseHref = function() {
    return baseHref
}
;
C3$jscomp$10.GetBaseURL = function() {
    if (!mainDocument)
        return "";
    const a = mainDocument.location;
    return C3$jscomp$10.GetPathFromURL(a.origin + a.pathname) + baseHref
}
;
C3$jscomp$10.GetPathFromURL = function(a) {
    if (!a.length || a.endsWith("/") || a.endsWith("\\"))
        return a;
    const b = Math.max(a.lastIndexOf("/"), a.lastIndexOf("\\"));
    return -1 === b ? "" : a.substr(0, b + 1)
}
;
C3$jscomp$10.GetFilenameFromURL = function(a) {
    if (!a.length)
        return a;
    if (a.endsWith("/") || a.endsWith("\\"))
        return "";
    const b = Math.max(a.lastIndexOf("/"), a.lastIndexOf("\\"));
    return -1 === b ? a : a.substr(b + 1)
}
;
C3$jscomp$10.GetFileExtension = function(a) {
    let b = a.lastIndexOf(".");
    return 1 > b ? "" : a.substr(b)
}
;
C3$jscomp$10.SetFileExtension = function(a, b) {
    const c = a.lastIndexOf(".");
    return -1 === c ? a + "." + b : a.substr(0, c + 1) + b
}
;
C3$jscomp$10.GetFileNamePart = function(a) {
    let b = a.lastIndexOf(".");
    return 1 > b ? a : a.substr(0, b)
}
;
C3$jscomp$10.NormalizeFileSeparator = function(a) {
    return a.replace(/\\/g, "/")
}
;
C3$jscomp$10.IsFileExtension = function(a, b) {
    a = a ? C3$jscomp$10.GetFileExtension(a).slice(1) : "";
    return b === a
}
;
C3$jscomp$10.FileNameEquals = function(a, b) {
    let c, d;
    C3$jscomp$10.IsFileLike(a) && (c = C3$jscomp$10.GetFileNamePart(a.name));
    C3$jscomp$10.IsString(a) && (c = C3$jscomp$10.GetFileNamePart(a));
    C3$jscomp$10.IsFileLike(b) && (d = C3$jscomp$10.GetFileNamePart(b.name));
    C3$jscomp$10.IsString(b) && (d = C3$jscomp$10.GetFileNamePart(b));
    return c === d
}
;
C3$jscomp$10.ParseFilePath = function(a) {
    a = C3$jscomp$10.NormalizeFileSeparator(a);
    let b = /^\w:\//.exec(a);
    b ? (b = b[0],
    a = a.slice(3),
    "/" !== a[0] && (a = "/" + a)) : b = "";
    a = a.replace(/\/{2,}/g, "/");
    1 < a.length && "/" === a.slice(-1) && (a = a.slice(0, -1));
    var c = a.lastIndexOf("/") + 1;
    let d = ""
      , e = a
      , f = "";
    0 < c && (d = a.slice(0, c),
    e = a.slice(c));
    a = e;
    c = e.lastIndexOf(".");
    0 < c && (f = e.slice(c),
    a = e.slice(0, -f.length));
    return {
        dir: d,
        base: e,
        name: a,
        root: b,
        ext: f,
        full: b + d + e
    }
}
;
C3$jscomp$10.Wait = function(a, b) {
    return new Promise( (c, d) => {
        self.setTimeout(c, a, b)
    }
    )
}
;
C3$jscomp$10.swallowException = function(a) {
    try {
        a()
    } catch (b) {
        C3$jscomp$10.isDebug && console.warn("Swallowed exception: ", b)
    }
}
;
C3$jscomp$10.noop = function() {}
;
C3$jscomp$10.equalsNoCase = function(a, b) {
    return "string" !== typeof a || "string" !== typeof b ? !1 : a === b || a.normalize().toLowerCase() === b.normalize().toLowerCase()
}
;
C3$jscomp$10.equalsCase = function(a, b) {
    return "string" !== typeof a || "string" !== typeof b ? !1 : a === b ? !0 : a.normalize() === b.normalize()
}
;
C3$jscomp$10.typedArraySet16 = function(a, b, c) {
    a[c++] = b[0];
    a[c++] = b[1];
    a[c++] = b[2];
    a[c++] = b[3];
    a[c++] = b[4];
    a[c++] = b[5];
    a[c++] = b[6];
    a[c++] = b[7];
    a[c++] = b[8];
    a[c++] = b[9];
    a[c++] = b[10];
    a[c++] = b[11];
    a[c++] = b[12];
    a[c++] = b[13];
    a[c++] = b[14];
    a[c] = b[15]
}
;
C3$jscomp$10.truncateArray = function(a, b) {
    a.length = b
}
;
C3$jscomp$10.clearArray = function(a) {
    a && 0 !== a.length && C3$jscomp$10.truncateArray(a, 0)
}
;
C3$jscomp$10.clear2DArray = function(a) {
    if (a) {
        for (let b = 0; b < a.length; b++)
            C3$jscomp$10.truncateArray(a[b], 0);
        C3$jscomp$10.truncateArray(a, 0)
    }
}
;
C3$jscomp$10.extendArray = function(a, b, c) {
    b |= 0;
    var d = a.length;
    if (!(b <= d))
        for (; d < b; ++d)
            a.push(c)
}
;
C3$jscomp$10.resizeArray = function(a, b, c) {
    b |= 0;
    const d = a.length;
    b < d ? C3$jscomp$10.truncateArray(a, b) : b > d && C3$jscomp$10.extendArray(a, b, c)
}
;
C3$jscomp$10.shallowAssignArray = function(a, b) {
    C3$jscomp$10.clearArray(a);
    C3$jscomp$10.appendArray(a, b)
}
;
C3$jscomp$10.appendArray = function(a, b) {
    if (1E4 > b.length)
        a.push(...b);
    else
        for (let c = 0, d = b.length; c < d; ++c)
            a.push(b[c])
}
;
C3$jscomp$10.arrayRemove = function(a, b) {
    b = Math.floor(b);
    if (!(0 > b || b >= a.length)) {
        for (var c = a.length - 1; b < c; ++b)
            a[b] = a[b + 1];
        C3$jscomp$10.truncateArray(a, c)
    }
}
;
C3$jscomp$10.arrayFindRemove = function(a, b) {
    b = a.indexOf(b);
    0 <= b && a.splice(b, 1)
}
;
C3$jscomp$10.arraysEqual = function(a, b) {
    let c = a.length;
    if (b.length !== c)
        return !1;
    for (let d = 0; d < c; ++d)
        if (a[d] !== b[d])
            return !1;
    return !0
}
;
C3$jscomp$10.arrayFilterOut = function(a, b) {
    let c = []
      , d = 0;
    for (let e = 0, f = a.length; e < f; ++e) {
        let h = a[e];
        b(h) ? c.push(h) : (a[d] = h,
        ++d)
    }
    C3$jscomp$10.truncateArray(a, d);
    return c
}
;
C3$jscomp$10.arrayRemoveAllInSet = function(a, b) {
    const c = a.length;
    let d = 0;
    for (let e = 0, f = a.length; e < f; ++e) {
        let h = a[e];
        b.has(h) || (a[d++] = h)
    }
    C3$jscomp$10.truncateArray(a, d);
    return c - d
}
;
C3$jscomp$10.isArrayIndexInBounds = function(a, b) {
    return a !== Math.floor(a) ? !1 : 0 <= a && a < b.length
}
;
C3$jscomp$10.validateArrayIndex = function(a, b) {
    if (!C3$jscomp$10.isArrayIndexInBounds(a, b))
        throw new RangeError("array index out of bounds");
}
;
C3$jscomp$10.cloneArray = function(a) {
    return a.slice()
}
;
C3$jscomp$10.deepCloneArray = function(a, b) {
    let c = [];
    for (let d of a)
        if (C3$jscomp$10.IsObject(d)) {
            a = b(d);
            if (!a)
                throw Error("missing clone");
            if (a.constructor !== d.constructor)
                throw Error("object is not a clone");
            c.push(a)
        } else
            C3$jscomp$10.IsArray(d) ? c.push(C3$jscomp$10.deepCloneArray(d, b)) : c.push(d);
    return c
}
;
C3$jscomp$10.clone2DArray = function(a) {
    let b = [];
    for (let c of a)
        b.push(c.slice());
    return b
}
;
C3$jscomp$10.mergeSets = function(a, b) {
    return a.union ? a.union(b) : new Set([...a, ...b])
}
;
C3$jscomp$10.mergeSetsInPlace = function(a, b) {
    for (const c of b)
        a.add(c);
    return a
}
;
C3$jscomp$10.first = function(a) {
    for (let b of a)
        return b;
    return null
}
;
C3$jscomp$10.xor = function(a, b) {
    return !a !== !b
}
;
C3$jscomp$10.compare = function(a, b, c) {
    switch (b) {
    case 0:
        return a === c;
    case 1:
        return a !== c;
    case 2:
        return a < c;
    case 3:
        return a <= c;
    case 4:
        return a > c;
    case 5:
        return a >= c;
    default:
        return !1
    }
}
;
C3$jscomp$10.hasAnyOwnProperty = function(a) {
    for (let b in a)
        if (a.hasOwnProperty(b))
            return !0;
    return !1
}
;
C3$jscomp$10.PromiseAllWithProgress = function(a, b) {
    return a.length ? new Promise( (c, d) => {
        const e = [];
        let f = 0
          , h = !1;
        for (let l = 0, m = a.length; l < m; ++l)
            e.push(void 0),
            a[l].then(p => {
                h || (e[l] = p,
                ++f,
                f === a.length ? c(e) : b(f, a.length))
            }
            ).catch(p => {
                h = !0;
                d(p)
            }
            )
    }
    ) : Promise.resolve([])
}
;
let memoryCallbacks = [];
C3$jscomp$10.AddLibraryMemoryCallback = function(a) {
    memoryCallbacks.push(a)
}
;
C3$jscomp$10.GetEstimatedLibraryMemoryUsage = function() {
    let a = 0;
    for (let b of memoryCallbacks) {
        let c = b();
        a += c
    }
    return Math.floor(a)
}
;
let nextTaskId = 1;
const activeTaskIds = new Map
  , taskMessageChannel = new MessageChannel;
taskMessageChannel.port2.onmessage = function(a) {
    a = a.data;
    const b = activeTaskIds.get(a);
    activeTaskIds.delete(a);
    b && b(performance.now())
}
;
C3$jscomp$10.RequestUnlimitedAnimationFrame = function(a) {
    const b = nextTaskId++;
    activeTaskIds.set(b, a);
    taskMessageChannel.port1.postMessage(b);
    return b
}
;
C3$jscomp$10.CancelUnlimitedAnimationFrame = function(a) {
    activeTaskIds.delete(a)
}
;
C3$jscomp$10.PostTask = C3$jscomp$10.RequestUnlimitedAnimationFrame;
C3$jscomp$10.WaitForNextTask = function() {
    return new Promise(a => C3$jscomp$10.PostTask(a))
}
;
const activeRPAFids = new Set;
C3$jscomp$10.RequestPostAnimationFrame = function(a) {
    const b = self.requestAnimationFrame(async c => {
        await C3$jscomp$10.WaitForNextTask();
        activeRPAFids.has(b) && (activeRPAFids.delete(b),
        a(c))
    }
    );
    activeRPAFids.add(b);
    return b
}
;
C3$jscomp$10.CancelPostAnimationFrame = function(a) {
    activeRPAFids.has(a) && (self.cancelAnimationFrame(a),
    activeRPAFids.delete(a))
}
;
"use strict";
const C3$jscomp$11 = self.C3;
C3$jscomp$11.IsAbsoluteURL = function(a) {
    return /^(?:[a-z\-]+:)?\/\//.test(a) || "data:" === a.substr(0, 5) || "blob:" === a.substr(0, 5)
}
;
C3$jscomp$11.IsRelativeURL = function(a) {
    return !C3$jscomp$11.IsAbsoluteURL(a)
}
;
C3$jscomp$11.ThrowIfNotOk = function(a) {
    if (!a.ok)
        throw Error(`fetch '${a.url}' response returned ${a.status} ${a.statusText}`);
}
;
C3$jscomp$11.FetchOk = function(a, b) {
    return fetch(a, b).then(c => {
        C3$jscomp$11.ThrowIfNotOk(c);
        return c
    }
    )
}
;
C3$jscomp$11.FetchText = function(a) {
    return C3$jscomp$11.FetchOk(a).then(b => b.text())
}
;
C3$jscomp$11.FetchJson = function(a) {
    return C3$jscomp$11.FetchOk(a).then(b => b.json())
}
;
C3$jscomp$11.FetchBlob = function(a) {
    return C3$jscomp$11.FetchOk(a).then(b => b.blob())
}
;
C3$jscomp$11.FetchArrayBuffer = function(a) {
    return C3$jscomp$11.FetchOk(a).then(b => b.arrayBuffer())
}
;
C3$jscomp$11.FetchImage = function(a) {
    return new Promise( (b, c) => {
        const d = new Image;
        d.onload = () => b(d);
        d.onerror = e => c(e);
        d.src = a
    }
    )
}
;
C3$jscomp$11.BlobToArrayBuffer = function(a) {
    return "function" === typeof a.arrayBuffer ? a.arrayBuffer() : new Promise( (b, c) => {
        const d = new FileReader;
        d.onload = () => b(d.result);
        d.onerror = () => c(d.error);
        d.readAsArrayBuffer(a)
    }
    )
}
;
C3$jscomp$11.BlobToString = function(a) {
    return "function" === typeof a.text ? a.text() : new Promise( (b, c) => {
        const d = new FileReader;
        d.onload = () => b(d.result);
        d.onerror = () => c(d.error);
        d.readAsText(a)
    }
    )
}
;
C3$jscomp$11.BlobToJson = function(a) {
    return C3$jscomp$11.BlobToString(a).then(b => JSON.parse(b))
}
;
C3$jscomp$11.BlobToImage = async function(a, b) {
    a = URL.createObjectURL(a);
    try {
        const c = await C3$jscomp$11.FetchImage(a);
        URL.revokeObjectURL(a);
        a = "";
        b && "function" === typeof c.decode && await c.decode();
        return c
    } finally {
        a && URL.revokeObjectURL(a)
    }
}
;
C3$jscomp$11.CreateCanvas = function(a, b) {
    if ("undefined" !== typeof document && "function" === typeof document.createElement) {
        const c = document.createElement("canvas");
        c.width = a;
        c.height = b;
        return c
    }
    return new OffscreenCanvas(a,b)
}
;
C3$jscomp$11.CanvasToBlob = function(a, b, c) {
    "number" !== typeof c && (c = 1);
    b = b || "image/png";
    c = C3$jscomp$11.clamp(c, 0, 1);
    if (a.convertToBlob)
        return a.convertToBlob({
            type: b,
            quality: c
        });
    if (a.toBlob)
        return new Promise(d => a.toBlob(d, b, c));
    throw Error("could not convert canvas to blob");
}
;
C3$jscomp$11.DrawableToBlob = function(a, b, c) {
    const d = C3$jscomp$11.CreateCanvas(a.width, a.height);
    d.getContext("2d").drawImage(a, 0, 0);
    return C3$jscomp$11.CanvasToBlob(d, b, c)
}
;
C3$jscomp$11.ImageDataToBlob = function(a, b, c) {
    if (C3$jscomp$11.Supports.ImageBitmapOptions)
        return createImageBitmap(a, {
            premultiplyAlpha: "none"
        }).then(e => C3$jscomp$11.DrawableToBlob(e, b, c));
    if (C3$jscomp$11.Supports.ImageBitmap)
        return createImageBitmap(a).then(e => C3$jscomp$11.DrawableToBlob(e, b, c));
    const d = C3$jscomp$11.CreateCanvas(a.width, a.height);
    d.getContext("2d").putImageData(a, 0, 0);
    return C3$jscomp$11.CanvasToBlob(d, b, c)
}
;
C3$jscomp$11.CopySet = function(a, b) {
    a.clear();
    for (const c of b)
        a.add(c)
}
;
C3$jscomp$11.MapToObject = function(a) {
    const b = Object.create(null);
    for (const [c,d] of a.entries())
        b[c] = d;
    return b
}
;
C3$jscomp$11.ObjectToMap = function(a, b) {
    b.clear();
    for (const [c,d] of Object.entries(a))
        b.set(c, d)
}
;
C3$jscomp$11.ToSuperJSON = function ToSuperJSON(a) {
    if ("object" === typeof a && null !== a) {
        if (a instanceof Set)
            return {
                _c3type_: "set",
                data: [...a].map(d => ToSuperJSON(d))
            };
        if (a instanceof Map)
            return {
                _c3type_: "map",
                data: [...a].map(d => [d[0], ToSuperJSON(d[1])])
            };
        const c = Object.create(null);
        for (const [d,e] of Object.entries(a))
            c[d] = ToSuperJSON(e);
        return c
    }
    return a
}
;
C3$jscomp$11.FromSuperJSON = function FromSuperJSON(a) {
    if ("object" === typeof a & null !== a) {
        if ("set" === a._c3type_)
            return new Set(a.data.map(d => FromSuperJSON(d)));
        if ("map" === a._c3type_)
            return new Map(a.data.map(d => [d[0], FromSuperJSON(d[1])]));
        const c = Object.create(null);
        for (const [d,e] of Object.entries(a))
            c[d] = FromSuperJSON(e);
        return c
    }
    return a
}
;
C3$jscomp$11.CSSToCamelCase = function(a) {
    if (a.startsWith("--"))
        return a;
    let b = ""
      , c = !1
      , d = 0;
    for (const e of a)
        "-" === e ? 0 < d && (c = !0) : c ? (b += e.toUpperCase(),
        c = !1) : b += e,
        ++d;
    return b
}
;
C3$jscomp$11.IsIterator = function(a) {
    return "object" === typeof a && "function" === typeof a.next
}
;
C3$jscomp$11.MakeFilledArray = function(a, b) {
    const c = [];
    if ("function" === typeof b)
        for (var d = 0; d < a; ++d)
            c.push(b());
    else
        for (d = 0; d < a; ++d)
            c.push(b);
    return c
}
;
"use strict";
const C3$jscomp$12 = self.C3
  , HSL_TEST = /([0-9.]+),([0-9.]+)%?,([0-9.]+)%?/i
  , HSLA_TEST = /([0-9.]+),([0-9.]+)%?,([0-9.]+)%?,([0-9.])/i;
function padTwoDigits(a) {
    return 0 === a.length ? "00" : 1 === a.length ? "0" + a : a
}
function hueToRGB(a, b, c) {
    0 > c && (c += 1);
    1 < c && --c;
    return c < 1 / 6 ? a + 6 * (b - a) * c : .5 > c ? b : c < 2 / 3 ? a + (b - a) * (2 / 3 - c) * 6 : a
}
C3$jscomp$12.Color = class {
    constructor(a, b, c, d) {
        this._a = this._b = this._g = this._r = 0;
        a instanceof C3$jscomp$12.Color ? this.set(a) : this.setRgba(a || 0, b || 0, c || 0, d || 0)
    }
    setRgb(a, b, c) {
        this._r = +a;
        this._g = +b;
        this._b = +c;
        this.clamp();
        return this
    }
    setRgba(a, b, c, d) {
        this._r = +a;
        this._g = +b;
        this._b = +c;
        this._a = +d;
        this.clamp();
        return this
    }
    set(a) {
        this._r = a._r;
        this._g = a._g;
        this._b = a._b;
        this._a = a._a;
        return this
    }
    copy(a) {
        return this.set(a)
    }
    add(a) {
        this._r += a._r;
        this._g += a._g;
        this._b += a._b;
        this._a += a._a;
        this.clamp()
    }
    addRgb(a, b, c, d=0) {
        this._r += +a;
        this._g += +b;
        this._b += +c;
        this._a += +d;
        this.clamp()
    }
    diff(a) {
        this.setR(Math.max(this._r, a._r) - Math.min(this._r, a._r));
        this.setG(Math.max(this._g, a._g) - Math.min(this._g, a._g));
        this.setB(Math.max(this._b, a._b) - Math.min(this._b, a._b));
        this.setA(Math.max(this._a, a._a) - Math.min(this._a, a._a));
        this.clamp()
    }
    copyRgb(a) {
        this._r = a._r;
        this._g = a._g;
        this._b = a._b
    }
    setR(a) {
        this._r = C3$jscomp$12.clamp(+a, 0, 1)
    }
    getR() {
        return this._r
    }
    setG(a) {
        this._g = C3$jscomp$12.clamp(+a, 0, 1)
    }
    getG() {
        return this._g
    }
    setB(a) {
        this._b = C3$jscomp$12.clamp(+a, 0, 1)
    }
    getB() {
        return this._b
    }
    setA(a) {
        this._a = C3$jscomp$12.clamp(+a, 0, 1)
    }
    getA() {
        return this._a
    }
    clone() {
        return C3$jscomp$12.New(C3$jscomp$12.Color, this._r, this._g, this._b, this._a)
    }
    toArray() {
        return [this._r, this._g, this._b, this._a]
    }
    toTypedArray() {
        return new Float64Array(this.toArray())
    }
    writeToTypedArray(a, b) {
        a[b++] = this._r;
        a[b++] = this._g;
        a[b++] = this._b;
        a[b] = this._a
    }
    writeRGBToTypedArray(a, b) {
        a[b++] = this._r;
        a[b++] = this._g;
        a[b] = this._b
    }
    equals(a) {
        return this._r === a._r && this._g === a._g && this._b === a._b && this._a === a._a
    }
    equalsIgnoringAlpha(a) {
        return this._r === a._r && this._g === a._g && this._b === a._b
    }
    equalsRgb(a, b, c) {
        return this._r === a && this._g === b && this._b === c
    }
    equalsRgba(a, b, c, d) {
        return this._r === a && this._g === b && this._b === c && this._a === d
    }
    equalsF32Array(a, b) {
        return a[b] === Math.fround(this._r) && a[b + 1] === Math.fround(this._g) && a[b + 2] === Math.fround(this._b) && a[b + 3] === Math.fround(this._a)
    }
    equalsRGBF32Array(a, b) {
        return a[b] === Math.fround(this._r) && a[b + 1] === Math.fround(this._g) && a[b + 2] === Math.fround(this._b)
    }
    multiply(a) {
        this._r *= a._r;
        this._g *= a._g;
        this._b *= a._b;
        this._a *= a._a
    }
    multiplyAlpha(a) {
        this._r *= a;
        this._g *= a;
        this._b *= a;
        this._a *= a
    }
    premultiply() {
        this._r *= this._a;
        this._g *= this._a;
        this._b *= this._a;
        return this
    }
    unpremultiply() {
        this._r /= this._a;
        this._g /= this._a;
        this._b /= this._a;
        return this
    }
    clamp() {
        this._r = C3$jscomp$12.clamp(this._r, 0, 1);
        this._g = C3$jscomp$12.clamp(this._g, 0, 1);
        this._b = C3$jscomp$12.clamp(this._b, 0, 1);
        this._a = C3$jscomp$12.clamp(this._a, 0, 1);
        return this
    }
    setFromRgbValue(a) {
        this._r = C3$jscomp$12.GetRValue(a);
        this._g = C3$jscomp$12.GetGValue(a);
        this._b = C3$jscomp$12.GetBValue(a);
        this._a = C3$jscomp$12.GetAValue(a)
    }
    getCssRgb(a, b, c) {
        a = C3$jscomp$12.IsFiniteNumber(a) ? a : this.getR();
        b = C3$jscomp$12.IsFiniteNumber(b) ? b : this.getG();
        c = C3$jscomp$12.IsFiniteNumber(c) ? c : this.getB();
        return `rgb(${100 * a}%, ${100 * b}%, ${100 * c}%)`
    }
    getCssRgba(a, b, c, d) {
        a = C3$jscomp$12.IsFiniteNumber(a) ? a : this.getR();
        b = C3$jscomp$12.IsFiniteNumber(b) ? b : this.getG();
        c = C3$jscomp$12.IsFiniteNumber(c) ? c : this.getB();
        d = C3$jscomp$12.IsFiniteNumber(d) ? d : this.getA();
        return `rgba(${100 * a}%, ${100 * b}%, ${100 * c}%, ${d})`
    }
    toHexString() {
        const a = Math.round(255 * this.getR())
          , b = Math.round(255 * this.getG())
          , c = Math.round(255 * this.getB());
        return "#" + padTwoDigits(a.toString(16)) + padTwoDigits(b.toString(16)) + padTwoDigits(c.toString(16))
    }
    parseHexString(a) {
        if ("string" !== typeof a)
            return !1;
        a = a.trim();
        "#" === a.charAt(0) && (a = a.substr(1));
        let b, c;
        if (3 === a.length)
            b = parseInt(a[0], 16) / 15,
            c = parseInt(a[1], 16) / 15,
            a = parseInt(a[2], 16) / 15;
        else if (6 === a.length)
            b = parseInt(a.substr(0, 2), 16) / 255,
            c = parseInt(a.substr(2, 2), 16) / 255,
            a = parseInt(a.substr(4, 2), 16) / 255;
        else
            return !1;
        isFinite(b) && this.setR(b);
        isFinite(c) && this.setG(c);
        isFinite(a) && this.setB(a);
        this.setA(1);
        return !0
    }
    toCommaSeparatedRgb() {
        const a = Math.round(255 * this.getR())
          , b = Math.round(255 * this.getG())
          , c = Math.round(255 * this.getB());
        return `${a}, ${b}, ${c}`
    }
    toRgbArray() {
        const a = Math.round(255 * this.getR())
          , b = Math.round(255 * this.getG())
          , c = Math.round(255 * this.getB());
        return [a, b, c]
    }
    parseCommaSeparatedRgb(a) {
        if ("string" !== typeof a)
            return !1;
        a = a.replace(/^rgb\(|\)|%/, "");
        var b = a.split(",");
        if (3 > b.length)
            return !1;
        a = parseInt(b[0].trim(), 10) / 255;
        const c = parseInt(b[1].trim(), 10) / 255;
        b = parseInt(b[2].trim(), 10) / 255;
        isFinite(a) && this.setR(a);
        isFinite(c) && this.setG(c);
        isFinite(b) && this.setB(b);
        this.setA(1);
        return !0
    }
    parseCommaSeparatedPercentageRgb(a) {
        if ("string" !== typeof a)
            return !1;
        a = a.replace(/^rgb\(|\)|%/, "");
        var b = a.split(",");
        if (3 > b.length)
            return !1;
        a = parseInt(b[0].trim(), 10) / 100;
        const c = parseInt(b[1].trim(), 10) / 100;
        b = parseInt(b[2].trim(), 10) / 100;
        isFinite(a) && this.setR(a);
        isFinite(c) && this.setG(c);
        isFinite(b) && this.setB(b);
        this.setA(1);
        return !0
    }
    parseCommaSeparatedRgba(a) {
        if ("string" !== typeof a)
            return !1;
        a = a.replace(/^rgba\(|\)|%/, "");
        var b = a.split(",");
        if (4 > b.length)
            return !1;
        a = parseInt(b[0].trim(), 10) / 255;
        const c = parseInt(b[1].trim(), 10) / 255
          , d = parseInt(b[2].trim(), 10) / 255;
        b = parseFloat(b[3].trim());
        isFinite(a) && this.setR(a);
        isFinite(c) && this.setG(c);
        isFinite(d) && this.setB(d);
        isFinite(b) && this.setA(b);
        return !0
    }
    parseCommaSeparatedPercentageRgba(a) {
        if ("string" !== typeof a)
            return !1;
        a = a.replace(/^rgba\(|\)|%/, "");
        var b = a.split(",");
        if (4 > b.length)
            return !1;
        a = parseInt(b[0].trim(), 10) / 100;
        const c = parseInt(b[1].trim(), 10) / 100
          , d = parseInt(b[2].trim(), 10) / 100;
        b = parseFloat(b[3].trim());
        isFinite(a) && this.setR(a);
        isFinite(c) && this.setG(c);
        isFinite(d) && this.setB(d);
        isFinite(b) && this.setA(b);
        return !0
    }
    parseString(a) {
        if ("string" !== typeof a)
            return !1;
        a = a.replace(/\s+/, "");
        if (a.includes(",")) {
            if (a.startsWith("rgb("))
                return a.includes("%") ? this.parseCommaSeparatedPercentageRgb(a) : this.parseCommaSeparatedRgb(a);
            if (a.startsWith("rgba("))
                return a.includes("%") ? this.parseCommaSeparatedPercentageRgba(a) : this.parseCommaSeparatedRgba(a);
            if (a.startsWith("hsl(") || a.startsWith("hsla("))
                return this.parseHSLString(a);
            const b = a.split(",");
            if (a.includes("%")) {
                if (3 === b.length)
                    return this.parseCommaSeparatedPercentageRgb(a);
                if (4 === b.length)
                    return this.parseCommaSeparatedPercentageRgba(a)
            } else {
                if (3 === b.length)
                    return this.parseCommaSeparatedRgb(a);
                if (4 === b.length)
                    return this.parseCommaSeparatedRgba(a)
            }
            return !1
        }
        return this.parseHexString(a)
    }
    toJSON() {
        return [this._r, this._g, this._b, this._a]
    }
    setFromHSLA(a, b, c, d) {
        a %= 360;
        b = C3$jscomp$12.clamp(b, 0, 100);
        c = C3$jscomp$12.clamp(c, 0, 100);
        d = C3$jscomp$12.clamp(d, 0, 1);
        a /= 360;
        b /= 100;
        c /= 100;
        if (0 === b)
            c = b = a = c;
        else {
            const e = .5 > c ? c * (1 + b) : c + b - c * b
              , f = 2 * c - e;
            c = hueToRGB(f, e, a + 1 / 3);
            b = hueToRGB(f, e, a);
            a = hueToRGB(f, e, a - 1 / 3)
        }
        this.setR(c);
        this.setG(b);
        this.setB(a);
        this.setA(d);
        return this
    }
    parseHSLString(a) {
        var b = a.replace(/ |hsl|hsla|\(|\)|;/gi, "");
        a = HSL_TEST.exec(b);
        b = HSLA_TEST.exec(b);
        return a && 4 === a.length ? (this.setFromHSLA(+a[1], +a[2], +a[3], 1),
        !0) : b && 5 === b.length ? (this.setFromHSLA(+a[1], +a[2], +a[3], +a[4]),
        !0) : !1
    }
    toHSLAString() {
        var a = this._r;
        const b = this._g
          , c = this._b
          , d = this._a
          , e = C3$jscomp$12.Color.GetHue(a, b, c)
          , f = C3$jscomp$12.Color.GetSaturation(a, b, c);
        a = C3$jscomp$12.Color.GetLuminosity(a, b, c);
        return `hsla(${e}, ${f}%, ${a}%, ${d})`
    }
    toHSLAArray() {
        const a = this._r
          , b = this._g
          , c = this._b;
        return [C3$jscomp$12.Color.GetHue(a, b, c), C3$jscomp$12.Color.GetSaturation(a, b, c), C3$jscomp$12.Color.GetLuminosity(a, b, c), this._a]
    }
    setFromJSON(a) {
        !Array.isArray(a) || 3 > a.length || (this._r = a[0],
        this._g = a[1],
        this._b = a[2],
        this._a = 4 <= a.length ? a[3] : 1)
    }
    set r(a) {
        this.setR(a)
    }
    get r() {
        return this.getR()
    }
    set g(a) {
        this.setG(a)
    }
    get g() {
        return this.getG()
    }
    set b(a) {
        this.setB(a)
    }
    get b() {
        return this.getB()
    }
    set a(a) {
        this.setA(a)
    }
    get a() {
        return this.getA()
    }
    setAtIndex(a, b) {
        switch (a) {
        case 0:
            this.setR(b);
            break;
        case 1:
            this.setG(b);
            break;
        case 2:
            this.setB(b);
            break;
        case 3:
            this.setA(b);
            break;
        default:
            throw new RangeError("invalid color index");
        }
    }
    getAtIndex(a) {
        switch (a) {
        case 0:
            return this.getR();
        case 1:
            return this.getG();
        case 2:
            return this.getB();
        case 3:
            return this.getA();
        default:
            throw new RangeError("invalid color index");
        }
    }
    static Equals(a, b) {
        let c;
        if (Array.isArray(a))
            c = new C3$jscomp$12.Color,
            c.setFromJSON(a);
        else if (a instanceof C3$jscomp$12.Color)
            c = a;
        else
            throw Error("unexpected type");
        if (Array.isArray(b))
            a = new C3$jscomp$12.Color,
            a.setFromJSON(b);
        else if (b instanceof C3$jscomp$12.Color)
            a = b;
        else
            throw Error("unexpected type");
        return c.equals(a)
    }
    static DiffChannel(a, b) {
        return C3$jscomp$12.clamp(Math.max(a, b) - Math.min(a, b), 0, 1)
    }
    static Diff(a, b) {
        const c = new C3$jscomp$12.Color;
        c.setR(Math.max(a._r, b._r) - Math.min(a._r, b._r));
        c.setG(Math.max(a._g, b._g) - Math.min(a._g, b._g));
        c.setB(Math.max(a._b, b._b) - Math.min(a._b, b._b));
        c.setA(Math.max(a._a, b._a) - Math.min(a._a, b._a));
        return c
    }
    static DiffNoAlpha(a, b) {
        const c = new C3$jscomp$12.Color(0,0,0,1);
        c.setR(Math.max(a._r, b._r) - Math.min(a._r, b._r));
        c.setG(Math.max(a._g, b._g) - Math.min(a._g, b._g));
        c.setB(Math.max(a._b, b._b) - Math.min(a._b, b._b));
        return c
    }
    static GetHue(a, b, c) {
        const d = Math.max(a, b, c)
          , e = Math.min(a, b, c);
        if (d === e)
            return 0;
        let f = 0;
        switch (d) {
        case a:
            f = (b - c) / (d - e) + (b < c ? 6 : 0);
            break;
        case b:
            f = (c - a) / (d - e) + 2;
            break;
        case c:
            f = (a - b) / (d - e) + 4
        }
        return Math.round(f / 6 * 360)
    }
    static GetSaturation(a, b, c) {
        const d = Math.max(a, b, c);
        a = Math.min(a, b, c);
        if (d === a)
            return 0;
        b = d - a;
        return Math.round(100 * (.5 < (d + a) / 2 ? b / (2 - d - a) : b / (d + a)))
    }
    static GetLuminosity(a, b, c) {
        const d = Math.max(a, b, c);
        return d ? Math.round((d + Math.min(a, b, c)) / 2 * 100) : 0
    }
}
;
C3$jscomp$12.Color.White = Object.freeze(C3$jscomp$12.New(C3$jscomp$12.Color, 1, 1, 1, 1));
C3$jscomp$12.Color.Black = Object.freeze(C3$jscomp$12.New(C3$jscomp$12.Color, 0, 0, 0, 1));
C3$jscomp$12.Color.TransparentBlack = Object.freeze(C3$jscomp$12.New(C3$jscomp$12.Color, 0, 0, 0, 0));
"use strict";
const C3$jscomp$13 = self.C3;
C3$jscomp$13.Vector2 = class {
    constructor(a, b) {
        this._y = this._x = 0;
        a instanceof C3$jscomp$13.Vector2 ? this.copy(a) : this.set(a || 0, b || 0)
    }
    set(a, b) {
        this._x = +a;
        this._y = +b
    }
    copy(a) {
        this._x = a._x;
        this._y = a._y
    }
    equals(a) {
        return this._x === a._x && this._y === a._y
    }
    equalsValues(a, b) {
        return this._x === a && this._y === b
    }
    equalsF32Array(a, b) {
        return a[b] === Math.fround(this._x) && a[b + 1] === Math.fround(this._y)
    }
    setX(a) {
        this._x = +a
    }
    getX() {
        return this._x
    }
    setY(a) {
        this._y = +a
    }
    getY() {
        return this._y
    }
    toArray() {
        return [this._x, this._y]
    }
    toTypedArray() {
        return new Float64Array(this.toArray())
    }
    writeToTypedArray(a, b) {
        a[b++] = this._x;
        a[b] = this._y
    }
    offset(a, b) {
        this._x += +a;
        this._y += +b
    }
    scale(a, b) {
        this._x *= a;
        this._y *= b
    }
    divide(a, b) {
        this._x /= a;
        this._y /= b
    }
    round() {
        this._x = Math.round(this._x);
        this._y = Math.round(this._y)
    }
    floor() {
        this._x = Math.floor(this._x);
        this._y = Math.floor(this._y)
    }
    ceil() {
        this._x = Math.ceil(this._x);
        this._y = Math.ceil(this._y)
    }
    angle() {
        return C3$jscomp$13.angleTo(0, 0, this._x, this._y)
    }
    lengthSquared() {
        return this._x * this._x + this._y * this._y
    }
    length() {
        return Math.hypot(this._x, this._y)
    }
    rotatePrecalc(a, b) {
        const c = this._x * b - this._y * a;
        this._y = this._y * b + this._x * a;
        this._x = c
    }
    rotate(a) {
        0 !== a && this.rotatePrecalc(Math.sin(a), Math.cos(a))
    }
    rotateAbout(a, b, c) {
        0 === a || b === this._x && c === this._y || (this._x -= b,
        this._y -= c,
        this.rotatePrecalc(Math.sin(a), Math.cos(a)),
        this._x += +b,
        this._y += +c)
    }
    move(a, b) {
        0 !== b && (this._x += Math.cos(a) * b,
        this._y += Math.sin(a) * b)
    }
    normalize() {
        const a = this.length();
        0 !== a && 1 !== a && (this._x /= a,
        this._y /= a)
    }
    clamp(a, b) {
        this._x = C3$jscomp$13.clamp(this._x, a, b);
        this._y = C3$jscomp$13.clamp(this._y, a, b)
    }
    dot(a) {
        return this._x * a._x + this._y * a._y
    }
    reverse() {
        this._x = -this._x;
        this._y = -this._y
    }
    perp() {
        let a = this._x;
        this._x = this._y;
        this._y = -a;
        return this
    }
}
;
"use strict";
const C3$jscomp$14 = self.C3;
C3$jscomp$14.Rect = class {
    constructor(a, b, c, d) {
        this._bottom = this._right = this._top = this._left = 0;
        a instanceof C3$jscomp$14.Rect ? this.copy(a) : this.set(a || 0, b || 0, c || 0, d || 0)
    }
    set(a, b, c, d) {
        this._left = +a;
        this._top = +b;
        this._right = +c;
        this._bottom = +d
    }
    setWH(a, b, c, d) {
        a = +a;
        b = +b;
        this._left = a;
        this._top = b;
        this._right = a + +c;
        this._bottom = b + +d
    }
    copy(a) {
        this._left = +a._left;
        this._top = +a._top;
        this._right = +a._right;
        this._bottom = +a._bottom
    }
    clone() {
        return new C3$jscomp$14.Rect(this._left,this._top,this._right,this._bottom)
    }
    static Merge(a, b) {
        const c = new C3$jscomp$14.Rect;
        c.setLeft(Math.min(a._left, b._left));
        c.setTop(Math.min(a._top, b._top));
        c.setRight(Math.max(a._right, b._right));
        c.setBottom(Math.max(a._bottom, b._bottom));
        return c
    }
    static FromObject(a) {
        return new C3$jscomp$14.Rect(a.left,a.top,a.right,a.bottom)
    }
    equals(a) {
        return this._left === a._left && this._top === a._top && this._right === a._right && this._bottom === a._bottom
    }
    equalsWH(a, b, c, d) {
        return this._left === a && this._top === b && this.width() === c && this.height() === d
    }
    equalsF32Array(a, b) {
        return a[b] === Math.fround(this._left) && a[b + 1] === Math.fround(this._top) && a[b + 2] === Math.fround(this._right) && a[b + 3] === Math.fround(this._bottom)
    }
    setLeft(a) {
        this._left = +a
    }
    getLeft() {
        return this._left
    }
    setTop(a) {
        this._top = +a
    }
    getTop() {
        return this._top
    }
    setRight(a) {
        this._right = +a
    }
    getRight() {
        return this._right
    }
    setBottom(a) {
        this._bottom = +a
    }
    getBottom() {
        return this._bottom
    }
    toArray() {
        return [this._left, this._top, this._right, this._bottom]
    }
    toTypedArray() {
        return new Float64Array(this.toArray())
    }
    toDOMRect() {
        return new DOMRect(this._left,this._top,this.width(),this.height())
    }
    static fromDOMRect(a) {
        return C3$jscomp$14.New(C3$jscomp$14.Rect, a.left, a.top, a.right, a.bottom)
    }
    writeToTypedArray(a, b) {
        a[b++] = this._left;
        a[b++] = this._top;
        a[b++] = this._right;
        a[b] = this._bottom
    }
    writeAsQuadToTypedArray(a, b) {
        a[b++] = this._left;
        a[b++] = this._top;
        a[b++] = this._right;
        a[b++] = this._top;
        a[b++] = this._right;
        a[b++] = this._bottom;
        a[b++] = this._left;
        a[b] = this._bottom
    }
    writeAsQuadToTypedArray3D(a, b, c) {
        a[b++] = this._left;
        a[b++] = this._top;
        a[b++] = c;
        a[b++] = this._right;
        a[b++] = this._top;
        a[b++] = c;
        a[b++] = this._right;
        a[b++] = this._bottom;
        a[b++] = c;
        a[b++] = this._left;
        a[b++] = this._bottom;
        a[b] = c
    }
    width() {
        return this._right - this._left
    }
    height() {
        return this._bottom - this._top
    }
    midX() {
        return (this._left + this._right) / 2
    }
    midY() {
        return (this._top + this._bottom) / 2
    }
    offset(a, b) {
        a = +a;
        b = +b;
        this._left += a;
        this._top += b;
        this._right += a;
        this._bottom += b
    }
    offsetLeft(a) {
        this._left += +a
    }
    offsetTop(a) {
        this._top += +a
    }
    offsetRight(a) {
        this._right += +a
    }
    offsetBottom(a) {
        this._bottom += +a
    }
    toSquare(a) {
        if ("x" !== a)
            throw Error("invalid axis, only 'x' supported");
        this._bottom = this._top < this._bottom ? this._left < this._right ? this._top + this.width() : this._top - this.width() : this._left < this._right ? this._top - this.width() : this._top + this.width()
    }
    inflate(a, b) {
        a = +a;
        b = +b;
        this._left -= a;
        this._top -= b;
        this._right += a;
        this._bottom += b
    }
    deflate(a, b) {
        a = +a;
        b = +b;
        this._left += a;
        this._top += b;
        this._right -= a;
        this._bottom -= b
    }
    multiply(a, b) {
        this._left *= a;
        this._top *= b;
        this._right *= a;
        this._bottom *= b
    }
    divide(a, b) {
        this._left /= a;
        this._top /= b;
        this._right /= a;
        this._bottom /= b
    }
    mirrorAround(a) {
        this._left = +a - this._left;
        this._right = +a - this._right
    }
    flipAround(a) {
        this._top = +a - this._top;
        this._bottom = +a - this._bottom
    }
    rotate90DegreesAround(a, b) {
        const c = this.width()
          , d = this.height()
          , e = this.getLeft() + c * a
          , f = this.getTop() + d * b;
        this.setWH(e - d * b, f - c * a, d, c)
    }
    swapLeftRight() {
        const a = this._left;
        this._left = this._right;
        this._right = a
    }
    swapTopBottom() {
        const a = this._top;
        this._top = this._bottom;
        this._bottom = a
    }
    shuntY(a) {
        const b = this._top;
        this._top = +a - this._bottom;
        this._bottom = +a - b
    }
    round() {
        this._left = Math.round(this._left);
        this._top = Math.round(this._top);
        this._right = Math.round(this._right);
        this._bottom = Math.round(this._bottom)
    }
    roundInner() {
        this._left = Math.ceil(this._left);
        this._top = Math.ceil(this._top);
        this._right = Math.floor(this._right);
        this._bottom = Math.floor(this._bottom)
    }
    roundOuter() {
        this._left = Math.floor(this._left);
        this._top = Math.floor(this._top);
        this._right = Math.ceil(this._right);
        this._bottom = Math.ceil(this._bottom)
    }
    floor() {
        this._left = Math.floor(this._left);
        this._top = Math.floor(this._top);
        this._right = Math.floor(this._right);
        this._bottom = Math.floor(this._bottom)
    }
    ceil() {
        this._left = Math.ceil(this._left);
        this._top = Math.ceil(this._top);
        this._right = Math.ceil(this._right);
        this._bottom = Math.ceil(this._bottom)
    }
    clamp(a, b, c, d) {
        this._left = Math.max(this._left, +a);
        this._top = Math.max(this._top, +b);
        this._right = Math.min(this._right, +c);
        this._bottom = Math.min(this._bottom, +d)
    }
    clampBoth(a, b, c, d) {
        a = +a;
        b = +b;
        c = +c;
        d = +d;
        this._left = C3$jscomp$14.clamp(this._left, a, c);
        this._top = C3$jscomp$14.clamp(this._top, b, d);
        this._right = C3$jscomp$14.clamp(this._right, a, c);
        this._bottom = C3$jscomp$14.clamp(this._bottom, b, d)
    }
    normalize() {
        this._left > this._right && this.swapLeftRight();
        this._top > this._bottom && this.swapTopBottom()
    }
    intersectsRect(a) {
        return !(a._right < this._left || a._bottom < this._top || a._left > this._right || a._top > this._bottom)
    }
    intersectsRectOffset(a, b, c) {
        return !(a._right + b < this._left || a._bottom + c < this._top || a._left + b > this._right || a._top + c > this._bottom)
    }
    containsPoint(a, b) {
        return a >= this._left && a <= this._right && b >= this._top && b <= this._bottom
    }
    containsRect(a) {
        return a._left >= this._left && a._top >= this._top && a._right <= this._right && a._bottom <= this._bottom
    }
    expandToContain(a) {
        a._left < this._left && (this._left = +a._left);
        a._top < this._top && (this._top = +a._top);
        a._right > this._right && (this._right = +a._right);
        a._bottom > this._bottom && (this._bottom = +a._bottom)
    }
    lerpInto(a) {
        this._left = C3$jscomp$14.lerp(a._left, a._right, this._left);
        this._top = C3$jscomp$14.lerp(a._top, a._bottom, this._top);
        this._right = C3$jscomp$14.lerp(a._left, a._right, this._right);
        this._bottom = C3$jscomp$14.lerp(a._top, a._bottom, this._bottom)
    }
}
;
"use strict";
const C3$jscomp$15 = self.C3;
C3$jscomp$15.Quad = class {
    constructor(a, b, c, d, e, f, h, l) {
        this._bly = this._blx = this._bry = this._brx = this._try = this._trx = this._tly = this._tlx = 0;
        a instanceof C3$jscomp$15.Quad ? this.copy(a) : this.set(a || 0, b || 0, c || 0, d || 0, e || 0, f || 0, h || 0, l || 0)
    }
    set(a, b, c, d, e, f, h, l) {
        this._tlx = +a;
        this._tly = +b;
        this._trx = +c;
        this._try = +d;
        this._brx = +e;
        this._bry = +f;
        this._blx = +h;
        this._bly = +l
    }
    setRect(a, b, c, d) {
        this.set(a, b, c, b, c, d, a, d)
    }
    copy(a) {
        this._tlx = a._tlx;
        this._tly = a._tly;
        this._trx = a._trx;
        this._try = a._try;
        this._brx = a._brx;
        this._bry = a._bry;
        this._blx = a._blx;
        this._bly = a._bly
    }
    equals(a) {
        return this._tlx === a._tlx && this._tly === a._tly && this._trx === a._trx && this._try === a._try && this._brx === a._brx && this._bry === a._bry && this._blx === a._blx && this._bly === a._bly
    }
    setTlx(a) {
        this._tlx = +a
    }
    getTlx() {
        return this._tlx
    }
    setTly(a) {
        this._tly = +a
    }
    getTly() {
        return this._tly
    }
    setTrx(a) {
        this._trx = +a
    }
    getTrx() {
        return this._trx
    }
    setTry(a) {
        this._try = +a
    }
    getTry() {
        return this._try
    }
    setBrx(a) {
        this._brx = +a
    }
    getBrx() {
        return this._brx
    }
    setBry(a) {
        this._bry = +a
    }
    getBry() {
        return this._bry
    }
    setBlx(a) {
        this._blx = +a
    }
    getBlx() {
        return this._blx
    }
    setBly(a) {
        this._bly = +a
    }
    getBly() {
        return this._bly
    }
    toDOMQuad() {
        return new DOMQuad(new DOMPoint(this._tlx,this._tly),new DOMPoint(this._trx,this._try),new DOMPoint(this._brx,this._bry),new DOMPoint(this._blx,this._bly))
    }
    static fromDOMQuad(a) {
        return C3$jscomp$15.New(C3$jscomp$15.Quad, a.p1.x, a.p1.y, a.p2.x, a.p2.y, a.p3.x, a.p3.y, a.p4.x, a.p4.y)
    }
    toArray() {
        return [this._tlx, this._tly, this._trx, this._try, this._brx, this._bry, this._blx, this._bly]
    }
    toTypedArray() {
        return new Float64Array(this.toArray())
    }
    writeToTypedArray(a, b) {
        a[b++] = this._tlx;
        a[b++] = this._tly;
        a[b++] = this._trx;
        a[b++] = this._try;
        a[b++] = this._brx;
        a[b++] = this._bry;
        a[b++] = this._blx;
        a[b] = this._bly
    }
    writeToTypedArray3D(a, b, c) {
        a[b++] = this._tlx;
        a[b++] = this._tly;
        a[b++] = c;
        a[b++] = this._trx;
        a[b++] = this._try;
        a[b++] = c;
        a[b++] = this._brx;
        a[b++] = this._bry;
        a[b++] = c;
        a[b++] = this._blx;
        a[b++] = this._bly;
        a[b] = c
    }
    offset(a, b) {
        a = +a;
        b = +b;
        this._tlx += a;
        this._tly += b;
        this._trx += a;
        this._try += b;
        this._brx += a;
        this._bry += b;
        this._blx += a;
        this._bly += b
    }
    round() {
        this._tlx = Math.round(this._tlx);
        this._tly = Math.round(this._tly);
        this._trx = Math.round(this._trx);
        this._try = Math.round(this._try);
        this._brx = Math.round(this._brx);
        this._bry = Math.round(this._bry);
        this._blx = Math.round(this._blx);
        this._bly = Math.round(this._bly)
    }
    floor() {
        this._tlx = Math.floor(this._tlx);
        this._tly = Math.floor(this._tly);
        this._trx = Math.floor(this._trx);
        this._try = Math.floor(this._try);
        this._brx = Math.floor(this._brx);
        this._bry = Math.floor(this._bry);
        this._blx = Math.floor(this._blx);
        this._bly = Math.floor(this._bly)
    }
    ceil() {
        this._tlx = Math.ceil(this._tlx);
        this._tly = Math.ceil(this._tly);
        this._trx = Math.ceil(this._trx);
        this._try = Math.ceil(this._try);
        this._brx = Math.ceil(this._brx);
        this._bry = Math.ceil(this._bry);
        this._blx = Math.ceil(this._blx);
        this._bly = Math.ceil(this._bly)
    }
    setFromRect(a) {
        this._tlx = a._left;
        this._tly = a._top;
        this._trx = a._right;
        this._try = a._top;
        this._brx = a._right;
        this._bry = a._bottom;
        this._blx = a._left;
        this._bly = a._bottom
    }
    setFromRotatedRect(a, b) {
        0 === b ? this.setFromRect(a) : this.setFromRotatedRectPrecalc(a, Math.sin(b), Math.cos(b))
    }
    setFromRotatedRectPrecalc(a, b, c) {
        const d = a._left * b
          , e = a._top * b
          , f = a._right * b;
        b *= a._bottom;
        const h = a._left * c
          , l = a._top * c
          , m = a._right * c;
        a = a._bottom * c;
        this._tlx = h - e;
        this._tly = l + d;
        this._trx = m - e;
        this._try = l + f;
        this._brx = m - b;
        this._bry = a + f;
        this._blx = h - b;
        this._bly = a + d
    }
    getBoundingBox(a) {
        a.set(Math.min(this._tlx, this._trx, this._brx, this._blx), Math.min(this._tly, this._try, this._bry, this._bly), Math.max(this._tlx, this._trx, this._brx, this._blx), Math.max(this._tly, this._try, this._bry, this._bly))
    }
    containsPoint(a, b) {
        var c = this._trx - this._tlx
          , d = this._try - this._tly;
        const e = this._brx - this._tlx
          , f = this._bry - this._tly;
        a -= this._tlx;
        b -= this._tly;
        var h = c * c + d * d;
        let l = c * e + d * f;
        d = c * a + d * b;
        const m = e * e + f * f
          , p = e * a + f * b;
        let r = 1 / (h * m - l * l);
        c = (m * d - l * p) * r;
        h = (h * p - l * d) * r;
        if (0 <= c && 0 < h && 1 > c + h)
            return !0;
        c = this._blx - this._tlx;
        d = this._bly - this._tly;
        h = c * c + d * d;
        l = c * e + d * f;
        d = c * a + d * b;
        r = 1 / (h * m - l * l);
        c = (m * d - l * p) * r;
        h = (h * p - l * d) * r;
        return 0 <= c && 0 < h && 1 > c + h
    }
    midX() {
        return (this._tlx + this._trx + this._brx + this._blx) / 4
    }
    midY() {
        return (this._tly + this._try + this._bry + this._bly) / 4
    }
    intersectsSegment(a, b, c, d) {
        return this.containsPoint(a, b) || this.containsPoint(c, d) ? !0 : C3$jscomp$15.segmentIntersectsQuad(a, b, c, d, this)
    }
    intersectsQuad(a) {
        var b = a.midX()
          , c = a.midY();
        if (this.containsPoint(b, c))
            return !0;
        b = this.midX();
        c = this.midY();
        if (a.containsPoint(b, c))
            return !0;
        b = this._tlx;
        c = this._tly;
        const d = this._trx
          , e = this._try
          , f = this._brx
          , h = this._bry
          , l = this._blx
          , m = this._bly;
        return C3$jscomp$15.segmentIntersectsQuad(b, c, d, e, a) || C3$jscomp$15.segmentIntersectsQuad(d, e, f, h, a) || C3$jscomp$15.segmentIntersectsQuad(f, h, l, m, a) || C3$jscomp$15.segmentIntersectsQuad(l, m, b, c, a)
    }
    rotatePointsAnticlockwise() {
        const a = this._tlx
          , b = this._tly;
        this._tlx = this._trx;
        this._tly = this._try;
        this._trx = this._brx;
        this._try = this._bry;
        this._brx = this._blx;
        this._bry = this._bly;
        this._blx = a;
        this._bly = b
    }
    mirror() {
        this._swap(0, 2);
        this._swap(1, 3);
        this._swap(6, 4);
        this._swap(7, 5)
    }
    flip() {
        this._swap(0, 6);
        this._swap(1, 7);
        this._swap(2, 4);
        this._swap(3, 5)
    }
    diag() {
        this._swap(2, 6);
        this._swap(3, 7)
    }
    _swap(a, b) {
        const c = this._getAtIndex(a);
        this._setAtIndex(a, this._getAtIndex(b));
        this._setAtIndex(b, c)
    }
    _getAtIndex(a) {
        switch (a) {
        case 0:
            return this._tlx;
        case 1:
            return this._tly;
        case 2:
            return this._trx;
        case 3:
            return this._try;
        case 4:
            return this._brx;
        case 5:
            return this._bry;
        case 6:
            return this._blx;
        case 7:
            return this._bly;
        default:
            throw new RangeError("invalid quad point index");
        }
    }
    _setAtIndex(a, b) {
        b = +b;
        switch (a) {
        case 0:
            this._tlx = b;
            break;
        case 1:
            this._tly = b;
            break;
        case 2:
            this._trx = b;
            break;
        case 3:
            this._try = b;
            break;
        case 4:
            this._brx = b;
            break;
        case 5:
            this._bry = b;
            break;
        case 6:
            this._blx = b;
            break;
        case 7:
            this._bly = b;
            break;
        default:
            throw new RangeError("invalid quad point index");
        }
    }
}
;
"use strict";
const C3$jscomp$16 = self.C3
  , DEFAULT_POLY_POINTS = [0, 0, 1, 0, 1, 1, 0, 1]
  , tempQuad = C3$jscomp$16.New(C3$jscomp$16.Quad);
C3$jscomp$16.CollisionPoly = class extends C3$jscomp$16.DefendedBase {
    constructor(a, b=!0) {
        super();
        a || (a = DEFAULT_POLY_POINTS);
        this._ptsArr = Float64Array.from(a);
        this._bbox = new C3$jscomp$16.Rect;
        this._isBboxChanged = !0;
        this._enabled = b
    }
    Release() {}
    pointsArr() {
        return this._ptsArr
    }
    pointCount() {
        return this._ptsArr.length / 2
    }
    setPoints(a) {
        this._ptsArr.length === a.length ? this._ptsArr.set(a) : this._ptsArr = Float64Array.from(a);
        this._isBboxChanged = !0
    }
    setDefaultPoints() {
        this.setPoints(DEFAULT_POLY_POINTS)
    }
    copy(a) {
        this.setPoints(a._ptsArr)
    }
    setBboxChanged() {
        this._isBboxChanged = !0
    }
    _updateBbox() {
        if (this._isBboxChanged) {
            var a = this._ptsArr
              , b = a[0]
              , c = a[1]
              , d = b
              , e = c;
            for (let f = 0, h = a.length; f < h; f += 2) {
                const l = a[f]
                  , m = a[f + 1];
                l < b && (b = l);
                l > d && (d = l);
                m < c && (c = m);
                m > e && (e = m)
            }
            this._bbox.set(b, c, d, e);
            this._isBboxChanged = !1
        }
    }
    setFromRect(a, b, c) {
        let d = this._ptsArr;
        8 !== d.length && (this._ptsArr = d = new Float64Array(8));
        d[0] = a.getLeft() - b;
        d[1] = a.getTop() - c;
        d[2] = a.getRight() - b;
        d[3] = a.getTop() - c;
        d[4] = a.getRight() - b;
        d[5] = a.getBottom() - c;
        d[6] = a.getLeft() - b;
        d[7] = a.getBottom() - c;
        this._bbox.copy(a);
        0 === b && 0 === c || this._bbox.offset(-b, -c);
        this._isBboxChanged = !1
    }
    setFromQuad(a, b, c) {
        tempQuad.copy(a);
        tempQuad.offset(b, c);
        this.setPoints(tempQuad.toArray());
        this._isBboxChanged = !0
    }
    transform(a, b, c) {
        let d = 0
          , e = 1;
        0 !== c && (d = Math.sin(c),
        e = Math.cos(c));
        this.transformPrecalc(a, b, d, e)
    }
    transformPrecalc(a, b, c, d) {
        const e = this._ptsArr;
        for (let f = 0, h = e.length; f < h; f += 2) {
            const l = f + 1
              , m = e[f] * a
              , p = e[l] * b;
            e[f] = m * d - p * c;
            e[l] = p * d + m * c
        }
        this._isBboxChanged = !0
    }
    offset(a, b) {
        const c = this._ptsArr;
        for (let d = 0, e = c.length; d < e; d += 2)
            c[d] += a,
            c[d + 1] += b
    }
    containsPoint(a, b) {
        const c = this._ptsArr;
        if (a === c[0] && b === c[1])
            return !0;
        this._updateBbox();
        var d = this._bbox;
        const e = d.getLeft() - 110
          , f = d.getTop() - 101
          , h = d.getRight() + 131;
        d = d.getBottom() + 120;
        let l, m, p, r, v, x, B, A;
        e < a ? (l = e,
        p = a) : (l = a,
        p = e);
        f < b ? (m = f,
        r = b) : (m = b,
        r = f);
        h < a ? (v = h,
        B = a) : (v = a,
        B = h);
        d < b ? (x = d,
        A = b) : (x = b,
        A = d);
        let D = 0
          , F = 0;
        for (let K = 0, M = c.length; K < M; K += 2) {
            var I = (K + 2) % M;
            const Q = c[K]
              , W = c[K + 1]
              , ca = c[I];
            I = c[I + 1];
            C3$jscomp$16.segmentsIntersectPreCalc(e, f, a, b, l, p, m, r, Q, W, ca, I) && ++D;
            C3$jscomp$16.segmentsIntersectPreCalc(h, d, a, b, v, B, x, A, Q, W, ca, I) && ++F
        }
        return 1 === D % 2 || 1 === F % 2
    }
    intersectsPoly(a, b, c) {
        const d = a._ptsArr
          , e = this._ptsArr;
        if (this.containsPoint(d[0] + b, d[1] + c) || a.containsPoint(e[0] - b, e[1] - c))
            return !0;
        for (let h = 0, l = e.length; h < l; h += 2) {
            var f = (h + 2) % l;
            a = e[h];
            const m = e[h + 1]
              , p = e[f];
            f = e[f + 1];
            let r, v, x, B;
            a < p ? (r = a,
            x = p) : (r = p,
            x = a);
            m < f ? (v = m,
            B = f) : (v = f,
            B = m);
            for (let A = 0, D = d.length; A < D; A += 2) {
                const F = (A + 2) % D;
                if (C3$jscomp$16.segmentsIntersectPreCalc(a, m, p, f, r, x, v, B, d[A] + b, d[A + 1] + c, d[F] + b, d[F + 1] + c))
                    return !0
            }
        }
        return !1
    }
    intersectsSegment(a, b, c, d, e, f) {
        if (this.containsPoint(c - a, d - b) || this.containsPoint(e - a, f - b))
            return !0;
        let h, l, m, p;
        c < e ? (h = c,
        m = e) : (h = e,
        m = c);
        d < f ? (l = d,
        p = f) : (l = f,
        p = d);
        const r = this._ptsArr;
        for (let v = 0, x = r.length; v < x; v += 2) {
            const B = (v + 2) % x;
            if (C3$jscomp$16.segmentsIntersectPreCalc(c, d, e, f, h, m, l, p, r[v] + a, r[v + 1] + b, r[B] + a, r[B + 1] + b))
                return !0
        }
        return !1
    }
    mirror(a) {
        const b = this._ptsArr;
        for (let c = 0, d = b.length; c < d; c += 2)
            b[c] = 2 * a - b[c];
        this._isBboxChanged = !0
    }
    flip(a) {
        const b = this._ptsArr;
        for (let c = 0, d = b.length; c < d; c += 2) {
            const e = c + 1;
            b[e] = 2 * a - b[e]
        }
        this._isBboxChanged = !0
    }
    diag() {
        const a = this._ptsArr;
        for (let b = 0, c = a.length; b < c; b += 2) {
            const d = b + 1
              , e = a[b];
            a[b] = a[d];
            a[d] = e
        }
        this._isBboxChanged = !0
    }
    GetMidX() {
        const a = this._ptsArr;
        let b = 0;
        for (let c = 0, d = a.length; c < d; c += 2)
            b += a[c];
        return b / this.pointCount()
    }
    GetMidY() {
        const a = this._ptsArr;
        let b = 0;
        for (let c = 0, d = a.length; c < d; c += 2)
            b += a[c + 1];
        return b / this.pointCount()
    }
    GetPointsArray() {
        return this._ptsArr
    }
    GetPointCount() {
        return this.pointCount()
    }
    IsEnabled() {
        return this._enabled
    }
}
;
"use strict";
const C3$jscomp$17 = self.C3;
C3$jscomp$17.PairMap = class extends C3$jscomp$17.DefendedBase {
    constructor(a) {
        super();
        this._firstMap = new Map;
        if (a)
            for (const [b,c,d] of a)
                this.Set(b, c, d)
    }
    Release() {
        this.Clear();
        this._firstMap = null
    }
    IsEmpty() {
        return 0 === this._firstMap.size
    }
    Clear() {
        const a = this._firstMap;
        for (const b of a.values())
            b.clear();
        a.clear()
    }
    Set(a, b, c) {
        const d = this._firstMap;
        let e = d.get(a);
        e || (e = new Map,
        d.set(a, e));
        e.set(b, c)
    }
    Get(a, b) {
        return (a = this._firstMap.get(a)) ? a.get(b) : a
    }
    Has(a, b) {
        return (a = this._firstMap.get(a)) ? a.has(b) : !1
    }
    Delete(a, b) {
        const c = this._firstMap
          , d = c.get(a);
        if (!d)
            return !1;
        (b = d.delete(b)) && 0 === d.size && c.delete(a);
        return b
    }
    DeleteEither(a) {
        const b = this._firstMap
          , c = b.get(a);
        c && (c.clear(),
        b.delete(a));
        for (const [d,e] of b.entries())
            e.delete(a) && 0 === e.size && b.delete(d)
    }
    GetSize() {
        let a = 0;
        for (const b of this._firstMap.values())
            a += b.size;
        return a
    }
    *values() {
        for (const a of this._firstMap.values())
            yield*a.values()
    }
    *keyPairs() {
        for (const [a,b] of this._firstMap.entries())
            for (const c of b.keys())
                yield[a, c]
    }
    *entries() {
        for (const [a,b] of this._firstMap.entries())
            for (const [c,d] of b.entries())
                yield[a, c, d]
    }
}
;
"use strict";
const C3$jscomp$18 = self.C3;
C3$jscomp$18.ArraySet = class extends C3$jscomp$18.DefendedBase {
    constructor() {
        super();
        this._set = new Set;
        this._arr = [];
        this._needToRebuildArray = !1
    }
    Release() {
        this.Clear()
    }
    Clear() {
        this._set.clear();
        C3$jscomp$18.clearArray(this._arr);
        this._needToRebuildArray = !1
    }
    Add(a) {
        this._set.has(a) || (this._set.add(a),
        this._needToRebuildArray || this._arr.push(a))
    }
    Has(a) {
        return this._set.has(a)
    }
    Delete(a) {
        this._set.delete(a) && (this._needToRebuildArray = !0)
    }
    GetSize() {
        return this._set.size
    }
    IsEmpty() {
        return 0 === this._set.size
    }
    GetArray() {
        this._needToRebuildArray && (this._RebuildArray(),
        this._needToRebuildArray = !1);
        return this._arr
    }
    _RebuildArray() {
        const a = this._arr;
        C3$jscomp$18.clearArray(a);
        for (const b of this._set)
            a.push(b)
    }
}
;
"use strict";
const C3$jscomp$19 = self.C3
  , EASE_MAP = new Map
  , PREDEFINED_EASE_MAP = new Map
  , CUSTOM_EASE_EDITOR_MAP = new Map
  , CUSTOM_EASE_DATA_EDITOR_MAP = new Map
  , CUSTOM_EASE_RUNTIME_MAP = new Map
  , CUSTOM_EASE_DATA_RUNTIME_MAP = new Map
  , PRIVATE_EASE_MAP = new Map
  , BUILT_IN_TRANSITION_MAP = new Map
  , ALIAS_MAP = new Map;
ALIAS_MAP.set("linear", "noease");
ALIAS_MAP.set("default", "noease");
const EASE_TRANSLATION_KEYS = "default noease easeinquad easeoutquad easeinoutquad easeincubic easeoutcubic easeinoutcubic easeinquart easeoutquart easeinoutquart easeinquint easeoutquint easeinoutquint easeinsine easeoutsine easeinoutsine easeinexpo easeoutexpo easeinoutexpo easeincirc easeoutcirc easeinoutcirc easeinelastic easeoutelastic easeinoutelastic easeinback easeoutback easeinoutback easeinbounce easeoutbounce easeinoutbounce".split(" ")
  , SHORT_EASE_TRANSLATION_KEYS = "default noease quad cubic quart quint sine expo circ elastic back bounce".split(" ")
  , EASE_API2INTERNAL_NAMES = new Map([["linear", "noease"], ["in-sine", "easeinsine"], ["out-sine", "easeoutsine"], ["in-out-sine", "easeinoutsine"], ["in-elastic", "easeinelastic"], ["out-elastic", "easeoutelastic"], ["in-out-elastic", "easeinoutelastic"], ["in-back", "easeinback"], ["out-back", "easeoutback"], ["in-out-back", "easeinoutback"], ["in-bounce", "easeinbounce"], ["out-bounce", "easeoutbounce"], ["in-out-bounce", "easeinoutbounce"], ["in-cubic", "easeincubic"], ["out-cubic", "easeoutcubic"], ["in-out-cubic", "easeinoutcubic"], ["in-quadratic", "easeinquad"], ["out-quadratic", "easeoutquad"], ["in-out-quadratic", "easeinoutquad"], ["in-quartic", "easeinquart"], ["out-quartic", "easeoutquart"], ["in-out-quartic", "easeinoutquart"], ["in-quintic", "easeinquint"], ["out-quintic", "easeoutquint"], ["in-out-quintic", "easeinoutquint"], ["in-circular", "easeincirc"], ["out-circular", "easeoutcirc"], ["in-out-circular", "easeinoutcirc"], ["in-exponential", "easeinexpo"], ["out-exponential", "easeoutexpo"], ["in-out-exponential", "easeinoutexpo"]]);
self.Ease = class a {
    constructor() {}
    static InheritEase() {
        return "default"
    }
    static DefaultEase() {
        return "noease"
    }
    static ToInternal(b) {
        return EASE_API2INTERNAL_NAMES.get(b)
    }
    static GetEditorEaseNames(b, ...c) {
        this._CreateEaseMap();
        if (b) {
            CUSTOM_EASE_EDITOR_MAP.has(b) || CUSTOM_EASE_EDITOR_MAP.set(b, new Map);
            var d = CUSTOM_EASE_EDITOR_MAP.get(b);
            d = [...d.keys()].filter(e => a.GetEditorEaseData(e, b) ? a.GetEditorEaseData(e, b).transition.IsForAnyPurpose() : !0)
        } else
            d = CUSTOM_EASE_RUNTIME_MAP,
            d = [...d.keys()];
        d = d.sort();
        return [...PREDEFINED_EASE_MAP.keys()].concat(d).filter(e => !c.includes(e))
    }
    static GetRuntimeEaseNames() {
        this._CreateEaseMap();
        const b = [...CUSTOM_EASE_RUNTIME_MAP.keys()];
        b.sort();
        return [...PREDEFINED_EASE_MAP.keys()].concat(b)
    }
    static GetCustomRuntimeEaseNames() {
        this._CreateEaseMap();
        const b = [...CUSTOM_EASE_RUNTIME_MAP.keys()];
        b.sort();
        return b
    }
    static IsPredefinedTranslatedName(b) {
        for (const c of EASE_TRANSLATION_KEYS)
            if (self.lang(`ui.bars.timeline.eases.${c}`) === b)
                return !0;
        for (const c of SHORT_EASE_TRANSLATION_KEYS)
            if (self.lang(`ui.bars.timeline.short-eases.${c}`) === b)
                return !0
    }
    static IsNamePredefined(b) {
        this._CreateEaseMap();
        return [...PREDEFINED_EASE_MAP.keys()].includes(b)
    }
    static _GetEase(b) {
        const c = ALIAS_MAP.get(b);
        if (c)
            return EASE_MAP.get(c);
        if (a.IsNamePredefined(b))
            return EASE_MAP.get(b);
        if (PRIVATE_EASE_MAP.has(b))
            return PRIVATE_EASE_MAP.get(b)
    }
    static GetBuiltInTransition(b) {
        this._CreateEaseMap();
        return BUILT_IN_TRANSITION_MAP.get(b)
    }
    static GetEditorEase(b, c) {
        this._CreateEaseMap();
        const d = a._GetEase(b);
        if (d)
            return d;
        if (!c)
            throw Error("missing ease function");
        return CUSTOM_EASE_EDITOR_MAP.get(c).get(b)
    }
    static GetEditorEaseData(b, c) {
        this._CreateEaseMap();
        if (c = CUSTOM_EASE_DATA_EDITOR_MAP.get(c))
            return c.get(b)
    }
    static HasEditorEase(b, c) {
        this._CreateEaseMap();
        return a._GetEase(b) ? !0 : !!CUSTOM_EASE_EDITOR_MAP.get(c).get(b)
    }
    static GetRuntimeEase(b) {
        this._CreateEaseMap();
        const c = a._GetEase(b);
        return c ? c : CUSTOM_EASE_RUNTIME_MAP.get(b)
    }
    static GetRuntimeEaseData(b) {
        this._CreateEaseMap();
        return CUSTOM_EASE_DATA_RUNTIME_MAP.get(b)
    }
    static GetEaseFromIndex(b) {
        this._CreateEaseMap();
        return this.GetRuntimeEaseNames()[b]
    }
    static GetIndexForEase(b, c) {
        this._CreateEaseMap();
        return this.GetEditorEaseNames(c).indexOf(b)
    }
    static GetIndexForEaseAtRuntime(b) {
        return this.GetIndexForEase(b)
    }
    static _CreateEaseMap() {
        0 === EASE_MAP.size && (this._AddPredifinedEase("default", () => {}
        ),
        this._AddPredifinedEase("noease", [{
            x: 0,
            y: 0,
            sax: .336,
            say: 0,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.336,
            eay: 0,
            se: !1,
            ee: !0
        }], !0),
        this._AddPredifinedEase("easeinsine", [{
            x: 0,
            y: 0,
            sax: .485,
            say: 0,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.038,
            eay: 0,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeoutsine", [{
            x: 0,
            y: 0,
            sax: .038,
            say: 0,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.485,
            eay: 0,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeinoutsine", [{
            x: 0,
            y: 0,
            sax: .336,
            say: 0,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.336,
            eay: 0,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeinelastic", [{
            x: 0,
            y: 0,
            sax: .018,
            say: 0,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: .116,
            y: .002,
            sax: .025,
            say: 0,
            eax: -.025,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: .266,
            y: -.005,
            sax: .024,
            say: 0,
            eax: -.021,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: .416,
            y: .016,
            sax: .024,
            say: 0,
            eax: -.026,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: .566,
            y: -.045,
            sax: .061,
            say: 0,
            eax: -.025,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: .716,
            y: .132,
            sax: .072,
            say: -.004,
            eax: -.045,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: .866,
            y: -.373,
            sax: .06,
            say: 0,
            eax: -.049,
            eay: -.002,
            se: !0,
            ee: !0
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.038,
            eay: -.263,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeoutelastic", [{
            x: 0,
            y: 0,
            sax: .038,
            say: .263,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: .136,
            y: 1.373,
            sax: .049,
            say: .002,
            eax: -.06,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: .286,
            y: .868,
            sax: .045,
            say: 0,
            eax: -.072,
            eay: .004,
            se: !0,
            ee: !0
        }, {
            x: .436,
            y: 1.045,
            sax: .025,
            say: 0,
            eax: -.061,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: .586,
            y: .984,
            sax: .026,
            say: 0,
            eax: -.024,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: .736,
            y: 1.005,
            sax: .021,
            say: 0,
            eax: -.024,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: .886,
            y: .998,
            sax: .025,
            say: 0,
            eax: -.025,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.018,
            eay: 0,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeinoutelastic", [{
            x: 0,
            y: 0,
            sax: .025,
            say: 0,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: .067,
            y: .001,
            sax: .025,
            say: 0,
            eax: -.025,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: .18,
            y: -.005,
            sax: .025,
            say: 0,
            eax: -.025,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: .292,
            y: .025,
            sax: .053,
            say: 0,
            eax: -.025,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: .405,
            y: -.118,
            sax: .069,
            say: 0,
            eax: -.027,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: .597,
            y: 1.118,
            sax: .027,
            say: 0,
            eax: -.069,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: .71,
            y: .975,
            sax: .025,
            say: 0,
            eax: -.053,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: .822,
            y: 1.005,
            sax: .025,
            say: 0,
            eax: -.025,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: .935,
            y: .999,
            sax: .025,
            say: 0,
            eax: -.025,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.025,
            eay: 0,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeinback", [{
            x: 0,
            y: 0,
            sax: .35,
            say: 0,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.34,
            eay: -1.579,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeoutback", [{
            x: 0,
            y: 0,
            sax: .34,
            say: 1.579,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.35,
            eay: 0,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeinoutback", [{
            x: 0,
            y: 0,
            sax: .035,
            say: 0,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: .242,
            y: -.1,
            sax: .258,
            say: 0,
            eax: -.025,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: .76,
            y: 1.1,
            sax: .025,
            say: 0,
            eax: -.26,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.035,
            eay: 0,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeinbounce", [{
            x: 0,
            y: 0,
            sax: .033,
            say: .025,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: .092,
            y: 0,
            sax: .026,
            say: .078,
            eax: -.033,
            eay: .025,
            se: !0,
            ee: !0
        }, {
            x: .274,
            y: 0,
            sax: .097,
            say: .319,
            eax: -.026,
            eay: .078,
            se: !0,
            ee: !0
        }, {
            x: .637,
            y: 0,
            sax: .105,
            say: .625,
            eax: -.097,
            eay: .319,
            se: !0,
            ee: !0
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.125,
            eay: -.004,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeoutbounce", [{
            x: 0,
            y: 0,
            sax: .125,
            say: .004,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: .365,
            y: 1,
            sax: .097,
            say: -.319,
            eax: -.105,
            eay: -.625,
            se: !0,
            ee: !0
        }, {
            x: .728,
            y: 1,
            sax: .026,
            say: -.078,
            eax: -.097,
            eay: -.319,
            se: !0,
            ee: !0
        }, {
            x: .91,
            y: 1,
            sax: .033,
            say: -.025,
            eax: -.026,
            eay: -.078,
            se: !0,
            ee: !0
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.033,
            eay: -.025,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeinoutbounce", [{
            x: 0,
            y: 0,
            sax: .01,
            say: .006,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: .046,
            y: 0,
            sax: .021,
            say: .038,
            eax: -.01,
            eay: .006,
            se: !0,
            ee: !0
        }, {
            x: .137,
            y: 0,
            sax: .059,
            say: .158,
            eax: -.021,
            eay: .038,
            se: !0,
            ee: !0
        }, {
            x: .319,
            y: 0,
            sax: .117,
            say: .744,
            eax: -.059,
            eay: .158,
            se: !0,
            ee: !0
        }, {
            x: .683,
            y: 1,
            sax: .059,
            say: -.158,
            eax: -.117,
            eay: -.744,
            se: !0,
            ee: !0
        }, {
            x: .865,
            y: 1,
            sax: .021,
            say: -.038,
            eax: -.059,
            eay: -.158,
            se: !0,
            ee: !0
        }, {
            x: .956,
            y: 1,
            sax: .01,
            say: -.006,
            eax: -.021,
            eay: -.038,
            se: !0,
            ee: !0
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.01,
            eay: -.006,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeincubic", [{
            x: 0,
            y: 0,
            sax: .75,
            say: 0,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.138,
            eay: -.321,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeoutcubic", [{
            x: 0,
            y: 0,
            sax: .138,
            say: .321,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.75,
            eay: 0,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeinoutcubic", [{
            x: 0,
            y: 0,
            sax: .285,
            say: 0,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: .5,
            y: .5,
            sax: .081,
            say: .272,
            eax: -.081,
            eay: -.272,
            se: !0,
            ee: !0
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.285,
            eay: 0,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeinquad", [{
            x: 0,
            y: 0,
            sax: .4,
            say: 0,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.178,
            eay: -.392,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeoutquad", [{
            x: 0,
            y: 0,
            sax: .178,
            say: .392,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.4,
            eay: 0,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeinoutquad", [{
            x: 0,
            y: 0,
            sax: .25,
            say: 0,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: .5,
            y: .5,
            sax: .03,
            say: .065,
            eax: -.03,
            eay: -.065,
            se: !0,
            ee: !0
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.25,
            eay: 0,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeinquart", [{
            x: 0,
            y: 0,
            sax: .25,
            say: 1,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.5,
            eay: 0,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeoutquart", [{
            x: 0,
            y: 0,
            sax: .5,
            say: 0,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.25,
            eay: -1,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeinoutquart", [{
            x: 0,
            y: 0,
            sax: .765,
            say: .03,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.765,
            eay: -.03,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeinquint", [{
            x: 0,
            y: 0,
            sax: .6,
            say: 0,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.2,
            eay: -1,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeoutquint", [{
            x: 0,
            y: 0,
            sax: .2,
            say: 1,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.6,
            eay: 0,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeinoutquint", [{
            eax: 0,
            eay: 0,
            ee: !1,
            sax: .84,
            say: 0,
            se: !0,
            x: 0,
            y: 0
        }, {
            eax: -.84,
            eay: 0,
            ee: !0,
            sax: 0,
            say: 0,
            se: !1,
            x: 1,
            y: 1
        }]),
        this._AddPredifinedEase("easeincirc", [{
            x: 0,
            y: 0,
            sax: .25,
            say: 0,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.024,
            eay: -.808,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeoutcirc", [{
            x: 0,
            y: 0,
            sax: .024,
            say: .808,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.25,
            eay: 0,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeinoutcirc", [{
            x: 0,
            y: 0,
            sax: .125,
            say: 0,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: .5,
            y: .5,
            sax: .02,
            say: .428,
            eax: -.02,
            eay: -.428,
            se: !0,
            ee: !0
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.125,
            eay: 0,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeinexpo", [{
            x: 0,
            y: 0,
            sax: .66,
            say: 0,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.14,
            eay: -1,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeoutexpo", [{
            x: 0,
            y: 0,
            sax: .14,
            say: 1,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.66,
            eay: 0,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeinoutexpo", [{
            eax: 0,
            eay: 0,
            ee: !1,
            sax: .345,
            say: 0,
            se: !0,
            x: 0,
            y: 0
        }, {
            eax: -.06,
            eay: -.5,
            ee: !0,
            sax: .06,
            say: .5,
            se: !0,
            x: .5,
            y: .5
        }, {
            eax: -.335,
            eay: 0,
            ee: !0,
            sax: 0,
            say: 0,
            se: !1,
            x: 1,
            y: 1
        }]),
        this._AddPrivateCustomEase("cubicbezier", this.EaseCubicBezier),
        this._AddPrivateCustomEase("spline", this.EaseSpline))
    }
    static _AddPredifinedEase(b, c, d=!1) {
        if ("function" === typeof c)
            a._AddEase(b, c, "predefined");
        else if (C3$jscomp$19.IsArray(c))
            if (self.BuiltInTransition) {
                const e = C3$jscomp$19.New(self.BuiltInTransition, b, d);
                e.SetFromJson(c);
                a._AddEase(b, (f, h, l, m) => e.Interpolate(f, h, l, m), "predefined");
                BUILT_IN_TRANSITION_MAP.set(b, e)
            } else {
                const e = C3$jscomp$19.New(C3$jscomp$19.Transition, [b, c.map(f => [f.x, f.y, f.sax, f.say, f.eax, f.eay, f.se, f.ee])], !1);
                e.MakeLinear(d);
                a._AddEase(b, (f, h, l, m) => e.Interpolate(f, h, l, m), "predefined")
            }
        else
            throw Error("unexpected arguments");
    }
    static _AddPrivateCustomEase(b, c) {
        a._AddEase(b, c, "private")
    }
    static AddCustomEase(b, c, d, e) {
        this._CreateEaseMap();
        a._AddEase(b, c, "custom", d, e)
    }
    static RemoveCustomEase(b, c) {
        if (!this.IsNamePredefined(b) && ![...PRIVATE_EASE_MAP.keys()].includes(b)) {
            var d = CUSTOM_EASE_EDITOR_MAP.get(c);
            d && d.delete(b);
            (c = CUSTOM_EASE_DATA_EDITOR_MAP.get(c)) && c.delete(b)
        }
    }
    static _AddEase(b, c, d, e, f) {
        switch (d) {
        case "predefined":
            EASE_MAP.set(b, c);
            PREDEFINED_EASE_MAP.set(b, c);
            break;
        case "custom":
            e ? (CUSTOM_EASE_EDITOR_MAP.has(e) || CUSTOM_EASE_EDITOR_MAP.set(e, new Map),
            CUSTOM_EASE_DATA_EDITOR_MAP.has(e) || CUSTOM_EASE_DATA_EDITOR_MAP.set(e, new Map),
            CUSTOM_EASE_EDITOR_MAP.get(e).set(b, c),
            CUSTOM_EASE_DATA_EDITOR_MAP.get(e).set(b, f)) : (CUSTOM_EASE_RUNTIME_MAP.set(b, c),
            CUSTOM_EASE_DATA_RUNTIME_MAP.set(b, f));
            break;
        case "private":
            EASE_MAP.set(b, c);
            PRIVATE_EASE_MAP.set(b, c);
            break;
        default:
            throw Error("unexpected ease mode");
        }
    }
    static NoEase(b, c, d, e) {
        return 0 === e ? c : d * b / e + c
    }
    static EaseCubicBezier(b, c, d, e, f) {
        return c + 3 * b * (d - c) + 3 * b ** 2 * (c + e - 2 * d) + b ** 3 * (f - c + 3 * d - 3 * e)
    }
    static EaseSpline(b, c, d, e, f, h, l, m, p, r) {
        if (e === f && h === l)
            return b;
        b = get_t_for_x(b, c, e, h, m, r);
        c = a$jscomp$282(d, f, l, p);
        e = b$jscomp$151(d, f, l, p);
        d = c$jscomp$42(d, f, l, p);
        return calc_bezier(b, c, e, d)
    }
    static GetBezierSamples(b, c, d, e) {
        const f = []
          , h = a$jscomp$282(b, c, d, e)
          , l = b$jscomp$151(b, c, d, e);
        b = c$jscomp$42(b, c, d, e);
        for (c = 0; 11 > c; ++c)
            d = calc_bezier(c * SAMPLE_STEP, h, l, b),
            f.push(d);
        return f
    }
}
;
const SAMPLE_STEP = .1
  , a$jscomp$282 = (a, b, c, d) => d - 3 * c + 3 * b - a
  , b$jscomp$151 = (a, b, c, d) => 3 * c - 6 * b + 3 * a
  , c$jscomp$42 = (a, b, c, d) => 3 * (b - a)
  , calc_bezier = (a, b, c, d) => ((b * a + c) * a + d) * a
  , get_slope = (a, b, c, d) => 3 * b * a * a + 2 * c * a + d
  , get_t_for_x = (a, b, c, d, e, f) => {
    if (1 == a)
        return 1;
    for (var h = 0, l = 1, m = f[l]; 10 != l && m <= a; )
        l++,
        m = f[l],
        h += SAMPLE_STEP;
    l--;
    m = f[l];
    f = h + (a - m) / (f[l + 1] - m) * SAMPLE_STEP;
    l = a$jscomp$282(b, c, d, e);
    m = b$jscomp$151(b, c, d, e);
    b = c$jscomp$42(b, c, d, e);
    c = get_slope(f, l, m, b);
    if (0 !== c)
        if (.01 <= c)
            for (h = 0; 4 > h; ++h)
                c = calc_bezier(f, l, m, b) - a,
                d = get_slope(f, l, m, b),
                f -= c / d;
        else {
            c = h;
            h += SAMPLE_STEP;
            d = 0;
            let p;
            do
                f = c + (h - c) / 2,
                e = calc_bezier(f, l, m, b) - a,
                0 < e ? h = f : c = f,
                e = 1E-7 < Math.abs(e),
                p = 10 > ++d;
            while (e && p)
        }
    return f
}
;
"use strict";
const C3$jscomp$20 = self.C3;
function RequireStringOrNumber(a) {
    C3$jscomp$20.IsString(a)
}
C3$jscomp$20.ProbabilityTable = class {
    constructor(a) {
        this._items = [];
        this._name = a || "";
        this._totalWeight = 0
    }
    Release() {
        this.Clear();
        this._items = null
    }
    GetName() {
        return this._name
    }
    Clear() {
        C3$jscomp$20.clear2DArray(this._items);
        this._totalWeight = 0
    }
    GetTotalWeight() {
        return this._totalWeight
    }
    Sample(a=Math.random() * this.GetTotalWeight()) {
        let b = 0;
        for (const [c,d] of this._items)
            if (b += c,
            a < b)
                return d;
        return 0
    }
    AddItem(a, b) {
        RequireStringOrNumber(b);
        this._totalWeight += a;
        this._items.push([a, b])
    }
    RemoveItem(a, b) {
        RequireStringOrNumber(b);
        const c = 0 === a;
        for (let d = 0; d < this._items.length; d++) {
            const e = this._items[d]
              , f = e[1] === b;
            if ((c || e[0] === a) && f) {
                this._items.splice(d, 1);
                this._totalWeight -= e[0];
                break
            }
        }
    }
    asJSON() {
        return JSON.stringify(this._items)
    }
    static fromJSON(a) {
        const b = new C3$jscomp$20.ProbabilityTable;
        a = JSON.parse(a);
        for (const c of a)
            b.AddItem(c[0], c[1]);
        return b
    }
}
;
"use strict";
let nextId = 0;
self.C3.ScreenReaderText = class {
    constructor(a, b) {
        this._runtime = a;
        this._text = b;
        this._id = nextId++;
        this._runtime.PostComponentMessageToDOM("runtime", "screen-reader-text", {
            type: "create",
            id: this._id,
            text: this._text
        })
    }
    Release() {
        this._runtime.PostComponentMessageToDOM("runtime", "screen-reader-text", {
            type: "release",
            id: this._id
        });
        this._runtime = null;
        this._text = "";
        this._id = -1
    }
    SetText(a) {
        this._text !== a && (this._text = a,
        this._runtime.PostComponentMessageToDOM("runtime", "screen-reader-text", {
            type: "update",
            id: this._id,
            text: this._text
        }))
    }
}
;
"use strict";
self.C3.Event = class {
    constructor(a, b) {
        this.type = a;
        this.cancelable = !!b;
        this.isAsync = this.propagationStopped = this.defaultPrevented = !1
    }
    preventDefault() {
        if (!this.cancelable)
            throw Error(`event '${this.type}' is not cancelable`);
        this.defaultPrevented = !0
    }
    stopPropagation() {
        if (!this.cancelable)
            throw Error(`event '${this.type}' cannot be stopped`);
        if (this.isAsync)
            throw Error(`cannot stop async event '${this.type}' propagation`);
        this.propagationStopped = !0
    }
}
;
"use strict";
const C3$jscomp$23 = self.C3;
C3$jscomp$23.Event.Handler = class extends C3$jscomp$23.DefendedBase {
    constructor(a) {
        super();
        this._type = a;
        this._captureListeners = [];
        this._captureListenersSet = new Set;
        this._listeners = [];
        this._listenersSet = new Set;
        this._fireDepth = 0;
        this._queueModifyListeners = []
    }
    Release() {
        0 < this._fireDepth || (C3$jscomp$23.clearArray(this._captureListeners),
        this._captureListenersSet.clear(),
        C3$jscomp$23.clearArray(this._listeners),
        this._listenersSet.clear(),
        C3$jscomp$23.clearArray(this._queueModifyListeners),
        C3$jscomp$23.Release(this))
    }
    _AddListener(a, b) {
        this._IsFiring() ? this._queueModifyListeners.push({
            op: "add",
            func: a,
            capture: b
        }) : b ? this._captureListenersSet.has(a) || (this._captureListeners.push(a),
        this._captureListenersSet.add(a)) : this._listenersSet.has(a) || (this._listeners.push(a),
        this._listenersSet.add(a))
    }
    _RemoveListener(a, b) {
        this._IsFiring() ? this._queueModifyListeners.push({
            op: "remove",
            func: a,
            capture: b
        }) : b ? this._captureListenersSet.has(a) && (this._captureListenersSet.delete(a),
        C3$jscomp$23.arrayFindRemove(this._captureListeners, a)) : this._listenersSet.has(a) && (this._listenersSet.delete(a),
        C3$jscomp$23.arrayFindRemove(this._listeners, a))
    }
    _IsEmpty() {
        return !this._captureListeners.length && !this._listeners.length
    }
    _IsFiring() {
        return 0 < this._fireDepth
    }
    _ProcessQueuedListeners() {
        const a = new Set
          , b = new Set;
        for (const c of this._queueModifyListeners)
            if ("add" === c.op)
                this._AddListener(c.func, c.capture),
                c.capture ? b.delete(c.func) : a.delete(c.func);
            else if ("remove" === c.op)
                c.capture ? (this._captureListenersSet.delete(c.func),
                b.add(c.func)) : (this._listenersSet.delete(c.func),
                a.add(c.func));
            else
                throw Error("invalid op");
        C3$jscomp$23.arrayRemoveAllInSet(this._listeners, a);
        C3$jscomp$23.arrayRemoveAllInSet(this._captureListeners, b);
        C3$jscomp$23.clearArray(this._queueModifyListeners)
    }
    _FireCancellable(a) {
        this._IncreaseFireDepth();
        let b = !1;
        for (let c = 0, d = this._captureListeners.length; c < d; ++c)
            if (this._captureListeners[c](a),
            a.propagationStopped) {
                b = !0;
                break
            }
        if (!b)
            for (let c = 0, d = this._listeners.length; c < d && (this._listeners[c](a),
            !a.propagationStopped); ++c)
                ;
        this._DecreaseFireDepth();
        return !a.defaultPrevented
    }
    _FireNonCancellable(a) {
        this._IncreaseFireDepth();
        for (let b = 0, c = this._captureListeners.length; b < c; ++b)
            this._captureListeners[b](a);
        for (let b = 0, c = this._listeners.length; b < c; ++b)
            this._listeners[b](a);
        this._DecreaseFireDepth();
        return !0
    }
    _IncreaseFireDepth() {
        this._fireDepth++
    }
    _DecreaseFireDepth() {
        this._fireDepth--;
        0 === this._fireDepth && 0 < this._queueModifyListeners.length && this._ProcessQueuedListeners()
    }
    SetDelayRemoveEventsEnabled(a) {
        a ? this._IncreaseFireDepth() : this._DecreaseFireDepth()
    }
    _FireAsync(a) {
        let b = [];
        for (let c = 0, d = this._captureListeners.length; c < d; ++c) {
            let e = this._captureListeners[c];
            b.push(C3$jscomp$23.Asyncify( () => e(a)))
        }
        for (let c = 0, d = this._listeners.length; c < d; ++c) {
            let e = this._listeners[c];
            b.push(C3$jscomp$23.Asyncify( () => e(a)))
        }
        return Promise.all(b).then( () => !a.defaultPrevented)
    }
    _FireAndWait_AsyncOptional(a) {
        const b = [];
        this._IncreaseFireDepth();
        for (let d = 0, e = this._captureListeners.length; d < e; ++d) {
            var c = this._captureListeners[d](a);
            c instanceof Promise && b.push(c)
        }
        for (let d = 0, e = this._listeners.length; d < e; ++d)
            c = this._listeners[d](a),
            c instanceof Promise && b.push(c);
        this._DecreaseFireDepth();
        return b.length ? Promise.all(b).then( () => !a.defaultPrevented) : !a.defaultPrevented
    }
    async _FireAndWaitAsync(a) {
        return await this._FireAndWait_AsyncOptional(a)
    }
    async _FireAndWaitAsyncSequential(a) {
        this._IncreaseFireDepth();
        for (let c = 0, d = this._captureListeners.length; c < d; ++c) {
            var b = this._captureListeners[c](a);
            b instanceof Promise && await b
        }
        for (let c = 0, d = this._listeners.length; c < d; ++c)
            b = this._listeners[c](a),
            b instanceof Promise && await b;
        this._DecreaseFireDepth();
        return !a.defaultPrevented
    }
    *_FireAsGenerator(a) {
        this._IncreaseFireDepth();
        for (let c = 0, d = this._captureListeners.length; c < d; ++c) {
            var b = this._captureListeners[c](a);
            C3$jscomp$23.IsIterator(b) && (yield*b)
        }
        for (let c = 0, d = this._listeners.length; c < d; ++c)
            b = this._listeners[c](a),
            C3$jscomp$23.IsIterator(b) && (yield*b);
        this._DecreaseFireDepth()
    }
}
;
"use strict";
const C3$jscomp$24 = self.C3;
C3$jscomp$24.Event.Dispatcher = class extends C3$jscomp$24.DefendedBase {
    constructor() {
        super();
        this._eventHandlers = new Map;
        this._dispatcherWasReleased = !1
    }
    Release() {
        if (this._dispatcherWasReleased)
            throw Error("already released");
        this.ClearEvents();
        this._dispatcherWasReleased = !0;
        C3$jscomp$24.Release(this)
    }
    WasReleased() {
        return this._dispatcherWasReleased
    }
    ClearEvents() {
        if (this._eventHandlers) {
            for (let a of this._eventHandlers.values())
                a.Release();
            this._eventHandlers.clear()
        }
    }
    _GetHandlerByType(a, b) {
        let c = this._eventHandlers.get(a);
        return c ? c : b ? (c = C3$jscomp$24.New(C3$jscomp$24.Event.Handler, a),
        this._eventHandlers.set(a, c),
        c) : null
    }
    HasAnyHandlerFor(a) {
        return this._eventHandlers.has(a)
    }
    addEventListener(a, b, c) {
        this._GetHandlerByType(a, !0)._AddListener(b, !!c)
    }
    removeEventListener(a, b, c) {
        let d = this._GetHandlerByType(a, !1);
        d && (d._RemoveListener(b, !!c),
        d._IsEmpty() && this._eventHandlers.delete(a))
    }
    dispatchEvent(a) {
        const b = this._GetHandlerByType(a.type, !1);
        return b ? a.cancelable ? b._FireCancellable(a) : b._FireNonCancellable(a) : !0
    }
    dispatchEventAsync(a) {
        const b = this._GetHandlerByType(a.type, !1);
        if (!b)
            return Promise.resolve(!0);
        a.isAsync = !0;
        return b._FireAsync(a)
    }
    async dispatchEventAndClearAsync(a) {
        const b = this._GetHandlerByType(a.type, !1);
        if (!b)
            return !0;
        this._eventHandlers.delete(a.type);
        a.isAsync = !0;
        a = await b._FireAsync(a);
        b.Release();
        return a
    }
    async dispatchEventAndWaitAsync(a) {
        const b = this._GetHandlerByType(a.type, !1);
        return b ? await b._FireAndWaitAsync(a) : !0
    }
    dispatchEventAndWait_AsyncOptional(a) {
        const b = this._GetHandlerByType(a.type, !1);
        return b ? b._FireAndWait_AsyncOptional(a) : !0
    }
    async dispatchEventAndWaitAsyncSequential(a) {
        const b = this._GetHandlerByType(a.type, !1);
        return b ? await b._FireAndWaitAsyncSequential(a) : !0
    }
    dispatchGeneratorEvent(a) {
        const b = this._GetHandlerByType(a.type, !1);
        if (!b)
            return null;
        if (a.cancelable)
            throw Error("not supported");
        return b._FireAsGenerator(a)
    }
    SetDelayRemoveEventsEnabled(a) {
        for (const b of this._eventHandlers.values())
            b.SetDelayRemoveEventsEnabled(a)
    }
}
;
"use strict";
const C3$jscomp$25 = self.C3
  , SUPPORTS_RIC = "undefined" !== typeof requestIdleCallback;
let workQueue = []
  , callbackId = -1
  , highThroughputMode = 0;
function SetNewCallback(a) {
    callbackId = SUPPORTS_RIC && 0 === highThroughputMode ? requestIdleCallback(DoAsyncifiedWork, {
        timeout: 35
    }) : setTimeout(DoAsyncifiedWork, 0 < highThroughputMode ? 1 : a)
}
function DoAsyncifiedWork(a) {
    callbackId = -1;
    if (workQueue.length) {
        var b = performance.now()
          , c = 0;
        do {
            DoNextAsyncifiedJob(workQueue.shift());
            var d = performance.now();
            ++c;
            var e = (d - b) / c * 1.1
        } while (workQueue.length && (SUPPORTS_RIC && 0 === highThroughputMode && "undefined" !== typeof a ? e < a.timeRemaining() : 12 > d - b + e));
        -1 === callbackId && workQueue.length && SetNewCallback(Math.max(16 - (d - b), 4))
    }
}
function DoNextAsyncifiedJob(a) {
    let b;
    try {
        b = a.func()
    } catch (c) {
        a.reject(c);
        return
    }
    a.resolve(b)
}
let asyncifyDisabled = C3$jscomp$25.QueryString.Has("disable-asyncify");
asyncifyDisabled && console.warn("[Asyncify] Asyncify has been disabled due to disable-asyncify in the query string. Some work will now be done synchronously.");
C3$jscomp$25.Asyncify = function(a) {
    let b = null;
    C3$jscomp$25.isDebug && (b = C3$jscomp$25.GetCallStack());
    return new Promise( (c, d) => {
        workQueue.push({
            func: a,
            resolve: c,
            reject: d,
            stack: b
        });
        asyncifyDisabled ? DoNextAsyncifiedJob(workQueue.pop()) : -1 === callbackId && SetNewCallback(16)
    }
    )
}
;
C3$jscomp$25.Asyncify.SetHighThroughputMode = function(a) {
    if (a)
        ++highThroughputMode;
    else if (--highThroughputMode,
    0 > highThroughputMode)
        throw Error("already turned off high throughput mode");
}
;
"use strict";
const C3$jscomp$26 = self.C3;
let cachedNowTime = -1;
function ClearTimeCache() {
    cachedNowTime = -1
}
C3$jscomp$26.FastGetDateNow = function() {
    -1 === cachedNowTime && (cachedNowTime = Date.now(),
    self.setTimeout(ClearTimeCache, 16));
    return cachedNowTime
}
;
let timerId = -1
  , nextDeadline = -1
  , activeIdleTimeouts = new Set;
function CheckActiveIdleTimeouts() {
    nextDeadline = timerId = -1;
    let a = Date.now();
    for (let b of activeIdleTimeouts)
        if (b._CheckTimeout(a)) {
            let c = b._GetDeadline();
            if (-1 === nextDeadline || c < nextDeadline)
                nextDeadline = c
        } else
            activeIdleTimeouts.delete(b);
    -1 !== nextDeadline && (timerId = self.setTimeout(CheckActiveIdleTimeouts, Math.max(nextDeadline - a + 100, 1E3)))
}
C3$jscomp$26.IdleTimeout = class {
    constructor(a, b) {
        this._callback = a;
        this._timeout = 1E3 * b;
        this._deadline = 0;
        this._isActive = !1
    }
    Reset() {
        let a = C3$jscomp$26.FastGetDateNow();
        this._deadline = a + this._timeout;
        this._isActive || (activeIdleTimeouts.add(this),
        this._isActive = !0);
        -1 === timerId ? (nextDeadline = this._deadline,
        timerId = self.setTimeout(CheckActiveIdleTimeouts, this._timeout + 100)) : this._deadline < nextDeadline && nextDeadline > a + 1E3 && (self.clearTimeout(timerId),
        nextDeadline = this._deadline,
        timerId = self.setTimeout(CheckActiveIdleTimeouts, this._timeout + 100))
    }
    _CheckTimeout(a) {
        return a >= this._deadline ? this._callback() ? (this._deadline = a + this._timeout,
        !0) : this._isActive = !1 : !0
    }
    _GetDeadline() {
        return this._deadline
    }
    Cancel() {
        this._isActive && (activeIdleTimeouts.delete(this),
        this._isActive = !1,
        0 === activeIdleTimeouts.size && -1 !== timerId && (self.clearTimeout(timerId),
        nextDeadline = timerId = -1))
    }
    Release() {
        this.Cancel();
        this._callback = null
    }
}
;
"use strict";
const C3$jscomp$27 = self.C3;
C3$jscomp$27.Disposable = class a {
    constructor(b) {
        this._disposed = !1;
        this._disposeAction = b
    }
    Dispose() {
        this._disposed || (this._disposed = !0,
        this._disposeAction && (this._disposeAction(),
        this._disposeAction = null))
    }
    IsDisposed() {
        return this._disposed
    }
    Release() {
        this.Dispose()
    }
    static Release(b) {
        return new a( () => b.Release())
    }
    static From(b, c, d, e, f) {
        if ("undefined" === typeof e || null === e)
            e = !1;
        else if ("boolean" !== typeof e && "object" !== typeof e)
            throw new TypeError("invalid event listener options");
        f && (d = d.bind(f));
        if (c.includes(" ")) {
            c = c.split(" ");
            f = new C3$jscomp$27.CompositeDisposable;
            for (let h of c)
                b.addEventListener(h, d, e),
                f.Add(C3$jscomp$27.New(C3$jscomp$27.Disposable, () => b.removeEventListener(h, d, e)));
            return f
        }
        b.addEventListener(c, d, e);
        return C3$jscomp$27.New(C3$jscomp$27.Disposable, () => b.removeEventListener(c, d, e))
    }
}
;
C3$jscomp$27.StubDisposable = class extends C3$jscomp$27.Disposable {
    SetAction(a) {
        this._disposeAction = a
    }
}
;
C3$jscomp$27.CompositeDisposable = class extends C3$jscomp$27.Disposable {
    constructor(...a) {
        super();
        this._disposables = new Set;
        for (let b of a)
            this.Add(b)
    }
    Add(...a) {
        if (this._disposed)
            throw Error("already disposed");
        for (let b of a)
            this._disposables.add(b)
    }
    Remove(a) {
        if (this._disposed)
            throw Error("already disposed");
        this._disposables.delete(a)
    }
    RemoveAll() {
        if (this._disposed)
            throw Error("already disposed");
        if (this._disposables) {
            for (let a of this._disposables)
                a.Dispose();
            this._disposables.clear()
        }
    }
    IsDisposed() {
        return this._disposed
    }
    Dispose() {
        if (this._disposed)
            throw Error("already disposed");
        this._disposed = !0;
        for (let a of this._disposables)
            a.Dispose();
        this._disposables.clear();
        this._disposables = null
    }
    Release() {
        this.Dispose()
    }
}
;
"use strict";
const C3$jscomp$28 = self.C3;
C3$jscomp$28.KahanSum = class extends C3$jscomp$28.DefendedBase {
    constructor() {
        super();
        this._sum = this._t = this._y = this._c = 0
    }
    Add(a) {
        this._y = +a - this._c;
        this._t = this._sum + this._y;
        this._c = this._t - this._sum - this._y;
        this._sum = this._t
    }
    Subtract(a) {
        this._sum -= +a
    }
    Get() {
        return this._sum
    }
    Reset() {
        this._sum = this._t = this._y = this._c = 0
    }
    Set(a) {
        this._t = this._y = this._c = 0;
        this._sum = +a
    }
    Copy(a) {
        this._c = a._c;
        this._y = a._y;
        this._t = a._t;
        this._sum = a._sum
    }
    Release() {}
}
;
"use strict";
const C3$jscomp$29 = self.C3
  , js_cols = {
    RBnode: function(a) {
        this.tree = a;
        this.left = this.right = this.tree.sentinel;
        this.parent = null;
        this.color = !1;
        this.key = null
    },
    RedBlackSet: function(a) {
        this.size = 0;
        this.sentinel = new js_cols.RBnode(this);
        this.sentinel.color = !1;
        this.root = this.sentinel;
        this.root.parent = this.sentinel;
        this.compare = a || this.default_compare
    }
};
js_cols.RedBlackSet.prototype.default_compare = function(a, b) {
    return a < b ? -1 : b < a ? 1 : 0
}
;
js_cols.RedBlackSet.prototype.clone = function() {
    var a = new js_cols.RedBlackSet(this.compare);
    a.insertAll(this);
    return a
}
;
js_cols.RedBlackSet.prototype.clear = function() {
    this.size = 0;
    this.sentinel = new js_cols.RBnode(this);
    this.sentinel.color = !1;
    this.root = this.sentinel;
    this.root.parent = this.sentinel
}
;
js_cols.RedBlackSet.prototype.leftRotate = function(a) {
    var b = a.right;
    a.right = b.left;
    b.left != this.sentinel && (b.left.parent = a);
    b.parent = a.parent;
    a.parent == this.sentinel ? this.root = b : a == a.parent.left ? a.parent.left = b : a.parent.right = b;
    b.left = a;
    a.parent = b
}
;
js_cols.RedBlackSet.prototype.rightRotate = function(a) {
    var b = a.left;
    a.left = b.right;
    b.right != this.sentinel && (b.right.parent = a);
    b.parent = a.parent;
    a.parent == this.sentinel ? this.root = b : a == a.parent.right ? a.parent.right = b : a.parent.left = b;
    b.right = a;
    a.parent = b
}
;
js_cols.RedBlackSet.prototype.insert = function(a) {
    if (this.contains(a))
        this.get_(a).key = a;
    else {
        var b = new js_cols.RBnode(this);
        b.key = a;
        a = this.sentinel;
        for (var c = this.root; c != this.sentinel; )
            a = c,
            c = 0 > this.compare(b.key, c.key) ? c.left : c.right;
        b.parent = a;
        a == this.sentinel ? this.root = b : 0 > this.compare(b.key, a.key) ? a.left = b : a.right = b;
        b.left = this.sentinel;
        b.right = this.sentinel;
        b.color = !0;
        this.insertFixup(b);
        this.size++
    }
}
;
js_cols.RedBlackSet.prototype.insertFixup = function(a) {
    for (; a != this.sentinel && a != this.root && 1 == a.parent.color; )
        if (a.parent == a.parent.parent.left) {
            var b = a.parent.parent.right;
            1 == b.color ? (a.parent.color = !1,
            b.color = !1,
            a.parent.parent.color = !0,
            a = a.parent.parent) : (a == a.parent.right && (a = a.parent,
            this.leftRotate(a)),
            a.parent.color = !1,
            a.parent.parent.color = !0,
            a.parent.parent != this.sentinel && this.rightRotate(a.parent.parent))
        } else
            b = a.parent.parent.left,
            1 == b.color ? (a.parent.color = !1,
            b.color = !1,
            a.parent.parent.color = !0,
            a = a.parent.parent) : (a == a.parent.left && (a = a.parent,
            this.rightRotate(a)),
            a.parent.color = !1,
            a.parent.parent.color = !0,
            a.parent.parent != this.sentinel && this.leftRotate(a.parent.parent));
    this.root.color = !1
}
;
js_cols.RedBlackSet.prototype.delete_ = function(a) {
    var b = a.left == this.sentinel || a.right == this.sentinel ? a : this.successor_(a);
    var c = b.left != this.sentinel ? b.left : b.right;
    c.parent = b.parent;
    b.parent == this.sentinel ? this.root = c : b == b.parent.left ? b.parent.left = c : b.parent.right = c;
    b != a && (a.key = b.key);
    0 == b.color && this.deleteFixup(c);
    this.size--
}
;
js_cols.RedBlackSet.prototype.deleteFixup = function(a) {
    for (; a != this.root && 0 == a.color; )
        if (a == a.parent.left) {
            var b = a.parent.right;
            1 == b.color && (b.color = !1,
            a.parent.color = !0,
            this.leftRotate(a.parent),
            b = a.parent.right);
            0 == b.left.color && 0 == b.right.color ? (b.color = !0,
            a = a.parent) : (0 == b.right.color && (b.left.color = !1,
            b.color = !0,
            this.rightRotate(b),
            b = a.parent.right),
            b.color = a.parent.color,
            a.parent.color = !1,
            b.right.color = !1,
            this.leftRotate(a.parent),
            a = this.root)
        } else
            b = a.parent.left,
            1 == b.color && (b.color = !1,
            a.parent.color = !0,
            this.rightRotate(a.parent),
            b = a.parent.left),
            0 == b.right.color && 0 == b.left.color ? (b.color = !0,
            a = a.parent) : (0 == b.left.color && (b.right.color = !1,
            b.color = !0,
            this.leftRotate(b),
            b = a.parent.left),
            b.color = a.parent.color,
            a.parent.color = !1,
            b.left.color = !1,
            this.rightRotate(a.parent),
            a = this.root);
    a.color = !1
}
;
js_cols.RedBlackSet.prototype.remove = function(a) {
    a = this.get_(a);
    if (a != this.sentinel) {
        var b = a.key;
        this.delete_(a);
        return b
    }
    return null
}
;
js_cols.RedBlackSet.prototype.removeSwapped = function(a, b) {
    this.remove(b)
}
;
js_cols.RedBlackSet.prototype.min = function(a) {
    for (; a.left != this.sentinel; )
        a = a.left;
    return a
}
;
js_cols.RedBlackSet.prototype.max = function(a) {
    for (; a.right != this.sentinel; )
        a = a.right;
    return a
}
;
js_cols.RedBlackSet.prototype.successor_ = function(a) {
    if (a.right != this.sentinel)
        return this.min(a.right);
    for (var b = a.parent; b != this.sentinel && a == b.right; )
        a = b,
        b = b.parent;
    return b
}
;
js_cols.RedBlackSet.prototype.predeccessor_ = function(a) {
    if (a.left != this.sentinel)
        return this.max(a.left);
    for (var b = a.parent; b != this.sentinel && a == b.left; )
        a = b,
        b = b.parent;
    return b
}
;
js_cols.RedBlackSet.prototype.successor = function(a) {
    if (0 < this.size) {
        a = this.get_(a);
        if (a == this.sentinel)
            return null;
        if (a.right != this.sentinel)
            return this.min(a.right).key;
        for (var b = a.parent; b != this.sentinel && a == b.right; )
            a = b,
            b = b.parent;
        return b != this.sentinel ? b.key : null
    }
    return null
}
;
js_cols.RedBlackSet.prototype.predecessor = function(a) {
    if (0 < this.size) {
        a = this.get_(a);
        if (a == this.sentinel)
            return null;
        if (a.left != this.sentinel)
            return this.max(a.left).key;
        for (var b = a.parent; b != this.sentinel && a == b.left; )
            a = b,
            b = b.parent;
        return b != this.sentinel ? b.key : null
    }
    return null
}
;
js_cols.RedBlackSet.prototype.getMin = function() {
    return this.min(this.root).key
}
;
js_cols.RedBlackSet.prototype.getMax = function() {
    return this.max(this.root).key
}
;
js_cols.RedBlackSet.prototype.get_ = function(a) {
    for (var b = this.root; b != this.sentinel && 0 != this.compare(b.key, a); )
        b = 0 > this.compare(a, b.key) ? b.left : b.right;
    return b
}
;
js_cols.RedBlackSet.prototype.contains = function(a) {
    return null != this.get_(a).key
}
;
js_cols.RedBlackSet.prototype.getValues = function() {
    var a = [];
    this.forEach(function(b) {
        a.push(b)
    });
    return a
}
;
js_cols.RedBlackSet.prototype.insertAll = function(a) {
    if ("array" == js_cols.typeOf(a))
        for (var b = 0; b < a.length; b++)
            this.insert(a[b]);
    else if ("function" == js_cols.typeOf(a.forEach))
        a.forEach(this.insert, this);
    else if ("function" == js_cols.typeOf(a.getValues))
        for (a = a.getValues(),
        b = 0; b < a.length; b++)
            this.insert(a[b]);
    else if ("object" == js_cols.typeOf(a))
        for (b in a)
            this.insert(a[b])
}
;
js_cols.RedBlackSet.prototype.removeAll = function(a) {
    if ("array" == js_cols.typeOf(a))
        for (var b = 0; b < a.length; b++)
            this.remove(a[b]);
    else if ("function" == js_cols.typeOf(a.forEach))
        a.forEach(this.removeSwapped, this);
    else if ("function" == js_cols.typeOf(a.getValues))
        for (a = a.getValues(),
        b = 0; b < a.length; b++)
            this.remove(a[b]);
    else if ("object" == js_cols.typeOf(a))
        for (b in a)
            this.remove(a[b])
}
;
js_cols.RedBlackSet.prototype.containsAll = function(a) {
    if ("array" == js_cols.typeOf(a)) {
        for (var b = 0; b < a.length; b++)
            if (!this.contains(a[b]))
                return !1;
        return !0
    }
    if ("function" == js_cols.typeOf(a.forEach))
        return a.every(this.contains, this);
    if ("function" == js_cols.typeOf(a.getValues)) {
        a = a.getValues();
        for (b = 0; b < a.length; b++)
            if (!this.contains(a[b]))
                return !1;
        return !0
    }
    if ("object" == js_cols.typeOf(a)) {
        for (b in a)
            if (!this.contains(a[b]))
                return !1;
        return !0
    }
}
;
js_cols.RedBlackSet.prototype.range = function(a, b) {
    var c = [];
    this.traverseFromTo(function(d) {
        c.push(d)
    }, a, b);
    return c
}
;
js_cols.RedBlackSet.prototype.traverse = function(a, b) {
    if (!this.isEmpty())
        for (var c = this.min(this.root); c != this.sentinel && !a.call(b, c.key, this); )
            c = this.successor_(c)
}
;
js_cols.RedBlackSet.prototype.traverseFrom = function(a, b, c) {
    if (!this.isEmpty())
        for (b = this.get_(b); b != this.sentinel && !a.call(c, b.key, this); )
            b = this.successor_(b)
}
;
js_cols.RedBlackSet.prototype.traverseTo = function(a, b, c) {
    if (!this.isEmpty()) {
        var d = this.min(this.root);
        for (b = this.get_(b); d != b && !a.call(c, d.key, this); )
            d = this.successor_(d)
    }
}
;
js_cols.RedBlackSet.prototype.traverseFromTo = function(a, b, c, d) {
    if (!this.isEmpty())
        for (b = this.get_(b),
        c = this.get_(c); b != c && !a.call(d, b.key, this); )
            b = this.successor_(b)
}
;
js_cols.RedBlackSet.prototype.traverseBackwards = function(a, b) {
    if (!this.isEmpty())
        for (var c = this.max(this.root); c != this.sentinel && !a.call(b, c.key, this); )
            c = this.predeccessor_(c)
}
;
js_cols.RedBlackSet.prototype.forEach = function(a, b) {
    if (!this.isEmpty())
        for (var c = this.min(this.root); c != this.sentinel; c = this.successor_(c))
            a.call(b, c.key, c.key, this)
}
;
js_cols.RedBlackSet.prototype.some = function(a, b) {
    if (this.isEmpty())
        return !1;
    for (var c = this.min(this.root); c != this.sentinel; c = this.successor_(c))
        if (a.call(b, c.key, c.key, this))
            return !0;
    return !1
}
;
js_cols.RedBlackSet.prototype.every = function(a, b) {
    if (this.isEmpty())
        return !1;
    for (var c = this.min(this.root); c != this.sentinel; c = this.successor_(c))
        if (!a.call(b, c.key, c.key, this))
            return !1;
    return !0
}
;
js_cols.RedBlackSet.prototype.map = function(a, b) {
    var c = [];
    if (this.isEmpty())
        return c;
    for (var d = this.min(this.root); d != this.sentinel; d = this.successor_(d))
        c.push(a.call(b, d.key, d.key, this));
    return c
}
;
js_cols.RedBlackSet.prototype.filter = function(a, b) {
    var c = [];
    if (this.isEmpty())
        return c;
    for (var d = this.min(this.root); d != this.sentinel; d = this.successor_(d))
        a.call(b, d.key, d.key, this) && c.push(d.key);
    return c
}
;
js_cols.RedBlackSet.prototype.getCount = function() {
    return this.size
}
;
js_cols.RedBlackSet.prototype.isEmpty = function() {
    return 0 == this.size
}
;
js_cols.RedBlackSet.prototype.isSubsetOf = function(a) {
    var b = js_cols.getCount(a);
    if (this.getCount() > b)
        return !1;
    b = 0;
    if (this.isEmpty())
        return !0;
    for (var c = this.min(this.root); c != this.sentinel; c = this.successor_(c))
        js_cols.contains.call(a, a, c.key) && b++;
    return b == this.getCount()
}
;
js_cols.RedBlackSet.prototype.intersection = function(a) {
    var b = new js_cols.RedBlackSet(this.compare);
    if (this.isEmpty())
        return b;
    for (var c = this.min(this.root); c != this.sentinel; c = this.successor_(c))
        a.contains.call(a, c.key, c.key, this) && b.insert(c.key);
    return b
}
;
C3$jscomp$29.RedBlackSet = class extends C3$jscomp$29.DefendedBase {
    constructor(a) {
        super();
        this._rbSet = new js_cols.RedBlackSet(a);
        this._enableQueue = !1;
        this._queueInsert = new Set;
        this._queueRemove = new Set
    }
    Add(a) {
        this._enableQueue ? this._rbSet.contains(a) ? this._queueRemove.delete(a) : this._queueInsert.add(a) : this._rbSet.insert(a)
    }
    Remove(a) {
        this._enableQueue ? this._rbSet.contains(a) ? this._queueRemove.add(a) : this._queueInsert.delete(a) : this._rbSet.remove(a)
    }
    Has(a) {
        return this._enableQueue ? this._queueInsert.has(a) ? !0 : !this._queueRemove.has(a) && this._rbSet.contains(a) : this._rbSet.contains(a)
    }
    Clear() {
        this._rbSet.clear();
        this._queueInsert.clear();
        this._queueRemove.clear()
    }
    toArray() {
        if (this._enableQueue)
            throw Error("cannot be used in queueing mode");
        return this._rbSet.getValues()
    }
    GetSize() {
        return this._rbSet.getCount() + this._queueInsert.size - this._queueRemove.size
    }
    IsEmpty() {
        return 0 === this.GetSize()
    }
    Front() {
        if (this.IsEmpty())
            throw Error("empty set");
        if (this._enableQueue)
            throw Error("cannot be used in queueing mode");
        const a = this._rbSet;
        return a.min(a.root).key
    }
    Shift() {
        if (this.IsEmpty())
            throw Error("empty set");
        if (this._enableQueue)
            throw Error("cannot be used in queueing mode");
        const a = this.Front();
        this.Remove(a);
        return a
    }
    SetQueueingEnabled(a) {
        a = !!a;
        if (this._enableQueue !== a && (this._enableQueue = a,
        !a)) {
            for (const b of this._queueRemove)
                this._rbSet.remove(b);
            this._queueRemove.clear();
            for (const b of this._queueInsert)
                this._rbSet.insert(b);
            this._queueInsert.clear()
        }
    }
    ForEach(a) {
        this._rbSet.forEach(a)
    }
    *values() {
        if (!this.IsEmpty()) {
            var a = this._rbSet;
            for (let b = a.min(a.root); b != a.sentinel; b = a.successor_(b))
                yield b.key
        }
    }
    [Symbol.iterator]() {
        return this.values()
    }
}
;
"use strict";
const C3$jscomp$30 = self.C3;
C3$jscomp$30.PromiseThrottle = class {
    constructor(a=C3$jscomp$30.hardwareConcurrency) {
        this._maxParallel = a;
        this._queue = [];
        this._activeCount = 0
    }
    Add(a) {
        return new Promise( (b, c) => {
            this._queue.push({
                func: a,
                resolve: b,
                reject: c
            });
            this._MaybeStartNext()
        }
        )
    }
    _FindInQueue(a) {
        for (let b = 0, c = this._queue.length; b < c; ++b)
            if (this._queue[b].func === a)
                return b;
        return -1
    }
    RemoveAndResolve(a, b) {
        a = this._FindInQueue(a);
        if (-1 === a)
            throw Error("cannot find promise to resolve");
        this._queue[a].resolve(b);
        this._queue.splice(a, 1)
    }
    RemoveAndReject(a, b) {
        a = this._FindInQueue(a);
        if (-1 === a)
            throw Error("cannot find promise to reject");
        this._queue[a].reject(b);
        this._queue.splice(a, 1)
    }
    async _MaybeStartNext() {
        if (this._queue.length && !(this._activeCount >= this._maxParallel)) {
            this._activeCount++;
            var a = this._queue.shift();
            try {
                const b = await a.func();
                a.resolve(b)
            } catch (b) {
                a.reject(b)
            }
            this._activeCount--;
            this._MaybeStartNext()
        }
    }
    static async Batch(a, b) {
        const c = [];
        let d = !1;
        const e = async h => {
            for (; (h = b.pop()) && !d; )
                try {
                    c.push(await h())
                } catch (l) {
                    throw d = !0,
                    l;
                }
        }
          , f = [];
        for (; a--; )
            f.push(e());
        await Promise.all(f);
        return c
    }
}
;
"use strict";
const C3$jscomp$31 = self.C3;
C3$jscomp$31.RateLimiter = class {
    constructor(a, b, c) {
        this._callback = a;
        this._interval = b;
        this._intervalOnBattery = c || 2 * b;
        this._timerId = -1;
        this._lastCallTime = -Infinity;
        this._timerCallFunc = () => this._OnTimer();
        this._canRunImmediate = this._ignoreReset = !1;
        this._callbackArguments = null
    }
    SetCanRunImmediate(a) {
        this._canRunImmediate = !!a
    }
    _GetInterval() {
        return "undefined" !== typeof C3$jscomp$31.Battery && C3$jscomp$31.Battery.IsOnBatteryPower() ? this._intervalOnBattery : this._interval
    }
    Call(...a) {
        if (-1 === this._timerId) {
            this._callbackArguments = a;
            a = C3$jscomp$31.FastGetDateNow();
            var b = a - this._lastCallTime
              , c = this._GetInterval();
            b >= c && this._canRunImmediate ? (this._lastCallTime = a,
            this._RunCallback()) : this._timerId = self.setTimeout(this._timerCallFunc, Math.max(c - b, 4))
        }
    }
    _RunCallback() {
        this._ignoreReset = !0;
        const a = this._callbackArguments;
        this._callbackArguments = null;
        a ? this._callback(...a) : this._callback();
        this._ignoreReset = !1
    }
    Reset() {
        this._ignoreReset || (this._CancelTimer(),
        this._callbackArguments = null,
        this._lastCallTime = C3$jscomp$31.FastGetDateNow())
    }
    _OnTimer() {
        this._timerId = -1;
        this._lastCallTime = C3$jscomp$31.FastGetDateNow();
        this._RunCallback()
    }
    _CancelTimer() {
        -1 !== this._timerId && (self.clearTimeout(this._timerId),
        this._timerId = -1)
    }
    Release() {
        this._CancelTimer();
        this._timerCallFunc = this._callbackArguments = this._callback = null
    }
}
;
"use strict";
const C3$jscomp$32 = self.C3;
C3$jscomp$32.SVGRasterManager = class {
    constructor() {
        this._images = new Map;
        this._allowNpotSurfaces = !1;
        this._redrawCallback = this._releaseResultCallback = this._rasterAtSizeCallback = this._getBaseSizeCallback = null
    }
    SetNpotSurfaceAllowed(a) {
        this._allowNpotSurfaces = !!a
    }
    IsNpotSurfaceAllowed() {
        return this._allowNpotSurfaces
    }
    SetGetBaseSizeCallback(a) {
        this._getBaseSizeCallback = a
    }
    GetBaseSize(a) {
        if (!this._getBaseSizeCallback)
            throw Error("no get base size callback set");
        return this._getBaseSizeCallback(a)
    }
    SetRasterAtSizeCallback(a) {
        this._rasterAtSizeCallback = a
    }
    RasterAtSize(a, b, c, d, e, f) {
        if (!this._rasterAtSizeCallback)
            throw Error("no raster at size callback set");
        return this._rasterAtSizeCallback(a, b, c, d, e, f)
    }
    SetReleaseResultCallback(a) {
        this._releaseResultCallback = a
    }
    ReleaseResult(a) {
        if (!this._releaseResultCallback)
            throw Error("no release result callback set");
        this._releaseResultCallback(a)
    }
    SetRedrawCallback(a) {
        this._redrawCallback = a
    }
    Redraw() {
        if (!this._redrawCallback)
            throw Error("no redraw callback set");
        this._redrawCallback()
    }
    AddImage(a) {
        let b = this._images.get(a);
        b || (b = C3$jscomp$32.New(C3$jscomp$32.SVGRasterImage, this, a),
        this._images.set(a, b));
        b.IncReference();
        return b
    }
    _RemoveImage(a) {
        this._images.delete(a.GetDataSource())
    }
    OnTexturesChanged() {
        for (const a of this._images.values())
            a.ReleaseRasterizedResult(),
            a.ForceRasterAgain()
    }
}
;
"use strict";
const C3$jscomp$33 = self.C3;
C3$jscomp$33.SVGRasterImage = class {
    constructor(a, b) {
        this._manager = a;
        this._dataSource = b;
        this._baseHeight = this._baseWidth = this._refCount = 0;
        this._getBaseSizePromise = this._manager.GetBaseSize(b).then(c => {
            this._manager && (this._baseWidth = c[0],
            this._baseHeight = c[1],
            this._manager.Redraw())
        }
        ).catch(c => {
            console.error("[SVG] Error loading SVG: ", c);
            this._hadError = !0;
            this._manager && this._manager.Redraw()
        }
        );
        this._rasterImageHeight = this._rasterImageWidth = this._rasterSurfaceHeight = this._rasterSurfaceWidth = 0;
        this._isRasterizing = !1;
        this._rasterizedResult = null;
        this._hadError = this._forceRaster = !1
    }
    Release() {
        if (0 >= this._refCount)
            throw Error("already released");
        this._refCount--;
        0 === this._refCount && this._Release()
    }
    ReleaseRasterizedResult() {
        this._rasterizedResult && (this._manager.ReleaseResult(this._rasterizedResult),
        this._rasterizedResult = null)
    }
    _Release() {
        this.ReleaseRasterizedResult();
        this._manager._RemoveImage(this);
        this._manager = null
    }
    GetDataSource() {
        return this._dataSource
    }
    IncReference() {
        this._refCount++
    }
    HasReferences() {
        return 0 < this._refCount
    }
    GetRasterizedResult() {
        return this._rasterizedResult
    }
    ForceRasterAgain() {
        this._forceRaster = !0
    }
    async StartRasterForSize(a, b, c) {
        if (0 !== b && 0 !== c && !this._hadError && !this._isRasterizing) {
            var d = C3$jscomp$33.nextHighestPowerOfTwo(Math.ceil(b))
              , e = C3$jscomp$33.nextHighestPowerOfTwo(Math.ceil(c))
              , f = Math.max(d, e);
            4096 < f && (f = 4096 / f,
            b *= f,
            c *= f,
            d = Math.min(Math.ceil(d * f), 4096),
            e = Math.min(Math.ceil(e * f), 4096));
            b < d && c < e && (c = b / c,
            d / e > c ? (b = e * c,
            c = e) : (b = d,
            c = d / c));
            this._manager.IsNpotSurfaceAllowed() && (d = Math.ceil(b),
            e = Math.ceil(c));
            d <= this._rasterSurfaceWidth && e <= this._rasterSurfaceHeight && !this._forceRaster || (this._isRasterizing = !0,
            this._rasterSurfaceWidth = d,
            this._rasterSurfaceHeight = e,
            a = await this._manager.RasterAtSize(this._dataSource, a, this._rasterSurfaceWidth, this._rasterSurfaceHeight, b, c),
            this._manager && (this.ReleaseRasterizedResult(),
            this._rasterizedResult = a,
            this._rasterImageWidth = b,
            this._rasterImageHeight = c,
            this._forceRaster = this._isRasterizing = !1,
            this._manager.Redraw()))
        }
    }
    WhenBaseSizeReady() {
        return this._getBaseSizePromise
    }
    GetBaseWidth() {
        return this._baseWidth
    }
    GetBaseHeight() {
        return this._baseHeight
    }
    GetRasterWidth() {
        return this._rasterImageWidth
    }
    GetRasterHeight() {
        return this._rasterImageHeight
    }
    HadError() {
        return this._hadError
    }
}
;
"use strict";
const C3$jscomp$34 = self.C3;
C3$jscomp$34.UTF8_BOM = "\ufeff";
const NUMERIC_CHARS = new Set([..."0123456789"]);
C3$jscomp$34.IsNumericChar = function(a) {
    return NUMERIC_CHARS.has(a)
}
;
const WHITESPACE_CHARS = new Set([..." \t\n\r\u00a0\u0085\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u2028\u2029\u202f\u205f\u3000"]);
C3$jscomp$34.IsWhitespaceChar = function(a) {
    return WHITESPACE_CHARS.has(a)
}
;
C3$jscomp$34.FilterWhitespace = function(a) {
    return [...a].filter(b => !C3$jscomp$34.IsWhitespaceChar(b)).join("")
}
;
C3$jscomp$34.IsStringAllWhitespace = function(a) {
    for (const b of a)
        if (!C3$jscomp$34.IsWhitespaceChar(b))
            return !1;
    return !0
}
;
C3$jscomp$34.IsCharArrayAllWhitespace = function(a) {
    for (const b of a)
        if (!C3$jscomp$34.IsWhitespaceChar(b))
            return !1;
    return !0
}
;
C3$jscomp$34.IsUnprintableChar = function(a) {
    return 1 === a.length && 32 > a.charCodeAt(0)
}
;
C3$jscomp$34.FilterUnprintableChars = function(a) {
    return [...a].filter(b => !C3$jscomp$34.IsUnprintableChar(b)).join("")
}
;
const NUMERIC_STRING_CHARS = new Set([..."0123456789.+-e"]);
C3$jscomp$34.IsStringNumber = function(a) {
    a = a.trim();
    if (!a.length)
        return !1;
    let b = a.charAt(0);
    if ("-" !== b && !NUMERIC_CHARS.has(b))
        return !1;
    for (let c of a)
        if (!NUMERIC_STRING_CHARS.has(c))
            return !1;
    return !0
}
;
C3$jscomp$34.RemoveTrailingDigits = function(a) {
    let b = a.length;
    for (; 0 < b; ) {
        let c = a.charAt(b - 1);
        if (!C3$jscomp$34.IsNumericChar(c))
            break;
        --b
    }
    return a.substr(0, b)
}
;
C3$jscomp$34.IncrementNumberAtEndOf = function(a) {
    let b = C3$jscomp$34.RemoveTrailingDigits(a);
    a = (a = a.substr(b.length)) ? (parseInt(a, 10) + 1).toString() : "2";
    return b + a
}
;
const HTML_ENTITY_MAP = new Map([["&", "&amp;"], ["<", "&lt;"], [">", "&gt;"], ['"', "&quot;"], ["'", "&#39;"]]);
function lookupHtmlEntity(a) {
    return HTML_ENTITY_MAP.get(a)
}
const HTML_ENTITY_REGEX = /[&<>"']/g;
C3$jscomp$34.EscapeHTML = function(a) {
    return a.replace(HTML_ENTITY_REGEX, lookupHtmlEntity)
}
;
C3$jscomp$34.EscapeJS = function(a) {
    a = C3$jscomp$34.ReplaceAll(a, "\\", "\\\\");
    a = C3$jscomp$34.ReplaceAll(a, '"', '\\"');
    a = C3$jscomp$34.ReplaceAll(a, "\t", "\\t");
    a = C3$jscomp$34.ReplaceAll(a, "\r", "");
    return C3$jscomp$34.ReplaceAll(a, "\n", "\\n")
}
;
C3$jscomp$34.EscapeXML = function(a) {
    a = C3$jscomp$34.ReplaceAll(a, "&", "&amp;");
    a = C3$jscomp$34.ReplaceAll(a, "<", "&lt;");
    a = C3$jscomp$34.ReplaceAll(a, ">", "&gt;");
    return C3$jscomp$34.ReplaceAll(a, '"', "&quot;")
}
;
const ESCAPE_REGEX = /[-[\]{}()*+?.,\\^$|#\s]/g;
C3$jscomp$34.EscapeRegex = function(a) {
    return a.replace(ESCAPE_REGEX, "\\$&")
}
;
C3$jscomp$34.CountCharsInString = function(a, b) {
    let c = 0;
    for (const d of a)
        d === b && ++c;
    return c
}
;
C3$jscomp$34.FindAll = function(a, b, c=!1) {
    if (!b)
        return [];
    c || (a = a.toLowerCase(),
    b = b.toLowerCase());
    c = b.length;
    var d = 0;
    let e = [];
    for (; -1 < (d = a.indexOf(b, d)); )
        e.push(d),
        d += c;
    return e
}
;
C3$jscomp$34.ReplaceAll = function(a, b, c) {
    return a.replaceAll(b, () => c)
}
;
C3$jscomp$34.ReplaceAllCaseInsensitive = function(a, b, c) {
    return a.replace(new RegExp(C3$jscomp$34.EscapeRegex(b),"gi"), () => c)
}
;
C3$jscomp$34.SetElementContent = function(a, b) {
    "string" === typeof b ? a.textContent = b : b.isPlainText() ? a.textContent = b.toString() : (a.innerHTML = b.toHTML(),
    b instanceof C3$jscomp$34.BBString && b.attachLinkHandlers(a))
}
;
C3$jscomp$34.StringLikeEquals = function(a, b) {
    return a instanceof C3$jscomp$34.HtmlString || a instanceof C3$jscomp$34.BBString ? a.equals(b) : b instanceof C3$jscomp$34.HtmlString || b instanceof C3$jscomp$34.BBString ? b.equals(a) : a === b
}
;
C3$jscomp$34.StringSubstitute = function(a, ...b) {
    let c = a;
    for (let d = 0, e = b.length; d < e; ++d) {
        const f = `{${d}}`;
        if (!a.includes(f))
            throw Error(`missing placeholder '${f}' in string substitution`);
        c = c.replace(f, b[d].toString())
    }
    return c
}
;
C3$jscomp$34.StringSubstituteAllowMissing = function(a, ...b) {
    let c = a
      , d = -1
      , e = -1;
    for (let f = 0, h = b.length; f < h; ++f) {
        const l = `{${f}}`;
        a.includes(l) ? (e = f,
        c = c.replace(l, b[f].toString())) : -1 === d && (d = f)
    }
    if (0 <= d && 0 <= e && d < e)
        throw Error(`missing placeholder '${d}' in string substitution`);
    return c
}
;
C3$jscomp$34.StringSubstituteMap = function(a, b) {
    for (let[c,d] of Object.entries(b))
        a = a.replaceAll(c, d.toString());
    return a
}
;
C3$jscomp$34.SortAZ = function(a, b) {
    return a > b ? 1 : a < b ? -1 : 0
}
;
C3$jscomp$34.SortAZCaseInsensitive = function(a, b) {
    a = a.toLowerCase();
    b = b.toLowerCase();
    return a > b ? 1 : a < b ? -1 : 0
}
;
let intlSegmenter = null
  , graphemeSplitter = null;
self.Intl && self.Intl.Segmenter ? intlSegmenter = new self.Intl.Segmenter : graphemeSplitter = new self.GraphemeSplitter;
C3$jscomp$34.SplitGraphemes = function(a) {
    if (intlSegmenter) {
        const b = [];
        for (const c of intlSegmenter.segment(a))
            b.push(c.segment);
        return b
    }
    return graphemeSplitter.splitGraphemes(a)
}
;
C3$jscomp$34.IterateGraphemes = function*(a) {
    if (intlSegmenter)
        for (const b of intlSegmenter.segment(a))
            yield b.segment;
    else
        yield*graphemeSplitter.iterateGraphemes(a)
}
;
C3$jscomp$34.CountGraphemes = function(a) {
    if (intlSegmenter) {
        let b = 0;
        for (const c of intlSegmenter.segment(a))
            ++b;
        return b
    }
    return graphemeSplitter.countGraphemes(a)
}
;
const MEGABYTE = 1048576
  , GIGABYTE = 1024 * MEGABYTE
  , TERABYTE = 1024 * GIGABYTE;
C3$jscomp$34.FormatDataSize = function(a, b) {
    b = "common." + (b ? "dataRates" : "dataSizes") + ".";
    const c = self.langSub;
    if (1024 > a)
        return c(b + "bytes", a);
    if (a < MEGABYTE)
        return a /= 1024,
        a = 10 > a ? Math.round(10 * a) / 10 : Math.round(a),
        c(b + "kilobytes", a);
    if (a < GIGABYTE)
        return a /= MEGABYTE,
        a = 10 > a ? Math.round(10 * a) / 10 : Math.round(a),
        c(b + "megabytes", a);
    if (a < TERABYTE)
        return a /= GIGABYTE,
        a = 10 > a ? Math.round(10 * a) / 10 : Math.round(a),
        c(b + "gigabytes", a);
    a /= TERABYTE;
    a = 10 > a ? Math.round(10 * a) / 10 : Math.round(a);
    return c(b + "terabytes", a)
}
;
const DEFAULT_FORMATTIME_OPTS = {
    approximate: !1,
    days: !0,
    hours: !0,
    minutes: !0,
    seconds: !0
};
C3$jscomp$34.FormatTime = function(a, b) {
    b = Object.assign({}, DEFAULT_FORMATTIME_OPTS, b);
    C3$jscomp$34.Lang.PushContext("common.time");
    const c = []
      , d = self.lang
      , e = self.langPluralSub;
    if (b.days) {
        var f = Math.floor(a / 86400);
        0 < f && (a -= 86400 * f,
        c.push(e(".days", null, f)))
    }
    b.hours && (f = Math.floor(a / 3600),
    0 < f || c.length) && (a -= 3600 * f,
    c.push(e(".hours", null, f)));
    b.minutes && (f = Math.floor(a / 60),
    0 < f || c.length || !b.seconds) && (a -= 60 * f,
    c.push(e(".minutes", null, f)));
    b.seconds && c.push(e(".seconds", null, Math.floor(a % 60)));
    a = (b.approximate ? d(".approx-prefix") : "") + c.join(d(".separator"));
    C3$jscomp$34.Lang.PopContext();
    return a
}
;
C3$jscomp$34.ZeroPad = function(a, b) {
    let c = 0 > a ? "-" : "";
    a = Math.abs(a);
    a = a.toString();
    b -= a.length;
    for (let d = 0; d < b; ++d)
        c += "0";
    return c + a
}
;
C3$jscomp$34.StringToTitleCase = function(a) {
    return a.toLowerCase().replace(/\b\w/g, b => b.toUpperCase())
}
;
C3$jscomp$34.CompareVersionStrings = function(a, b) {
    a = a.split(".").map(c => c.trim());
    b = b.split(".").map(c => c.trim());
    C3$jscomp$34.resizeArray(a, 4, "0");
    C3$jscomp$34.resizeArray(b, 4, "0");
    a = a.map(c => parseInt(c, 10));
    b = b.map(c => parseInt(c, 10));
    for (let c = 0; 4 > c; ++c) {
        const d = a[c] - b[c];
        if (0 !== d)
            return 0 > d ? -1 : 1
    }
    return 0
}
;
C3$jscomp$34.CreateGUID = function() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, a => {
        const b = Math.floor(16 * Math.random());
        return ("x" === a ? b : b & 3 | 8).toString(16)
    }
    )
}
;
C3$jscomp$34.StringHammingDistance = function(a, b) {
    if (a.length !== b.length)
        throw Error("strings must be same length");
    let c = 0;
    for (let d = 0, e = a.length; d < e; ++d)
        a.charAt(d) !== b.charAt(d) && ++c;
    return c
}
;
C3$jscomp$34.StringLevenshteinDistance = function(a, b) {
    if (0 === a.length)
        return b.length;
    if (0 === b.length)
        return a.length;
    let c, d, e, f;
    if (a.length > b.length) {
        var h = a;
        a = b;
        b = h
    }
    f = Array(a.length + 1);
    for (h = 0; h <= a.length; h++)
        f[h] = h;
    for (h = 1; h <= b.length; h++) {
        d = h;
        for (c = 1; c <= a.length; c++)
            e = b[h - 1] === a[c - 1] ? f[c - 1] : Math.min(f[c - 1] + 1, Math.min(d + 1, f[c] + 1)),
            f[c - 1] = d,
            d = e;
        f[a.length] = d
    }
    return f[a.length]
}
;
"use strict";
const C3$jscomp$35 = self.C3
  , BB_CODE_MAP = new Map([["b", "strong"], ["i", "em"], ["s", "s"], ["u", "u"], ["sub", "sub"], ["sup", "sup"], ["small", "small"], ["mark", "mark"], ["code", "code"], ["a1", "a"], ["a2", "a"], ["a3", "a"], ["a4", "a"], ["a5", "a"], ["a6", "a"], ["a7", "a"], ["a8", "a"], ["a9", "a"], ["tip1", "abbr"], ["tip2", "abbr"], ["tip3", "abbr"], ["tip4", "abbr"], ["tip5", "abbr"], ["tip6", "abbr"], ["tip7", "abbr"], ["tip8", "abbr"], ["tip9", "abbr"], ["bad", ["span", "bbCodeBad"]], ["good", ["span", "bbCodeGood"]], ["info", ["span", "bbCodeInfo"]], ["h1", ["span", "bbCodeH1"]], ["h2", ["span", "bbCodeH2"]], ["h3", ["span", "bbCodeH3"]], ["h4", ["span", "bbCodeH4"]], ["item", ["span", "bbCodeItem"]]])
  , SELF_CLOSING_TAGS = new Set(["icon"])
  , BBREGEX = /\[(\/?)([a-zA-Z0-9]+)\]/g
  , CUSTOM_BBREGEX = /\[(\/?)([^\[\n]*?)\]/g;
let linkActions = null
  , tipList = null
  , classIndex = 0;
function bbToHtmlReplacerFunc(a, b, c) {
    var d = BB_CODE_MAP.get(c);
    if (d) {
        if ("string" === typeof d) {
            if ("a" === d && 0 === linkActions.length || "abbr" === d && 0 === tipList.length)
                return a;
            if ("a" !== d || b) {
                if ("abbr" !== d || b)
                    return "<" + b + d + ">";
                b = parseInt(c.substring(3), 10) - 1;
                if (0 > b || b >= tipList.length)
                    throw Error("invalid bbcode tip substitution");
                b = tipList[b];
                d = "";
                "string" === typeof b ? d = b : "function" === typeof b && (d = b());
                if ("string" !== typeof d)
                    throw new TypeError("invalid bbcode tip");
                return `<abbr title="${C3$jscomp$35.ReplaceAll(d, '"', "&quot;")}">`
            }
            b = parseInt(c.substring(1), 10) - 1;
            if (0 > b || b >= linkActions.length)
                throw Error("invalid bbcode link substitution");
            d = linkActions[b];
            if ("string" === typeof d)
                return `<a href="${linkActions[b]}">`;
            if ("function" === typeof d)
                return `<a class="bblink${b}">`;
            throw new TypeError("invalid bbcode link action");
        }
        if (Array.isArray(d))
            return a = d[0],
            d = d[1],
            b ? "</" + a + ">" : `<${a} class="${d}">`
    } else
        return "class" === c ? b ? "</span>" : `<span class="bbclass${classIndex++}">` : a
}
const LINEBREAK_REGEX = /\n/g;
C3$jscomp$35.BBString = class {
    constructor(a, b) {
        this._bbstr = b && b.noEscape ? a : C3$jscomp$35.EscapeHTML(a);
        this._htmlstr = "";
        this._convertLineBreaks = !1;
        this._linkActions = [];
        this._tipList = [];
        if (b) {
            this._convertLineBreaks = !!b.convertLineBreaks;
            if (b.links) {
                if (9 < b.links.length)
                    throw Error("too many links");
                this._linkActions = b.links
            }
            if (b.tips) {
                if (9 < b.tips.length)
                    throw Error("too many tips");
                this._tipList = b.tips
            }
        }
        this._hasAnyBBtags = this._bbstr.includes("[");
        this._needsLineBreakConversion = this._convertLineBreaks && this._bbstr.includes("\n");
        this._isPlain = !this._hasAnyBBtags && !this._needsLineBreakConversion && !this._bbstr.includes("&");
        this._hasParsedFragments = !1;
        this._fragments = []
    }
    toString() {
        return this._bbstr
    }
    valueOf() {
        return this._bbstr
    }
    isPlainText() {
        return this._isPlain
    }
    toPlainText() {
        return this._hasAnyBBtags ? this._bbstr.replace(BBREGEX, "") : this._bbstr
    }
    toHTML() {
        if (this._isPlain)
            return this._bbstr;
        if (!this._htmlstr && this._bbstr) {
            let a = this._bbstr;
            this._hasAnyBBtags && (classIndex = 0,
            linkActions = this._linkActions,
            tipList = this._tipList,
            a = a.replace(BBREGEX, bbToHtmlReplacerFunc),
            tipList = linkActions = null);
            this._needsLineBreakConversion && (a = a.replace(LINEBREAK_REGEX, "<br>"));
            this._htmlstr = a
        }
        return this._htmlstr
    }
    attachLinkHandlers(a) {
        if (this._linkActions.length)
            for (let b = 0, c = this._linkActions.length; b < c; ++b) {
                const d = this._linkActions[b];
                if ("function" !== typeof d)
                    continue;
                const e = a.querySelector(".bblink" + b);
                if (!e)
                    throw Error("unable to attach BBString link handler");
                e.onclick = d
            }
    }
    equals(a) {
        return a instanceof C3$jscomp$35.HtmlString ? this.toHTML() === a.toHTML() : a instanceof C3$jscomp$35.BBString ? this._bbstr === a._bbstr : this._bbstr === a
    }
    toFragmentList() {
        if (this._hasParsedFragments)
            return this._fragments;
        const a = []
          , b = this._bbstr
          , c = [];
        let d = CUSTOM_BBREGEX.lastIndex = 0;
        for (var e = null; null !== (e = CUSTOM_BBREGEX.exec(b)); ) {
            var f = e.index;
            if (0 < f && "\\" === b.charAt(f - 1))
                continue;
            var h = e[0]
              , l = e[1];
            e = e[2];
            const m = b.substring(d, f);
            d = f + h.length;
            m && a.push({
                text: m,
                styles: c.slice(0)
            });
            if (e)
                if (l)
                    for (e = e.toLowerCase(),
                    f = c.length - 1; 0 <= f; --f) {
                        if (c[f].tag === e) {
                            c.splice(f, 1);
                            break
                        }
                    }
                else if (f = e,
                h = null,
                l = e.indexOf("="),
                -1 !== l ? (f = e.substring(0, l).toLowerCase(),
                h = e.substring(l + 1)) : f = f.toLowerCase(),
                SELF_CLOSING_TAGS.has(f))
                    if ("icon" === f)
                        a.push({
                            icon: h,
                            styles: c.slice(0)
                        });
                    else
                        throw Error(`unknown self-closing tag ${f}`);
                else
                    c.push({
                        tag: f,
                        param: h
                    })
        }
        d < b.length && a.push({
            text: b.substring(d),
            styles: c.slice(0)
        });
        for (const m of a)
            m.text && (m.text = this._ProcessBBCodeEscapeSequences(m.text));
        this._fragments = a.map(m => m.icon ? C3$jscomp$35.New(C3$jscomp$35.IconFragment, {
            icon: m.icon,
            styles: m.styles
        }) : C3$jscomp$35.New(C3$jscomp$35.TextFragment, {
            chArr: C3$jscomp$35.SplitGraphemes(m.text),
            styles: m.styles
        }));
        this._hasParsedFragments = !0;
        return this._fragments
    }
    _ProcessBBCodeEscapeSequences(a) {
        a = C3$jscomp$35.ReplaceAll(a, "\\[", "[");
        return C3$jscomp$35.ReplaceAll(a, "\\\\", "\\")
    }
    static StripTags(a) {
        return C3$jscomp$35.New(C3$jscomp$35.BBString, a, {
            noEscape: !0
        }).toPlainText()
    }
    static StripAnyTags(a) {
        return a.replace(CUSTOM_BBREGEX, "")
    }
}
;
"use strict";
const C3$jscomp$36 = self.C3;
function IsWordBreakWhiteSpace(a) {
    return "\u00a0" === a || "\u202f" === a ? !1 : C3$jscomp$36.IsWhitespaceChar(a)
}
function WordBreakTrimEnd(a) {
    for (; 0 < a.length && IsWordBreakWhiteSpace(a.at(-1)); )
        a.pop()
}
function IsNewline(a) {
    return "\n" === a || "\r\n" === a
}
C3$jscomp$36.WordWrap = class {
    constructor() {
        this._lines = [];
        this._iconSet = null
    }
    GetLines() {
        return this._lines
    }
    GetLineCount() {
        return this._lines.length
    }
    SetIconSet(a) {
        this._iconSet = a
    }
    _MeasureLine(a, b) {
        let c = 0
          , d = 0
          , e = 0
          , f = 0
          , h = 0;
        for (const l of a)
            -1 === l.GetWidth() && (a = b(l),
            l.SetHeight(a.height),
            l.SetFontBoundingBoxAscent(a.fontBoundingBoxAscent || 0),
            l.SetFontBoundingBoxDescent(a.fontBoundingBoxDescent || 0),
            l.SetTopToAlphabeticDistance(a.topToAlphabeticDistance || 0),
            l.IsText() ? l.SetWidth(a.width) : l.IsIcon() && l.CalculateWidthFromHeight(this._iconSet)),
            c += l.GetWidth(),
            d = Math.max(d, l.GetHeight()),
            e = Math.max(e, l.GetFontBoundingBoxAscent()),
            f = Math.max(f, l.GetFontBoundingBoxDescent()),
            h = Math.max(h, l.GetTopToAlphabeticDistance());
        return {
            width: c,
            height: d,
            fontBoundingBoxAscent: e,
            fontBoundingBoxDescent: f,
            topToAlphabeticDistance: h
        }
    }
    _AddLine(a, b, c, d, e, f) {
        this._lines.push(C3$jscomp$36.New(C3$jscomp$36.WordWrap.Line, {
            fragments: a,
            width: b,
            height: c,
            fontBoundingBoxAscent: d,
            fontBoundingBoxDescent: e,
            topToAlphabeticDistance: f
        }))
    }
    WordWrap(a, b, c, d, e) {
        "string" === typeof a && (a = [C3$jscomp$36.New(C3$jscomp$36.TextFragment, {
            chArr: C3$jscomp$36.SplitGraphemes(a)
        })]);
        C3$jscomp$36.clearArray(this._lines);
        if (!(!a.length || 1 === a.length && a[0].IsText() && a[0].IsEmpty() || 2 > c)) {
            if (1 === a.length) {
                const f = a[0];
                if (f.IsText() && 100 >= f.GetLength() && !f.HasNewLine()) {
                    let {width: h, height: l, fontBoundingBoxAscent: m, fontBoundingBoxDescent: p, topToAlphabeticDistance: r} = b(f);
                    h += e;
                    f.SetWidth(h);
                    f.SetHeight(l);
                    f.SetFontBoundingBoxAscent(m || 0);
                    f.SetFontBoundingBoxDescent(p || 0);
                    f.SetTopToAlphabeticDistance(r || 0);
                    if (h <= c) {
                        this._AddLine([f], h, l, m, p, r);
                        return
                    }
                }
            }
            if ("word" === d)
                d = this._TokeniseWords(a);
            else {
                d = [];
                for (const f of a)
                    f.IsText() ? (a = f.GetCharacterArray(),
                    C3$jscomp$36.appendArray(d, a.map(h => [C3$jscomp$36.New(C3$jscomp$36.TextFragment, {
                        chArr: [h],
                        styles: f.GetStyles()
                    })]))) : d.push([f])
            }
            this._WrapText(d, b, c, e)
        }
    }
    _TokeniseWords(a) {
        const b = [];
        var c = []
          , d = !1;
        for (const f of a)
            if (a = f.GetStyles(),
            f.IsIcon())
                0 < c.length && b.push(c),
                b.push([f]),
                c = [];
            else
                for (const h of f.GetCharacterArray())
                    if (IsNewline(h))
                        0 < c.length && b.push(c),
                        c = C3$jscomp$36.New(C3$jscomp$36.TextFragment, {
                            chArr: ["\n"],
                            styles: a
                        }),
                        b.push([c]),
                        c = [];
                    else if (0 === c.length)
                        d = C3$jscomp$36.New(C3$jscomp$36.TextFragment, {
                            chArr: [h],
                            styles: a
                        }),
                        c.push(d),
                        d = IsWordBreakWhiteSpace(h);
                    else {
                        var e = IsWordBreakWhiteSpace(h);
                        e === d ? (e = c.at(-1),
                        e.GetStyles() === a ? e._AppendChar(h) : (e = C3$jscomp$36.New(C3$jscomp$36.TextFragment, {
                            chArr: [h],
                            styles: a
                        }),
                        c.push(e))) : (b.push(c),
                        c = [],
                        d = C3$jscomp$36.New(C3$jscomp$36.TextFragment, {
                            chArr: [h],
                            styles: a
                        }),
                        c.push(d),
                        d = e)
                    }
        0 < c.length && b.push(c);
        return b
    }
    _CopyLine(a) {
        return a.map(b => b._Clone())
    }
    _AddWordToLine(a, b) {
        var c = a.length ? a.at(-1) : null;
        let d = 0;
        c && c.IsText() && b[0].IsText() && b[0].GetStyles() === c.GetStyles() && (c._Append(b[0].GetCharacterArray()),
        d = 1);
        for (c = b.length; d < c; ++d)
            a.push(b[d]._Clone())
    }
    _WrapText(a, b, c, d) {
        let e = []
          , f = 0;
        var h = 0;
        let l = 0
          , m = 0;
        var p = 0;
        for (const r of a) {
            if (1 === r.length && r[0].IsText() && 1 === r[0].GetLength() && IsNewline(r[0].GetCharacterArray()[0])) {
                0 === h && (h = C3$jscomp$36.New(C3$jscomp$36.TextFragment, {
                    chArr: [" "],
                    styles: r[0].GetStyles()
                }),
                p = b(h),
                h = p.height,
                l = p.fontBoundingBoxAscent || 0,
                m = p.fontBoundingBoxDescent || 0,
                p = p.topToAlphabeticDistance || 0);
                this._AddLine(e, f, h, l, m, p);
                e = [];
                p = m = l = h = f = 0;
                continue
            }
            a = this._CopyLine(e);
            this._AddWordToLine(a, r);
            const v = this._MeasureLine(a, b)
              , x = v.width;
            x >= c ? (0 < e.length && this._AddLine(e, f, h, l, m, p),
            e = [],
            r[0].IsText() && C3$jscomp$36.IsCharArrayAllWhitespace(r[0].GetCharacterArray()) ? p = m = l = h = f = 0 : (this._AddWordToLine(e, r),
            p = this._MeasureLine(e, b),
            f = p.width,
            h = p.height,
            l = p.fontBoundingBoxAscent,
            m = p.fontBoundingBoxDescent,
            p = p.topToAlphabeticDistance)) : (e = a,
            f = x,
            h = v.height,
            l = v.fontBoundingBoxAscent,
            m = v.fontBoundingBoxDescent,
            p = v.topToAlphabeticDistance)
        }
        0 < e.length && this._AddLine(e, f, h, l, m, p);
        this._TrimLinesTrailingWhitespace(b, d)
    }
    _TrimLinesTrailingWhitespace(a, b) {
        for (const e of this._lines) {
            const f = e._GetFragmentsArray();
            if (!f.length)
                continue;
            let h = f.at(-1);
            if (h.IsText()) {
                var c = h.GetCharacterArray()
                  , d = c.slice(0);
                WordBreakTrimEnd(d);
                0 === d.length ? (e.OffsetWidth(-h.GetWidth()),
                f.pop()) : d.length < c.length && (h.SetCharacterArray(d),
                c = a(h).width,
                d = h.GetWidth() - c,
                h.SetWidth(c),
                e.OffsetWidth(-d));
                0 !== b && 0 < f.length && (h = f.at(-1),
                h.OffsetWidth(b),
                e.OffsetWidth(b))
            }
        }
    }
    Clear() {
        C3$jscomp$36.clearArray(this._lines)
    }
    GetMaxLineWidth() {
        return this._lines.reduce( (a, b) => Math.max(a, b.GetWidth()), 0)
    }
    GetTotalLineHeight() {
        return this._lines.reduce( (a, b) => a + b.GetHeight(), 0)
    }
}
;
"use strict";
self.C3.WordWrap.Line = class {
    constructor(a) {
        this._fragments = a.fragments || [];
        this._width = a.width || -1;
        this._height = a.height || -1;
        this._fontBoundingBoxAscent = a.fontBoundingBoxAscent || -1;
        this._fontBoundingBoxDescent = a.fontBoundingBoxDescent || -1;
        this._topToAlphabeticDistance = a.topToAlphabeticDistance || -1;
        this._posY = this._posX = 0
    }
    fragments() {
        return this._fragments.values()
    }
    *fragmentsReverse() {
        const a = this._fragments;
        for (let b = a.length - 1; 0 <= b; --b)
            yield a[b]
    }
    _GetFragmentsArray() {
        return this._fragments
    }
    OffsetWidth(a) {
        this._width += a
    }
    GetWidth() {
        return this._width
    }
    GetHeight() {
        return this._height
    }
    GetFoundBoundingBoxAscent() {
        return this._fontBoundingBoxAscent
    }
    GetFontBoundingBoxDescent() {
        return this._fontBoundingBoxDescent
    }
    GetTopToAlphabeticDistance() {
        return this._topToAlphabeticDistance
    }
    SetPosX(a) {
        this._posX = a
    }
    GetPosX() {
        return this._posX
    }
    SetPosY(a) {
        this._posY = a
    }
    GetPosY() {
        return this._posY
    }
}
;
"use strict";
self.C3.FragmentBase = class {
    constructor(a) {
        this._styles = a.styles || [];
        this._width = a.width || -1;
        this._height = a.height || -1;
        this._fontBoundingBoxAscent = a.fontBoundingBoxAscent || -1;
        this._fontBoundingBoxDescent = a.fontBoundingBoxDescent || -1;
        this._topToAlphabeticDistance = a.topToAlphabeticDistance || -1;
        this._posY = this._posX = 0
    }
    IsText() {
        return !1
    }
    IsIcon() {
        return !1
    }
    GetStyles() {
        return this._styles
    }
    GetStyleTag(a) {
        const b = this._styles;
        for (let c = b.length - 1; 0 <= c; --c) {
            const d = b[c];
            if (d.tag === a)
                return d
        }
        return null
    }
    HasStyleTag(a) {
        return !!this.GetStyleTag(a)
    }
    GetStyleMap() {
        const a = new Map;
        for (const b of this._styles)
            a.set(b.tag, b.param);
        return a
    }
    OffsetWidth(a) {
        this._width += a
    }
    SetWidth(a) {
        this._width = a
    }
    GetWidth() {
        return this._width
    }
    SetHeight(a) {
        this._height = a
    }
    GetHeight() {
        return this._height
    }
    SetFontBoundingBoxAscent(a) {
        this._fontBoundingBoxAscent = a
    }
    GetFontBoundingBoxAscent() {
        return this._fontBoundingBoxAscent
    }
    SetFontBoundingBoxDescent(a) {
        this._fontBoundingBoxDescent = a
    }
    GetFontBoundingBoxDescent() {
        return this._fontBoundingBoxDescent
    }
    SetTopToAlphabeticDistance(a) {
        this._topToAlphabeticDistance = a
    }
    GetTopToAlphabeticDistance() {
        return this._topToAlphabeticDistance
    }
    SetPosX(a) {
        this._posX = a
    }
    GetPosX() {
        return this._posX
    }
    SetPosY(a) {
        this._posY = a
    }
    GetPosY() {
        return this._posY
    }
}
;
"use strict";
const C3$jscomp$39 = self.C3;
C3$jscomp$39.TextFragment = class extends C3$jscomp$39.FragmentBase {
    constructor(a) {
        super(a);
        this._chArr = a.chArr
    }
    IsText() {
        return !0
    }
    _Append(a) {
        C3$jscomp$39.appendArray(this._chArr, a);
        this._topToAlphabeticDistance = this._fontBoundingBoxDescent = this._fontBoundingBoxAscent = this._height = this._width = -1
    }
    _AppendChar(a) {
        this._chArr.push(a)
    }
    _Clone() {
        return C3$jscomp$39.New(C3$jscomp$39.TextFragment, {
            chArr: this._chArr.slice(0),
            styles: this._styles,
            width: this._width,
            height: this._height,
            fontBoundingBoxAscent: this._fontBoundingBoxAscent,
            fontBoundingBoxDescent: this._fontBoundingBoxDescent,
            topToAlphabeticDistance: this._topToAlphabeticDistance
        })
    }
    GetCharacterArray() {
        return this._chArr
    }
    SetCharacterArray(a) {
        this._chArr = a
    }
    GetLength() {
        return this._chArr.length
    }
    IsEmpty() {
        return 0 === this._chArr.length
    }
    HasNewLine() {
        return this._chArr.includes("\n")
    }
}
;
"use strict";
const C3$jscomp$40 = self.C3;
C3$jscomp$40.IconFragment = class extends C3$jscomp$40.FragmentBase {
    constructor(a) {
        super(a);
        this._icon = a.icon
    }
    IsIcon() {
        return !0
    }
    GetIconParameter() {
        return this._icon
    }
    _Clone() {
        return C3$jscomp$40.New(C3$jscomp$40.IconFragment, {
            icon: this._icon,
            styles: this._styles,
            width: this._width,
            height: this._height,
            fontBoundingBoxAscent: this._fontBoundingBoxAscent,
            fontBoundingBoxDescent: this._fontBoundingBoxDescent,
            topToAlphabeticDistance: this._topToAlphabeticDistance
        })
    }
    GetTextIcon(a) {
        if (!a)
            return null;
        let b = Number(this._icon);
        return String(b) === this._icon ? (b = Math.floor(b),
        a.GetTextIconByIndex(b)) : a.GetTextIconByTag(this._icon)
    }
    CalculateWidthFromHeight(a) {
        this._width = (a = this.GetTextIcon(a)) ? this._height * a.GetWidth() / a.GetHeight() : 0
    }
    GetDrawable(a) {
        return (a = this.GetTextIcon(a)) ? a.GetDrawable() : null
    }
    GetLength() {
        return 1
    }
}
;
"use strict";
const C3$jscomp$41 = self.C3;
C3$jscomp$41.TextIconManager = class {
    constructor(a) {
        this._iconSets = new Map;
        this._getIconSetMetaCallback = a.getIconSetMeta;
        this._getIconSetContentCallback = a.getIconSetContent
    }
    Release() {
        for (const a of this._iconSets.values())
            a.Release();
        this._iconSets.clear()
    }
    GetIconSet(a) {
        var b = this._iconSets.get(a);
        if (b)
            return b;
        b = this._getIconSetMetaCallback(a);
        b = C3$jscomp$41.New(C3$jscomp$41.TextIconSet, this, {
            source: a,
            iconMeta: b
        });
        this._iconSets.set(a, b);
        return b
    }
    HasIconSet(a) {
        return this._iconSets.has(a)
    }
    DeleteIconSet(a) {
        const b = this._iconSets.get(a);
        b && b.Release();
        this._iconSets.delete(a)
    }
    async _GetIconSetContent(a) {
        return await this._getIconSetContentCallback(a)
    }
}
;
"use strict";
const C3$jscomp$42 = self.C3;
C3$jscomp$42.TextIconSet = class {
    constructor(a, b) {
        this._textIconManager = a;
        this._source = b.source;
        this._iconsArray = [];
        this._iconsByTag = new Map;
        this._isLoading = this._hasStartedLoad = !1;
        this._loadPromise = null;
        a = b.iconMeta.icons;
        for (let c = 0, d = a.length; c < d; ++c) {
            b = a[c];
            const e = C3$jscomp$42.New(C3$jscomp$42.TextIcon, this, {
                index: c,
                tag: b.tag,
                source: b.source,
                width: b.width,
                height: b.height
            });
            this._iconsArray.push(e);
            b.tag && this._iconsByTag.set(b.tag.toLowerCase(), e)
        }
    }
    Release() {
        for (const a of this._iconsArray)
            a.Release();
        C3$jscomp$42.clearArray(this._iconsArray);
        this._iconsByTag.clear();
        this._source = this._textIconManager = null
    }
    HasLoaded() {
        return this._hasStartedLoad
    }
    IsLoading() {
        return this._isLoading
    }
    LoadContent() {
        this._loadPromise || (this._loadPromise = this._DoLoadContent());
        return this._loadPromise
    }
    async _DoLoadContent() {
        if (!this._hasStartedLoad) {
            this._isLoading = this._hasStartedLoad = !0;
            var a = await this._textIconManager._GetIconSetContent(this._source);
            if (this._textIconManager) {
                a = a.icons;
                for (let b = 0, c = Math.min(a.length, this._iconsArray.length); b < c; ++b)
                    this._iconsArray[b]._SetDrawable(a[b].drawable);
                this._isLoading = !1
            }
        }
    }
    GetTextIconByIndex(a) {
        a = Math.floor(a);
        return 0 > a || a >= this._iconsArray.length ? null : this._iconsArray[a]
    }
    GetTextIconByTag(a) {
        return this._iconsByTag.get(a.toLowerCase()) || null
    }
}
;
"use strict";
self.C3.TextIcon = class {
    constructor(a, b) {
        this._textIconSet = a;
        this._source = b.source || null;
        this._index = b.index;
        this._tag = b.tag;
        this._width = b.width;
        this._height = b.height;
        this._drawable = null
    }
    Release() {
        this._height = this._width = 0;
        this._textIconSet = null
    }
    GetSource() {
        return this._source
    }
    GetWidth() {
        return this._width
    }
    GetHeight() {
        return this._height
    }
    _SetDrawable(a) {
        this._drawable = a
    }
    GetDrawable() {
        return this._drawable
    }
}
;
"use strict";
const C3$jscomp$44 = self.C3
  , glMatrix = self.glMatrix
  , vec3$jscomp$1 = glMatrix.vec3
  , vec4$jscomp$1 = glMatrix.vec4
  , mat4$jscomp$1 = glMatrix.mat4
  , tempVec3a = vec3$jscomp$1.create()
  , tempVec3b = vec3$jscomp$1.create()
  , tempVec3c = vec3$jscomp$1.create()
  , tempVec4 = vec4$jscomp$1.create()
  , tempMat4 = mat4$jscomp$1.create()
  , neartl = vec3$jscomp$1.create()
  , neartr = vec3$jscomp$1.create()
  , nearbl = vec3$jscomp$1.create()
  , nearbr = vec3$jscomp$1.create()
  , fartl = vec3$jscomp$1.create()
  , fartr = vec3$jscomp$1.create()
  , farbl = vec3$jscomp$1.create()
  , farbr = vec3$jscomp$1.create()
  , unitViewport = vec4$jscomp$1.fromValues(0, 0, 1, 1);
C3$jscomp$44.Gfx = {
    Project(a, b, c, d, e, f, h) {
        const l = d[0] * a + d[4] * b + d[8] * c + d[12]
          , m = d[1] * a + d[5] * b + d[9] * c + d[13]
          , p = d[2] * a + d[6] * b + d[10] * c + d[14];
        d = d[3] * a + d[7] * b + d[11] * c + d[15];
        a = e[0] * l + e[4] * m + e[8] * p + e[12] * d;
        b = e[1] * l + e[5] * m + e[9] * p + e[13] * d;
        c = e[2] * l + e[6] * m + e[10] * p + e[14] * d;
        e = e[3] * l + e[7] * m + e[11] * p + e[15] * d;
        if (0 === e)
            return !1;
        e = 1 / e;
        h[0] = (a * e * .5 + .5) * f[2] + f[0];
        h[1] = (b * e * .5 + .5) * f[3] + f[1];
        h[2] = .5 * (1 + c * e);
        return !0
    },
    Unproject(a, b, c, d, e, f, h) {
        mat4$jscomp$1.multiply(tempMat4, e, d);
        if (null === mat4$jscomp$1.invert(tempMat4, tempMat4))
            return !1;
        tempVec4[0] = (a - f[0]) / f[2] * 2 - 1;
        tempVec4[1] = (b - f[1]) / f[3] * 2 - 1;
        tempVec4[2] = 2 * c - 1;
        tempVec4[3] = 1;
        vec4$jscomp$1.transformMat4(tempVec4, tempVec4, tempMat4);
        if (0 === tempVec4[3])
            return !1;
        tempVec4[3] = 1 / tempVec4[3];
        h[0] = tempVec4[0] * tempVec4[3];
        h[1] = tempVec4[1] * tempVec4[3];
        h[2] = tempVec4[2] * tempVec4[3];
        return !0
    },
    UnprojectScreenToWorldZ(a, b, c, d, e, f, h) {
        if (!C3$jscomp$44.Gfx.Unproject(a, b, 0, d, e, f, tempVec3a) || !C3$jscomp$44.Gfx.Unproject(a, b, 1, d, e, f, tempVec3b))
            return !1;
        vec3$jscomp$1.subtract(tempVec3b, tempVec3b, tempVec3a);
        vec3$jscomp$1.set(tempVec3c, 0, 0, 1);
        a = -c;
        b = vec3$jscomp$1.dot(tempVec3c, tempVec3b);
        c = 0;
        if (0 === b) {
            if (0 !== vec3$jscomp$1.dot(tempVec3c, tempVec3a) + a)
                return !1
        } else if (c = -(vec3$jscomp$1.dot(tempVec3a, tempVec3c) + a) / b,
        0 > c)
            return !1;
        vec3$jscomp$1.scaleAndAdd(h, tempVec3a, tempVec3b, c);
        return !0
    }
};
function PlaneFromPoints(a, b, c, d) {
    vec3$jscomp$1.subtract(tempVec3a, c, b);
    vec3$jscomp$1.subtract(tempVec3b, a, b);
    vec3$jscomp$1.cross(tempVec3c, tempVec3a, tempVec3b);
    vec3$jscomp$1.normalize(tempVec3c, tempVec3c);
    d.set(tempVec3c[0], tempVec3c[1], tempVec3c[2], vec3$jscomp$1.dot(a, tempVec3c))
}
function IsInFrontOfPlane(a, b, c, d, e, f, h) {
    const l = h.x
      , m = h.y
      , p = h.z
      , r = h.w
      , v = h.xF
      , x = h.yF;
    h = h.zF;
    const B = 1 - v
      , A = 1 - x
      , D = 1 - h;
    return l * a * v + l * d * B + m * b * x + m * e * A + p * c * h + p * f * D >= r ? !0 : l * d * v + l * a * B + m * e * x + m * b * A + p * f * h + p * c * D > r
}
function IsPointInFrontOfPlane(a, b, c, d) {
    return d.x * a + d.y * b + d.z * c >= d.w
}
class Plane {
    constructor() {
        this.zF = this.yF = this.xF = this.w = this.z = this.y = this.x = NaN
    }
    set(a, b, c, d) {
        this.x = a;
        this.y = b;
        this.z = c;
        this.w = d;
        this.xF = 0 < a ? 1 : 0;
        this.yF = 0 < b ? 1 : 0;
        this.zF = 0 < c ? 1 : 0
    }
}
C3$jscomp$44.Gfx.ViewFrustum = class {
    constructor() {
        this._leftP = new Plane;
        this._topP = new Plane;
        this._rightP = new Plane;
        this._bottomP = new Plane;
        this._nearP = new Plane;
        this._farP = new Plane
    }
    CalculatePlanes(a, b) {
        C3$jscomp$44.Gfx.Unproject(0, 1, 0, a, b, unitViewport, neartl);
        C3$jscomp$44.Gfx.Unproject(1, 1, 0, a, b, unitViewport, neartr);
        C3$jscomp$44.Gfx.Unproject(0, 0, 0, a, b, unitViewport, nearbl);
        C3$jscomp$44.Gfx.Unproject(1, 0, 0, a, b, unitViewport, nearbr);
        C3$jscomp$44.Gfx.Unproject(0, 1, 1, a, b, unitViewport, fartl);
        C3$jscomp$44.Gfx.Unproject(1, 1, 1, a, b, unitViewport, fartr);
        C3$jscomp$44.Gfx.Unproject(0, 0, 1, a, b, unitViewport, farbl);
        C3$jscomp$44.Gfx.Unproject(1, 0, 1, a, b, unitViewport, farbr);
        PlaneFromPoints(nearbl, neartl, fartl, this._leftP);
        PlaneFromPoints(neartl, neartr, fartr, this._topP);
        PlaneFromPoints(neartr, nearbr, farbr, this._rightP);
        PlaneFromPoints(nearbr, nearbl, farbl, this._bottomP);
        PlaneFromPoints(farbl, fartl, fartr, this._farP);
        PlaneFromPoints(nearbr, neartr, neartl, this._nearP)
    }
    ContainsAABB(a, b, c, d, e, f) {
        return IsInFrontOfPlane(a, b, c, d, e, f, this._leftP) && IsInFrontOfPlane(a, b, c, d, e, f, this._topP) && IsInFrontOfPlane(a, b, c, d, e, f, this._rightP) && IsInFrontOfPlane(a, b, c, d, e, f, this._bottomP) && IsInFrontOfPlane(a, b, c, d, e, f, this._nearP) && IsInFrontOfPlane(a, b, c, d, e, f, this._farP)
    }
    IsBehindNearPlane(a, b, c) {
        return !IsPointInFrontOfPlane(a, b, c, this._nearP)
    }
}
;
"use strict";
const C3$jscomp$45 = self.C3
  , glMatrix$jscomp$1 = self.glMatrix
  , vec3$jscomp$2 = glMatrix$jscomp$1.vec3
  , vec4$jscomp$2 = glMatrix$jscomp$1.vec4
  , mat4$jscomp$2 = glMatrix$jscomp$1.mat4
  , tempMat4$jscomp$1 = mat4$jscomp$2.create()
  , tmpVec3a = vec3$jscomp$2.fromValues(0, 0, 0)
  , tmpVec3b = vec3$jscomp$2.fromValues(0, 0, 0)
  , tmpVec3c = vec3$jscomp$2.fromValues(0, 0, 0)
  , defaultUpVector = vec3$jscomp$2.fromValues(0, 1, 0);
vec4$jscomp$2.fromValues(0, 0, 0, 0);
const tmpQuad = new C3$jscomp$45.Quad
  , tmpRect = new C3$jscomp$45.Rect
  , defaultTexCoordsQuad = new C3$jscomp$45.Quad(0,0,1,0,1,1,0,1)
  , DEFAULT_RENDERERBASE_OPTS = {
    nearZ: 1,
    farZ: 1E4
}
  , matWebGLtoWebGPU = mat4$jscomp$2.fromValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, .5, 0, 0, 0, .5, 1);
C3$jscomp$45.Gfx.RendererBase = class {
    constructor(a) {
        a = Object.assign({}, DEFAULT_RENDERERBASE_OPTS, a);
        this._height = this._width = 0;
        this._fovY = C3$jscomp$45.toRadians(45);
        this._tan_fovY_2 = Math.tan(this._fovY / 2);
        this._matP = mat4$jscomp$2.create();
        this._matMV = mat4$jscomp$2.create();
        this._zAxisScale = !1;
        this._nearZ = a.nearZ;
        this._farZ = a.farZ;
        this._allShaderPrograms = [];
        this._shaderProgramsByName = new Map;
        this._spSmoothLineFill = this._spSmoothEllipseOutline = this._spSmoothEllipseFill = this._spHardEllipseOutline = this._spHardEllipseFill = this._spPenumbraFill = this._spLinearGradientFill = this._spColorFill = this._spTileRandomization = this._spTilemapFill = this._spPoints = this._spTextureFill = null;
        this._stateGroups = new Map;
        this._currentStateGroup = null;
        this._blendModeTable = [];
        this._namedBlendModeMap = new Map;
        this._currentZ = this._baseZ = 0;
        this._lineWidth = 1;
        this._lineWidthStack = [this._lineWidth];
        this._lineCap = 1;
        this._lineCapStack = [this._lineCap];
        this._lineOffset = .5;
        this._lineOffsetStack = [this._lineOffset];
        this._frameNumber = 0;
        this._enableMipmaps = !0;
        this._hasMajorPerformanceCaveat = !1
    }
    FillIndexBufferData(a) {
        let b = 0
          , c = a.length
          , d = 0;
        for (; b < c; )
            a[b++] = d,
            a[b++] = d + 1,
            a[b++] = d + 2,
            a[b++] = d,
            a[b++] = d + 2,
            a[b++] = d + 3,
            d += 4
    }
    _ClearState() {
        this._currentZ = this._baseZ = 0;
        this._spSmoothLineFill = this._spSmoothEllipseOutline = this._spSmoothEllipseFill = this._spHardEllipseOutline = this._spHardEllipseFill = this._spPenumbraFill = this._spLinearGradientFill = this._spColorFill = this._spTileRandomization = this._spTilemapFill = this._spPoints = this._spTextureFill = null;
        this._ClearAllShaderPrograms()
    }
    InitState() {
        this._ClearState();
        this._currentStateGroup = null
    }
    OnDeviceOrContextLost() {
        for (const a of this._allShaderPrograms)
            a.Release();
        this._ClearState()
    }
    GetWidth() {
        return this._width
    }
    GetHeight() {
        return this._height
    }
    GetDefaultCameraZ(a) {
        return this.IsZAxisScaleNormalized() ? 100 : a / (2 * this._GetTanFovYDiv2())
    }
    GetZAxisScaleFactor(a) {
        return this.IsZAxisScaleNormalized() ? a / (2 * this._GetTanFovYDiv2()) / this.GetDefaultCameraZ(a) : 1
    }
    SetNearZ(a) {
        this._nearZ = a
    }
    GetNearZ() {
        return this._nearZ
    }
    SetFarZ(a) {
        this._farZ = a
    }
    GetFarZ() {
        return this._farZ
    }
    SetFovY(a) {
        this._fovY = a;
        this._tan_fovY_2 = Math.tan(this._fovY / 2)
    }
    GetFovY() {
        return this._fovY
    }
    _GetTanFovYDiv2() {
        return this._tan_fovY_2
    }
    SetZAxisScaleNormalized() {
        this._zAxisScale = !1
    }
    SetZAxisScaleRegular() {
        this._zAxisScale = !0
    }
    IsZAxisScaleNormalized() {
        return !this._zAxisScale
    }
    IsZAxisScaleRegular() {
        return this._zAxisScale
    }
    CalculatePerspectiveMatrix(a, b, c=.5, d=.5) {
        const e = this.GetNearZ()
          , f = this.GetFarZ();
        var h = this.GetFovY();
        if (.5 === c && .5 === d)
            this.IsWebGPU() ? mat4$jscomp$2.perspectiveZO(a, h, b, e, f) : mat4$jscomp$2.perspective(a, h, b, e, f);
        else {
            c = 1 - c;
            h = 2 * c - 2;
            c *= 2;
            const l = 2 * d - 2;
            d *= 2;
            const m = this._GetTanFovYDiv2() * e;
            b *= m;
            mat4$jscomp$2.frustum(a, h * b, c * b, l * m, d * m, e, f);
            this.IsWebGPU() && mat4$jscomp$2.mul(a, matWebGLtoWebGPU, a)
        }
    }
    CalculateOrthographicMatrix(a, b, c, d=1) {
        var e = self.devicePixelRatio;
        const f = 2 * this.GetDefaultCameraZ(c) * e * this._GetTanFovYDiv2() / c;
        b = b * f / (2 * e * d);
        c = c * f / (2 * e * d);
        d = -b;
        e = -c;
        this.IsWebGPU() ? mat4$jscomp$2.orthoZO(a, d, b, e, c, this.GetNearZ(), this.GetFarZ()) : mat4$jscomp$2.ortho(a, d, b, e, c, this.GetNearZ(), this.GetFarZ())
    }
    CalculateLookAtModelView(a, b, c, d, e, f=1) {
        let h = 1;
        this.IsZAxisScaleNormalized() && (h = 200 * this._GetTanFovYDiv2() / e);
        vec3$jscomp$2.set(tmpVec3c, h, -h, 1);
        vec3$jscomp$2.multiply(tmpVec3a, b, tmpVec3c);
        vec3$jscomp$2.multiply(tmpVec3b, c, tmpVec3c);
        mat4$jscomp$2.lookAt(a, tmpVec3a, tmpVec3b, d || defaultUpVector);
        tmpVec3c[2] = f;
        mat4$jscomp$2.scale(a, a, tmpVec3c)
    }
    CalculateLookAtModelView2(a, b, c, d, e, f, h, l) {
        vec3$jscomp$2.set(tmpVec3a, a, b, c);
        vec3$jscomp$2.set(tmpVec3b, d, e, f);
        this.CalculateLookAtModelView(tempMat4$jscomp$1, tmpVec3a, tmpVec3b, defaultUpVector, h, l);
        return tempMat4$jscomp$1
    }
    _AddShaderProgram(a) {
        this._allShaderPrograms.push(a);
        this._shaderProgramsByName.set(a.GetName(), a)
    }
    _RemoveShaderProgram(a) {
        const b = this._allShaderPrograms.indexOf(a);
        -1 !== b && this._allShaderPrograms.splice(b, 1);
        this._shaderProgramsByName.delete(a.GetName())
    }
    _ClearAllShaderPrograms() {
        C3$jscomp$45.clearArray(this._allShaderPrograms);
        this._shaderProgramsByName.clear()
    }
    GetShaderProgramByName(a) {
        return this._shaderProgramsByName.get(a) || null
    }
    GetTextureFillShaderProgram() {
        return this._spTextureFill
    }
    SetTextureFillMode() {
        this.SetProgram(this._spTextureFill)
    }
    GetPointsRenderingProgram() {
        return this._spPoints
    }
    SetPointsRenderingProgram() {
        this.SetProgram(this._spPoints)
    }
    SetTilemapFillMode() {
        this.SetProgram(this._spTilemapFill)
    }
    SetTileRandomizationMode() {
        this.SetProgram(this._spTileRandomization)
    }
    SetColorFillMode() {
        this.SetProgram(this._spColorFill)
    }
    SetLinearGradientFillMode() {
        this.SetProgram(this._spLinearGradientFill)
    }
    SetPenumbraFillMode() {
        this.SetProgram(this._spPenumbraFill)
    }
    SetHardEllipseFillMode() {
        this.SetProgram(this._spHardEllipseFill)
    }
    SetHardEllipseOutlineMode() {
        this.SetProgram(this._spHardEllipseOutline)
    }
    SetSmoothEllipseFillMode() {
        this.SetProgram(this._spSmoothEllipseFill)
    }
    SetSmoothEllipseOutlineMode() {
        this.SetProgram(this._spSmoothEllipseOutline)
    }
    SetSmoothLineFillMode() {
        this.SetProgram(this._spSmoothLineFill)
    }
    _SetCurrentStateGroup(a) {
        this._currentStateGroup = a
    }
    GetCurrentStateGroup() {
        return this._currentStateGroup
    }
    AcquireStateGroup(a, b, c, d) {
        const e = C3$jscomp$45.Gfx.StateGroup.MakeKey(a, b, c, d);
        let f = this._stateGroups.get(e);
        f || (f = C3$jscomp$45.New(C3$jscomp$45.Gfx.StateGroup, this, a, b, c, d),
        this._stateGroups.set(e, f));
        f.AddRef();
        return f
    }
    ReleaseStateGroup(a) {
        a.DecRef();
        0 === a._GetRefCount() && (this._currentStateGroup === a && (this._currentStateGroup = null),
        this._stateGroups.delete(a.GetKey()),
        a.Release())
    }
    _InitBlendModeData(a) {
        C3$jscomp$45.clearArray(this._blendModeTable);
        this._namedBlendModeMap.clear();
        let b = 0;
        for (const c of a) {
            a = c[0];
            const d = c[1]
              , e = c[2];
            this._blendModeTable.push([d, e]);
            this._namedBlendModeMap.set(a, {
                number: b,
                srcBlend: d,
                destBlend: e
            });
            b++
        }
    }
    _GetBlendByIndex(a) {
        return this._blendModeTable[a]
    }
    GetSrcBlendByIndex(a) {
        return this._GetBlendByIndex(a)[0]
    }
    GetDestBlendByIndex(a) {
        return this._GetBlendByIndex(a)[1]
    }
    GetNamedBlend(a) {
        a = this._namedBlendModeMap.get(a);
        if ("undefined" === typeof a)
            throw Error("invalid blend name");
        return a
    }
    NamedBlendToNumber(a) {
        a = this._namedBlendModeMap.get(a);
        if ("undefined" === typeof a)
            throw Error("invalid blend name");
        return a.number
    }
    SetBaseZ(a) {
        this._baseZ = a
    }
    GetBaseZ() {
        return this._baseZ
    }
    SetCurrentZ(a) {
        this._currentZ = a;
        this._currentStateGroup = null
    }
    GetCurrentZ() {
        return this._currentZ
    }
    Line(a, b, c, d) {
        var e = C3$jscomp$45.angleTo(a, b, c, d)
          , f = .5 * this._lineWidth;
        const h = Math.sin(e) * f;
        e = Math.cos(e) * f;
        f = this._lineCap;
        2 === f ? this.LinePreCalc_LineCap2(a, b, 0, c, d, 0, h, e) : 1 === f ? this.LinePreCalc_LineCap1(a, b, 0, c, d, 0, h, e) : this.LinePreCalc_LineCap0(a, b, 0, c, d, 0, h, e)
    }
    Line3D(a, b, c, d, e, f) {
        var h = C3$jscomp$45.angleTo(a, b, d, e)
          , l = .5 * this._lineWidth;
        const m = Math.sin(h) * l;
        h = Math.cos(h) * l;
        l = this._lineCap;
        2 === l ? this.LinePreCalc_LineCap2(a, b, c, d, e, f, m, h) : 1 === l ? this.LinePreCalc_LineCap1(a, b, c, d, e, f, m, h) : this.LinePreCalc_LineCap0(a, b, c, d, e, f, m, h)
    }
    LinePreCalc_LineCap2(a, b, c, d, e, f, h, l) {
        var m = this._lineOffset;
        a = a + m - l;
        b = b + m - h;
        d = d + m + l;
        e = e + m + h;
        m = 2 * l;
        const p = 2 * h;
        this.Quad3D2(a + h, b - l, c, d + h, e - l, f, d - h - m, e + l - p, f, a - h + m, b + l + p, c, defaultTexCoordsQuad)
    }
    LinePreCalc_LineCap1(a, b, c, d, e, f, h, l) {
        const m = this._lineOffset;
        a = a + m - l;
        b = b + m - h;
        d = d + m + l;
        e = e + m + h;
        this.Quad3D2(a + h, b - l, c, d + h, e - l, f, d - h, e + l, f, a - h, b + l, c, defaultTexCoordsQuad)
    }
    LinePreCalc_LineCap0(a, b, c, d, e, f, h, l) {
        const m = this._lineOffset;
        a += m;
        b += m;
        d += m;
        e += m;
        this.Quad3D2(a + h, b - l, c, d + h, e - l, f, d - h, e + l, f, a - h, b + l, c, defaultTexCoordsQuad)
    }
    TexturedLine(a, b, c, d, e, f) {
        var h = C3$jscomp$45.angleTo(a, b, c, d)
          , l = .5 * this._lineWidth;
        const m = Math.sin(h) * l;
        h = Math.cos(h) * l;
        l = this._lineCap;
        2 === l ? this.TexturedLinePreCalc_LineCap2(a, b, c, d, m, h, e, f) : 1 === l ? this.TexturedLinePreCalc_LineCap1(a, b, c, d, m, h, e, f) : this.TexturedLinePreCalc_LineCap0(a, b, c, d, m, h, e, f)
    }
    TexturedLinePreCalc_LineCap2(a, b, c, d, e, f, h, l) {
        var m = this._lineOffset;
        a = a + m - f;
        b = b + m - e;
        c = c + m + f;
        d = d + m + e;
        m = 2 * f;
        const p = 2 * e;
        tmpQuad.set(a + e, b - f, c + e, d - f, c - e - m, d + f - p, a - e + m, b + f + p);
        tmpRect.set(h, 0, l, 0);
        this.Quad3(tmpQuad, tmpRect)
    }
    TexturedLinePreCalc_LineCap1(a, b, c, d, e, f, h, l) {
        const m = this._lineOffset;
        a = a + m - f;
        b = b + m - e;
        c = c + m + f;
        d = d + m + e;
        tmpQuad.set(a + e, b - f, c + e, d - f, c - e, d + f, a - e, b + f);
        tmpRect.set(h, 0, l, 0);
        this.Quad3(tmpQuad, tmpRect)
    }
    TexturedLinePreCalc_LineCap0(a, b, c, d, e, f, h, l) {
        const m = this._lineOffset;
        a += m;
        b += m;
        c += m;
        d += m;
        tmpQuad.set(a + e, b - f, c + e, d - f, c - e, d + f, a - e, b + f);
        tmpRect.set(h, 0, l, 0);
        this.Quad3(tmpQuad, tmpRect)
    }
    LineRect(a, b, c, d) {
        const e = .5 * this._lineWidth
          , f = this._lineCap;
        2 === f ? this._LineRectPreCalc_LineCap2(a, b, c, d, e) : 1 === f ? this._LineRectPreCalc_LineCap1(a, b, c, d, e) : this._LineRectPreCalc_LineCap0(a, b, c, d, e)
    }
    _LineRectPreCalc_LineCap2(a, b, c, d, e) {
        this.LinePreCalc_LineCap2(a, b, 0, c, b, 0, 0, e);
        this.LinePreCalc_LineCap2(c, b, 0, c, d, 0, e, 0);
        this.LinePreCalc_LineCap2(c, d, 0, a, d, 0, 0, -e);
        this.LinePreCalc_LineCap2(a, d, 0, a, b, 0, -e, 0)
    }
    _LineRectPreCalc_LineCap1(a, b, c, d, e) {
        this.LinePreCalc_LineCap1(a, b, 0, c, b, 0, 0, e);
        this.LinePreCalc_LineCap1(c, b, 0, c, d, 0, e, 0);
        this.LinePreCalc_LineCap1(c, d, 0, a, d, 0, 0, -e);
        this.LinePreCalc_LineCap1(a, d, 0, a, b, 0, -e, 0)
    }
    _LineRectPreCalc_LineCap0(a, b, c, d, e) {
        this.LinePreCalc_LineCap0(a, b, 0, c, b, 0, 0, e);
        this.LinePreCalc_LineCap0(c, b, 0, c, d, 0, e, 0);
        this.LinePreCalc_LineCap0(c, d, 0, a, d, 0, 0, -e);
        this.LinePreCalc_LineCap0(a, d, 0, a, b, 0, -e, 0)
    }
    LineRect2(a) {
        this.LineRect(a.getLeft(), a.getTop(), a.getRight(), a.getBottom())
    }
    LineQuad(a) {
        var b = C3$jscomp$45.angleTo(a.getTlx(), a.getTly(), a.getTrx(), a.getTry())
          , c = .5 * this._lineWidth;
        const d = Math.sin(b) * c;
        b = Math.cos(b) * c;
        c = this._lineCap;
        2 === c ? this._LineQuadPreCalc_LineCap2(a, d, b) : 1 === c ? this._LineQuadPreCalc_LineCap1(a, d, b) : this._LineQuadPreCalc_LineCap0(a, d, b)
    }
    _LineQuadPreCalc_LineCap2(a, b, c) {
        this.LinePreCalc_LineCap2(a.getTlx(), a.getTly(), 0, a.getTrx(), a.getTry(), 0, b, c);
        this.LinePreCalc_LineCap2(a.getTrx(), a.getTry(), 0, a.getBrx(), a.getBry(), 0, c, -b);
        this.LinePreCalc_LineCap2(a.getBrx(), a.getBry(), 0, a.getBlx(), a.getBly(), 0, -b, -c);
        this.LinePreCalc_LineCap2(a.getBlx(), a.getBly(), 0, a.getTlx(), a.getTly(), 0, -c, b)
    }
    _LineQuadPreCalc_LineCap1(a, b, c) {
        this.LinePreCalc_LineCap1(a.getTlx(), a.getTly(), 0, a.getTrx(), a.getTry(), 0, b, c);
        this.LinePreCalc_LineCap1(a.getTrx(), a.getTry(), 0, a.getBrx(), a.getBry(), 0, c, -b);
        this.LinePreCalc_LineCap1(a.getBrx(), a.getBry(), 0, a.getBlx(), a.getBly(), 0, -b, -c);
        this.LinePreCalc_LineCap1(a.getBlx(), a.getBly(), 0, a.getTlx(), a.getTly(), 0, -c, b)
    }
    _LineQuadPreCalc_LineCap0(a, b, c) {
        this.LinePreCalc_LineCap0(a.getTlx(), a.getTly(), 0, a.getTrx(), a.getTry(), 0, b, c);
        this.LinePreCalc_LineCap0(a.getTrx(), a.getTry(), 0, a.getBrx(), a.getBry(), 0, c, -b);
        this.LinePreCalc_LineCap0(a.getBrx(), a.getBry(), 0, a.getBlx(), a.getBly(), 0, -b, -c);
        this.LinePreCalc_LineCap0(a.getBlx(), a.getBly(), 0, a.getTlx(), a.getTly(), 0, -c, b)
    }
    SetLineWidth(a) {
        this._lineWidth = a;
        this._lineWidthStack[this._lineWidthStack.length - 1] = a
    }
    GetLineWidth() {
        return this._lineWidth
    }
    PushLineWidth(a) {
        if (100 <= this._lineWidthStack.length)
            throw Error("pushed too many line widths - check push/pop pairs");
        this._lineWidthStack.push(a);
        this._lineWidth = a
    }
    PopLineWidth() {
        if (1 >= this._lineWidthStack.length)
            throw Error("cannot pop last line width - check push/pop pairs");
        this._lineWidthStack.pop();
        this._lineWidth = this._lineWidthStack.at(-1)
    }
    SetLineCapButt() {
        this._lineCap = 0;
        this._lineCapStack[this._lineCapStack.length - 1] = 0
    }
    SetLineCapSquare() {
        this._lineCap = 1;
        this._lineCapStack[this._lineCapStack.length - 1] = 0
    }
    SetLineCapZag() {
        this._lineCap = 2;
        this._lineCapStack[this._lineCapStack.length - 1] = 0
    }
    PushLineCap(a) {
        if ("butt" === a)
            this.PushLineCapButt();
        else if ("square" === a)
            this.PushLineCapSquare();
        else if ("zag" === a)
            this.PushLineCapZag();
        else
            throw Error("invalid line cap");
    }
    PushLineCapButt() {
        if (100 <= this._lineCapStack.length)
            throw Error("pushed too many line caps - check push/pop pairs");
        this._lineCapStack.push(0);
        this._lineCap = 0
    }
    PushLineCapSquare() {
        if (100 <= this._lineCapStack.length)
            throw Error("pushed too many line caps - check push/pop pairs");
        this._lineCapStack.push(1);
        this._lineCap = 1
    }
    PushLineCapZag() {
        if (100 <= this._lineCapStack.length)
            throw Error("pushed too many line caps - check push/pop pairs");
        this._lineCapStack.push(2);
        this._lineCap = 2
    }
    PopLineCap() {
        if (1 >= this._lineCapStack.length)
            throw Error("cannot pop last line cap - check push/pop pairs");
        this._lineCapStack.pop();
        this._lineCap = this._lineCapStack.at(-1)
    }
    SetLineOffset(a) {
        this._lineOffset = a;
        this._lineOffsetStack[this._lineOffsetStack.length - 1] = a
    }
    GetLineOffset() {
        return this._lineOffset
    }
    PushLineOffset(a) {
        if (100 <= this._lineOffsetStack.length)
            throw Error("pushed too many line offsets - check push/pop pairs");
        this._lineOffsetStack.push(a);
        this._lineOffset = a
    }
    PopLineOffset() {
        if (1 >= this._lineOffsetStack.length)
            throw Error("cannot pop last line offset - check push/pop pairs");
        this._lineOffsetStack.pop();
        this._lineOffset = this._lineOffsetStack.at(-1)
    }
    ConvexPoly(a) {
        var b = a.length / 2;
        if (3 > b)
            throw Error("need at least 3 points");
        b -= 2;
        const c = b - 1
          , d = a[0]
          , e = a[1];
        for (let f = 0; f < b; f += 2) {
            const h = 2 * f
              , l = a[h + 2]
              , m = a[h + 3]
              , p = a[h + 4]
              , r = a[h + 5];
            f === c ? this.Quad2(d, e, l, m, p, r, p, r) : this.Quad2(d, e, l, m, p, r, a[h + 6], a[h + 7])
        }
    }
    GetNumVertexComponents() {
        return 3
    }
    Finish() {
        this.EndBatch(!0);
        this._frameNumber++
    }
    GetFrameNumber() {
        return this._frameNumber
    }
    IncrementFrameNumber() {
        this._frameNumber++
    }
    SetMipmapsEnabled(a) {
        this._enableMipmaps = !!a
    }
    AreMipmapsEnabled() {
        return this._enableMipmaps
    }
    SetHasMajorPerformanceCaveat(a) {
        this._hasMajorPerformanceCaveat = !!a
    }
    HasMajorPerformanceCaveat() {
        return this._hasMajorPerformanceCaveat
    }
    IsWebGL() {
        return !1
    }
    IsWebGPU() {
        return !1
    }
    GetEstimatedBackBufferMemoryUsage() {}
    GetEstimatedRenderBufferMemoryUsage() {}
    GetEstimatedTextureMemoryUsage() {}
    GetEstimatedTotalMemoryUsage() {
        return this.GetEstimatedBackBufferMemoryUsage() + this.GetEstimatedRenderBufferMemoryUsage() + this.GetEstimatedTextureMemoryUsage()
    }
    CreateRendererText() {
        return C3$jscomp$45.New(C3$jscomp$45.Gfx.RendererText, this)
    }
}
;
"use strict";
self.C3.Gfx.ShaderProgramBase = class {
    constructor(a, b) {
        this._name = b.name;
        this._renderer = a;
        this._extendBoxHorizontal = b.extendBoxHorizontal || 0;
        this._extendBoxVertical = b.extendBoxVertical || 0;
        this._crossSampling = !!b.crossSampling;
        this._mustPreDraw = !!b.mustPreDraw;
        this._preservesOpaqueness = !!b.preservesOpaqueness;
        this._supports3dDirectRendering = !!b.supports3dDirectRendering;
        this._animated = !!b.animated;
        this._blendsBackground = !!b.blendsBackground;
        this._usesDepth = !!b.usesDepth;
        this._usesAnySrcRectOrPixelSize = !1;
        this._needsPostDrawOrExtendBox = this._crossSampling || this._blendsBackground || 0 !== this._extendBoxHorizontal || 0 !== this._extendBoxVertical
    }
    Release() {
        this._renderer = null
    }
    GetRenderer() {
        return this._renderer
    }
    GetName() {
        return this._name
    }
    ExtendsBox() {
        return 0 !== this._extendBoxHorizontal || 0 !== this._extendBoxVertical
    }
    GetBoxExtendHorizontal() {
        return this._extendBoxHorizontal
    }
    GetBoxExtendVertical() {
        return this._extendBoxVertical
    }
    UsesCrossSampling() {
        return this._crossSampling
    }
    MustPreDraw() {
        return this._mustPreDraw
    }
    PreservesOpaqueness() {
        return this._preservesOpaqueness
    }
    Supports3DDirectRendering() {
        return this._supports3dDirectRendering
    }
    IsAnimated() {
        return this._animated
    }
    BlendsBackground() {
        return this._blendsBackground
    }
    UsesDepth() {
        return this._usesDepth
    }
    UsesAnySrcRectOrPixelSize() {
        return this._usesAnySrcRectOrPixelSize
    }
    NeedsPostDrawOrExtendsBox() {
        return this._needsPostDrawOrExtendBox
    }
    UsesIsSrcTexRotated() {
        return !1
    }
}
;
"use strict";
const C3$jscomp$47 = self.C3;
C3$jscomp$47.Gfx.StateGroup = class {
    constructor(a, b, c, d, e) {
        this._renderer = a;
        this._refCount = 0;
        this._shaderProgram = null;
        this._shaderProgramName = "";
        this._blendMode = c;
        this._color = C3$jscomp$47.New(C3$jscomp$47.Color);
        this._color.set(d);
        this._zElevation = e;
        "string" === typeof b ? this._shaderProgramName = b : (this._shaderProgram = b,
        this._shaderProgramName = this._shaderProgram.GetName())
    }
    Release() {
        if (0 < this._refCount)
            throw Error("releasing state group still in use");
        this._shaderProgram = this._renderer = null;
        this._shaderProgramName = ""
    }
    Apply() {
        const a = this._renderer;
        a.SetProgram(this._shaderProgram);
        a.SetBlendMode(this._blendMode);
        a.SetColor(this._color);
        a.SetCurrentZ(this._zElevation);
        a._SetCurrentStateGroup(this)
    }
    GetKey() {
        return C3$jscomp$47.Gfx.StateGroup.MakeKey(this._shaderProgramName, this._blendMode, this._color, this._zElevation)
    }
    AddRef() {
        ++this._refCount
    }
    DecRef() {
        --this._refCount
    }
    _GetRefCount() {
        return this._refCount
    }
    OnContextLost() {
        this._shaderProgram = null
    }
    OnContextRestored(a) {
        this._shaderProgram = a.GetShaderProgramByName(this._shaderProgramName);
        if (!this._shaderProgram)
            throw Error("failed to restore shader program");
    }
    static MakeKey(a, b, c, d) {
        return ("string" === typeof a ? a : a.GetName()) + "," + b + "," + c.getR() + "," + c.getG() + "," + c.getB() + "," + c.getA() + "," + d
    }
}
;
"use strict";
const C3$jscomp$48 = self.C3
  , tempQuadTex = C3$jscomp$48.New(C3$jscomp$48.Quad);
function interpolateQuad(a, b, c) {
    const d = c.getTlx()
      , e = c.getTly()
      , f = c.getTrx() - d
      , h = c.getTry() - e
      , l = c.getBlx() - d;
    c = c.getBly() - e;
    return [d + f * a + l * b, e + h * a + c * b]
}
C3$jscomp$48.Gfx.MeshPoint = class {
    constructor(a, b, c) {
        this._mesh = a;
        this._col = b;
        this._row = c;
        this._v = this._u = this._zElevation = this._y = this._x = 0
    }
    _Init(a, b, c, d) {
        this._x = a;
        this._y = b;
        this._u = c;
        this._v = d
    }
    GetX() {
        return this._x
    }
    SetX(a) {
        this._x !== a && (this._x = a,
        this._mesh._SetPointsChanged())
    }
    GetY() {
        return this._y
    }
    SetY(a) {
        this._y !== a && (this._y = a,
        this._mesh._SetPointsChanged())
    }
    GetZElevation() {
        return this._zElevation
    }
    SetZElevation(a) {
        this._zElevation !== a && (this._zElevation = Math.max(a, 0),
        this._mesh._SetPointsChanged())
    }
    GetU() {
        return this._u
    }
    SetU(a) {
        this._u = a
    }
    GetV() {
        return this._v
    }
    SetV(a) {
        this._v = a
    }
    _Interpolate_TexRect(a, b, c) {
        [this._x,this._y] = interpolateQuad(a._x, a._y, b);
        this._zElevation = a._zElevation;
        this._u = C3$jscomp$48.lerp(c.getLeft(), c.getRight(), a._u);
        this._v = C3$jscomp$48.lerp(c.getTop(), c.getBottom(), a._v)
    }
    _Interpolate_TexQuad(a, b, c) {
        [this._x,this._y] = interpolateQuad(a._x, a._y, b);
        this._zElevation = a._zElevation;
        [this._u,this._v] = interpolateQuad(a._u, a._v, c)
    }
    SaveToJson() {
        return {
            x: this.GetX(),
            y: this.GetY(),
            z: this.GetZElevation(),
            u: this.GetU(),
            v: this.GetV()
        }
    }
    LoadFromJson(a) {
        this.SetX(a.x);
        this.SetY(a.y);
        a.hasOwnProperty("z") && this.SetZElevation(a.z);
        this.SetU(a.u);
        this.SetV(a.v)
    }
    GetMesh() {
        return this._mesh
    }
    GetColumn() {
        return this._col
    }
    GetRow() {
        return this._row
    }
}
;
C3$jscomp$48.Gfx.Mesh = class {
    constructor(a, b, c) {
        if (2 > a || 2 > b)
            throw Error("invalid mesh size");
        this._hsize = a;
        this._vsize = b;
        this._owner = c || null;
        this._pts = [];
        this._minY = this._minX = 0;
        this._maxY = this._maxX = 1;
        this._maxZ = 0;
        this._pointsChanged = !1;
        c = a - 1;
        const d = b - 1;
        for (let e = 0; e < b; ++e) {
            const f = [];
            for (let h = 0; h < a; ++h) {
                const l = C3$jscomp$48.New(C3$jscomp$48.Gfx.MeshPoint, this, h, e)
                  , m = h / c
                  , p = e / d;
                l._Init(m, p, m, p);
                f.push(l)
            }
            this._pts.push(f)
        }
    }
    Release() {
        C3$jscomp$48.clearArray(this._pts)
    }
    GetHSize() {
        return this._hsize
    }
    GetVSize() {
        return this._vsize
    }
    GetOwner() {
        return this._owner
    }
    _GetPoints() {
        return this._pts
    }
    _SetPointsChanged() {
        this._pointsChanged = !0
    }
    _MaybeComputeBounds() {
        if (this._pointsChanged) {
            var a = Infinity
              , b = Infinity
              , c = -Infinity
              , d = -Infinity
              , e = 0;
            for (const f of this._pts)
                for (const h of f) {
                    const l = h.GetX()
                      , m = h.GetY();
                    a = Math.min(a, l);
                    b = Math.min(b, m);
                    c = Math.max(c, l);
                    d = Math.max(d, m);
                    e = Math.max(e, h.GetZElevation())
                }
            this._minX = a;
            this._minY = b;
            this._maxX = c;
            this._maxY = d;
            this._maxZ = e;
            this._pointsChanged = !1
        }
    }
    GetMinX() {
        this._MaybeComputeBounds();
        return this._minX
    }
    GetMinY() {
        this._MaybeComputeBounds();
        return this._minY
    }
    GetMaxX() {
        this._MaybeComputeBounds();
        return this._maxX
    }
    GetMaxY() {
        this._MaybeComputeBounds();
        return this._maxY
    }
    GetMaxZ() {
        this._MaybeComputeBounds();
        return this._maxZ
    }
    HasAnyZElevation() {
        return 0 < this.GetMaxZ()
    }
    GetMeshPointAt(a, b) {
        a = Math.floor(a);
        b = Math.floor(b);
        return 0 > a || a >= this._hsize || 0 > b || b >= this._vsize ? null : this._pts[b][a]
    }
    CalculateTransformedMesh(a, b, c) {
        const d = c instanceof C3$jscomp$48.Rect;
        if (a.GetHSize() !== this.GetHSize() || a.GetVSize() !== this.GetVSize())
            throw Error("source mesh wrong size");
        a = a._pts;
        const e = this._pts;
        for (let f = 0, h = e.length; f < h; ++f) {
            const l = a[f]
              , m = e[f];
            for (let p = 0, r = m.length; p < r; ++p) {
                const v = l[p]
                  , x = m[p];
                d ? x._Interpolate_TexRect(v, b, c) : x._Interpolate_TexQuad(v, b, c)
            }
        }
    }
    Draw(a) {
        const b = this._pts;
        let c = b[0];
        for (let d = 1, e = b.length; d < e; ++d) {
            const f = b[d];
            let h = c[0]
              , l = f[0];
            for (let m = 1, p = f.length; m < p; ++m) {
                const r = c[m]
                  , v = f[m];
                tempQuadTex.set(h.GetU(), h.GetV(), r.GetU(), r.GetV(), v.GetU(), v.GetV(), l.GetU(), l.GetV());
                a.Quad3D2(h.GetX(), h.GetY(), h.GetZElevation(), r.GetX(), r.GetY(), r.GetZElevation(), v.GetX(), v.GetY(), v.GetZElevation(), l.GetX(), l.GetY(), l.GetZElevation(), tempQuadTex);
                h = r;
                l = v
            }
            c = f
        }
    }
    Outline(a, b) {
        b || (b = (e, f, h) => [e, f, h]);
        const c = this._pts;
        let d = c[0];
        for (let e = 1, f = c.length; e < f; ++e) {
            const h = c[e];
            let l = d[0]
              , m = h[0];
            for (let p = 1, r = h.length; p < r; ++p) {
                const v = d[p]
                  , x = h[p]
                  , [B,A,D] = b(l.GetX(), l.GetY(), l.GetZElevation())
                  , [F,I,K] = b(v.GetX(), v.GetY(), v.GetZElevation())
                  , [M,Q,W] = b(x.GetX(), x.GetY(), x.GetZElevation())
                  , [ca,ia,ka] = b(m.GetX(), m.GetY(), m.GetZElevation());
                a.Line3D(B, A, D, F, I, K);
                a.Line3D(B, A, D, M, Q, W);
                a.Line3D(B, A, D, ca, ia, ka);
                p === r - 1 && a.Line3D(F, I, K, M, Q, W);
                e === f - 1 && a.Line3D(ca, ia, ka, M, Q, W);
                l = v;
                m = x
            }
            d = h
        }
    }
    InsertPolyMeshVertices(a) {
        a = a.pointsArr();
        const b = []
          , c = this.GetHSize() - 1
          , d = this.GetVSize() - 1
          , e = 1 / c
          , f = 1 / d
          , h = c - 1
          , l = d - 1;
        let m = a[0]
          , p = a[1]
          , r = C3$jscomp$48.clamp(Math.floor(m * c), 0, h)
          , v = C3$jscomp$48.clamp(Math.floor(p * d), 0, l)
          , x = 0
          , B = 0
          , A = 0;
        var D = -1;
        const F = () => {
            m = C3$jscomp$48.clamp(C3$jscomp$48.lerp(m, x, A), 0, 1);
            p = C3$jscomp$48.clamp(C3$jscomp$48.lerp(p, B, A), 0, 1);
            b.push(m, p)
        }
        ;
        for (let I = 0, K = a.length; I < K; I += 2)
            for (m = a[I],
            p = a[I + 1],
            b.push(m, p),
            r = C3$jscomp$48.clamp(Math.floor(m * c), 0, h),
            v = C3$jscomp$48.clamp(Math.floor(p * d), 0, l),
            D = (I + 2) % K,
            x = a[D],
            B = a[D + 1],
            D = -1; ; ) {
                if (1E6 < b.length)
                    throw Error("Too many mesh poly points");
                const M = r * e
                  , Q = v * f
                  , W = (r + 1) * e
                  , ca = (v + 1) * f;
                C3$jscomp$48.isPointInTriangleInclusive(m, p, M, Q, W, Q, W, ca);
                if (0 !== D && (A = C3$jscomp$48.rayIntersectExtended(m, p, x, B, M, Q, W, ca, -.001),
                0 <= A && .99999999 >= A)) {
                    F();
                    D = 0;
                    continue
                }
                if (0 < v && 2 !== D && (A = C3$jscomp$48.rayIntersectExtended(m, p, x, B, M, Q, W, Q, .001),
                0 <= A && .99999999 >= A)) {
                    F();
                    v--;
                    D = 4;
                    continue
                }
                if (r < h && 3 !== D && (A = C3$jscomp$48.rayIntersectExtended(m, p, x, B, W, Q, W, ca, .001),
                0 <= A && .99999999 >= A)) {
                    F();
                    r++;
                    D = 1;
                    continue
                }
                if (0 < r && 1 !== D && (A = C3$jscomp$48.rayIntersectExtended(m, p, x, B, M, Q, M, ca, .001),
                0 <= A && .99999999 >= A)) {
                    F();
                    r--;
                    D = 3;
                    continue
                }
                if (v < l && 4 !== D && (A = C3$jscomp$48.rayIntersectExtended(m, p, x, B, M, ca, W, ca, .001),
                0 <= A && .99999999 >= A)) {
                    F();
                    v++;
                    D = 2;
                    continue
                }
                break
            }
        return C3$jscomp$48.New(C3$jscomp$48.CollisionPoly, b)
    }
    TransformCollisionPoly(a, b) {
        a = this._TransformPolyPoints(a);
        this._SimplifyPoly(a);
        b.setPoints(a)
    }
    _TransformPolyPoints(a) {
        const b = [];
        a = a.pointsArr();
        for (let c = 0, d = a.length; c < d; c += 2) {
            const [e,f] = this.TransformPoint(a[c], a[c + 1]);
            b.push(e, f)
        }
        return b
    }
    TransformPoint(a, b) {
        var c = this.GetHSize() - 1
          , d = this.GetVSize() - 1
          , e = 1 / c
          , f = 1 / d;
        c = C3$jscomp$48.clamp(Math.floor(a * c), 0, c - 1);
        const h = C3$jscomp$48.clamp(Math.floor(b * d), 0, d - 1);
        d = c * e;
        const l = h * f
          , m = (c + 1) * e
          , p = (h + 1) * f
          , r = this.GetMeshPointAt(c, h)
          , v = this.GetMeshPointAt(c + 1, h + 1)
          , x = C3$jscomp$48.isPointInTriangleInclusive(a, b, d, l, m, l, m, p);
        e = x ? d + e : d;
        f = x ? l : l + f;
        c = this.GetMeshPointAt(c + (x ? 1 : 0), h + (x ? 0 : 1));
        const [B,A,D] = C3$jscomp$48.triangleCartesianToBarycentric(a, b, d, l, e, f, m, p);
        return C3$jscomp$48.triangleBarycentricToCartesian3d(B, A, D, r.GetX(), r.GetY(), r.GetZElevation(), c.GetX(), c.GetY(), c.GetZElevation(), v.GetX(), v.GetY(), v.GetZElevation())
    }
    _SimplifyPoly(a) {
        const b = [];
        let c = a[0]
          , d = a[1]
          , e = c - a.at(-2)
          , f = d - a.at(-1);
        for (let l = 0, m = a.length; l < m; l += 2) {
            var h = (l + 2) % m;
            const p = a[h];
            h = a[h + 1];
            const r = p - c
              , v = h - d
              , x = 1E-7 > Math.abs(v) && 1E-7 > Math.abs(f) && Math.sign(r) === Math.sign(e);
            (!(1E-7 > Math.abs(r) && 1E-7 > Math.abs(e) && Math.sign(v) === Math.sign(f) || x) && .001 < Math.abs(r / e - v / f) || 0 == r && 0 === v) && b.push(c, d);
            c = p;
            d = h;
            e = r;
            f = v
        }
        6 <= b.length && b.length < a.length && C3$jscomp$48.shallowAssignArray(a, b)
    }
    SaveToJson() {
        return {
            cols: this.GetHSize(),
            rows: this.GetVSize(),
            points: this._pts.map(a => a.map(b => b.SaveToJson()))
        }
    }
    LoadFromJson(a) {
        const b = this.GetHSize()
          , c = this.GetVSize();
        if (a.cols !== b || a.rows !== c)
            throw Error("mesh data wrong size");
        a = a.points;
        for (let d = 0; d < c; ++d) {
            const e = a[d];
            for (let f = 0; f < b; ++f)
                this.GetMeshPointAt(f, d).LoadFromJson(e[f])
        }
    }
}
;
"use strict";
const C3$jscomp$49 = self.C3
  , VALID_PIXEL_FORMATS = new Set(["rgba8", "rgb8", "rgba4", "rgb5_a1", "rgb565"])
  , VALID_SAMPLINGS = new Set(["nearest", "bilinear", "trilinear"])
  , VALID_MIPMAP_QUALITIES = new Set(["default", "low", "high"])
  , VALID_WRAP_MODES = new Set(["clamp-to-edge", "repeat", "mirror-repeat"]);
function GetFormatSpecifiers(a, b) {
    let c, d;
    switch (a) {
    case "rgba8":
        a = b.RGBA8;
        d = c = b.RGBA;
        b = b.UNSIGNED_BYTE;
        break;
    case "rgb8":
        a = b.RGB8;
        d = c = b.RGB;
        b = b.UNSIGNED_BYTE;
        break;
    case "rgba4":
        a = b.RGBA4;
        d = c = b.RGBA;
        b = b.UNSIGNED_SHORT_4_4_4_4;
        break;
    case "rgb5_a1":
        a = b.RGB5_A1;
        d = c = b.RGBA;
        b = b.UNSIGNED_SHORT_5_5_5_1;
        break;
    case "rgb565":
        a = b.RGB565;
        d = c = b.RGB;
        b = b.UNSIGNED_SHORT_5_6_5;
        break;
    default:
        throw Error("invalid pixel format");
    }
    return {
        sizedinternalformat: a,
        internalformat: c,
        format: d,
        type: b
    }
}
const CREATEFROM_DEFAULT_OPTIONS = {
    wrapX: "clamp-to-edge",
    wrapY: "clamp-to-edge",
    sampling: "trilinear",
    anisotropy: 0,
    pixelFormat: "rgba8",
    mipMap: !0,
    mipMapQuality: "default",
    premultiplyAlpha: !0,
    isSvg: !1,
    width: -1,
    height: -1
}
  , UPDATE_DEFAULT_OPTIONS = {
    premultiplyAlpha: !0,
    flipY: !1
}
  , allTextures = new Set;
C3$jscomp$49.Gfx.WebGLRendererTexture = class {
    constructor(a) {
        this._renderer = a;
        this._texture = null;
        this._height = this._width = 0;
        this._isStatic = !0;
        this._wrapY = this._wrapX = "clamp-to-edge";
        this._sampling = "trilinear";
        this._anisotropy = 0;
        this._pixelFormat = "rgba8";
        this._isMipMapped = !1;
        this._mipMapQuality = "default";
        this._refCount = 0
    }
    _CreateStatic(a, b) {
        if (!("undefined" !== typeof HTMLImageElement && a instanceof HTMLImageElement || "undefined" !== typeof HTMLCanvasElement && a instanceof HTMLCanvasElement || "undefined" !== typeof ImageBitmap && a instanceof ImageBitmap || "undefined" !== typeof OffscreenCanvas && a instanceof OffscreenCanvas || a instanceof ImageData || a instanceof ArrayBuffer) && null !== a)
            throw Error("invalid texture source");
        b = Object.assign({}, CREATEFROM_DEFAULT_OPTIONS, b);
        if (this._texture)
            throw Error("already created texture");
        this._wrapX = b.wrapX;
        this._wrapY = b.wrapY;
        this._sampling = b.sampling;
        this._anisotropy = b.anisotropy;
        this._pixelFormat = b.pixelFormat;
        this._isMipMapped = !!b.mipMap && this._renderer.AreMipmapsEnabled();
        this._mipMapQuality = b.mipMapQuality;
        if (!VALID_WRAP_MODES.has(this._wrapX) || !VALID_WRAP_MODES.has(this._wrapY))
            throw Error("invalid wrap mode");
        if (!VALID_SAMPLINGS.has(this._sampling))
            throw Error("invalid sampling");
        if (!VALID_PIXEL_FORMATS.has(this._pixelFormat))
            throw Error("invalid pixel format");
        if (!VALID_MIPMAP_QUALITIES.has(this._mipMapQuality))
            throw Error("invalid mipmap quality");
        this._isStatic = !0;
        if (a instanceof ArrayBuffer || null === a || b.isSvg) {
            if (this._width = b.width,
            this._height = b.height,
            a instanceof ArrayBuffer && a.byteLength !== this._width * this._height * 4)
                throw Error("ArrayBuffer wrong size");
        } else
            this._width = a.width,
            this._height = a.height;
        if (0 >= this._width || 0 >= this._height)
            throw Error("invalid texture data size");
        if (b.isSvg) {
            var c = C3$jscomp$49.CreateCanvas(this._width, this._height);
            c.getContext("2d").drawImage(a, 0, 0, this._width, this._height);
            a = c
        }
        var d = C3$jscomp$49.isPOT(this._width) && C3$jscomp$49.isPOT(this._height);
        c = this._renderer.GetMaxTextureSize();
        if (this._width > c || this._height > c)
            throw Error("texture data exceeds maximum texture size");
        c = this._renderer.GetContext();
        var e = this._renderer.GetWebGLVersionNumber();
        this._texture = c.createTexture();
        c.bindTexture(c.TEXTURE_2D, this._texture);
        c.pixelStorei(c.UNPACK_PREMULTIPLY_ALPHA_WEBGL, b.premultiplyAlpha);
        c.pixelStorei(c.UNPACK_FLIP_Y_WEBGL, !1);
        b = GetFormatSpecifiers(this._pixelFormat, c);
        if (this._renderer.SupportsNPOTTextures() || d || !this._IsTiled())
            2 <= e ? (c.texStorage2D(c.TEXTURE_2D, this._isMipMapped ? Math.floor(Math.log2(Math.max(this._width, this._height)) + 1) : 1, b.sizedinternalformat, this._width, this._height),
            a instanceof ArrayBuffer ? c.texSubImage2D(c.TEXTURE_2D, 0, 0, 0, this._width, this._height, b.format, b.type, new Uint8Array(a)) : null !== a && c.texSubImage2D(c.TEXTURE_2D, 0, 0, 0, b.format, b.type, a)) : a instanceof ArrayBuffer ? c.texImage2D(c.TEXTURE_2D, 0, b.internalformat, this._width, this._height, 0, b.format, b.type, new Uint8Array(a)) : null === a ? c.texImage2D(c.TEXTURE_2D, 0, b.internalformat, this._width, this._height, 0, b.format, b.type, null) : c.texImage2D(c.TEXTURE_2D, 0, b.internalformat, b.format, b.type, a);
        else {
            if (null === a)
                throw Error("cannot pass null data when creating a NPOT tiled texture without NPOT support");
            a instanceof ArrayBuffer && (a = new ImageData(new Uint8ClampedArray(a),this._width,this._height));
            a instanceof ImageData && (d = C3$jscomp$49.CreateCanvas(this._width, this._height),
            d.getContext("2d").putImageData(a, 0, 0),
            a = d);
            d = C3$jscomp$49.CreateCanvas(C3$jscomp$49.nextHighestPowerOfTwo(this._width), C3$jscomp$49.nextHighestPowerOfTwo(this._height));
            e = d.getContext("2d");
            e.imageSmoothingEnabled = "nearest" !== this._sampling;
            e.drawImage(a, 0, 0, this._width, this._height, 0, 0, d.width, d.height);
            c.texImage2D(c.TEXTURE_2D, 0, b.internalformat, b.format, b.type, d)
        }
        null !== a && this._SetTextureParameters(c);
        c.bindTexture(c.TEXTURE_2D, null);
        this._renderer._ResetLastTexture();
        this._refCount = 1;
        allTextures.add(this)
    }
    _CreateDynamic(a, b, c) {
        c = Object.assign({}, CREATEFROM_DEFAULT_OPTIONS, c);
        if (this._texture)
            throw Error("already created texture");
        this._wrapX = c.wrapX;
        this._wrapY = c.wrapY;
        this._sampling = c.sampling;
        this._pixelFormat = c.pixelFormat;
        this._isMipMapped = !!c.mipMap && this._renderer.AreMipmapsEnabled();
        this._mipMapQuality = c.mipMapQuality;
        if (!VALID_WRAP_MODES.has(this._wrapX) || !VALID_WRAP_MODES.has(this._wrapY))
            throw Error("invalid wrap mode");
        if (!VALID_SAMPLINGS.has(this._sampling))
            throw Error("invalid sampling");
        if (!VALID_PIXEL_FORMATS.has(this._pixelFormat))
            throw Error("invalid pixel format");
        if (!VALID_MIPMAP_QUALITIES.has(this._mipMapQuality))
            throw Error("invalid mipmap quality");
        this._isStatic = !1;
        this._width = Math.floor(a);
        this._height = Math.floor(b);
        a = C3$jscomp$49.isPOT(this._width) && C3$jscomp$49.isPOT(this._height);
        b = this._renderer.GetMaxTextureSize();
        if (0 >= this._width || 0 >= this._height)
            throw Error("invalid texture size");
        if (this._width > b || this._height > b)
            throw Error("texture exceeds maximum texture size");
        if (!this._renderer.SupportsNPOTTextures() && this._IsTiled() && !a)
            throw Error("non-power-of-two tiled textures not supported");
        a = this._renderer.GetContext();
        b = this._renderer.GetWebGLVersionNumber();
        this._texture = a.createTexture();
        a.bindTexture(a.TEXTURE_2D, this._texture);
        a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL, c.premultiplyAlpha);
        a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL, !1);
        c = GetFormatSpecifiers(this._pixelFormat, a);
        a.texImage2D(a.TEXTURE_2D, 0, 2 <= b ? c.sizedinternalformat : c.internalformat, this._width, this._height, 0, c.format, c.type, null);
        this._SetTextureParameters(a);
        a.bindTexture(a.TEXTURE_2D, null);
        this._renderer._ResetLastTexture();
        this._refCount = 1;
        allTextures.add(this)
    }
    _GetMipMapHint(a) {
        if ("default" === this._mipMapQuality)
            return this._isStatic ? a.NICEST : a.FASTEST;
        if ("low" === this._mipMapQuality)
            return a.FASTEST;
        if ("high" === this._mipMapQuality)
            return a.NICEST;
        throw Error("invalid mipmap quality");
    }
    _IsTiled() {
        return "clamp-to-edge" !== this._wrapX || "clamp-to-edge" !== this._wrapY
    }
    _GetTextureWrapMode(a, b) {
        if ("clamp-to-edge" === b)
            return a.CLAMP_TO_EDGE;
        if ("repeat" === b)
            return a.REPEAT;
        if ("mirror-repeat" === b)
            return a.MIRRORED_REPEAT;
        throw Error("invalid wrap mode");
    }
    _SetTextureParameters(a) {
        var b = C3$jscomp$49.isPOT(this._width) && C3$jscomp$49.isPOT(this._height);
        a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, this._GetTextureWrapMode(a, this._wrapX));
        a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, this._GetTextureWrapMode(a, this._wrapY));
        "nearest" === this._sampling ? (a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.NEAREST),
        a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.NEAREST),
        this._isMipMapped = !1) : (a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.LINEAR),
        (b || this._renderer.SupportsNPOTTextures()) && this._isMipMapped ? (a.hint(a.GENERATE_MIPMAP_HINT, this._GetMipMapHint(a)),
        a.generateMipmap(a.TEXTURE_2D),
        b = "trilinear" === this._sampling && !this._renderer.HasMajorPerformanceCaveat(),
        a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, b ? a.LINEAR_MIPMAP_LINEAR : a.LINEAR_MIPMAP_NEAREST)) : (a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.LINEAR),
        this._isMipMapped = !1));
        (b = this._renderer._GetAnisotropicExtension()) && 0 < this._anisotropy && "nearest" !== this._sampling && a.texParameterf(a.TEXTURE_2D, b.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(this._anisotropy, this._renderer._GetMaxAnisotropy()))
    }
    _Update(a, b) {
        if (!("undefined" !== typeof HTMLImageElement && a instanceof HTMLImageElement || "undefined" !== typeof HTMLVideoElement && a instanceof HTMLVideoElement || "undefined" !== typeof HTMLCanvasElement && a instanceof HTMLCanvasElement || "undefined" !== typeof ImageBitmap && a instanceof ImageBitmap || "undefined" !== typeof OffscreenCanvas && a instanceof OffscreenCanvas || a instanceof ImageData))
            throw Error("invalid texture source");
        if (!this._texture || 0 >= this._refCount)
            throw Error("texture not created");
        if (this._isStatic)
            throw Error("cannot update static texture");
        b = Object.assign({}, UPDATE_DEFAULT_OPTIONS, b);
        const c = a.width || a.videoWidth
          , d = a.height || a.videoHeight;
        var e = this._renderer.GetWebGLVersionNumber();
        const f = this._renderer.GetContext();
        f.bindTexture(f.TEXTURE_2D, this._texture);
        f.pixelStorei(f.UNPACK_PREMULTIPLY_ALPHA_WEBGL, b.premultiplyAlpha);
        f.pixelStorei(f.UNPACK_FLIP_Y_WEBGL, !!b.flipY);
        b = GetFormatSpecifiers(this._pixelFormat, f);
        e = 2 <= e ? b.sizedinternalformat : b.internalformat;
        try {
            if (this._width === c && this._height === d) {
                const h = C3$jscomp$49.isPOT(this._width) && C3$jscomp$49.isPOT(this._height);
                f.texSubImage2D(f.TEXTURE_2D, 0, 0, 0, b.format, b.type, a);
                (h || this._renderer.SupportsNPOTTextures()) && this._isMipMapped && (f.hint(f.GENERATE_MIPMAP_HINT, this._GetMipMapHint(f)),
                f.generateMipmap(f.TEXTURE_2D))
            } else {
                this._width = c;
                this._height = d;
                const h = C3$jscomp$49.isPOT(this._width) && C3$jscomp$49.isPOT(this._height);
                if (!this._renderer.SupportsNPOTTextures() && this._IsTiled() && !h)
                    throw Error("non-power-of-two tiled textures not supported");
                f.texImage2D(f.TEXTURE_2D, 0, e, b.format, b.type, a);
                (h || this._renderer.SupportsNPOTTextures()) && this._isMipMapped && (f.hint(f.GENERATE_MIPMAP_HINT, this._GetMipMapHint(f)),
                f.generateMipmap(f.TEXTURE_2D))
            }
        } catch (h) {
            console.error("Error updating WebGL texture: ", h)
        }
        f.bindTexture(f.TEXTURE_2D, null);
        this._renderer._ResetLastTexture()
    }
    _Delete() {
        if (0 < this._refCount)
            throw Error("texture still has references");
        if (!this._texture)
            throw Error("already deleted texture");
        allTextures.delete(this);
        this._renderer.GetContext().deleteTexture(this._texture);
        this._texture = null
    }
    IsValid() {
        return !!this._texture
    }
    _GetTexture() {
        return this._texture
    }
    GetRenderer() {
        return this._renderer
    }
    AddReference() {
        this._refCount++
    }
    SubtractReference() {
        if (0 >= this._refCount)
            throw Error("no more references");
        this._refCount--
    }
    GetReferenceCount() {
        return this._refCount
    }
    GetWidth() {
        return this._width
    }
    GetHeight() {
        return this._height
    }
    IsStatic() {
        return this._isStatic
    }
    GetEstimatedMemoryUsage() {
        let a = this._width * this._height;
        switch (this._pixelFormat) {
        case "rgba8":
            a *= 4;
            break;
        case "rgb8":
            a *= 3;
            break;
        case "rgba4":
        case "rgb5_a1":
        case "rgb565":
            a *= 2
        }
        this._isMipMapped && (a += Math.floor(a / 3));
        return a
    }
    static OnContextLost() {
        allTextures.clear()
    }
    static allTextures() {
        return allTextures.values()
    }
}
;
"use strict";
const C3$jscomp$50 = self.C3
  , glMatrix$jscomp$2 = self.glMatrix
  , mat4$jscomp$3 = glMatrix$jscomp$2.mat4
  , VALID_SAMPLINGS$jscomp$1 = new Set(["nearest", "bilinear", "trilinear"])
  , DEFAULT_RENDERTARGET_OPTIONS = {
    sampling: "trilinear",
    alpha: !0,
    depth: !1,
    isSampled: !0,
    isDefaultSize: !0,
    multisampling: 0
}
  , allRenderTargets = new Set;
C3$jscomp$50.Gfx.WebGLRenderTarget = class {
    constructor(a) {
        this._renderer = a;
        this._renderBuffer = this._texture = this._frameBufferNoDepth = this._frameBuffer = null;
        this._height = this._width = 0;
        this._isDefaultSize = !0;
        this._sampling = "trilinear";
        this._alpha = !0;
        this._depth = !1;
        this._isSampled = !0;
        this._multisampling = 0;
        this._projectionMatrix = mat4$jscomp$3.create();
        this._lastFarZ = this._lastNearZ = this._lastFov = 0
    }
    _Create(a, b, c) {
        c = Object.assign({}, DEFAULT_RENDERTARGET_OPTIONS, c);
        const d = this._renderer.GetWebGLVersionNumber();
        if (this._texture || this._renderBuffer)
            throw Error("already created render target");
        this._sampling = c.sampling;
        this._alpha = !!c.alpha;
        this._depth = !!c.depth;
        this._isSampled = !!c.isSampled;
        this._isDefaultSize = !!c.isDefaultSize;
        this._multisampling = c.multisampling;
        if (!VALID_SAMPLINGS$jscomp$1.has(this._sampling))
            throw Error("invalid sampling");
        if (0 < this._multisampling && (2 > d || this._isSampled))
            throw Error("invalid use of multisampling");
        2 > d && (this._isSampled = !0);
        this._width = a;
        this._height = b;
        if (0 >= this._width || 0 >= this._height)
            throw Error("invalid render target size");
        this._CalculateProjection();
        a = this._renderer.GetContext();
        this._frameBuffer = a.createFramebuffer();
        this._depth && (this._frameBufferNoDepth = a.createFramebuffer());
        this._isSampled ? (this._texture = this._renderer.CreateDynamicTexture(this._width, this._height, {
            sampling: this._sampling,
            pixelFormat: this._alpha ? "rgba8" : "rgb8",
            mipMap: !1
        }),
        b = this._texture._GetTexture(),
        a.bindFramebuffer(a.FRAMEBUFFER, this._frameBuffer),
        a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, b, 0),
        this._depth && (a.bindFramebuffer(a.FRAMEBUFFER, this._frameBufferNoDepth),
        a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, b, 0))) : (this._renderBuffer = a.createRenderbuffer(),
        a.bindRenderbuffer(a.RENDERBUFFER, this._renderBuffer),
        b = this._alpha ? a.RGBA8 : a.RGB8,
        0 < this._multisampling && ((c = a.getInternalformatParameter(a.RENDERBUFFER, b, a.SAMPLES)) && c[0] ? (c = c[0],
        this._multisampling > c && (this._multisampling = c)) : this._multisampling = 0),
        0 === this._multisampling ? a.renderbufferStorage(a.RENDERBUFFER, b, this._width, this._height) : a.renderbufferStorageMultisample(a.RENDERBUFFER, this._multisampling, b, this._width, this._height),
        a.bindFramebuffer(a.FRAMEBUFFER, this._frameBuffer),
        a.framebufferRenderbuffer(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.RENDERBUFFER, this._renderBuffer),
        this._depth && (a.bindFramebuffer(a.FRAMEBUFFER, this._frameBufferNoDepth),
        a.framebufferRenderbuffer(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.RENDERBUFFER, this._renderBuffer)),
        a.bindRenderbuffer(a.RENDERBUFFER, null));
        b = this._renderer._GetDepthBuffer();
        this._depth && b && (a.bindFramebuffer(a.FRAMEBUFFER, this._frameBuffer),
        this._renderer._CanSampleDepth() ? a.framebufferTexture2D(a.FRAMEBUFFER, a.DEPTH_STENCIL_ATTACHMENT, a.TEXTURE_2D, b, 0) : a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_STENCIL_ATTACHMENT, a.RENDERBUFFER, b));
        a.bindFramebuffer(a.FRAMEBUFFER, null);
        allRenderTargets.add(this)
    }
    _Resize(a, b) {
        if (this._width !== a || this._height !== b)
            this._width = a,
            this._height = b,
            this._CalculateProjection(),
            a = this._renderer.GetContext(),
            a.bindFramebuffer(a.FRAMEBUFFER, this._frameBuffer),
            this._texture ? this._texture._Update(new ImageData(this._width,this._height)) : (a.bindRenderbuffer(a.RENDERBUFFER, this._renderBuffer),
            a.renderbufferStorage(a.RENDERBUFFER, this._alpha ? a.RGBA8 : a.RGB8, this._width, this._height),
            a.bindRenderbuffer(a.RENDERBUFFER, null)),
            b = this._renderer._GetDepthBuffer(),
            this._depth && b && (this._renderer._CanSampleDepth() ? a.framebufferTexture2D(a.FRAMEBUFFER, a.DEPTH_STENCIL_ATTACHMENT, a.TEXTURE_2D, b, 0) : a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_STENCIL_ATTACHMENT, a.RENDERBUFFER, b)),
            a.bindFramebuffer(a.FRAMEBUFFER, null)
    }
    _Delete() {
        if (!this._texture && !this._renderBuffer)
            throw Error("already deleted render target");
        allRenderTargets.delete(this);
        var a = this._renderer.GetContext();
        this._texture ? (a.bindFramebuffer(a.FRAMEBUFFER, this._frameBuffer),
        a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, null, 0),
        this._depth && (a.bindFramebuffer(a.FRAMEBUFFER, this._frameBufferNoDepth),
        a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, null, 0)),
        this._renderer.DeleteTexture(this._texture),
        this._texture = null) : this._renderBuffer && (a.bindFramebuffer(a.FRAMEBUFFER, this._frameBuffer),
        a.framebufferRenderbuffer(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.RENDERBUFFER, null),
        this._depth && (a.bindFramebuffer(a.FRAMEBUFFER, this._frameBufferNoDepth),
        a.framebufferRenderbuffer(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.RENDERBUFFER, null)),
        a.deleteRenderbuffer(this._renderBuffer),
        this._renderBuffer = null);
        a.bindFramebuffer(a.FRAMEBUFFER, null);
        2 <= this._renderer.GetWebGLVersionNumber() && (a.bindFramebuffer(a.READ_FRAMEBUFFER, null),
        a.bindFramebuffer(a.DRAW_FRAMEBUFFER, null));
        a.deleteFramebuffer(this._frameBuffer);
        this._depth && a.deleteFramebuffer(this._frameBufferNoDepth);
        a = this._renderer.GetBatchState();
        a.currentFramebuffer = null;
        this._frameBuffer = a.currentFramebufferNoDepth = null
    }
    _CalculateProjection() {
        this._renderer.CalculatePerspectiveMatrix(this._projectionMatrix, this._width / this._height);
        this._lastFov = this._renderer.GetFovY();
        this._lastNearZ = this._renderer.GetNearZ();
        this._lastFarZ = this._renderer.GetFarZ()
    }
    _GetFramebuffer() {
        return this._frameBuffer
    }
    _GetFramebufferNoDepth() {
        return this._frameBufferNoDepth
    }
    GetRenderer() {
        return this._renderer
    }
    GetTexture() {
        return this._texture
    }
    GetProjectionMatrix() {
        this._renderer.GetFovY() === this._lastFov && this._renderer.GetNearZ() === this._lastNearZ && this._renderer.GetFarZ() === this._lastFarZ || this._CalculateProjection();
        return this._projectionMatrix
    }
    IsLinearSampling() {
        return "nearest" !== this._sampling
    }
    HasAlpha() {
        return this._alpha
    }
    IsSampled() {
        return this._isSampled
    }
    HasDepthBuffer() {
        return this._depth
    }
    GetWidth() {
        return this._width
    }
    GetHeight() {
        return this._height
    }
    IsDefaultSize() {
        return this._isDefaultSize
    }
    GetMultisampling() {
        return this._multisampling
    }
    GetOptions() {
        const a = {
            sampling: this._sampling,
            alpha: this._alpha,
            isSampled: this._isSampled
        };
        this._isDefaultSize || (a.width = this._width,
        a.height = this._height);
        return a
    }
    IsCompatibleWithOptions(a) {
        a = Object.assign({}, DEFAULT_RENDERTARGET_OPTIONS, a);
        return "nearest" !== a.sampling !== this.IsLinearSampling() || !!a.alpha !== this.HasAlpha() || !!a.depth !== this.HasDepthBuffer() || 2 <= this._renderer.GetWebGLVersionNumber() && !!a.isSampled !== this.IsSampled() ? !1 : "number" === typeof a.width || "number" === typeof a.height ? !this.IsDefaultSize() && this.GetWidth() === Math.floor(a.width) && this.GetHeight() === Math.floor(a.height) : this.IsDefaultSize()
    }
    _GetWebGLTexture() {
        return this._texture ? this._texture._GetTexture() : null
    }
    GetEstimatedMemoryUsage() {
        return this._texture ? this._texture.GetEstimatedMemoryUsage() : this._width * this._height * (this._alpha ? 4 : 3)
    }
    static async DebugReadPixelsToBlob(a, b) {
        a = await a.ReadBackRenderTargetToImageData(b, !0);
        return await C3$jscomp$50.ImageDataToBlob(a)
    }
    static OnContextLost() {
        allRenderTargets.clear()
    }
    static allRenderTargets() {
        return allRenderTargets.values()
    }
    static ResizeAll(a, b) {
        for (const c of allRenderTargets)
            c.IsDefaultSize() && c._Resize(a, b)
    }
}
;
"use strict";
const C3$jscomp$51 = self.C3
  , RESERVED_UNIFORM_NAMES = new Set("aPos aTex aPoints matP matMV samplerFront samplerBack samplerDepth destStart destEnd srcStart srcEnd srcOriginStart srcOriginEnd pixelSize seconds devicePixelRatio layerScale layerAngle layoutStart layoutEnd color color2_ pointTexStart pointTexEnd zElevation tileSize tileSpacing outlineThickness zNear zFar".split(" "));
C3$jscomp$51.Gfx.WebGLShaderProgram = class extends C3$jscomp$51.Gfx.ShaderProgramBase {
    static async Compile(a, b) {
        const c = a.GetContext();
        var d = b.src;
        const e = b.vertexSrc
          , f = b.name;
        b = c.createShader(c.FRAGMENT_SHADER);
        c.shaderSource(b, d);
        c.compileShader(b);
        d = c.createShader(c.VERTEX_SHADER);
        c.shaderSource(d, e);
        c.compileShader(d);
        const h = c.createProgram();
        c.attachShader(h, b);
        c.attachShader(h, d);
        c.bindAttribLocation(h, 0, "aPos");
        c.bindAttribLocation(h, 1, "aTex");
        c.bindAttribLocation(h, 2, "aPoints");
        c.linkProgram(h);
        const l = a._GetParallelShaderCompileExtension();
        l ? await a._WaitForObjectReady( () => c.getProgramParameter(h, l.COMPLETION_STATUS_KHR)) : await C3$jscomp$51.Wait(5);
        if (!c.getShaderParameter(b, c.COMPILE_STATUS))
            throw a = c.getShaderInfoLog(b),
            c.deleteShader(b),
            c.deleteShader(d),
            c.deleteProgram(h),
            Error("Error compiling fragment shader: " + a);
        if (!c.getShaderParameter(d, c.COMPILE_STATUS))
            throw a = c.getShaderInfoLog(d),
            c.deleteShader(b),
            c.deleteShader(d),
            c.deleteProgram(h),
            Error("Error compiling vertex shader: " + a);
        if (!c.getProgramParameter(h, c.LINK_STATUS))
            throw a = c.getProgramInfoLog(h),
            c.deleteShader(b),
            c.deleteShader(d),
            c.deleteProgram(h),
            Error("Error linking shader program: " + a);
        (a = C3$jscomp$51.FilterUnprintableChars(c.getProgramInfoLog(h) || "").trim()) && !C3$jscomp$51.IsStringAllWhitespace(a) && console.info(`[WebGL] Shader program '${f}' compilation log: `, a);
        c.deleteShader(b);
        c.deleteShader(d);
        return h
    }
    static async Create(a, b) {
        const c = await C3$jscomp$51.Gfx.WebGLShaderProgram.Compile(a, b);
        return new C3$jscomp$51.Gfx.WebGLShaderProgram(a,c,b)
    }
    constructor(a, b, c) {
        super(a, c);
        const d = a.GetContext();
        var e = a.GetBatchState();
        a.EndBatch();
        d.useProgram(b);
        this._gl = d;
        this._shaderProgram = b;
        this._isDeviceTransform = "<default-device-transform>" === c.name;
        const f = d.getAttribLocation(b, "aPos")
          , h = d.getAttribLocation(b, "aTex");
        this._locAPoints = d.getAttribLocation(b, "aPoints");
        -1 !== f && (d.bindBuffer(d.ARRAY_BUFFER, a._vertexBuffer),
        d.vertexAttribPointer(f, a.GetNumVertexComponents(), d.FLOAT, !1, 0, 0),
        d.enableVertexAttribArray(f));
        -1 !== h && (d.bindBuffer(d.ARRAY_BUFFER, a._texcoordBuffer),
        d.vertexAttribPointer(h, 2, d.FLOAT, !1, 0, 0),
        d.enableVertexAttribArray(h));
        -1 !== this._locAPoints && (d.bindBuffer(d.ARRAY_BUFFER, a._pointBuffer),
        d.vertexAttribPointer(this._locAPoints, 4, d.FLOAT, !1, 0, 0),
        d.enableVertexAttribArray(this._locAPoints));
        d.bindBuffer(d.ARRAY_BUFFER, null);
        this._uMatP = new C3$jscomp$51.Gfx.WebGLShaderUniform(this,"matP","mat4");
        this._uMatMV = new C3$jscomp$51.Gfx.WebGLShaderUniform(this,"matMV","mat4");
        this._uColor = new C3$jscomp$51.Gfx.WebGLShaderUniform(this,"color","vec4");
        this._uSamplerFront = new C3$jscomp$51.Gfx.WebGLShaderUniform(this,"samplerFront","sampler");
        this._uPointTexStart = new C3$jscomp$51.Gfx.WebGLShaderUniform(this,"pointTexStart","vec2");
        this._uPointTexEnd = new C3$jscomp$51.Gfx.WebGLShaderUniform(this,"pointTexEnd","vec2");
        this._uZElevation = new C3$jscomp$51.Gfx.WebGLShaderUniform(this,"zElevation","float");
        this._uTileSize = new C3$jscomp$51.Gfx.WebGLShaderUniform(this,"tileSize","vec2");
        this._uTileSpacing = new C3$jscomp$51.Gfx.WebGLShaderUniform(this,"tileSpacing","vec2");
        this._uColor2 = new C3$jscomp$51.Gfx.WebGLShaderUniform(this,"color2_","vec4");
        this._uOutlineThickness = new C3$jscomp$51.Gfx.WebGLShaderUniform(this,"outlineThickness","float");
        this._uSamplerBack = new C3$jscomp$51.Gfx.WebGLShaderUniform(this,"samplerBack","sampler");
        this._uSamplerDepth = new C3$jscomp$51.Gfx.WebGLShaderUniform(this,"samplerDepth","sampler");
        this._uDestStart = new C3$jscomp$51.Gfx.WebGLShaderUniform(this,"destStart","vec2");
        this._uDestEnd = new C3$jscomp$51.Gfx.WebGLShaderUniform(this,"destEnd","vec2");
        this._uSrcStart = new C3$jscomp$51.Gfx.WebGLShaderUniform(this,"srcStart","vec2");
        this._uSrcEnd = new C3$jscomp$51.Gfx.WebGLShaderUniform(this,"srcEnd","vec2");
        this._uSrcOriginStart = new C3$jscomp$51.Gfx.WebGLShaderUniform(this,"srcOriginStart","vec2");
        this._uSrcOriginEnd = new C3$jscomp$51.Gfx.WebGLShaderUniform(this,"srcOriginEnd","vec2");
        this._uPixelSize = new C3$jscomp$51.Gfx.WebGLShaderUniform(this,"pixelSize","vec2");
        this._uSeconds = new C3$jscomp$51.Gfx.WebGLShaderUniform(this,"seconds","float");
        this._uDevicePixelRatio = new C3$jscomp$51.Gfx.WebGLShaderUniform(this,"devicePixelRatio","float");
        this._uLayerScale = new C3$jscomp$51.Gfx.WebGLShaderUniform(this,"layerScale","float");
        this._uLayerAngle = new C3$jscomp$51.Gfx.WebGLShaderUniform(this,"layerAngle","float");
        this._uLayoutStart = new C3$jscomp$51.Gfx.WebGLShaderUniform(this,"layoutStart","vec2");
        this._uLayoutEnd = new C3$jscomp$51.Gfx.WebGLShaderUniform(this,"layoutEnd","vec2");
        this._uZNear = new C3$jscomp$51.Gfx.WebGLShaderUniform(this,"zNear","float");
        this._uZFar = new C3$jscomp$51.Gfx.WebGLShaderUniform(this,"zFar","float");
        this._hasAnyOptionalUniforms = !!(this._uPixelSize.IsUsed() || this._uSeconds.IsUsed() || this._uSamplerBack.IsUsed() || this._uDestStart.IsUsed() || this._uDestEnd.IsUsed() || this._uSrcStart.IsUsed() || this._uSrcEnd.IsUsed() || this._uSrcOriginStart.IsUsed() || this._uSrcOriginEnd.IsUsed() || this._uDevicePixelRatio.IsUsed() || this._uLayerScale.IsUsed() || this._uLayerAngle.IsUsed() || this._uLayoutStart.IsUsed() || this._uLayoutEnd.IsUsed());
        b = c.parameters || [];
        this._uCustomParameters = [];
        this._usesAnySrcRectOrPixelSize = this._uPixelSize.IsUsed() || this._uSrcStart.IsUsed() || this._uSrcEnd.IsUsed() || this._uSrcOriginStart.IsUsed() || this._uSrcOriginEnd.IsUsed();
        this._hasCurrentMatMV = this._hasCurrentMatP = !1;
        this._uColor.Init4f(1, 1, 1, 1);
        this._uColor2.Init4f(1, 1, 1, 1);
        this._uSamplerFront.Init1i(0);
        this._uSamplerBack.Init1i(1);
        this._uSamplerDepth.Init1i(2);
        this._uPointTexStart.Init2f(0, 0);
        this._uPointTexEnd.Init2f(1, 1);
        this._uZElevation.Init1f(0);
        this._uTileSize.Init2f(0, 0);
        this._uTileSpacing.Init2f(0, 0);
        this._uDestStart.Init2f(0, 0);
        this._uDestEnd.Init2f(1, 1);
        this._uSrcStart.Init2f(0, 0);
        this._uSrcEnd.Init2f(0, 0);
        this._uSrcOriginStart.Init2f(0, 0);
        this._uSrcOriginEnd.Init2f(0, 0);
        this._uPixelSize.Init2f(0, 0);
        this._uDevicePixelRatio.Init1f(1);
        this._uZNear.Init1f(a.GetNearZ());
        this._uZFar.Init1f(a.GetFarZ());
        this._uLayerScale.Init1f(1);
        this._uLayerAngle.Init1f(0);
        this._uSeconds.Init1f(0);
        this._uLayoutStart.Init2f(0, 0);
        this._uLayoutEnd.Init2f(0, 0);
        this._uOutlineThickness.Init1f(1);
        for (const l of b)
            a = l[2],
            b = new C3$jscomp$51.Gfx.WebGLShaderUniform(this,l[0],a),
            "color" === a ? b.Init3f(0, 0, 0) : b.Init1f(0),
            this._uCustomParameters.push(b);
        this._isDeviceTransform ? this._UpdateDeviceTransformUniforms(e.currentMatP) : (this.UpdateMatP(e.currentMatP, !0),
        this.UpdateMatMV(e.currentMV, !0));
        e = e.currentShader;
        d.useProgram(e ? e._shaderProgram : null)
    }
    Release() {
        this._gl.deleteProgram(this._shaderProgram);
        this._shaderProgram = null;
        this._renderer._RemoveShaderProgram(this);
        this._gl = null;
        super.Release()
    }
    GetWebGLContext() {
        return this._gl
    }
    GetShaderProgram() {
        return this._shaderProgram
    }
    GetParameterCount() {
        return this._uCustomParameters.length
    }
    GetParameterType(a) {
        return 0 > a || a >= this._uCustomParameters.length ? null : this._uCustomParameters[a].GetType()
    }
    AreCustomParametersAlreadySetInBatch(a) {
        for (let b = 0, c = a.length; b < c; ++b)
            if (!this._uCustomParameters[b].IsSetToCustomInBatch(a[b]))
                return !1;
        return !0
    }
    SetCustomParametersInBatch(a) {
        for (let b = 0, c = a.length; b < c; ++b)
            this._uCustomParameters[b].SetBatchValueCustom(a[b])
    }
    AreOptionalUniformsAlreadySetInBatch(a, b, c, d, e, f, h, l, m, p) {
        return this._uSamplerBack.IsUsed() || this._uPixelSize.IsUsed() && !this._uPixelSize.IsSetTo2InBatch(e, f) || this._uDestStart.IsUsed() && !this._uDestStart.IsSetTo2InBatch(a.getLeft(), a.getTop()) || this._uDestEnd.IsUsed() && !this._uDestEnd.IsSetTo2InBatch(a.getRight(), a.getBottom()) || this._uDevicePixelRatio.IsUsed() && !this._uDevicePixelRatio.IsSetTo1InBatch(h) || this._uLayerScale.IsUsed() && !this._uLayerScale.IsSetTo1InBatch(l) || this._uLayerAngle.IsUsed() && !this._uLayerAngle.IsSetTo1InBatch(m) || this._uSrcStart.IsUsed() && !this._uSrcStart.IsSetTo2InBatch(b.getLeft(), b.getTop()) || this._uSrcEnd.IsUsed() && !this._uSrcEnd.IsSetTo2InBatch(b.getRight(), b.getBottom()) || this._uSrcOriginStart.IsUsed() && !this._uSrcOriginStart.IsSetTo2InBatch(c.getLeft(), c.getTop()) || this._uSrcOriginEnd.IsUsed() && !this._uSrcOriginEnd.IsSetTo2InBatch(c.getRight(), c.getBottom()) || this._uLayoutStart.IsUsed() && !this._uLayoutStart.IsSetTo2InBatch(d.getLeft(), d.getTop()) || this._uLayoutEnd.IsUsed() && !this._uLayoutEnd.IsSetTo2InBatch(d.getTop(), d.getBottom()) || this._uSeconds.IsUsed() && !this._uSeconds.IsSetTo1InBatch(p) ? !1 : !0
    }
    SetOptionalUniformsInBatch(a, b, c, d, e, f, h, l, m, p) {
        this._uSamplerBack.IsUsed() || (this._uPixelSize.IsUsed() && this._uPixelSize.SetBatch2(e, f),
        this._uDestStart.IsUsed() && this._uDestStart.SetBatch2(a.getLeft(), a.getTop()),
        this._uDestEnd.IsUsed() && this._uDestEnd.SetBatch2(a.getRight(), a.getBottom()),
        this._uDevicePixelRatio.IsUsed() && this._uDevicePixelRatio.SetBatch1(h),
        this._uLayerScale.IsUsed() && this._uLayerScale.SetBatch1(l),
        this._uLayerAngle.IsUsed() && this._uLayerAngle.SetBatch1(m),
        this._uSrcStart.IsUsed() && this._uSrcStart.SetBatch2(b.getLeft(), b.getTop()),
        this._uSrcEnd.IsUsed() && this._uSrcEnd.SetBatch2(b.getRight(), b.getBottom()),
        this._uSrcOriginStart.IsUsed() && this._uSrcOriginStart.SetBatch2(c.getLeft(), c.getTop()),
        this._uSrcOriginEnd.IsUsed() && this._uSrcOriginEnd.SetBatch2(c.getRight(), c.getBottom()),
        this._uLayoutStart.IsUsed() && this._uLayoutStart.SetBatch2(d.getLeft(), d.getTop()),
        this._uLayoutEnd.IsUsed() && this._uLayoutEnd.SetBatch2(d.getTop(), d.getBottom()),
        this._uSeconds.IsUsed() && this._uSeconds.SetBatch1(p))
    }
    UpdateMatP(a, b) {
        this._hasCurrentMatP && !b || this._isDeviceTransform || (this._uMatP.IsUsed() && this._uMatP.UpdateMatrix4fv(a),
        this._hasCurrentMatP = !0)
    }
    SetMatPStale() {
        this._hasCurrentMatP = !1
    }
    UpdateMatMV(a, b) {
        this._hasCurrentMatMV && !b || this._isDeviceTransform || (this._uMatMV.IsUsed() && this._uMatMV.UpdateMatrix4fv(a),
        this._hasCurrentMatMV = !0)
    }
    SetMatMVStale() {
        this._hasCurrentMatMV = !1
    }
    _UpdateDeviceTransformUniforms(a) {
        if (!this._isDeviceTransform)
            throw Error("not device transform shader");
        this._uMatP.UpdateMatrix4fv(a);
        a = this._renderer;
        const b = a.GetWidth() / 2
          , c = a.GetHeight() / 2;
        a = a.CalculateLookAtModelView2(b, c, a.GetDefaultCameraZ(a.GetHeight()), b, c, 0, a.GetHeight());
        this._uMatMV.UpdateMatrix4fv(a)
    }
    UpdateColor(a) {
        this._uColor.IsUsed() && this._uColor.Update4f(a[0], a[1], a[2], a[3])
    }
    static GetReservedUniformNames() {
        return RESERVED_UNIFORM_NAMES
    }
    static GetDefaultVertexShaderSource(a) {
        a = a ? "highmedp" : "mediump";
        return ["#ifdef GL_FRAGMENT_PRECISION_HIGH\n#define highmedp highp\n#else\n#define highmedp mediump\n#endif\nattribute highp vec3 aPos;", `attribute ${a} vec2 aTex;`, `varying ${a} vec2 vTex;`, "uniform highp mat4 matP;\nuniform highp mat4 matMV;\nvoid main(void) {\n\tgl_Position = matP * matMV * vec4(aPos, 1.0);\n\tvTex = aTex;\n}"].join("\n")
    }
    static GetDefaultVertexShaderSource_WebGL2(a) {
        a = a ? "highp" : "mediump";
        return ["#version 300 es\nin highp vec3 aPos;", `in ${a} vec2 aTex;`, `out ${a} vec2 vTex;`, "uniform highp mat4 matP;\nuniform highp mat4 matMV;\nvoid main(void) {\n\tgl_Position = matP * matMV * vec4(aPos, 1.0);\n\tvTex = aTex;\n}"].join("\n")
    }
    static GetTextureFillFragmentShaderSource_WebGL1_NoFragDepth() {
        return "varying mediump vec2 vTex;\nuniform lowp vec4 color;\nuniform lowp sampler2D samplerFront;\nvoid main(void) {\n\tgl_FragColor = texture2D(samplerFront, vTex) * color;\n}"
    }
    static GetTextureFillFragmentShaderSource_WebGL1_FragDepthEXT() {
        return "#extension GL_EXT_frag_depth : enable\nvarying mediump vec2 vTex;\nuniform lowp vec4 color;\nuniform lowp sampler2D samplerFront;\nvoid main(void) {\n\tgl_FragColor = texture2D(samplerFront, vTex) * color;\n\tgl_FragDepthEXT = (gl_FragColor.a == 0.0 ? 1.0 : gl_FragCoord.z);\n}"
    }
    static GetTextureFillFragmentShaderSource_WebGL2() {
        return "#version 300 es\nin mediump vec2 vTex;\nout lowp vec4 outColor;\nuniform lowp vec4 color;\nuniform lowp sampler2D samplerFront;\nvoid main(void) {\n\toutColor = texture(samplerFront, vTex) * color;\n\tgl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);\n}"
    }
    static GetTilemapFragmentShaderSource_WebGL1_NoFragDepth() {
        return "#ifdef GL_FRAGMENT_PRECISION_HIGH\n#define highmedp highp\n#else\n#define highmedp mediump\n#endif\nvarying highmedp vec2 vTex;\nuniform lowp vec4 color;\nuniform lowp sampler2D samplerFront;\nuniform highmedp vec2 srcStart;\nuniform highmedp vec2 pixelSize;\nuniform highmedp vec2 tileSize;\nuniform highmedp vec2 tileSpacing;\nvoid main(void) {\n\thighmedp vec2 tile = floor(vTex);\n\thighmedp vec2 tex = fract(vTex);\n\thighmedp vec2 tileOrigin = srcStart + tile * (tileSize + tileSpacing);\n\thighmedp vec2 lowerBound = tileOrigin + pixelSize / 2.0;\n\thighmedp vec2 upperBound = tileOrigin + tileSize - pixelSize / 2.0;\n\tgl_FragColor = texture2D(samplerFront, clamp(tex, lowerBound, upperBound), -16.0) * color;\n}"
    }
    static GetTilemapFragmentShaderSource_WebGL1_FragDepthEXT() {
        return "#extension GL_EXT_frag_depth : enable\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n#define highmedp highp\n#else\n#define highmedp mediump\n#endif\nvarying highmedp vec2 vTex;\nuniform lowp vec4 color;\nuniform lowp sampler2D samplerFront;\nuniform highmedp vec2 srcStart;\nuniform highmedp vec2 pixelSize;\nuniform highmedp vec2 tileSize;\nuniform highmedp vec2 tileSpacing;\nvoid main(void) {\n\thighmedp vec2 tile = floor(vTex);\n\thighmedp vec2 tex = fract(vTex);\n\thighmedp vec2 tileOrigin = srcStart + tile * (tileSize + tileSpacing);\n\thighmedp vec2 lowerBound = tileOrigin + pixelSize / 2.0;\n\thighmedp vec2 upperBound = tileOrigin + tileSize - pixelSize / 2.0;\n\tgl_FragColor = texture2D(samplerFront, clamp(tex, lowerBound, upperBound), -16.0) * color;\n\tgl_FragDepthEXT = (gl_FragColor.a == 0.0 ? 1.0 : gl_FragCoord.z);\n}"
    }
    static GetTilemapFragmentShaderSource_WebGL2() {
        return "#version 300 es\nin highp vec2 vTex;\nout lowp vec4 outColor;\nuniform lowp vec4 color;\nuniform lowp sampler2D samplerFront;\nuniform highp vec2 srcStart;\nuniform highp vec2 pixelSize;\nuniform highp vec2 tileSize;\nuniform highp vec2 tileSpacing;\nvoid main(void) {\n\thighp vec2 tile = floor(vTex);\n\thighp vec2 tex = fract(vTex);\n\thighp vec2 tileOrigin = srcStart + tile * (tileSize + tileSpacing);\n\thighp vec2 lowerBound = tileOrigin + pixelSize / 2.0;\n\thighp vec2 upperBound = tileOrigin + tileSize - pixelSize / 2.0;\n\toutColor = texture(samplerFront, clamp(tex, lowerBound, upperBound), -16.0) * color;\n\tgl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);\n}"
    }
    static GetTileRandomizationFragmentShaderSource(a, b, c) {
        let d = "";
        2 <= a ? d = "#version 300 es\n" : (b && (d = "#extension GL_EXT_frag_depth : enable\n"),
        c && (d += "#extension GL_EXT_shader_texture_lod : enable\n#extension GL_OES_standard_derivatives : enable\n"));
        return d + `
#ifdef GL_FRAGMENT_PRECISION_HIGH
#define highmedp highp
#else
#define highmedp mediump
#endif
precision highmedp float;
${2 <= a ? "in" : "varying"} vec2 vTex;
${2 <= a ? "out lowp vec4 outColor;" : ""}
uniform lowp vec4 color;
uniform lowp sampler2D samplerFront;
uniform vec2 pixelSize;

uniform vec2 tileSize;
uniform vec2 tileSpacing;
uniform float outlineThickness;

const float PI = 3.1415926;

lowp vec4 cospVec4(lowp vec4 a, lowp vec4 b, float x)
{
	return (a + b + (a - b) * cos(x * PI)) / 2.0;
}

vec3 randVec3(vec2 seed)
{
	return vec3(fract(sin(dot(seed.xy + vec2(0.1, 0.1), vec2(12.9898,78.233))) * 43758.5453),
				fract(sin(dot(seed.yx + vec2(0.1, 0.1), vec2(12.9898,-78.233))) * 43758.5453),
				fract(sin(dot(seed.xy + vec2(0.1, 0.1), vec2(-12.9898,-78.233))) * 43758.5453));
}

lowp vec4 sampleTile(vec2 tile, vec2 uv, vec2 ddx, vec2 ddy)
{
	vec2 posRandom = tileSize;
	float angleRandom = outlineThickness;
	
	vec3 rand = (randVec3(floor(tile + 0.5)) - 0.5) * 2.0;
	
	float angle = angleRandom * rand.z * PI;
	float sin_a = sin(angle);
	float cos_a = cos(angle);
	float aspect = pixelSize.x / pixelSize.y;

	vec2 mid = tile + vec2(0.5, 0.5);
	vec2 dp = uv - mid;
	dp.x /= aspect;
	vec2 r = vec2(dp.x * cos_a - dp.y * sin_a,
				  dp.y * cos_a + dp.x * sin_a);
	r.x *= aspect;

	vec2 p = mid + r + (posRandom * rand.xy / 2.0);
	
	${2 <= a ? "return textureGrad(samplerFront, p, ddx, ddy);" : ""}
	${2 > a && c ? "return texture2DGradEXT(samplerFront, p, ddx, ddy);" : ""}
	${2 > a && !c ? "return texture2D(samplerFront, p);" : ""}
}

void main(void) {
	
	${2 > a ? "lowp vec4 outColor;" : ""}
	
	float blendMarginX = tileSpacing.x;
	float blendMarginY = tileSpacing.y;
	
	vec2 tile = floor(vTex);
	vec2 tex = fract(vTex);
	vec2 ddx = ${2 <= a || c ? "dFdx(vTex)" : "vec2(0.0, 0.0)"};
	vec2 ddy = ${2 <= a || c ? "dFdy(vTex)" : "vec2(0.0, 0.0)"};
	
	vec4 curTile = sampleTile(tile, vTex, ddx, ddy);
	
	bool inLeftMargin = (tex.x < blendMarginX);
	bool inRightMargin = (tex.x > 1.0 - blendMarginX);
	bool inTopMargin = (tex.y < blendMarginY);
	bool inBottomMargin = (tex.y > 1.0 - blendMarginY);
	
	if (inLeftMargin)
	{
		lowp vec4 leftTile = sampleTile(tile + vec2(-1.0, 0.0), vTex, ddx, ddy);
		float leftMix = (tex.x / (blendMarginX * 2.0)) + 0.5;
		lowp vec4 leftMixedTile = cospVec4(leftTile, curTile, leftMix);
		
		if (inTopMargin)
		{
			lowp vec4 topTile =     sampleTile(tile + vec2(0.0,  -1.0), vTex, ddx, ddy);
			lowp vec4 topLeftTile = sampleTile(tile + vec2(-1.0, -1.0), vTex, ddx, ddy);
			lowp vec4 topLeftMixedTile = cospVec4(topLeftTile, topTile, leftMix);
			
			outColor = cospVec4(topLeftMixedTile, leftMixedTile, (tex.y / (blendMarginY * 2.0)) + 0.5);
		}
		else if (inBottomMargin)
		{
			lowp vec4 bottomTile =     sampleTile(tile + vec2(0.0,  1.0), vTex, ddx, ddy);
			lowp vec4 bottomLeftTile = sampleTile(tile + vec2(-1.0, 1.0), vTex, ddx, ddy);
			lowp vec4 bottomLeftMixedTile = cospVec4(bottomLeftTile, bottomTile, leftMix);
			
			outColor = cospVec4(leftMixedTile, bottomLeftMixedTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));
		}
		else
		{
			outColor = leftMixedTile;
		}
	}
	else if (inRightMargin)
	{
		lowp vec4 rightTile = sampleTile(tile + vec2(1.0, 0.0), vTex, ddx, ddy);
		float rightMix = (tex.x - (1.0 - blendMarginX)) / (blendMarginX * 2.0);
		lowp vec4 rightMixedTile = cospVec4(curTile, rightTile, rightMix);
		
		if (inTopMargin)
		{
			lowp vec4 topTile =      sampleTile(tile + vec2(0.0, -1.0), vTex, ddx, ddy);
			lowp vec4 topRightTile = sampleTile(tile + vec2(1.0, -1.0), vTex, ddx, ddy);
			lowp vec4 topRightMixedTile = cospVec4(topTile, topRightTile, rightMix);
			
			outColor = cospVec4(topRightMixedTile, rightMixedTile, (tex.y / (blendMarginY * 2.0)) + 0.5);
		}
		else if (inBottomMargin)
		{
			lowp vec4 bottomTile =      sampleTile(tile + vec2(0.0, 1.0), vTex, ddx, ddy);
			lowp vec4 bottomRightTile = sampleTile(tile + vec2(1.0, 1.0), vTex, ddx, ddy);
			lowp vec4 bottomRightMixedTile = cospVec4(bottomTile, bottomRightTile, rightMix);
			
			outColor = cospVec4(rightMixedTile, bottomRightMixedTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));
		}
		else
		{
			outColor = rightMixedTile;
		}
	}
	else if (inTopMargin)
	{
		lowp vec4 topTile = sampleTile(tile + vec2(0.0, -1.0), vTex, ddx, ddy);
		outColor = cospVec4(topTile, curTile, (tex.y / (blendMarginY * 2.0)) + 0.5);
	}
	else if (inBottomMargin)
	{
		lowp vec4 bottomTile = sampleTile(tile + vec2(0.0, 1.0), vTex, ddx, ddy);
		outColor = cospVec4(curTile, bottomTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));
	}
	else
	{
		outColor = curTile;
	}
	
	outColor *= color;
	${2 > a ? "gl_FragColor = outColor;" : ""}
	${2 <= a ? "gl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);" : ""}
	${2 > a && b ? "gl_FragDepthEXT = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);" : ""}
}
`
    }
    static GetPointVertexShaderSource_WebGL1() {
        return "attribute vec4 aPoints;\nvarying float pointOpacity;\nuniform float zElevation;\nuniform mat4 matP;\nuniform mat4 matMV;\nvoid main(void) {\n\tgl_Position = matP * matMV * vec4(aPoints.xy, zElevation, 1.0);\n\tgl_PointSize = aPoints.z;\n\tpointOpacity = aPoints.w;\n}"
    }
    static GetPointVertexShaderSource_WebGL2() {
        return "#version 300 es\nin vec4 aPoints;\nout float pointOpacity;\nuniform float zElevation;\nuniform mat4 matP;\nuniform mat4 matMV;\nvoid main(void) {\n\tgl_Position = matP * matMV * vec4(aPoints.xy, zElevation, 1.0);\n\tgl_PointSize = aPoints.z;\n\tpointOpacity = aPoints.w;\n}"
    }
    static GetPointFragmentShaderSource_WebGL1_NoFragDepth() {
        return "uniform lowp sampler2D samplerFront;\nvarying lowp float pointOpacity;\nuniform mediump vec2 pointTexStart;\nuniform mediump vec2 pointTexEnd;\nuniform lowp vec4 color;\nvoid main(void) {\n\tmediump vec2 pointTexMin = min(pointTexStart, pointTexEnd);\n\tmediump vec2 pointTexMax = max(pointTexStart, pointTexEnd);\n\tmediump vec2 pointCoord = (pointTexEnd.x > pointTexStart.x ? gl_PointCoord : vec2(1.0 - gl_PointCoord.y, gl_PointCoord.x));\n\tgl_FragColor = texture2D(samplerFront, mix(pointTexMin, pointTexMax, pointCoord)) * color * pointOpacity;\n}"
    }
    static GetPointFragmentShaderSource_WebGL1_FragDepthEXT() {
        return "#extension GL_EXT_frag_depth : enable\nuniform lowp sampler2D samplerFront;\nvarying lowp float pointOpacity;\nuniform mediump vec2 pointTexStart;\nuniform mediump vec2 pointTexEnd;\nuniform lowp vec4 color;\nvoid main(void) {\n\tmediump vec2 pointTexMin = min(pointTexStart, pointTexEnd);\n\tmediump vec2 pointTexMax = max(pointTexStart, pointTexEnd);\n\tmediump vec2 pointCoord = (pointTexEnd.x > pointTexStart.x ? gl_PointCoord : vec2(1.0 - gl_PointCoord.y, gl_PointCoord.x));\n\tgl_FragColor = texture2D(samplerFront, mix(pointTexMin, pointTexMax, pointCoord)) * color * pointOpacity;\n\tgl_FragDepthEXT = (gl_FragColor.a == 0.0 ? 1.0 : gl_FragCoord.z);\n}"
    }
    static GetPointFragmentShaderSource_WebGL2() {
        return "#version 300 es\nuniform lowp sampler2D samplerFront;\nin lowp float pointOpacity;\nuniform mediump vec2 pointTexStart;\nuniform mediump vec2 pointTexEnd;\nuniform lowp vec4 color;\nout lowp vec4 outColor;\nvoid main(void) {\n\tmediump vec2 pointTexMin = min(pointTexStart, pointTexEnd);\n\tmediump vec2 pointTexMax = max(pointTexStart, pointTexEnd);\n\tmediump vec2 pointCoord = (pointTexEnd.x > pointTexStart.x ? gl_PointCoord : vec2(1.0 - gl_PointCoord.y, gl_PointCoord.x));\n\toutColor = texture(samplerFront, mix(pointTexMin, pointTexMax, pointCoord)) * color * pointOpacity;\n\tgl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);\n}"
    }
    static GetColorFillFragmentShaderSource() {
        return "uniform lowp vec4 color;\nvoid main(void) {\n\tgl_FragColor = color;\n}"
    }
    static GetLinearGradientFillFragmentShaderSource() {
        return "precision lowp float;\nvarying mediump vec2 vTex;\nuniform vec4 color;\nuniform vec4 color2_;\nvec3 fromLinear(vec3 linearRGB)\n{\n\tbvec3 cutoff = lessThan(linearRGB, vec3(0.0031308));\n\tvec3 higher = vec3(1.055) * pow(abs(linearRGB), vec3(1.0/2.4)) - vec3(0.055);\n\tvec3 lower = linearRGB * vec3(12.92);\n\treturn mix(higher, lower, vec3(cutoff));\n}\nvec3 toLinear(vec3 sRGB)\n{\n\tbvec3 cutoff = lessThan(sRGB, vec3(0.04045));\n\tvec3 higher = pow(abs((sRGB + vec3(0.055))/vec3(1.055)), vec3(2.4));\n\tvec3 lower = sRGB/vec3(12.92);\n\treturn mix(higher, lower, vec3(cutoff));\n}\nvoid main(void) {\n\tvec3 linearGrad = mix(toLinear(color.rgb), toLinear(color2_.rgb), vTex.x);\n\tfloat a = mix(color.a, color2_.a, vTex.x);\n\tgl_FragColor = vec4(fromLinear(linearGrad) * a, a);\n}"
    }
    static GetPenumbraFillFragmentShaderSource() {
        return "#ifdef GL_FRAGMENT_PRECISION_HIGH\n#define highmedp highp\n#else\n#define highmedp mediump\n#endif\nprecision lowp float;\nvarying highmedp vec2 vTex;\nuniform vec4 color;\nvoid main(void) {\n\thighmedp float grad = vTex.x / (1.0 - vTex.y);\n\tgl_FragColor = color * (1.0 - (cos(grad * 3.141592653589793) + 1.0) / 2.0);\n}"
    }
    static GetSmoothLineFillFragmentShaderSource() {
        return "varying mediump vec2 vTex;\nuniform lowp vec4 color;\nvoid main(void) {\n\tlowp float f = 1.0 - abs(vTex.y - 0.5) * 2.0;\n\tgl_FragColor = color * f;\n}"
    }
    static GetHardEllipseFillFragmentShaderSource() {
        return "varying mediump vec2 vTex;\nuniform lowp vec4 color;\nvoid main(void) {\n\tmediump vec2 diff = vTex - vec2(0.5, 0.5);\n\tmediump vec2 diffSq = diff * diff;\n\tmediump float f = step(diffSq.x + diffSq.y, 0.25);\n\tgl_FragColor = color * f;\n}"
    }
    static GetHardEllipseOutlineFragmentShaderSource() {
        return "varying mediump vec2 vTex;\nuniform lowp vec4 color;\nuniform mediump vec2 pixelSize;\nuniform mediump float outlineThickness;\nvoid main(void) {\n\tmediump vec2 diff = vTex - vec2(0.5, 0.5);\n\tmediump vec2 diffSq = diff * diff;\n\tmediump float distSq = diffSq.x + diffSq.y;\n\tmediump vec2 norm = normalize(diff);\n\tmediump vec2 halfNorm = norm * 0.5;\n\tmediump float innerF = step(distSq, 0.25);\n\tmediump vec2 innerEdge = halfNorm - pixelSize * norm * outlineThickness;\n\tmediump vec2 innerEdgeSq = innerEdge * innerEdge;\n\tmediump float outerF = step(innerEdgeSq.x + innerEdgeSq.y, distSq);\n\tgl_FragColor = color * innerF * outerF;\n}"
    }
    static GetSmoothEllipseFillFragmentShaderSource() {
        return "varying mediump vec2 vTex;\nuniform lowp vec4 color;\nuniform mediump vec2 pixelSize;\nvoid main(void) {\n\tmediump vec2 diff = vTex - vec2(0.5, 0.5);\n\tmediump vec2 diffSq = diff * diff;\n\tmediump vec2 norm = normalize(diff);\n\tmediump vec2 halfNorm = norm * 0.5;\n\tmediump vec2 halfNormSq = halfNorm * halfNorm;\n\tmediump vec2 innerEdge = halfNorm - pixelSize * norm;\n\tmediump vec2 innerEdgeSq = innerEdge * innerEdge;\n\tmediump float f = smoothstep(halfNormSq.x + halfNormSq.y, innerEdgeSq.x + innerEdgeSq.y, diffSq.x + diffSq.y);\n\tgl_FragColor = color * f;\n}"
    }
    static GetSmoothEllipseOutlineFragmentShaderSource() {
        return "varying mediump vec2 vTex;\nuniform lowp vec4 color;\nuniform mediump vec2 pixelSize;\nuniform mediump float outlineThickness;\nvoid main(void) {\n\tmediump vec2 diff = vTex - vec2(0.5, 0.5);\n\tmediump vec2 diffSq = diff * diff;\n\tmediump float distSq = diffSq.x + diffSq.y;\n\tmediump vec2 norm = normalize(diff);\n\tmediump vec2 halfNorm = norm * 0.5;\n\tmediump vec2 halfNormSq = halfNorm * halfNorm;\n\tmediump vec2 pxNorm = pixelSize * norm;\n\tmediump vec2 innerEdge1 = halfNorm - pxNorm;\n\tmediump vec2 innerEdge1Sq = innerEdge1 * innerEdge1;\n\tmediump float innerF = smoothstep(halfNormSq.x + halfNormSq.y, innerEdge1Sq.x + innerEdge1Sq.y, distSq);\n\tmediump vec2 innerEdge2 = halfNorm - pxNorm * outlineThickness;\n\tmediump vec2 innerEdge2Sq = innerEdge2 * innerEdge2;\n\tmediump vec2 innerEdge3 = halfNorm - pxNorm * (outlineThickness + 1.0);\n\tmediump vec2 innerEdge3Sq = innerEdge3 * innerEdge3;\n\tmediump float outerF = smoothstep(innerEdge3Sq.x + innerEdge3Sq.y, innerEdge2Sq.x + innerEdge2Sq.y, distSq);\n\tgl_FragColor = color * innerF * outerF;\n}"
    }
}
;
"use strict";
const C3$jscomp$52 = self.C3
  , mat4$jscomp$5 = self.glMatrix.mat4
  , TYPE_SIZES = new Map([["float", 1], ["percent", 1], ["sampler", 1], ["vec2", 2], ["vec3", 3], ["color", 3], ["vec4", 4], ["mat4", 16]]);
C3$jscomp$52.Gfx.WebGLShaderUniform = class {
    constructor(a, b, c) {
        if (!TYPE_SIZES.has(c))
            throw Error("invalid uniform type");
        this._owner = a;
        this._gl = this._owner.GetWebGLContext();
        this._name = b;
        this._type = c;
        this._isColorType = "color" === this._type;
        this._location = this._gl.getUniformLocation(this._owner.GetShaderProgram(), b);
        this._isUsed = !!this._location;
        a = TYPE_SIZES.get(c);
        this._lastValue = new Float32Array(a);
        this._lastBatchValue = new Float32Array(a)
    }
    Release() {
        this._location = this._gl = this._owner = null
    }
    IsUsed() {
        return this._isUsed
    }
    GetType() {
        return this._type
    }
    IsColorType() {
        return this._isColorType
    }
    Init1f(a) {
        this.IsUsed() && (this._lastValue[0] = a,
        this._lastBatchValue.set(this._lastValue),
        this._gl.uniform1f(this._location, a))
    }
    Init1i(a) {
        this.IsUsed() && (this._lastValue[0] = a,
        this._lastBatchValue.set(this._lastValue),
        this._gl.uniform1i(this._location, a))
    }
    Init2f(a, b) {
        this.IsUsed() && (this._lastValue[0] = a,
        this._lastValue[1] = b,
        this._lastBatchValue.set(this._lastValue),
        this._gl.uniform2f(this._location, a, b))
    }
    Init3f(a, b, c) {
        this.IsUsed() && (this._lastValue[0] = a,
        this._lastValue[1] = b,
        this._lastValue[2] = c,
        this._lastBatchValue.set(this._lastValue),
        this._gl.uniform3f(this._location, a, b, c))
    }
    Init4f(a, b, c, d) {
        this.IsUsed() && (this._lastValue[0] = a,
        this._lastValue[1] = b,
        this._lastValue[2] = c,
        this._lastValue[3] = d,
        this._lastBatchValue.set(this._lastValue),
        this._gl.uniform4f(this._location, a, b, c, d))
    }
    Update1f(a) {
        a = Math.fround(a);
        const b = this._lastValue;
        b[0] !== a && (b[0] = a,
        this._gl.uniform1f(this._location, a))
    }
    Update1i(a) {
        const b = this._lastValue;
        b[0] !== a && (b[0] = a,
        this._gl.uniform1i(this._location, a))
    }
    Update2f(a, b) {
        a = Math.fround(a);
        b = Math.fround(b);
        const c = this._lastValue;
        if (c[0] !== a || c[1] !== b)
            c[0] = a,
            c[1] = b,
            this._gl.uniform2f(this._location, a, b)
    }
    Update3f(a, b, c) {
        a = Math.fround(a);
        b = Math.fround(b);
        c = Math.fround(c);
        const d = this._lastValue;
        if (d[0] !== a || d[1] !== b || d[2] !== c)
            d[0] = a,
            d[1] = b,
            d[2] = c,
            this._gl.uniform3f(this._location, a, b, c)
    }
    Update4f(a, b, c, d) {
        a = Math.fround(a);
        b = Math.fround(b);
        c = Math.fround(c);
        d = Math.fround(d);
        const e = this._lastValue;
        if (e[0] !== a || e[1] !== b || e[2] !== c || e[3] !== d)
            e[0] = a,
            e[1] = b,
            e[2] = c,
            e[3] = d,
            this._gl.uniform4f(this._location, a, b, c, d)
    }
    UpdateMatrix4fv(a) {
        const b = this._lastValue;
        mat4$jscomp$5.exactEquals(b, a) || (C3$jscomp$52.typedArraySet16(b, a, 0),
        this._gl.uniformMatrix4fv(this._location, !1, a))
    }
    IsSetToCustomInBatch(a) {
        const b = this._lastBatchValue;
        return this.IsColorType() ? b[0] === Math.fround(a.getR()) && b[1] === Math.fround(a.getG()) && b[2] === Math.fround(a.getB()) : b[0] === Math.fround(a)
    }
    SetBatchValueCustom(a) {
        const b = this._lastBatchValue;
        this.IsColorType() ? (b[0] = a.getR(),
        b[1] = a.getG(),
        b[2] = a.getB()) : b[0] = a
    }
    IsSetTo1InBatch(a) {
        return this._lastBatchValue[0] === Math.fround(a)
    }
    IsSetTo2InBatch(a, b) {
        const c = this._lastBatchValue;
        return c[0] === Math.fround(a) && c[1] === Math.fround(b)
    }
    SetBatch1(a) {
        this._lastBatchValue[0] = a
    }
    SetBatch2(a, b) {
        const c = this._lastBatchValue;
        c[0] = a;
        c[1] = b
    }
}
;
"use strict";
const C3$jscomp$53 = self.C3
  , glMatrix$jscomp$5 = self.glMatrix
  , vec4$jscomp$3 = glMatrix$jscomp$5.vec4
  , mat4$jscomp$6 = glMatrix$jscomp$5.mat4;
C3$jscomp$53.Gfx.BatchState = class {
    constructor(a) {
        this.renderer = a;
        this.currentMV = mat4$jscomp$6.create();
        this.currentMatP = mat4$jscomp$6.create();
        this.currentFramebufferNoDepth = this.currentFramebuffer = null;
        this.isDepthSamplingEnabled = !1;
        this.currentColor = vec4$jscomp$3.fromValues(1, 1, 1, 1);
        this.currentShader = null;
        this.pointTexCoords = new C3$jscomp$53.Rect;
        this.clearColor = C3$jscomp$53.New(C3$jscomp$53.Color, 0, 0, 0, 0)
    }
}
;
C3$jscomp$53.Gfx.WebGLBatchJob = class {
    constructor(a) {
        const b = new ArrayBuffer(96);
        this._type = 0;
        this._batchState = a;
        this._gl = a.renderer.GetContext();
        this._indexCount = this._startIndex = 0;
        this._texParam = null;
        this._mat4param = new Float32Array(b,0,16);
        this._colorParam = new Float32Array(b,64,4);
        this._srcOriginRect = new Float32Array(b,80,4);
        this._shaderParams = []
    }
    InitQuad(a, b) {
        this._type = 1;
        this._startIndex = a;
        this._indexCount = b
    }
    DoQuad() {
        const a = this._gl;
        a.drawElements(a.TRIANGLES, this._indexCount, a.UNSIGNED_SHORT, this._startIndex)
    }
    InitSetTexture(a) {
        this._type = 2;
        this._texParam = a
    }
    DoSetTexture() {
        const a = this._gl
          , b = this._texParam;
        a.bindTexture(a.TEXTURE_2D, b ? b._GetTexture() : null)
    }
    InitSetColor(a) {
        this._type = 3;
        a.writeToTypedArray(this._colorParam, 0)
    }
    DoSetColor() {
        const a = this._colorParam
          , b = this._batchState;
        vec4$jscomp$3.copy(b.currentColor, a);
        b.currentShader.UpdateColor(a)
    }
    InitSetGradientColor(a) {
        this._type = 21;
        a.writeToTypedArray(this._colorParam, 0)
    }
    DoSetGradientColor() {
        const a = this._colorParam
          , b = this._batchState.currentShader;
        b._uColor2.IsUsed() && b._uColor2.Update4f(a[0], a[1], a[2], a[3])
    }
    InitSetBlend(a, b) {
        this._type = 4;
        this._startIndex = a;
        this._indexCount = b
    }
    DoSetBlend() {
        this._gl.blendFunc(this._startIndex, this._indexCount)
    }
    InitSetViewport(a, b, c, d) {
        this._type = 5;
        const e = this._colorParam;
        e[0] = a;
        e[1] = b;
        e[2] = c;
        e[3] = d
    }
    DoSetViewport() {
        const a = this._colorParam;
        this._gl.viewport(a[0], a[1], a[2], a[3])
    }
    InitSetProjection(a) {
        this._type = 6;
        mat4$jscomp$6.copy(this._mat4param, a)
    }
    DoSetProjection() {
        const a = this._batchState
          , b = a.renderer._allShaderPrograms
          , c = a.currentShader
          , d = this._mat4param;
        for (let e = 0, f = b.length; e < f; ++e) {
            const h = b[e];
            h === c ? h.UpdateMatP(d, !0) : h.SetMatPStale()
        }
        mat4$jscomp$6.copy(a.currentMatP, d)
    }
    InitSetModelView(a) {
        this._type = 7;
        mat4$jscomp$6.copy(this._mat4param, a)
    }
    DoSetModelView() {
        const a = this._batchState
          , b = a.renderer._allShaderPrograms
          , c = a.currentShader
          , d = this._mat4param;
        for (let e = 0, f = b.length; e < f; ++e) {
            const h = b[e];
            h === c ? h.UpdateMatMV(d, !0) : h.SetMatMVStale()
        }
        mat4$jscomp$6.copy(a.currentMV, d)
    }
    InitSetRenderTarget(a) {
        this._type = 8;
        this._texParam = a
    }
    DoSetRenderTarget() {
        const a = this._gl
          , b = this._texParam
          , c = this._batchState;
        b ? (c.currentFramebuffer = b._GetFramebuffer(),
        c.currentFramebufferNoDepth = b._GetFramebufferNoDepth(),
        c.isDepthSamplingEnabled && c.currentFramebufferNoDepth ? a.bindFramebuffer(a.FRAMEBUFFER, c.currentFramebufferNoDepth) : a.bindFramebuffer(a.FRAMEBUFFER, c.currentFramebuffer)) : (c.currentFramebuffer = null,
        c.currentFramebufferNoDepth = null,
        a.bindFramebuffer(a.FRAMEBUFFER, null))
    }
    InitClearSurface(a) {
        this._type = 9;
        a.writeToTypedArray(this._mat4param, 0)
    }
    InitClearSurface2(a, b, c, d) {
        this._type = 9;
        const e = this._mat4param;
        e[0] = a;
        e[1] = b;
        e[2] = c;
        e[3] = d
    }
    DoClearSurface() {
        const a = this._gl;
        var b = this._mat4param;
        const c = this._batchState.clearColor
          , d = b[0]
          , e = b[1]
          , f = b[2];
        b = b[3];
        c.equalsRgba(d, e, f, b) || (a.clearColor(d, e, f, b),
        c.setRgba(d, e, f, b));
        a.clear(a.COLOR_BUFFER_BIT)
    }
    InitSetPointTexCoords(a) {
        this._type = 15;
        a.writeToTypedArray(this._mat4param, 0)
    }
    DoSetPointTextureCoords() {
        const a = this._mat4param;
        this._batchState.pointTexCoords.set(a[0], a[1], a[2], a[3])
    }
    InitPoints(a, b) {
        this._type = 10;
        this._startIndex = a;
        this._indexCount = 1;
        this._mat4param[0] = b
    }
    DoPoints() {
        const a = this._gl
          , b = this._batchState
          , c = b.renderer._spPoints;
        a.useProgram(c._shaderProgram);
        c.UpdateMatP(b.currentMatP, !1);
        c.UpdateMatMV(b.currentMV, !1);
        var d = b.pointTexCoords;
        c._uPointTexStart.IsUsed() && c._uPointTexStart.Update2f(d.getLeft(), d.getTop());
        c._uPointTexEnd.IsUsed() && c._uPointTexEnd.Update2f(d.getRight(), d.getBottom());
        d = this._mat4param[0];
        c._uZElevation.IsUsed() && c._uZElevation.Update1f(d);
        c._uColor.IsUsed() && (d = b.currentColor,
        c._uColor.Update4f(d[0], d[1], d[2], d[3]));
        a.drawArrays(a.POINTS, this._startIndex / 4, this._indexCount);
        a.useProgram(b.currentShader._shaderProgram)
    }
    InitSetProgram(a) {
        this._type = 11;
        this._texParam = a
    }
    DoSetProgram() {
        var a = this._gl;
        const b = this._batchState
          , c = this._texParam;
        b.currentShader = c;
        a.useProgram(c._shaderProgram);
        c.UpdateMatP(b.currentMatP, !1);
        c.UpdateMatMV(b.currentMV, !1);
        c._uColor.IsUsed() && (a = b.currentColor,
        c._uColor.Update4f(a[0], a[1], a[2], a[3]))
    }
    InitSetProgramParameters() {
        this._type = 12
    }
    DoSetProgramParameters() {
        const a = this._batchState.currentShader
          , b = this._gl
          , c = this._mat4param
          , d = this._colorParam
          , e = this._srcOriginRect;
        if (a._uSamplerBack.IsUsed()) {
            const f = this._batchState.renderer
              , h = this._texParam;
            f._lastTexture1 !== h && (b.activeTexture(b.TEXTURE1),
            b.bindTexture(b.TEXTURE_2D, h ? h._GetTexture() : null),
            f._lastTexture1 = h,
            b.activeTexture(b.TEXTURE0))
        }
        a._uPixelSize.IsUsed() && a._uPixelSize.Update2f(c[0], c[1]);
        a._uDestStart.IsUsed() && a._uDestStart.Update2f(c[2], c[3]);
        a._uDestEnd.IsUsed() && a._uDestEnd.Update2f(c[4], c[5]);
        a._uDevicePixelRatio.IsUsed() && a._uDevicePixelRatio.Update1f(this._indexCount);
        a._uLayerScale.IsUsed() && a._uLayerScale.Update1f(c[6]);
        a._uLayerAngle.IsUsed() && a._uLayerAngle.Update1f(c[7]);
        a._uSrcStart.IsUsed() && a._uSrcStart.Update2f(c[12], c[13]);
        a._uSrcEnd.IsUsed() && a._uSrcEnd.Update2f(c[14], c[15]);
        a._uSrcOriginStart.IsUsed() && a._uSrcOriginStart.Update2f(e[0], e[1]);
        a._uSrcOriginEnd.IsUsed() && a._uSrcOriginEnd.Update2f(e[2], e[3]);
        a._uLayoutStart.IsUsed() && a._uLayoutStart.Update2f(d[0], d[1]);
        a._uLayoutEnd.IsUsed() && a._uLayoutEnd.Update2f(d[2], d[3]);
        a._uSeconds.IsUsed() && a._uSeconds.Update1f(this._startIndex)
    }
    InitSetProgramCustomParameters() {
        this._type = 13
    }
    DoSetProgramCustomParameters() {
        const a = this._batchState.currentShader._uCustomParameters
          , b = this._shaderParams;
        for (let c = 0, d = a.length; c < d; ++c) {
            const e = a[c]
              , f = b[c];
            e.IsColorType() ? e.Update3f(f.getR(), f.getG(), f.getB()) : e.Update1f(f)
        }
    }
    InitInvalidateFramebuffer(a) {
        this._type = 14;
        this._texParam = a
    }
    DoInvalidateFramebuffer() {
        const a = this._gl
          , b = this._texParam
          , c = this._batchState.currentFramebuffer;
        b !== c && a.bindFramebuffer(a.FRAMEBUFFER, b);
        a.invalidateFramebuffer(a.FRAMEBUFFER, [a.COLOR_ATTACHMENT0]);
        b !== c && a.bindFramebuffer(a.FRAMEBUFFER, c)
    }
    InitBlitFramebuffer(a, b, c) {
        this._type = 17;
        const d = this._mat4param
          , e = this._batchState.renderer;
        d[0] = a.GetWidth();
        d[1] = a.GetHeight();
        d[2] = b ? b.GetWidth() : e.GetWidth();
        d[3] = b ? b.GetHeight() : e.GetHeight();
        d[4] = a.IsLinearSampling() ? 1 : 0;
        d[5] = "stretch" === c;
        c = this._shaderParams;
        C3$jscomp$53.clearArray(c);
        c.push(a._GetFramebuffer());
        c.push(b ? b._GetFramebuffer() : null)
    }
    DoBlitFramebuffer() {
        var a = this._mat4param
          , b = this._shaderParams;
        const c = this._gl;
        var d = a[0]
          , e = a[1]
          , f = a[2];
        const h = a[3]
          , l = 0 !== a[4];
        a = 0 !== a[5];
        const m = b[1];
        c.bindFramebuffer(c.READ_FRAMEBUFFER, b[0]);
        c.bindFramebuffer(c.DRAW_FRAMEBUFFER, m);
        a ? c.blitFramebuffer(0, 0, d, e, 0, 0, f, h, c.COLOR_BUFFER_BIT, l ? c.LINEAR : c.NEAREST) : (b = Math.min(d, f),
        d = Math.min(e, h),
        f = Math.max(e - h, 0),
        e = Math.max(h - e, 0),
        c.blitFramebuffer(0, f, b, d + f, 0, e, b, d + e, c.COLOR_BUFFER_BIT, c.NEAREST))
    }
    InitStartQuery(a) {
        this._type = 18;
        this._texParam = a
    }
    DoStartQuery() {
        this._texParam.BeginTimeElapsed();
        this._texParam = null
    }
    InitEndQuery(a) {
        this._type = 19;
        this._texParam = a
    }
    DoEndQuery() {
        this._texParam.EndTimeElapsed();
        this._texParam = null
    }
    InitSetEllipseParams(a, b, c) {
        this._type = 20;
        const d = this._mat4param;
        d[0] = a;
        d[1] = b;
        d[2] = c
    }
    DoSetEllipseParams() {
        const a = this._batchState.currentShader
          , b = this._mat4param;
        a._uPixelSize.IsUsed() && a._uPixelSize.Update2f(b[0], b[1]);
        a._uOutlineThickness.IsUsed() && a._uOutlineThickness.Update1f(b[2])
    }
    InitSetTilemapInfo(a, b, c, d, e, f, h) {
        this._type = 16;
        const l = this._mat4param;
        a.writeToTypedArray(l, 0);
        l[4] = 1 / b;
        l[5] = 1 / c;
        l[6] = d / b;
        l[7] = e / c;
        l[8] = f / b;
        l[9] = h / c
    }
    DoSetTilemapInfo() {
        const a = this._batchState.currentShader
          , b = this._mat4param;
        a._uSrcStart.IsUsed() && a._uSrcStart.Update2f(b[0], b[1]);
        a._uPixelSize.IsUsed() && a._uPixelSize.Update2f(b[4], b[5]);
        a._uTileSize.IsUsed() && a._uTileSize.Update2f(b[6], b[7]);
        a._uTileSpacing.IsUsed() && a._uTileSpacing.Update2f(b[8], b[9])
    }
    InitSetTileRandomizationInfo(a, b, c, d, e, f, h) {
        this._type = 29;
        const l = this._mat4param;
        l[0] = 1 / a;
        l[1] = 1 / b;
        l[2] = c;
        l[3] = d;
        l[4] = e;
        l[5] = f;
        l[6] = h
    }
    DoSetTileRandomizationInfo() {
        const a = this._batchState.currentShader
          , b = this._mat4param;
        a._uPixelSize.IsUsed() && a._uPixelSize.Update2f(b[0], b[1]);
        a._uTileSize.IsUsed() && a._uTileSize.Update2f(b[2], b[3]);
        a._uOutlineThickness.IsUsed() && a._uOutlineThickness.Update1f(b[4]);
        a._uTileSpacing.IsUsed() && a._uTileSpacing.Update2f(b[5], b[6])
    }
    InitClearDepth(a) {
        this._type = 22;
        this._startIndex = a ? 1 : 0
    }
    DoClearDepth() {
        const a = this._gl
          , b = 0 !== this._startIndex;
        b || a.depthMask(!0);
        a.clear(a.DEPTH_BUFFER_BIT);
        b || a.depthMask(!1)
    }
    InitSetDepthEnabled(a) {
        this._type = 23;
        this._startIndex = a ? 1 : 0
    }
    DoSetDepthEnabled() {
        const a = this._gl;
        0 === this._startIndex ? (a.disable(a.DEPTH_TEST),
        a.depthMask(!1)) : (a.enable(a.DEPTH_TEST),
        a.depthMask(!0))
    }
    InitSetDepthSamplingEnabled(a) {
        this._type = 24;
        this._startIndex = a ? 1 : 0
    }
    DoSetDepthSamplingEnabled() {
        const a = this._gl
          , b = this._batchState
          , c = b.renderer
          , d = 0 !== this._startIndex;
        b.isDepthSamplingEnabled = d;
        a.activeTexture(a.TEXTURE2);
        d ? (b.currentFramebufferNoDepth && a.bindFramebuffer(a.FRAMEBUFFER, b.currentFramebufferNoDepth),
        a.bindTexture(a.TEXTURE_2D, c._GetDepthBuffer())) : (a.bindTexture(a.TEXTURE_2D, null),
        b.currentFramebufferNoDepth && a.bindFramebuffer(a.FRAMEBUFFER, b.currentFramebuffer));
        a.activeTexture(a.TEXTURE0)
    }
    InitCoplanarStartStencilPass() {
        this._type = 25
    }
    DoCoplanarStartStencilPass() {
        const a = this._gl;
        a.clear(a.STENCIL_BUFFER_BIT);
        a.enable(a.STENCIL_TEST);
        a.stencilFunc(a.ALWAYS, 1, 1);
        a.stencilOp(a.KEEP, a.KEEP, a.REPLACE);
        a.colorMask(!1, !1, !1, !1)
    }
    InitCoplanarStartColorPass() {
        this._type = 26
    }
    DoCoplanarStartColorPass() {
        const a = this._gl;
        a.colorMask(!0, !0, !0, !0);
        a.stencilFunc(a.EQUAL, 1, 1);
        a.stencilOp(a.KEEP, a.KEEP, a.KEEP)
    }
    InitCoplanarRestore() {
        this._type = 27
    }
    DoCoplanarRestore() {
        const a = this._gl;
        a.disable(a.STENCIL_TEST)
    }
    InitSetScissor(a, b, c, d, e) {
        this._type = 28;
        this._startIndex = a ? 1 : 0;
        a = this._mat4param;
        a[0] = b;
        a[1] = c;
        a[2] = d;
        a[3] = e
    }
    DoSetScissor() {
        const a = this._gl
          , b = this._mat4param;
        1 === this._startIndex ? (a.enable(a.SCISSOR_TEST),
        a.scissor(b[0], b[1], b[2], b[3])) : a.disable(a.SCISSOR_TEST)
    }
    Run() {
        switch (this._type) {
        case 1:
            this.DoQuad();
            break;
        case 2:
            this.DoSetTexture();
            break;
        case 3:
            this.DoSetColor();
            break;
        case 4:
            this.DoSetBlend();
            break;
        case 5:
            this.DoSetViewport();
            break;
        case 6:
            this.DoSetProjection();
            break;
        case 7:
            this.DoSetModelView();
            break;
        case 8:
            this.DoSetRenderTarget();
            break;
        case 9:
            this.DoClearSurface();
            break;
        case 10:
            this.DoPoints();
            break;
        case 11:
            this.DoSetProgram();
            break;
        case 12:
            this.DoSetProgramParameters();
            break;
        case 13:
            this.DoSetProgramCustomParameters();
            break;
        case 14:
            this.DoInvalidateFramebuffer();
            break;
        case 15:
            this.DoSetPointTextureCoords();
            break;
        case 16:
            this.DoSetTilemapInfo();
            break;
        case 17:
            this.DoBlitFramebuffer();
            break;
        case 18:
            this.DoStartQuery();
            break;
        case 19:
            this.DoEndQuery();
            break;
        case 20:
            this.DoSetEllipseParams();
            break;
        case 21:
            this.DoSetGradientColor();
            break;
        case 22:
            this.DoClearDepth();
            break;
        case 23:
            this.DoSetDepthEnabled();
            break;
        case 24:
            this.DoSetDepthSamplingEnabled();
            break;
        case 25:
            this.DoCoplanarStartStencilPass();
            break;
        case 26:
            this.DoCoplanarStartColorPass();
            break;
        case 27:
            this.DoCoplanarRestore();
            break;
        case 28:
            this.DoSetScissor();
            break;
        case 29:
            this.DoSetTileRandomizationInfo()
        }
    }
}
;
"use strict";
const C3$jscomp$54 = self.C3
  , GENERIC_FONT_FAMILIES = new Set("serif sans-serif monospace cursive fantasy system-ui ui-serif ui-sans-serif ui-monospace ui-rounded math emoji fangsong".split(" "))
  , DEFAULT_OPTS = {
    timeout: 60
}
  , tempColor = new C3$jscomp$54.Color(0,0,0,1)
  , VALID_HORIZ_ALIGNMENTS = new Set(["left", "center", "right"])
  , VALID_VERT_ALIGNMENTS = new Set(["top", "center", "bottom"])
  , VALID_WORD_WRAP_MODES = new Set(["word", "character"])
  , VALID_TEXT_DIRECTIONS = new Set(["ltr", "rtl"])
  , allRendererTexts = new Set;
C3$jscomp$54.FontManager && C3$jscomp$54.FontManager.addEventListener("fontload", a => {
    a = a.font.GetName();
    for (const b of allRendererTexts)
        (b.IsBBCodeEnabled() || C3$jscomp$54.equalsNoCase(b.GetFontName(), a)) && b._SetWordWrapChanged()
}
);
function fillOrStrokeRect(a, b, c, d, e, f) {
    b ? a.strokeRect(c, d, e, f) : a.fillRect(c, d, e, f)
}
function ptToPx(a) {
    return 4 / 3 * a
}
function getOffsetParam(a, b) {
    a = a.trim();
    const c = parseFloat(a);
    return isFinite(c) ? a.endsWith("%") ? b * c / 100 : c : 0
}
let didCheckFoundBoundingBoxSupport = !1
  , supportsFontBoundingBoxMeasurements = !1;
C3$jscomp$54.Gfx.RendererText = class {
    constructor(a, b) {
        b = Object.assign({}, DEFAULT_OPTS, b);
        this._renderer = a;
        this._fontName = "Arial";
        this._fontSize = 16;
        this._fontSizeScale = 1;
        this._lineHeight = 0;
        this._isItalic = this._isBold = !1;
        this._colorStr = "black";
        this._isBBcodeEnabled = !1;
        this._iconSet = null;
        this._iconSmoothing = !0;
        this.onloadfont = null;
        this._alreadyLoadedFonts = new Set;
        this._horizontalAlign = "left";
        this._verticalAlign = "top";
        this._text = "";
        this._bbString = null;
        this._wrappedText = C3$jscomp$54.New(C3$jscomp$54.WordWrap);
        this._wrapMode = "word";
        this._textDirection = "ltr";
        this._drawChanged = this._textLayoutChanged = this._wordWrapChanged = !1;
        this._drawMaxCharCount = -1;
        this._height = this._width = this._cssHeight = this._cssWidth = this._drawCharCount = 0;
        this._zoom = 1;
        this._measureContextTop = this._measureContext = this._textContext = this._textCanvas = null;
        this._lastCanvasHeight = this._lastCanvasWidth = -1;
        this._lastTextCanvasFillStyle = this._lastMeasureCanvasFont = this._lastTextCanvasFont = "";
        this._lastTextCanvasLineWidth = this._lastTextCanvasOpacity = 1;
        this._measureTextCallback = c => this._MeasureText(c);
        this._texture = null;
        this._rcTex = new C3$jscomp$54.Rect;
        this._scaleFactor = 1;
        this._textureTimeout = new C3$jscomp$54.IdleTimeout( () => {
            this.ReleaseTexture();
            this._SetTextCanvasSize(8, 8)
        }
        ,b.timeout);
        this.ontextureupdate = null;
        this._wasReleased = !1;
        allRendererTexts.add(this)
    }
    Release() {
        this.onloadfont = null;
        this._alreadyLoadedFonts.clear();
        this._measureTextCallback = this._measureContextTop = this._measureContext = this._textContext = this._textCanvas = this._bbString = this._iconSet = null;
        this._textureTimeout.Release();
        this.ontextureupdate = null;
        this.ReleaseTexture();
        this._wrappedText.Clear();
        this._renderer = this._wrappedText = null;
        this._wasReleased = !0;
        allRendererTexts.delete(this)
    }
    _SetDrawChanged() {
        this._drawChanged = !0
    }
    _SetTextLayoutChanged() {
        this._SetDrawChanged();
        this._textLayoutChanged = !0
    }
    _SetWordWrapChanged() {
        this._SetTextLayoutChanged();
        this._wordWrapChanged = !0
    }
    SetBBCodeEnabled(a) {
        a = !!a;
        this._isBBcodeEnabled !== a && (a = (this._isBBcodeEnabled = a) ? "alphabetic" : "top",
        this._textContext && (this._textContext.textBaseline = a),
        this._measureContext && (this._measureContext.textBaseline = a),
        this._SetWordWrapChanged())
    }
    IsBBCodeEnabled() {
        return this._isBBcodeEnabled
    }
    SetIconSet(a) {
        this._iconSet !== a && (this._iconSet = a,
        this._wrappedText.SetIconSet(a),
        this._iconSet && this._iconSet.IsLoading() && this._iconSet.LoadContent().then( () => this._SetDrawChanged()),
        this._SetWordWrapChanged())
    }
    SetIconSmoothing(a) {
        a = !!a;
        this._iconSmoothing !== a && (this._iconSmoothing = a,
        this._SetDrawChanged())
    }
    SetFontName(a) {
        a || (a = "serif");
        this._fontName !== a && (this._fontName = a,
        this._SetWordWrapChanged())
    }
    GetFontName() {
        return this._fontName
    }
    SetFontSize(a) {
        .1 > a && (a = .1);
        this._fontSize !== a && (this._fontSize = a,
        this._SetWordWrapChanged())
    }
    GetFontSize() {
        return this._fontSize
    }
    SetFontSizeScale(a) {
        this._fontSizeScale !== a && (this._fontSizeScale = a,
        this._SetWordWrapChanged())
    }
    SetLineHeight(a) {
        this._lineHeight !== a && (this._lineHeight = a,
        this._SetTextLayoutChanged())
    }
    GetLineHeight() {
        return this._lineHeight
    }
    SetBold(a) {
        a = !!a;
        this._isBold !== a && (this._isBold = a,
        this._SetWordWrapChanged())
    }
    IsBold() {
        return this._isBold
    }
    SetItalic(a) {
        a = !!a;
        this._isItalic !== a && (this._isItalic = a,
        this._SetWordWrapChanged())
    }
    IsItalic() {
        return this._isItalic
    }
    SetDrawMaxCharacterCount(a) {
        a = Math.floor(a);
        this._drawMaxCharCount !== a && (this._drawMaxCharCount = a,
        this._SetDrawChanged())
    }
    GetDrawMaxCharacterCount() {
        return this._drawMaxCharCount
    }
    _GetFontString(a, b) {
        let c = [];
        (this._isBold || b.HasStyleTag("b")) && c.push("bold");
        (this._isItalic || b.HasStyleTag("i")) && c.push("italic");
        var d = b.GetStyleTag("size");
        d = (d ? parseFloat(d.param) : this._fontSize) * this._fontSizeScale;
        a ? c.push(d + "pt") : c.push(d * this.GetDrawScale() + "pt");
        a = this._fontName;
        (b = b.GetStyleTag("font")) && b.param && (a = b.param,
        this.onloadfont && !this._alreadyLoadedFonts.has(a) && (this.onloadfont(a),
        this._alreadyLoadedFonts.add(a)));
        a && (GENERIC_FONT_FAMILIES.has(a) ? c.push(a) : c.push('"' + a + '"'));
        return c.join(" ")
    }
    SetColor(a) {
        a instanceof C3$jscomp$54.Color && (a = a.getCssRgb());
        this._colorStr !== a && (this._colorStr = a,
        this._SetDrawChanged())
    }
    SetColorRgb(a, b, c) {
        tempColor.setRgb(a, b, c);
        this.SetColor(tempColor)
    }
    SetHorizontalAlignment(a) {
        if (!VALID_HORIZ_ALIGNMENTS.has(a))
            throw Error("invalid horizontal alignment");
        this._horizontalAlign !== a && (this._horizontalAlign = a,
        this._SetTextLayoutChanged())
    }
    GetHorizontalAlignment() {
        return this._horizontalAlign
    }
    SetVerticalAlignment(a) {
        if (!VALID_VERT_ALIGNMENTS.has(a))
            throw Error("invalid vertical alignment");
        this._verticalAlign !== a && (this._verticalAlign = a,
        this._SetTextLayoutChanged())
    }
    GetVerticalAlignment() {
        return this._verticalAlign
    }
    SetWordWrapMode(a) {
        if (!VALID_WORD_WRAP_MODES.has(a))
            throw Error("invalid word wrap mode");
        this._wrapMode !== a && (this._wrapMode = a,
        this._SetWordWrapChanged())
    }
    GetWordWrapMode() {
        return this._wrapMode
    }
    SetTextDirection(a) {
        if (!VALID_TEXT_DIRECTIONS.has(a))
            throw Error("invalid text direction");
        this._textDirection !== a && (this._textDirection = a,
        this._textContext && (this._textContext.direction = this._textDirection),
        this._measureContext && (this._measureContext.direction = this._textDirection),
        this._SetWordWrapChanged())
    }
    GetTextDirection() {
        return this._textDirection
    }
    SetText(a) {
        this._text !== a && (this._text = a,
        this._SetWordWrapChanged())
    }
    GetText() {
        return this._text
    }
    GetDrawScale() {
        return this._scaleFactor * this._zoom * self.devicePixelRatio
    }
    SetSize(a, b, c) {
        "undefined" === typeof c && (c = 1);
        if (!(0 >= a || 0 >= a || this._cssWidth === a && this._cssHeight === b && this._zoom === c)) {
            var d = this._cssWidth;
            this._cssWidth = a;
            this._cssHeight = b;
            this._zoom = c;
            a = self.devicePixelRatio;
            this._width = this._cssWidth * this._zoom * a;
            this._height = this._cssHeight * this._zoom * a;
            a = Math.max(this._width, this._height);
            b = Math.min(this._renderer.GetMaxTextureSize(), 4096);
            c = 1;
            a > b && (c = b / a,
            this._width = Math.min(this._width * c, b),
            this._height = Math.min(this._height * c, b));
            this._scaleFactor = c;
            this._cssWidth !== d ? this._SetWordWrapChanged() : this._SetTextLayoutChanged()
        }
    }
    GetWidth() {
        return this._width
    }
    GetHeight() {
        return this._height
    }
    GetZoom() {
        return this._zoom
    }
    GetTextWidth() {
        this._UpdateTextMeasurements();
        return this._wrappedText.GetMaxLineWidth()
    }
    GetTextHeight() {
        this._UpdateTextMeasurements();
        return this._wrappedText.GetTotalLineHeight() + this._wrappedText.GetLineCount() * (this._lineHeight + 4) - this._lineHeight
    }
    GetLengthInGraphemes() {
        this._UpdateTextMeasurements();
        let a = 0;
        for (const b of this._wrappedText.GetLines())
            for (const c of b.fragments())
                a += c.GetLength();
        return a
    }
    GetTexture() {
        this._textureTimeout.Reset();
        this._MaybeUpdate();
        return this._texture
    }
    HitTestFragment(a, b) {
        this._UpdateTextMeasurements();
        const c = this.GetDrawScale();
        var d = this._wrappedText.GetLines();
        for (const e of d)
            if (d = e.GetFontBoundingBoxDescent() * c,
            b >= e.GetPosY() - e.GetHeight() * c + d && b < e.GetPosY() + d)
                for (const f of e.fragments())
                    if (a >= f.GetPosX() && a < f.GetPosX() + f.GetWidth() * c)
                        return f;
        return null
    }
    *fragmentsWithTag(a) {
        this._UpdateTextMeasurements();
        var b = this._wrappedText.GetLines();
        for (const c of b)
            for (const d of c.fragments())
                (b = d.GetStyleTag("tag")) && C3$jscomp$54.equalsNoCase(b.param, a) && (yield d)
    }
    FindFragmentWithTag(a, b) {
        for (const c of this.fragmentsWithTag(a)) {
            if (0 === b)
                return c;
            --b
        }
        return null
    }
    CountFragmentsWithTag(a) {
        let b = 0;
        for (const c of this.fragmentsWithTag(a))
            ++b;
        return b
    }
    _MaybeUpdate() {
        this._texture && !this._drawChanged && !this._textLayoutChanged && !this._wordWrapChanged || this._wasReleased || 0 >= this._width || 0 >= this._height || (this._drawChanged = !1,
        this._DoUpdate())
    }
    _DoUpdate() {
        this._wasReleased || (this._UpdateTextMeasurements(),
        this._SetTextCanvasSize(Math.max(C3$jscomp$54.nextHighestPowerOfTwo(Math.ceil(this._width)), 128), Math.max(C3$jscomp$54.nextHighestPowerOfTwo(Math.ceil(this._height)), 64)),
        this._DrawTextToCanvas(),
        this._UpdateTexture(),
        this._textureTimeout.Reset())
    }
    _SetTextCanvasSize(a, b) {
        this._textCanvas || (this._textCanvas = C3$jscomp$54.CreateCanvas(16, 16));
        let c = !1;
        if (this._lastCanvasWidth !== a || this._lastCanvasHeight !== b)
            this._lastCanvasWidth = a,
            this._lastCanvasHeight = b,
            this._textCanvas.width = a,
            this._textCanvas.height = b,
            c = !0;
        this._textContext || (this._textContext = this._textCanvas.getContext("2d"),
        c = !0);
        c ? (this._textContext.textBaseline = this._isBBcodeEnabled ? "alphabetic" : "top",
        this._textContext.direction = this._textDirection,
        this._textContext.font = this._lastTextCanvasFont,
        this._textContext.fillStyle = this._lastTextCanvasFillStyle,
        this._textContext.strokeStyle = this._lastTextCanvasFillStyle,
        this._textContext.globalAlpha = this._lastTextCanvasOpacity,
        this._textContext.lineWidth = this._lastTextCanvasLineWidth) : this._textContext.clearRect(0, 0, a, b)
    }
    _MaybeCreateMeasureContext() {
        this._measureContext || (this._measureContext = C3$jscomp$54.CreateCanvas(16, 16).getContext("2d"),
        this._measureContextTop = C3$jscomp$54.CreateCanvas(16, 16).getContext("2d"),
        this._measureContext.textBaseline = this._isBBcodeEnabled ? "alphabetic" : "top",
        this._measureContextTop.textBaseline = "top",
        this._measureContext.direction = this._textDirection,
        this._measureContextTop.direction = this._textDirection)
    }
    _SetMeasureFontString(a) {
        this._lastMeasureCanvasFont !== a && (this._lastMeasureCanvasFont = a,
        this._measureContext.font = a,
        this._measureContextTop.font = a)
    }
    _SupportsFontBoundingBoxMeasurements() {
        if (!didCheckFoundBoundingBoxSupport) {
            didCheckFoundBoundingBoxSupport = !0;
            this._MaybeCreateMeasureContext();
            const a = this._measureContext.measureText("test");
            supportsFontBoundingBoxMeasurements = "number" === typeof a.fontBoundingBoxAscent && "number" === typeof a.fontBoundingBoxDescent
        }
        return supportsFontBoundingBoxMeasurements
    }
    _UpdateTextMeasurements() {
        this._UpdateWordWrap();
        this._UpdateTextLayout()
    }
    _UpdateWordWrap() {
        this._wordWrapChanged && (this._MaybeCreateMeasureContext(),
        !this._isBBcodeEnabled || this._bbString && this._bbString.toString() === this._text || (this._bbString = new C3$jscomp$54.BBString(this._text,{
            noEscape: !0
        })),
        this._wrappedText.WordWrap(this._isBBcodeEnabled ? this._bbString.toFragmentList() : this._text, this._measureTextCallback, this._cssWidth, this._wrapMode, 0),
        this._wordWrapChanged = !1)
    }
    _UpdateTextLayout() {
        this._textLayoutChanged && (this._LayoutText(),
        this._textLayoutChanged = !1)
    }
    _MeasureText(a) {
        var b = a.IsText() ? a.GetCharacterArray().join("") : " ";
        this._SetMeasureFontString(this._GetFontString(!0, a));
        a = a.GetStyleTag("size");
        a = (a ? parseFloat(a.param) : this._fontSize) * this._fontSizeScale;
        const c = this._measureContext.measureText(b);
        let d = 0;
        this._isBBcodeEnabled && this._SupportsFontBoundingBoxMeasurements() && (b = this._measureContextTop.measureText(b),
        d = c.fontBoundingBoxAscent - b.fontBoundingBoxAscent);
        return {
            width: c.width,
            height: ptToPx(a),
            fontBoundingBoxAscent: c.fontBoundingBoxAscent || 0,
            fontBoundingBoxDescent: c.fontBoundingBoxDescent || 0,
            topToAlphabeticDistance: d
        }
    }
    _SetDrawFontString(a) {
        this._lastTextCanvasFont !== a && (this._lastTextCanvasFont = a,
        this._textContext.font = a)
    }
    _SetDrawCanvasColor(a) {
        this._lastTextCanvasFillStyle !== a && (this._lastTextCanvasFillStyle = a,
        this._textContext.fillStyle = a,
        this._textContext.strokeStyle = a)
    }
    _SetDrawCanvasOpacity(a) {
        this._lastTextCanvasOpacity !== a && (this._lastTextCanvasOpacity = a,
        this._textContext.globalAlpha = a)
    }
    _SetDrawCanvasLineWith(a) {
        this._lastTextCanvasLineWidth !== a && (this._lastTextCanvasLineWidth = a,
        this._textContext.lineWidth = a)
    }
    _LayoutText() {
        const a = this.GetDrawScale()
          , b = (4 + this._lineHeight) * a;
        var c = 0;
        const d = this._wrappedText.GetLines();
        if (0 !== d.length) {
            for (var e of d) {
                e.SetPosX(NaN);
                e.SetPosY(NaN);
                for (var f of e.fragments())
                    f.SetPosX(NaN),
                    f.SetPosY(NaN)
            }
            f = this._isBBcodeEnabled && this._SupportsFontBoundingBoxMeasurements();
            e = d[0].GetHeight() * a;
            "center" === this._verticalAlign ? (c = d.reduce( (h, l) => h + l.GetHeight() * a + b, 0) - b,
            c = Math.max(this._height / 2 - c / 2, 0),
            f && (e = d[0].GetTopToAlphabeticDistance() * a)) : "bottom" === this._verticalAlign && (c = d.reduce( (h, l) => h + l.GetHeight() * a + b, 0) - this._lineHeight * a,
            f = f ? d.at(-1).GetFontBoundingBoxDescent() * a : 0,
            c = this._height - c - f - 2);
            for (let h = 0, l = d.length; h < l; ++h) {
                f = d[h];
                const m = f.GetHeight() * a
                  , p = c;
                if (this._isBBcodeEnabled) {
                    if (c += 0 === h ? e : m,
                    0 < h && c > this._height - 4 * a)
                        break
                } else if (0 < h && c >= this._height - m)
                    break;
                0 <= p && this._LayoutTextLine(f, c, a);
                this._isBBcodeEnabled || (c += m);
                c += b
            }
        }
    }
    _LayoutTextLine(a, b, c) {
        let d = 0;
        "center" === this._horizontalAlign ? d = (this._width - a.GetWidth() * c) / 2 : "right" === this._horizontalAlign && (d = this._width - a.GetWidth() * c);
        a.SetPosX(d);
        a.SetPosY(b);
        for (const e of "ltr" === this._textDirection ? a.fragments() : a.fragmentsReverse())
            this._LayoutFragment(e, d, b, c),
            d += e.GetWidth() * c
    }
    _LayoutFragment(a, b, c, d) {
        var e = a.GetStyleTag("offsetx");
        b += e ? getOffsetParam(e.param, a.GetHeight()) * d : 0;
        e = a.GetStyleTag("offsety");
        c += e ? getOffsetParam(e.param, a.GetHeight()) * d : 0;
        a.IsIcon() && (e = a.GetStyleTag("iconoffsety"),
        c += e ? getOffsetParam(e.param, a.GetHeight()) * d : .2 * a.GetHeight() * d);
        a.SetPosX(b);
        a.SetPosY(c)
    }
    _DrawTextToCanvas() {
        this._textContext.imageSmoothingEnabled = this._iconSmoothing;
        this._drawCharCount = 0;
        const a = this.GetDrawScale()
          , b = this._wrappedText.GetLines();
        for (const c of b)
            this._DrawTextLine(c, a)
    }
    _DrawTextLine(a, b) {
        const c = a.GetPosX()
          , d = a.GetPosY();
        if (Number.isFinite(c) && Number.isFinite(d))
            for (const e of "ltr" === this._textDirection ? a.fragments() : a.fragmentsReverse())
                this._DrawFragment(e, b, a.GetHeight())
    }
    _DrawFragment(a, b, c) {
        const d = this._textContext
          , e = a.GetPosX()
          , f = a.GetPosY();
        if (Number.isFinite(e) && Number.isFinite(f)) {
            var h = c / 16;
            c = a.GetWidth() * b;
            var l = a.GetHeight() * b
              , m = a.GetHeight() / 16
              , p = (4 + this._lineHeight) * b
              , r = a.IsText() ? a.GetCharacterArray() : null;
            if (-1 !== this._drawMaxCharCount) {
                if (this._drawCharCount >= this._drawMaxCharCount)
                    return;
                a.IsText() && this._drawCharCount + r.length > this._drawMaxCharCount && (r = r.slice(0, this._drawMaxCharCount - this._drawCharCount),
                c = this._MeasureText(a).width * b);
                this._drawCharCount += a.GetLength()
            }
            var v = a.GetStyleTag("background")
              , x = a.HasStyleTag("u")
              , B = a.HasStyleTag("s");
            if ((!a.IsText() || !C3$jscomp$54.IsCharArrayAllWhitespace(r) || v || x || B) && !a.HasStyleTag("hide")) {
                var A = a.GetStyleTag("color")
                  , D = a.GetStyleTag("opacity");
                this._SetDrawCanvasOpacity(D ? parseFloat(D.param) / 100 : 1);
                v && (this._SetDrawCanvasColor(v.param),
                d.fillRect(e, f - l, c, l + p));
                p = (p = a.GetStyleTag("linethickness")) ? parseFloat(p.param) : 1;
                (v = a.HasStyleTag("stroke")) && this._SetDrawCanvasLineWith(.5 * m * p * this.GetDrawScale());
                a.IsText() ? (r = r.join(""),
                this._SetDrawFontString(this._GetFontString(!1, a)),
                !v && (this._SetDrawCanvasLineWith(.5 * m * p * this.GetDrawScale()),
                D = a.GetStyleTag("outlineback")) && (this._SetDrawCanvasColor(D.param),
                this._FillOrStrokeText(!0, r, e, f, c)),
                this._SetDrawCanvasColor(A ? A.param : this._colorStr),
                this._FillOrStrokeText(v, r, e, f, c),
                !v && (this._SetDrawCanvasLineWith(.5 * m * p * this.GetDrawScale()),
                a = a.GetStyleTag("outline")) && (this._SetDrawCanvasColor(a.param),
                this._FillOrStrokeText(!0, r, e, f, c))) : a.IsIcon() && 0 < a.GetWidth() && (a = a.GetDrawable(this._iconSet)) && d.drawImage(a, e, f - l, c, l);
                this._SetDrawCanvasColor(A ? A.param : this._colorStr);
                x && fillOrStrokeRect(d, v, e, f + b * h, c, b * h * p);
                B && (b *= m,
                d.fillRect(e, f - l / 4 + b / 2 - b * p / 2, c, b * p))
            }
        }
    }
    _FillOrStrokeText(a, b, c, d, e) {
        "rtl" === this._textDirection && (c += e);
        a ? "Gecko" === C3$jscomp$54.Platform.BrowserEngine ? this._textContext.strokeText(b, c, d, e) : this._textContext.strokeText(b, c, d) : "Gecko" === C3$jscomp$54.Platform.BrowserEngine ? this._textContext.fillText(b, c, d, e) : this._textContext.fillText(b, c, d)
    }
    _UpdateTexture() {
        if (!this._renderer.IsContextLost() && (this._texture || (this._texture = this._renderer.CreateDynamicTexture(this._textCanvas.width, this._textCanvas.height, {
            mipMap: !0,
            mipMapQuality: "high"
        })),
        this._renderer.UpdateTexture(this._textCanvas, this._texture),
        this._rcTex.set(0, 0, this._width / this._texture.GetWidth(), this._height / this._texture.GetHeight()),
        this.ontextureupdate))
            this.ontextureupdate()
    }
    GetTexRect() {
        return this._rcTex
    }
    ReleaseTexture() {
        this._texture && (this._renderer.IsContextLost() || this._renderer.DeleteTexture(this._texture),
        this._texture = null)
    }
    static OnContextLost() {
        for (const a of allRendererTexts)
            a.ReleaseTexture()
    }
    static GetAll() {
        return allRendererTexts.values()
    }
}
;
"use strict";
const C3$jscomp$55 = self.C3;
class WebGLRealTimeElapsedQuery {
    constructor(a) {
        this._gl = a.GetContext();
        this._version = a.GetWebGLVersionNumber();
        this._timerExt = a._GetDisjointTimerQueryExtension();
        this._query = null;
        this._hasResult = this._isActive = !1;
        this._result = 0;
        this._query = 1 === this._version ? this._timerExt.createQueryEXT() : this._gl.createQuery()
    }
    Release() {
        this._DeleteQueryObject();
        this._timerExt = this._gl = null;
        this._hasResult = !1
    }
    _DeleteQueryObject() {
        this._query && (1 === this._version ? this._timerExt.deleteQueryEXT(this._query) : this._gl.deleteQuery(this._query),
        this._query = null)
    }
    BeginTimeElapsed() {
        if (this._isActive)
            throw Error("query already active");
        1 === this._version ? this._timerExt.beginQueryEXT(this._timerExt.TIME_ELAPSED_EXT, this._query) : this._gl.beginQuery(this._timerExt.TIME_ELAPSED_EXT, this._query);
        this._isActive = !0
    }
    EndTimeElapsed() {
        if (!this._isActive)
            throw Error("query not active");
        1 === this._version ? this._timerExt.endQueryEXT(this._timerExt.TIME_ELAPSED_EXT) : this._gl.endQuery(this._timerExt.TIME_ELAPSED_EXT);
        this._isActive = !1
    }
    CheckForResult() {
        if (this._query && !this._hasResult && !this._isActive) {
            var a = 1 === this._version ? this._timerExt.getQueryObjectEXT(this._query, this._timerExt.QUERY_RESULT_AVAILABLE_EXT) : this._gl.getQueryParameter(this._query, this._gl.QUERY_RESULT_AVAILABLE);
            var b = this._gl.getParameter(this._timerExt.GPU_DISJOINT_EXT);
            a && !b && (this._result = 1 === this._version ? this._timerExt.getQueryObjectEXT(this._query, this._timerExt.QUERY_RESULT_EXT) : this._gl.getQueryParameter(this._query, this._gl.QUERY_RESULT),
            this._result /= 1E9,
            this._hasResult = !0);
            (a || b) && this._DeleteQueryObject()
        }
    }
    HasResult() {
        return this._hasResult
    }
    GetResult() {
        if (!this._hasResult)
            throw Error("no result available");
        return this._result
    }
}
C3$jscomp$55.Gfx.WebGLTimeElapsedQuery = class {
    constructor(a) {
        this._renderer = a;
        this._frameNumber = a.GetFrameNumber();
        this._isActive = !1;
        this._parentQuery = null;
        this._isNested = !1;
        this._realQuery = null;
        this._queries = []
    }
    Release() {
        for (const a of this._queries)
            a instanceof WebGLRealTimeElapsedQuery && a.Release();
        C3$jscomp$55.clearArray(this._queries);
        this._renderer = this._realQuery = this._parentQuery = null
    }
    BeginTimeElapsed() {
        if (this._isActive)
            throw Error("query already active");
        const a = this._renderer._GetTimeQueryStack();
        0 < a.length ? (this._isNested = !0,
        this._parentQuery = a.at(-1),
        this._parentQuery._EndReal(),
        this._parentQuery._queries.push(this)) : (this._isNested = !1,
        this._parentQuery = null);
        this._isActive = !0;
        a.push(this);
        this._StartReal()
    }
    EndTimeElapsed() {
        if (!this._isActive)
            throw Error("query not active");
        if (this._renderer._GetTimeQueryStack().pop() !== this)
            throw Error("can only end most nested query");
        this._isActive = !1;
        this._EndReal();
        this._parentQuery && (this._parentQuery._StartReal(),
        this._parentQuery = null)
    }
    _StartReal() {
        this._realQuery = C3$jscomp$55.New(WebGLRealTimeElapsedQuery, this._renderer);
        this._queries.push(this._realQuery);
        this._realQuery.BeginTimeElapsed()
    }
    _EndReal() {
        this._realQuery.EndTimeElapsed();
        this._realQuery = null
    }
    CheckForResult() {
        for (const a of this._queries)
            a.CheckForResult()
    }
    IsNested() {
        return this._isNested
    }
    HasResult() {
        return this._queries.every(a => a.HasResult())
    }
    GetResult() {
        return this._queries.reduce( (a, b) => a + b.GetResult(), 0)
    }
    GetFrameNumber() {
        return this._frameNumber
    }
}
;
"use strict";
const C3$jscomp$56 = self.C3;
C3$jscomp$56.Gfx.WebGLQueryResultBuffer = class {
    constructor(a, b=1E3) {
        this._renderer = a;
        this._maxQueries = b;
        this._buffer = [];
        this._renderer._AddQueryResultBuffer(this)
    }
    Release() {
        this.Clear();
        this._renderer._RemoveQueryResultBuffer(this);
        this._renderer = null
    }
    Clear() {
        for (const a of this._buffer)
            a.Release();
        C3$jscomp$56.clearArray(this._buffer)
    }
    AddTimeElapsedQuery() {
        const a = new C3$jscomp$56.Gfx.WebGLTimeElapsedQuery(this._renderer);
        this._buffer.push(a);
        this._buffer.length > this._maxQueries && this._buffer.shift().Release();
        return a
    }
    CheckForResults(a) {
        for (const b of this._buffer) {
            if (b.GetFrameNumber() >= a)
                break;
            if (b.IsNested())
                break;
            b.CheckForResult()
        }
    }
    GetFrameRangeResultSum(a, b) {
        if (b <= a)
            return NaN;
        let c = 0;
        for (const d of this._buffer) {
            if (d.GetFrameNumber() >= b)
                break;
            if (!(d.GetFrameNumber() < a))
                if (d.HasResult())
                    c += d.GetResult();
                else
                    return NaN
        }
        return c
    }
    DeleteAllBeforeFrameNumber(a) {
        for (let b = 0, c = this._buffer.length; b < c; ++b) {
            const d = this._buffer[b];
            if (d.GetFrameNumber() < a)
                d.Release();
            else {
                0 < b && this._buffer.splice(0, b);
                break
            }
        }
    }
}
;
"use strict";
const C3$jscomp$57 = self.C3
  , glMatrix$jscomp$6 = self.glMatrix
  , vec4$jscomp$4 = glMatrix$jscomp$6.vec4
  , mat4$jscomp$7 = glMatrix$jscomp$6.mat4
  , DEFAULT_WEBGLRENDERER_OPTS = {
    powerPreference: "default",
    enableGpuProfiling: !0,
    alpha: !1,
    depth: !1,
    canSampleDepth: !1,
    maxWebGLVersion: 2,
    failIfMajorPerformanceCaveat: !1
}
  , VALID_POWER_PREFERENCES = new Set(["default", "low-power", "high-performance"])
  , MAX_INDICES = 12E3
  , LAST_POINT = 7996
  , defaultTexCoordsQuad$jscomp$1 = new C3$jscomp$57.Quad(0,0,1,0,1,1,0,1)
  , tmpProjection = mat4$jscomp$7.create()
  , tmpModelView = mat4$jscomp$7.create()
  , tmpQuad$jscomp$1 = new C3$jscomp$57.Quad
  , tmpRect$jscomp$1 = new C3$jscomp$57.Rect;
let loseContextExtension = null;
C3$jscomp$57.isDebug && (self.debug_lose_webgl_context = function() {
    loseContextExtension ? loseContextExtension.loseContext() : console.warn("WEBGL_lose_context not supported")
}
,
self.debug_restore_webgl_context = function() {
    loseContextExtension ? loseContextExtension.restoreContext() : console.warn("WEBGL_lose_context not supported")
}
);
const pendingPolls = new Set;
let pollRafId = -1;
function CheckPendingPolls() {
    pollRafId = -1;
    for (const a of pendingPolls)
        a.checkFunc() && (a.resolve(),
        pendingPolls.delete(a));
    0 < pendingPolls.size && (pollRafId = self.requestAnimationFrame(CheckPendingPolls))
}
C3$jscomp$57.Gfx.WebGLRenderer = class extends C3$jscomp$57.Gfx.RendererBase {
    constructor(a, b) {
        super(b);
        b = Object.assign({}, DEFAULT_WEBGLRENDERER_OPTS, b);
        if (!VALID_POWER_PREFERENCES.has(b.powerPreference))
            throw Error("invalid power preference");
        const c = {
            alpha: !!b.alpha,
            depth: !1,
            antialias: !1,
            powerPreference: b.powerPreference,
            failIfMajorPerformanceCaveat: !!b.failIfMajorPerformanceCaveat
        };
        let d = null
          , e = 0;
        2 <= b.maxWebGLVersion && (d = a.getContext("webgl2", c),
        e = 2);
        d || (d = a.getContext("webgl", c),
        e = 1);
        if (!d)
            throw Error("renderer-unavailable (could not get WebGL context)");
        this._gl = d;
        this._attribs = d.getContextAttributes();
        this._versionString = d.getParameter(d.VERSION);
        this._version = e;
        this._viewport = vec4$jscomp$4.create();
        this._didChangeTransform = !1;
        this._bbProjectionMatrix = mat4$jscomp$7.create();
        this._usesDepthBuffer = !!b.depth;
        this._canSampleDepth = !(!b.depth || !b.canSampleDepth);
        this._isDepthEnabled = this._usesDepthBuffer;
        this._isDepthSamplingEnabled = !1;
        this._depthBuffer = null;
        this._isAutoSizeDepthBuffer = !0;
        this._depthBufferHeight = this._depthBufferWidth = 0;
        this._pointBuffer = this._indexBuffer = this._texcoordBuffer = this._vertexBuffer = null;
        this._vertexData = new Float32Array(8E3 * this.GetNumVertexComponents());
        this._indexData = new Uint16Array(MAX_INDICES);
        this._texcoordData = new Float32Array(16E3);
        this._pointData = new Float32Array(32E3);
        this._lastVertexPtr = this._pointPtr = this._texPtr = this._vertexPtr = 0;
        this._spDeviceTransformTextureFill = this._lastProgram = null;
        this._batch = [];
        this._topOfBatch = this._batchPtr = 0;
        this._currentRenderTarget = null;
        this._lastPointZ = 0;
        this._batchState = C3$jscomp$57.New(C3$jscomp$57.Gfx.BatchState, this);
        this._lastColor = C3$jscomp$57.New(C3$jscomp$57.Color, 1, 1, 1, 1);
        this._lastTexture1 = this._lastTexture0 = null;
        this._lastDestBlend = this._lastSrcBlend = 0;
        this._lastPointTexCoords = new C3$jscomp$57.Rect;
        this._lastScissorRect = C3$jscomp$57.New(C3$jscomp$57.Rect, 0, 0, -1, -1);
        this._coplanarMode = 0;
        this._maxTextureSize = -1;
        this._highpPrecision = this._maxPointSize = this._minPointSize = 0;
        this._unmaskedRenderer = this._unmaskedVendor = "(unavailable)";
        this._extensions = [];
        this._isInitialisingAfterContextRestored = !1;
        this._textureLodExt = this._stdDerivativesExt = this._fragDepthExt = this._depthTextureExt = this._anisotropicExt = this._parallelShaderCompileExt = null;
        this._maxAnisotropy = 0;
        this._isGpuProfilingEnabled = !!b.enableGpuProfiling;
        this._timerExt = null;
        this._allQueryResultBuffers = new Set;
        this._timeQueryStack = [];
        this.FillIndexBufferData(this._indexData)
    }
    IsWebGL() {
        return !0
    }
    async InitState() {
        super.InitState();
        var a = this._gl
          , b = this.GetNumVertexComponents();
        this._lastColor.setRgba(1, 1, 1, 1);
        this._lastTexture1 = this._lastTexture0 = null;
        this._pointPtr = this._vertexPtr = 0;
        this._lastVertexPtr = 8E3 * b - 4 * b;
        C3$jscomp$57.clearArray(this._batch);
        this._topOfBatch = this._batchPtr = 0;
        this._currentRenderTarget = this._lastProgram = null;
        this._lastPointTexCoords.set(0, 0, 1, 1);
        this._lastPointZ = 0;
        b = this._batchState;
        b.currentShader = null;
        b.currentFramebuffer = null;
        b.currentFramebufferNoDepth = null;
        vec4$jscomp$4.set(b.currentColor, 1, 1, 1, 1);
        b.clearColor.setRgba(0, 0, 0, 0);
        b.pointTexCoords.set(0, 0, 1, 1);
        a.clearColor(0, 0, 0, 0);
        a.clear(a.COLOR_BUFFER_BIT);
        a.enable(a.BLEND);
        a.blendFunc(a.ONE, a.ONE_MINUS_SRC_ALPHA);
        this._lastSrcBlend = a.ONE;
        this._lastDestBlend = a.ONE_MINUS_SRC_ALPHA;
        this._InitBlendModes(a);
        a.disable(a.CULL_FACE);
        a.disable(a.STENCIL_TEST);
        a.disable(a.DITHER);
        this._usesDepthBuffer ? (a.enable(a.DEPTH_TEST),
        a.depthMask(!0),
        a.depthFunc(a.LEQUAL)) : (a.disable(a.DEPTH_TEST),
        a.depthMask(!1));
        this._isDepthEnabled = this._usesDepthBuffer;
        this._isDepthSamplingEnabled = !1;
        this._pointBuffer = a.createBuffer();
        a.bindBuffer(a.ARRAY_BUFFER, this._pointBuffer);
        a.bufferData(a.ARRAY_BUFFER, this._pointData.byteLength, a.DYNAMIC_DRAW);
        this._vertexBuffer = a.createBuffer();
        a.bindBuffer(a.ARRAY_BUFFER, this._vertexBuffer);
        a.bufferData(a.ARRAY_BUFFER, this._vertexData.byteLength, a.DYNAMIC_DRAW);
        this._texcoordBuffer = a.createBuffer();
        a.bindBuffer(a.ARRAY_BUFFER, this._texcoordBuffer);
        a.bufferData(a.ARRAY_BUFFER, this._texcoordData.byteLength, a.DYNAMIC_DRAW);
        this._indexBuffer = a.createBuffer();
        a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
        a.bufferData(a.ELEMENT_ARRAY_BUFFER, this._indexData, a.STATIC_DRAW);
        a.activeTexture(a.TEXTURE0);
        a.bindTexture(a.TEXTURE_2D, null);
        this._maxTextureSize = a.getParameter(a.MAX_TEXTURE_SIZE);
        b = a.getParameter(a.ALIASED_POINT_SIZE_RANGE);
        this._minPointSize = b[0];
        this._maxPointSize = b[1];
        b = a.getShaderPrecisionFormat(a.VERTEX_SHADER, a.HIGH_FLOAT);
        var c = a.getShaderPrecisionFormat(a.FRAGMENT_SHADER, a.HIGH_FLOAT);
        this._highpPrecision = b && c ? Math.min(b.precision, c.precision) : 0;
        2048 < this._maxPointSize && (this._maxPointSize = 2048);
        this._extensions = a.getSupportedExtensions();
        if (b = a.getExtension("WEBGL_debug_renderer_info"))
            this._unmaskedVendor = a.getParameter(b.UNMASKED_VENDOR_WEBGL),
            this._unmaskedRenderer = a.getParameter(b.UNMASKED_RENDERER_WEBGL);
        this._parallelShaderCompileExt = a.getExtension("KHR_parallel_shader_compile");
        C3$jscomp$57.isDebug && (loseContextExtension = a.getExtension("WEBGL_lose_context"));
        this._isGpuProfilingEnabled && (1 === this.GetWebGLVersionNumber() ? this._timerExt = a.getExtension("EXT_disjoint_timer_query") : this._timerExt = a.getExtension("EXT_disjoint_timer_query_webgl2") || a.getExtension("EXT_disjoint_timer_query"));
        this._maxAnisotropy = (this._anisotropicExt = a.getExtension("EXT_texture_filter_anisotropic")) ? a.getParameter(this._anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
        if (2 > this.GetWebGLVersionNumber() && this._usesDepthBuffer && this._canSampleDepth && (this._depthTextureExt = a.getExtension("WEBGL_depth_texture"),
        !this._depthTextureExt))
            throw Error("no depth texture support");
        2 > this.GetWebGLVersionNumber() && (this._fragDepthExt = a.getExtension("EXT_frag_depth"),
        this._stdDerivativesExt = a.getExtension("OES_standard_derivatives"),
        this._textureLodExt = a.getExtension("EXT_shader_texture_lod"));
        a = C3$jscomp$57.Gfx.WebGLShaderProgram;
        b = a.GetDefaultVertexShaderSource(!1);
        c = a.GetTextureFillFragmentShaderSource_WebGL1_NoFragDepth();
        let d = b
          , e = a.GetPointFragmentShaderSource_WebGL1_NoFragDepth()
          , f = a.GetPointVertexShaderSource_WebGL1()
          , h = a.GetTilemapFragmentShaderSource_WebGL1_NoFragDepth()
          , l = a.GetDefaultVertexShaderSource(!0);
        var m = !1;
        this._usesDepthBuffer && (2 > this.GetWebGLVersionNumber() ? this._fragDepthExt && (c = a.GetTextureFillFragmentShaderSource_WebGL1_FragDepthEXT(),
        e = a.GetPointFragmentShaderSource_WebGL1_FragDepthEXT(),
        h = a.GetTilemapFragmentShaderSource_WebGL1_FragDepthEXT(),
        m = !0) : (d = a.GetDefaultVertexShaderSource_WebGL2(),
        c = a.GetTextureFillFragmentShaderSource_WebGL2(),
        e = a.GetPointFragmentShaderSource_WebGL2(),
        f = a.GetPointVertexShaderSource_WebGL2(),
        h = a.GetTilemapFragmentShaderSource_WebGL2(),
        l = a.GetDefaultVertexShaderSource_WebGL2(!0)));
        m = a.GetTileRandomizationFragmentShaderSource(this.GetWebGLVersionNumber(), m, this._stdDerivativesExt && this._textureLodExt);
        const p = 2 <= this.GetWebGLVersionNumber() ? a.GetDefaultVertexShaderSource_WebGL2() : b;
        a = [[c, d, "<default>"], [c, d, "<default-device-transform>"], [e, f, "<point>"], [a.GetColorFillFragmentShaderSource(), b, "<fill>"], [a.GetLinearGradientFillFragmentShaderSource(), b, "<lineargradient>"], [a.GetPenumbraFillFragmentShaderSource(), b, "<penumbra>"], [a.GetHardEllipseFillFragmentShaderSource(), b, "<hardellipse>"], [a.GetHardEllipseOutlineFragmentShaderSource(), b, "<hardellipseoutline>"], [a.GetSmoothEllipseFillFragmentShaderSource(), b, "<smoothellipse>"], [a.GetSmoothEllipseOutlineFragmentShaderSource(), b, "<smoothellipseoutline>"], [a.GetSmoothLineFillFragmentShaderSource(), b, "<smoothline>"], [h, l, "<tilemap>"], [m, p, "<tilerandomization>"]];
        a = await Promise.all(a.map(r => this.CreateShaderProgram({
            src: r[0],
            vertexSrc: r[1],
            name: r[2]
        })));
        this._spTextureFill = a[0];
        this._spDeviceTransformTextureFill = a[1];
        this._spPoints = a[2];
        this._spColorFill = a[3];
        this._spLinearGradientFill = a[4];
        this._spPenumbraFill = a[5];
        this._spHardEllipseFill = a[6];
        this._spHardEllipseOutline = a[7];
        this._spSmoothEllipseFill = a[8];
        this._spSmoothEllipseOutline = a[9];
        this._spSmoothLineFill = a[10];
        this._spTilemapFill = a[11];
        this._spTileRandomization = a[12];
        this.SetTextureFillMode()
    }
    async CreateShaderProgram(a) {
        a = await C3$jscomp$57.Gfx.WebGLShaderProgram.Create(this, a);
        this._AddShaderProgram(a);
        return a
    }
    ResetLastProgram() {
        this._lastProgram = null
    }
    SetSize(a, b, c) {
        if (this._width !== a || this._height !== b || c) {
            this.EndBatch();
            c = this._gl;
            var d = this._batchState;
            this._width = a;
            this._height = b;
            this._SetViewport(0, 0, a, b);
            this.CalculatePerspectiveMatrix(this._bbProjectionMatrix, a / b);
            this.SetProjectionMatrix(this._bbProjectionMatrix);
            this._spDeviceTransformTextureFill && (c.useProgram(this._spDeviceTransformTextureFill.GetShaderProgram()),
            this._spDeviceTransformTextureFill._UpdateDeviceTransformUniforms(this._matP),
            this._lastProgram = this._spDeviceTransformTextureFill,
            this._batchState.currentShader = this._spDeviceTransformTextureFill);
            c.bindTexture(c.TEXTURE_2D, null);
            c.activeTexture(c.TEXTURE1);
            c.bindTexture(c.TEXTURE_2D, null);
            c.activeTexture(c.TEXTURE0);
            this._lastTexture1 = this._lastTexture0 = null;
            this._usesDepthBuffer && this._isAutoSizeDepthBuffer && this._SetDepthBufferSize(this._width, this._height);
            this._currentRenderTarget && this._currentRenderTarget._Resize(this._width, this._height);
            c.bindFramebuffer(c.FRAMEBUFFER, null);
            this._currentRenderTarget = null;
            d.currentFramebuffer = null;
            d.currentFramebufferNoDepth = null
        }
    }
    _SetDepthBufferSize(a, b) {
        const c = this._gl;
        this._depthBuffer && this._depthBufferWidth === a && this._depthBufferHeight === b || (this._canSampleDepth ? (this._depthBuffer && c.deleteTexture(this._depthBuffer),
        this._depthBuffer = c.createTexture(),
        c.bindTexture(c.TEXTURE_2D, this._depthBuffer),
        c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MAG_FILTER, c.NEAREST),
        c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MIN_FILTER, c.NEAREST),
        c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_S, c.CLAMP_TO_EDGE),
        c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_T, c.CLAMP_TO_EDGE),
        2 <= this.GetWebGLVersionNumber() ? c.texImage2D(c.TEXTURE_2D, 0, c.DEPTH24_STENCIL8, a, b, 0, c.DEPTH_STENCIL, c.UNSIGNED_INT_24_8, null) : this._depthTextureExt && c.texImage2D(c.TEXTURE_2D, 0, c.DEPTH_STENCIL, a, b, 0, c.DEPTH_STENCIL, this._depthTextureExt.UNSIGNED_INT_24_8_WEBGL, null),
        c.bindTexture(c.TEXTURE_2D, null)) : (this._depthBuffer && c.deleteRenderbuffer(this._depthBuffer),
        this._depthBuffer = c.createRenderbuffer(),
        c.bindRenderbuffer(c.RENDERBUFFER, this._depthBuffer),
        c.renderbufferStorage(c.RENDERBUFFER, 2 <= this._version ? c.DEPTH24_STENCIL8 : c.DEPTH_STENCIL, a, b),
        c.bindRenderbuffer(c.RENDERBUFFER, null)),
        this._depthBufferWidth = a,
        this._depthBufferHeight = b)
    }
    SetFixedSizeDepthBuffer(a, b) {
        this._usesDepthBuffer && (this._isAutoSizeDepthBuffer = !1,
        this._SetDepthBufferSize(a, b))
    }
    SetAutoSizeDepthBuffer() {
        this._usesDepthBuffer && (this._isAutoSizeDepthBuffer = !0,
        this._SetDepthBufferSize(this._width, this._height))
    }
    _SetViewport(a, b, c, d) {
        const e = this._viewport;
        if (e[0] !== a || e[1] !== b || e[2] !== c || e[3] !== d)
            this.PushBatch().InitSetViewport(a, b, c, d),
            vec4$jscomp$4.set(e, a, b, c, d),
            this._topOfBatch = 0
    }
    SetFovY(a) {
        super.SetFovY(a);
        this.CalculatePerspectiveMatrix(this._bbProjectionMatrix, this._width / this._height)
    }
    SetNearZ(a) {
        super.SetNearZ(a);
        this.CalculatePerspectiveMatrix(this._bbProjectionMatrix, this._width / this._height)
    }
    SetFarZ(a) {
        super.SetFarZ(a);
        this.CalculatePerspectiveMatrix(this._bbProjectionMatrix, this._width / this._height)
    }
    SetProjectionMatrix(a) {
        mat4$jscomp$7.exactEquals(this._matP, a) || (this.PushBatch().InitSetProjection(a),
        mat4$jscomp$7.copy(this._matP, a),
        this._topOfBatch = 0,
        this._didChangeTransform = !0)
    }
    SetDefaultRenderTargetProjectionState() {
        let a, b;
        var c = this._currentRenderTarget;
        null === c ? (a = this._bbProjectionMatrix,
        b = this.GetWidth(),
        c = this.GetHeight()) : (a = c.GetProjectionMatrix(),
        b = c.GetWidth(),
        c = c.GetHeight());
        this.SetProjectionMatrix(a);
        this._SetViewport(0, 0, b, c)
    }
    SetModelViewMatrix(a) {
        mat4$jscomp$7.exactEquals(this._matMV, a) || (this.PushBatch().InitSetModelView(a),
        mat4$jscomp$7.copy(this._matMV, a),
        this._topOfBatch = 0,
        this._didChangeTransform = !0)
    }
    ResetDidChangeTransformFlag() {
        this._didChangeTransform = !1
    }
    DidChangeTransform() {
        return this._didChangeTransform
    }
    GetBatchState() {
        return this._batchState
    }
    PushBatch() {
        const a = this._batch;
        this._batchPtr === a.length && a.push(new C3$jscomp$57.Gfx.WebGLBatchJob(this._batchState));
        return a[this._batchPtr++]
    }
    EndBatch() {
        0 === this._batchPtr || this.IsContextLost() || (this._WriteBuffers(),
        this._ExecuteBatch(),
        this._topOfBatch = this._pointPtr = this._texPtr = this._vertexPtr = this._batchPtr = 0)
    }
    _WriteBuffers() {
        const a = this._gl;
        0 < this._pointPtr && (a.bindBuffer(a.ARRAY_BUFFER, this._pointBuffer),
        a.bufferSubData(a.ARRAY_BUFFER, 0, this._pointData.subarray(0, this._pointPtr)));
        0 < this._vertexPtr && (a.bindBuffer(a.ARRAY_BUFFER, this._vertexBuffer),
        a.bufferSubData(a.ARRAY_BUFFER, 0, this._vertexData.subarray(0, this._vertexPtr)),
        a.bindBuffer(a.ARRAY_BUFFER, this._texcoordBuffer),
        a.bufferSubData(a.ARRAY_BUFFER, 0, this._texcoordData.subarray(0, this._texPtr)))
    }
    _ExecuteBatch() {
        const a = this._batch;
        for (let b = 0, c = this._batchPtr; b < c; ++b)
            a[b].Run()
    }
    GetOpacity() {
        return this._lastColor.getA()
    }
    SetColorRgba(a, b, c, d) {
        const e = this._lastColor;
        e.equalsRgba(a, b, c, d) || (e.setRgba(a, b, c, d),
        this.PushBatch().InitSetColor(e),
        this._topOfBatch = 0,
        this._currentStateGroup = null)
    }
    SetOpacity(a) {
        const b = this._lastColor;
        b.getA() !== a && (b.setA(a),
        this.PushBatch().InitSetColor(b),
        this._topOfBatch = 0,
        this._currentStateGroup = null)
    }
    SetColor(a) {
        const b = this._lastColor;
        b.equals(a) || (b.set(a),
        this.PushBatch().InitSetColor(b),
        this._topOfBatch = 0,
        this._currentStateGroup = null)
    }
    ResetColor() {
        this.SetColorRgba(1, 1, 1, 1)
    }
    GetColor() {
        return this._lastColor
    }
    SetTexture(a) {
        a !== this._lastTexture0 && (this.PushBatch().InitSetTexture(a),
        this._lastTexture0 = a,
        this._topOfBatch = 0)
    }
    _ResetLastTexture() {
        this._lastTexture0 = null
    }
    SetBlendMode(a) {
        a = this._GetBlendByIndex(a);
        this._SetBlend(a[0], a[1])
    }
    SetNamedBlendMode(a) {
        a = this.GetNamedBlend(a);
        this._SetBlend(a.srcBlend, a.destBlend)
    }
    _SetBlend(a, b) {
        if (a !== this._lastSrcBlend || b !== this._lastDestBlend)
            this.PushBatch().InitSetBlend(a, b),
            this._lastSrcBlend = a,
            this._lastDestBlend = b,
            this._topOfBatch = 0,
            this._currentStateGroup = null
    }
    IsPremultipliedAlphaBlend() {
        return this._lastSrcBlend === this._gl.ONE && this._lastDestBlend === this._gl.ONE_MINUS_SRC_ALPHA
    }
    SetAlphaBlend() {
        this._SetBlend(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA)
    }
    SetNoPremultiplyAlphaBlend() {
        this._SetBlend(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA)
    }
    SetCopyBlend() {
        this._SetBlend(this._gl.ONE, this._gl.ZERO)
    }
    Rect(a) {
        this.Rect2(a.getLeft(), a.getTop(), a.getRight(), a.getBottom())
    }
    Rect2(a, b, c, d) {
        this.Quad2(a, b, c, b, c, d, a, d)
    }
    _ExtendQuadBatch() {
        let a = this._vertexPtr;
        a >= this._lastVertexPtr && (this.EndBatch(),
        a = 0);
        1 === this._topOfBatch ? this._batch[this._batchPtr - 1]._indexCount += 6 : (this.PushBatch().InitQuad(a, 6),
        this._topOfBatch = 1)
    }
    _WriteQuadToVertexBuffer(a) {
        a.writeToTypedArray3D(this._vertexData, this._vertexPtr, this._baseZ + this._currentZ);
        this._vertexPtr += 12
    }
    Quad(a) {
        this._ExtendQuadBatch();
        this._WriteQuadToVertexBuffer(a);
        defaultTexCoordsQuad$jscomp$1.writeToTypedArray(this._texcoordData, this._texPtr);
        this._texPtr += 8
    }
    Quad2(a, b, c, d, e, f, h, l) {
        this._ExtendQuadBatch();
        const m = this._vertexData;
        let p = this._vertexPtr;
        const r = this._baseZ + this._currentZ;
        m[p++] = a;
        m[p++] = b;
        m[p++] = r;
        m[p++] = c;
        m[p++] = d;
        m[p++] = r;
        m[p++] = e;
        m[p++] = f;
        m[p++] = r;
        m[p++] = h;
        m[p++] = l;
        m[p++] = r;
        this._vertexPtr = p;
        defaultTexCoordsQuad$jscomp$1.writeToTypedArray(this._texcoordData, this._texPtr);
        this._texPtr += 8
    }
    Quad3(a, b) {
        this._ExtendQuadBatch();
        this._WriteQuadToVertexBuffer(a);
        b.writeAsQuadToTypedArray(this._texcoordData, this._texPtr);
        this._texPtr += 8
    }
    Quad4(a, b) {
        this._ExtendQuadBatch();
        this._WriteQuadToVertexBuffer(a);
        b.writeToTypedArray(this._texcoordData, this._texPtr);
        this._texPtr += 8
    }
    Quad3D(a, b, c, d, e, f, h, l, m, p, r, v, x) {
        this._ExtendQuadBatch();
        const B = this._vertexData;
        let A = this._vertexPtr;
        const D = this._baseZ + this._currentZ;
        B[A++] = a;
        B[A++] = b;
        B[A++] = D + c;
        B[A++] = d;
        B[A++] = e;
        B[A++] = D + f;
        B[A++] = h;
        B[A++] = l;
        B[A++] = D + m;
        B[A++] = p;
        B[A++] = r;
        B[A++] = D + v;
        this._vertexPtr = A;
        x.writeAsQuadToTypedArray(this._texcoordData, this._texPtr);
        this._texPtr += 8
    }
    Quad3D2(a, b, c, d, e, f, h, l, m, p, r, v, x) {
        this._ExtendQuadBatch();
        const B = this._vertexData;
        let A = this._vertexPtr;
        const D = this._baseZ + this._currentZ;
        B[A++] = a;
        B[A++] = b;
        B[A++] = D + c;
        B[A++] = d;
        B[A++] = e;
        B[A++] = D + f;
        B[A++] = h;
        B[A++] = l;
        B[A++] = D + m;
        B[A++] = p;
        B[A++] = r;
        B[A++] = D + v;
        this._vertexPtr = A;
        x.writeToTypedArray(this._texcoordData, this._texPtr);
        this._texPtr += 8
    }
    DrawMesh(a, b, c) {
        const d = this._vertexData
          , e = this._texcoordData;
        if (0 !== c.length % 3)
            throw Error("invalid index buffer length");
        for (let m = 0, p = c.length; m < p; ) {
            var f = c[m++]
              , h = c[m++]
              , l = c[m++];
            const r = 3 * f
              , v = 3 * h
              , x = 3 * l;
            f *= 2;
            h *= 2;
            l *= 2;
            this._ExtendQuadBatch();
            let B = this._vertexPtr
              , A = this._texPtr;
            d[B++] = a[r + 0];
            d[B++] = a[r + 1];
            d[B++] = a[r + 2];
            d[B++] = a[v + 0];
            d[B++] = a[v + 1];
            d[B++] = a[v + 2];
            d[B++] = a[x + 0];
            d[B++] = a[x + 1];
            d[B++] = a[x + 2];
            d[B++] = a[x + 0];
            d[B++] = a[x + 1];
            d[B++] = a[x + 2];
            e[A++] = b[f + 0];
            e[A++] = b[f + 1];
            e[A++] = b[h + 0];
            e[A++] = b[h + 1];
            e[A++] = b[l + 0];
            e[A++] = b[l + 1];
            e[A++] = b[l + 0];
            e[A++] = b[l + 1];
            this._vertexPtr = B;
            this._texPtr = A
        }
    }
    FullscreenQuad(a, b) {
        this.SetCurrentZ(0);
        mat4$jscomp$7.copy(tmpProjection, this._matP);
        mat4$jscomp$7.copy(tmpModelView, this._matMV);
        this.SetDefaultRenderTargetProjectionState();
        const [c,d] = this.GetRenderTargetSize(this._currentRenderTarget);
        var e = this.CalculateLookAtModelView2(0, 0, this.GetDefaultCameraZ(d), 0, 0, 0, d);
        this.SetModelViewMatrix(e);
        if ("crop" === a && this._currentRenderTarget && b) {
            a = this._width / 2;
            e = this._height / 2;
            const l = b.GetWidth();
            b = b.GetHeight();
            var f = this._currentRenderTarget.GetWidth()
              , h = this._currentRenderTarget.GetHeight();
            f = Math.min(f, l);
            const m = Math.min(h, b)
              , p = Math.max(b - h, 0);
            h = Math.max(h - b, 0);
            tmpRect$jscomp$1.set(-a, e - h, -a + f, e - m - h);
            tmpQuad$jscomp$1.setFromRect(tmpRect$jscomp$1);
            tmpRect$jscomp$1.set(0, p, f, m + p);
            tmpRect$jscomp$1.divide(l, b);
            this.Quad3(tmpQuad$jscomp$1, tmpRect$jscomp$1)
        } else
            a = c / 2,
            e = d / 2,
            this.Rect2(-a, e, a, -e);
        this.SetProjectionMatrix(tmpProjection);
        this.SetModelViewMatrix(tmpModelView)
    }
    StartRenderingPoints(a) {
        this._lastPointTexCoords.equals(a) || (this._lastPointTexCoords.copy(a),
        this.PushBatch().InitSetPointTexCoords(a),
        this._topOfBatch = 0)
    }
    FinishRenderingPoints() {}
    Point(a, b, c, d) {
        this._pointPtr >= LAST_POINT && this.EndBatch();
        let e = this._pointPtr;
        var f = this._baseZ + this._currentZ;
        2 === this._topOfBatch && this._lastPointZ === f ? this._batch[this._batchPtr - 1]._indexCount++ : (this.PushBatch().InitPoints(e, f),
        this._topOfBatch = 2,
        this._lastPointZ = f);
        f = this._pointData;
        f[e++] = a;
        f[e++] = b;
        f[e++] = c;
        f[e++] = d;
        this._pointPtr = e
    }
    SetProgram(a) {
        this._lastProgram !== a && (this.PushBatch().InitSetProgram(a),
        this._lastProgram = a,
        this._topOfBatch = 0,
        this._currentStateGroup = null)
    }
    GetProgram() {
        return this._lastProgram
    }
    SetDeviceTransformTextureFillMode() {
        this.SetProgram(this._spDeviceTransformTextureFill)
    }
    SetGradientColor(a) {
        this.PushBatch().InitSetGradientColor(a);
        this._topOfBatch = 0
    }
    SetEllipseParams(a, b, c=1) {
        this.PushBatch().InitSetEllipseParams(a, b, c);
        this._topOfBatch = 0
    }
    SetTilemapInfo(a, b, c, d, e, f, h) {
        if (this._lastProgram !== this._spTilemapFill)
            throw Error("must set tilemap fill mode first");
        this.PushBatch().InitSetTilemapInfo(a, b, c, d, e, f, h);
        this._topOfBatch = 0
    }
    SetTileRandomizationInfo(a, b, c, d, e, f, h) {
        if (this._lastProgram !== this._spTileRandomization)
            throw Error("must set tile randomization mode first");
        this.PushBatch().InitSetTileRandomizationInfo(a, b, c, d, e, f, h);
        this._topOfBatch = 0
    }
    SetProgramParameters(a, b, c, d, e, f, h, l, m, p, r) {
        const v = this._lastProgram;
        r %= 10800;
        if (v._hasAnyOptionalUniforms && !v.AreOptionalUniformsAlreadySetInBatch(b, c, d, e, f, h, l, m, p, r)) {
            var x = this.PushBatch();
            x.InitSetProgramParameters();
            v.SetOptionalUniformsInBatch(b, c, d, e, f, h, l, m, p, r);
            var B = x._mat4param;
            B[0] = f;
            B[1] = h;
            b.writeToTypedArray(B, 2);
            B[6] = m;
            B[7] = p;
            c.writeToTypedArray(B, 12);
            b = x._colorParam;
            e.writeToTypedArray(b, 0);
            e = b[1];
            b[1] = b[3];
            b[3] = e;
            d.writeToTypedArray(x._srcOriginRect, 0);
            x._startIndex = r;
            x._indexCount = l;
            v._uSamplerBack.IsUsed() ? x._texParam = a ? a.GetTexture() : null : x._texParam = null;
            this._topOfBatch = 0
        }
    }
    SetProgramCustomParameters(a) {
        const b = this._lastProgram;
        if (0 !== a.length && !b.AreCustomParametersAlreadySetInBatch(a)) {
            var c = this.PushBatch();
            c.InitSetProgramCustomParameters();
            b.SetCustomParametersInBatch(a);
            C3$jscomp$57.shallowAssignArray(c._shaderParams, a);
            this._topOfBatch = 0
        }
    }
    ClearRgba(a, b, c, d) {
        this.PushBatch().InitClearSurface2(a, b, c, d);
        this._topOfBatch = 0
    }
    Clear(a) {
        this.PushBatch().InitClearSurface(a);
        this._topOfBatch = 0
    }
    Start() {}
    Finish() {
        super.Finish();
        this._gl.flush()
    }
    ClearDepth() {
        this._usesDepthBuffer && this._currentRenderTarget && this._currentRenderTarget.HasDepthBuffer() && (this.PushBatch().InitClearDepth(this._isDepthEnabled),
        this._topOfBatch = 0)
    }
    SetDepthEnabled(a) {
        a = !!a;
        this._isDepthEnabled !== a && this._usesDepthBuffer && (this._isDepthEnabled = a,
        this.PushBatch().InitSetDepthEnabled(a),
        this._topOfBatch = 0)
    }
    IsDepthEnabled() {
        return this._isDepthEnabled
    }
    _GetDepthBuffer() {
        return this._depthBuffer
    }
    _CanSampleDepth() {
        return this._canSampleDepth
    }
    SetDepthSamplingEnabled(a) {
        a = !!a;
        if (this._canSampleDepth && this._isDepthSamplingEnabled !== a) {
            if (a && this.IsDepthEnabled())
                throw Error("depth still enabled");
            this._isDepthSamplingEnabled = a;
            this.PushBatch().InitSetDepthSamplingEnabled(a);
            this._topOfBatch = 0
        }
    }
    SetScissorRect(a, b, c, d, e=0) {
        a = Math.floor(a);
        b = Math.floor(b);
        c = Math.floor(c);
        d = Math.floor(d);
        this._lastScissorRect.equalsWH(a, b, c, d) || (this._lastScissorRect.setWH(a, b, c, d),
        b = (e || this.GetRenderTargetSize(this.GetRenderTarget())[1]) - b - d,
        this.PushBatch().InitSetScissor(!0, a, b, c, d),
        this._topOfBatch = 0)
    }
    RemoveScissorRect() {
        -1 !== this._lastScissorRect.getRight() && (this._lastScissorRect.set(0, 0, -1, -1),
        this.PushBatch().InitSetScissor(!1, 0, 0, 0, 0),
        this._topOfBatch = 0)
    }
    CheckForQueryResults() {
        for (const a of this._allQueryResultBuffers)
            a.CheckForResults(this._frameNumber)
    }
    IsContextLost() {
        return !this._gl || this._gl.isContextLost() || this._isInitialisingAfterContextRestored
    }
    OnContextLost() {
        super.OnDeviceOrContextLost();
        C3$jscomp$57.Gfx.WebGLRendererTexture.OnContextLost();
        C3$jscomp$57.Gfx.WebGLRenderTarget.OnContextLost();
        C3$jscomp$57.Gfx.RendererText.OnContextLost();
        for (const a of this._allQueryResultBuffers)
            a.Clear();
        this._extensions = [];
        this._textureLodExt = this._stdDerivativesExt = this._fragDepthExt = this._depthTextureExt = this._anisotropicExt = this._parallelShaderCompileExt = this._timerExt = null;
        this._maxAnisotropy = 0;
        this._unmaskedRenderer = this._unmaskedVendor = "(unavailable)";
        this._depthBuffer = this._spDeviceTransformTextureFill = this._lastProgram = null;
        for (const a of this._stateGroups.values())
            a.OnContextLost()
    }
    async OnContextRestored() {
        this._isInitialisingAfterContextRestored = !0;
        await this.InitState();
        this._isInitialisingAfterContextRestored = !1;
        for (const a of this._stateGroups.values())
            a.OnContextRestored(this);
        this.SetSize(this._width, this._height, !0)
    }
    CreateStaticTexture(a, b) {
        if (this.IsContextLost())
            throw Error("context lost");
        this.EndBatch();
        const c = C3$jscomp$57.New(C3$jscomp$57.Gfx.WebGLRendererTexture, this);
        c._CreateStatic(a, b);
        return c
    }
    async CreateStaticTextureAsync(a, b) {
        if (this.IsContextLost())
            throw Error("context lost");
        b = Object.assign({}, b);
        if (C3$jscomp$57.Supports.ImageBitmapOptions) {
            let c = await createImageBitmap(a, {
                premultiplyAlpha: "premultiply"
            });
            const d = b.wrapX && "clamp-to-edge" !== b.wrapX || b.wrapY && "clamp-to-edge" !== b.wrapY
              , e = C3$jscomp$57.isPOT(c.width) && C3$jscomp$57.isPOT(c.height);
            this.SupportsNPOTTextures() || e || !d ? b.premultiplyAlpha = !1 : C3$jscomp$57.Supports.ImageBitmapOptionsResize ? (c = await createImageBitmap(a, {
                premultiplyAlpha: "premultiply",
                resizeWidth: C3$jscomp$57.nextHighestPowerOfTwo(c.width),
                resizeHeight: C3$jscomp$57.nextHighestPowerOfTwo(c.height)
            }),
            b.premultiplyAlpha = !1) : c = await createImageBitmap(a, {
                premultiplyAlpha: "none"
            });
            return await C3$jscomp$57.Asyncify( () => this.CreateStaticTexture(c, b))
        }
        if (a instanceof Blob) {
            if ("undefined" === typeof Image)
                throw Error("texture upload variant not supported in worker");
            a = await C3$jscomp$57.BlobToImage(a)
        }
        return await C3$jscomp$57.Asyncify( () => this.CreateStaticTexture(a, b))
    }
    CreateDynamicTexture(a, b, c) {
        this.EndBatch();
        const d = C3$jscomp$57.New(C3$jscomp$57.Gfx.WebGLRendererTexture, this);
        d._CreateDynamic(a, b, c);
        return d
    }
    UpdateTexture(a, b, c) {
        this.EndBatch();
        b._Update(a, c)
    }
    DeleteTexture(a) {
        a && (a.SubtractReference(),
        0 < a.GetReferenceCount() || (this.EndBatch(),
        a === this._lastTexture0 && (this._gl.bindTexture(this._gl.TEXTURE_2D, null),
        this._lastTexture0 = null),
        a === this._lastTexture1 && (this._gl.activeTexture(this._gl.TEXTURE1),
        this._gl.bindTexture(this._gl.TEXTURE_2D, null),
        this._gl.activeTexture(this._gl.TEXTURE0),
        this._lastTexture1 = null),
        a._Delete()))
    }
    CreateRenderTarget(a) {
        let b = this._width
          , c = this._height
          , d = !0;
        a && ("number" === typeof a.width && (b = Math.floor(a.width),
        d = !1),
        "number" === typeof a.height && (c = Math.floor(a.height),
        d = !1));
        if (0 >= b || 0 >= c)
            throw Error("invalid size");
        this.EndBatch();
        const e = C3$jscomp$57.New(C3$jscomp$57.Gfx.WebGLRenderTarget, this);
        e._Create(b, c, Object.assign({
            isDefaultSize: d
        }, a));
        this._currentRenderTarget = null;
        this._batchState.currentFramebuffer = null;
        this._batchState.currentFramebufferNoDepth = null;
        return e
    }
    SetRenderTarget(a, b=!0) {
        a !== this._currentRenderTarget && (a && a.IsDefaultSize() && a._Resize(this._width, this._height),
        this.PushBatch().InitSetRenderTarget(a),
        this._currentRenderTarget = a,
        this._topOfBatch = 0,
        b && this.SetDefaultRenderTargetProjectionState())
    }
    GetRenderTarget() {
        return this._currentRenderTarget
    }
    GetRenderTargetSize(a) {
        return a ? [a.GetWidth(), a.GetHeight()] : [this._width, this._height]
    }
    CopyRenderTarget(a, b="stretch") {
        2 > this._version || this._currentRenderTarget && 0 < this._currentRenderTarget.GetMultisampling() ? (this.SetCopyBlend(),
        this.ResetColor(),
        this.DrawRenderTarget(a, b)) : (this.PushBatch().InitBlitFramebuffer(a, this._currentRenderTarget, b),
        this._topOfBatch = 0)
    }
    DrawRenderTarget(a, b="stretch") {
        a = a.GetTexture();
        if (!a)
            throw Error("not a texture-backed render target");
        this.SetTexture(a);
        this.FullscreenQuad(b, a)
    }
    InvalidateRenderTarget(a) {
        2 > this._version || (this.PushBatch().InitInvalidateFramebuffer(a._GetFramebuffer()),
        this._topOfBatch = 0)
    }
    DeleteRenderTarget(a) {
        this.SetRenderTarget(null);
        this.EndBatch();
        const b = a.GetTexture();
        b === this._lastTexture0 && (this._gl.bindTexture(this._gl.TEXTURE_2D, null),
        this._lastTexture0 = null);
        b === this._lastTexture1 && (this._gl.activeTexture(this._gl.TEXTURE1),
        this._gl.bindTexture(this._gl.TEXTURE_2D, null),
        this._gl.activeTexture(this._gl.TEXTURE0),
        this._lastTexture1 = null);
        a._Delete()
    }
    async ReadBackRenderTargetToImageData(a, b, c) {
        this.EndBatch();
        const d = this._currentRenderTarget;
        if (a) {
            var e = a.GetWidth();
            var f = a.GetHeight();
            var h = a._GetFramebuffer()
        } else
            e = this.GetWidth(),
            f = this.GetHeight(),
            h = null;
        let l = a = 0;
        var m = e
          , p = f;
        c && (a = C3$jscomp$57.clamp(Math.floor(c.getLeft()), 0, e - 1),
        l = C3$jscomp$57.clamp(Math.floor(c.getTop()), 0, f - 1),
        m = c.width(),
        m = 0 === m ? e - a : C3$jscomp$57.clamp(Math.floor(m), 0, e - a),
        p = c.height(),
        p = 0 === p ? f - l : C3$jscomp$57.clamp(Math.floor(p), 0, f - l),
        l = f - (l + p));
        const r = this._gl;
        r.bindFramebuffer(r.FRAMEBUFFER, h);
        f = () => {
            r.bindFramebuffer(r.FRAMEBUFFER, null);
            this._currentRenderTarget = null;
            this._batchState.currentFramebuffer = null;
            this._batchState.currentFramebufferNoDepth = null;
            this.SetRenderTarget(d)
        }
        ;
        if (!b && 2 <= this.GetWebGLVersionNumber()) {
            r.bindFramebuffer(r.READ_FRAMEBUFFER, h);
            h = r.createBuffer();
            c = m * p * 4;
            e = r.PIXEL_PACK_BUFFER;
            r.bindBuffer(e, h);
            r.bufferData(e, c, r.STREAM_READ);
            r.readPixels(a, l, m, p, r.RGBA, r.UNSIGNED_BYTE, 0);
            r.bindFramebuffer(r.READ_FRAMEBUFFER, null);
            r.bindBuffer(e, null);
            f();
            const v = r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE, 0);
            await this._WaitForObjectReady( () => r.getSyncParameter(v, r.SYNC_STATUS) === r.SIGNALED);
            r.deleteSync(v);
            b = new ImageData(m,p);
            r.bindBuffer(e, h);
            r.getBufferSubData(e, 0, new Uint8Array(b.data.buffer), 0, c);
            r.bindBuffer(e, null);
            r.deleteBuffer(h)
        } else
            b = new ImageData(m,p),
            r.readPixels(a, l, m, p, r.RGBA, r.UNSIGNED_BYTE, new Uint8Array(b.data.buffer)),
            f();
        return b
    }
    CoplanarStartStencilPass() {
        this.SetDepthEnabled(!0);
        this.PushBatch().InitCoplanarStartStencilPass();
        this._topOfBatch = 0;
        this._coplanarMode = 1
    }
    CoplanarStartColorPass() {
        this.SetDepthEnabled(!1);
        this.PushBatch().InitCoplanarStartColorPass();
        this._topOfBatch = 0;
        this._coplanarMode = 2
    }
    IsCoplanarColorPass() {
        return 2 === this._coplanarMode
    }
    CoplanarRestoreStandardRendering() {
        this.SetDepthEnabled(!0);
        this.PushBatch().InitCoplanarRestore();
        this._coplanarMode = this._topOfBatch = 0
    }
    StartQuery(a) {
        this.SupportsGPUProfiling() && (this.PushBatch().InitStartQuery(a),
        this._topOfBatch = 0)
    }
    EndQuery(a) {
        this.SupportsGPUProfiling() && (this.PushBatch().InitEndQuery(a),
        this._topOfBatch = 0)
    }
    _WaitForObjectReady(a) {
        const b = new Promise(c => pendingPolls.add({
            resolve: c,
            checkFunc: a
        }));
        -1 === pollRafId && (pollRafId = self.requestAnimationFrame(CheckPendingPolls));
        return b
    }
    GetEstimatedBackBufferMemoryUsage() {
        return this._width * this._height * (this._attribs.alpha ? 4 : 3)
    }
    GetEstimatedRenderBufferMemoryUsage() {
        let a = 0;
        for (const b of C3$jscomp$57.Gfx.WebGLRenderTarget.allRenderTargets())
            b.GetTexture() || (a += b.GetEstimatedMemoryUsage());
        return a
    }
    GetEstimatedTextureMemoryUsage() {
        let a = 0;
        for (const b of C3$jscomp$57.Gfx.WebGLRendererTexture.allTextures())
            a += b.GetEstimatedMemoryUsage();
        return a
    }
    GetWebGLVersionString() {
        return this._versionString
    }
    GetWebGLVersionNumber() {
        return this._version
    }
    GetDisplayName() {
        return "webgl" + this.GetWebGLVersionNumber()
    }
    SupportsNPOTTextures() {
        return 2 <= this.GetWebGLVersionNumber()
    }
    GetMaxTextureSize() {
        return this._maxTextureSize
    }
    GetMinPointSize() {
        return this._minPointSize
    }
    GetMaxPointSize() {
        return this._maxPointSize
    }
    SupportsHighP() {
        return 0 !== this._highpPrecision
    }
    GetHighPPrecision() {
        return this._highpPrecision
    }
    GetUnmaskedVendor() {
        return this._unmaskedVendor
    }
    GetUnmaskedRenderer() {
        return this._unmaskedRenderer
    }
    GetWebGLExtensionsAnalyticsString() {
        if (2 <= this.GetWebGLVersionNumber())
            return "webgl2";
        const a = [];
        this._fragDepthExt && a.push("EXT_frag_depth");
        this._stdDerivativesExt && a.push("OES_standard_derivatives");
        this._textureLodExt && a.push("EXT_shader_texture_lod");
        return 0 < a.length ? "webgl1:" + a.join(",") : "webgl1:none"
    }
    GetExtensions() {
        return this._extensions
    }
    SupportsGPUProfiling() {
        return !!this._timerExt
    }
    _GetDisjointTimerQueryExtension() {
        return this._timerExt
    }
    _GetParallelShaderCompileExtension() {
        return this._parallelShaderCompileExt
    }
    _GetAnisotropicExtension() {
        return this._anisotropicExt
    }
    _GetMaxAnisotropy() {
        return this._maxAnisotropy
    }
    _AddQueryResultBuffer(a) {
        this._allQueryResultBuffers.add(a)
    }
    _RemoveQueryResultBuffer(a) {
        this._allQueryResultBuffers.delete(a)
    }
    _GetTimeQueryStack() {
        return this._timeQueryStack
    }
    GetContext() {
        return this._gl
    }
    _InitBlendModes(a) {
        this._InitBlendModeData([["normal", a.ONE, a.ONE_MINUS_SRC_ALPHA], ["additive", a.ONE, a.ONE], ["xor", a.ONE, a.ONE_MINUS_SRC_ALPHA], ["copy", a.ONE, a.ZERO], ["destination-over", a.ONE_MINUS_DST_ALPHA, a.ONE], ["source-in", a.DST_ALPHA, a.ZERO], ["destination-in", a.ZERO, a.SRC_ALPHA], ["source-out", a.ONE_MINUS_DST_ALPHA, a.ZERO], ["destination-out", a.ZERO, a.ONE_MINUS_SRC_ALPHA], ["source-atop", a.DST_ALPHA, a.ONE_MINUS_SRC_ALPHA], ["destination-atop", a.ONE_MINUS_DST_ALPHA, a.SRC_ALPHA]])
    }
    CreateWebGLText() {
        return this.CreateRendererText()
    }
}
;
"use strict";
const DEFAULT_CTOR_OPTS = {
    getDrawSize: null,
    getRenderTarget: null,
    releaseRenderTarget: null,
    getTime: null,
    redraw: null
};
self.C3.Gfx.EffectChainManager = class {
    constructor(a) {
        a = Object.assign({}, DEFAULT_CTOR_OPTS, a);
        this._cbGetDrawSize = a.getDrawSize;
        this._cbGetRenderTarget = a.getRenderTarget;
        this._cbReleaseRenderTarget = a.releaseRenderTarget;
        this._cbGetTime = a.getTime;
        this._cbRedraw = a.redraw;
        this._webgpuBackTexture = null;
        this._allEffectChains = new Set
    }
    _AddEffectChain(a) {
        this._allEffectChains.add(a)
    }
    _RemoveEffectChain(a) {
        this._allEffectChains.delete(a)
    }
    OnContextLost() {
        this._webgpuBackTexture = null;
        for (const a of this._allEffectChains)
            a.OnContextLost()
    }
    GetDrawSize(a) {
        return this._cbGetDrawSize ? this._cbGetDrawSize(a) : [a.GetWidth(), a.GetHeight()]
    }
    GetRenderTarget(a) {
        return this._cbGetRenderTarget(a)
    }
    ReleaseRenderTarget(a, b) {
        this._cbReleaseRenderTarget(a, b)
    }
    GetTime() {
        return this._cbGetTime()
    }
    Redraw(a) {
        this._cbRedraw(a)
    }
    _GetWebGPUBackTexture(a, b, c) {
        b = Math.floor(b);
        c = Math.floor(c);
        !this._webgpuBackTexture || this._webgpuBackTexture.GetWidth() === b && this._webgpuBackTexture.GetHeight() === c || (a.DeleteTexture(this._webgpuBackTexture),
        this._webgpuBackTexture = null);
        null === this._webgpuBackTexture && (this._webgpuBackTexture = a.CreateStaticTexture(null, {
            width: b,
            height: c,
            sampling: "nearest",
            mipMap: !1
        }));
        return this._webgpuBackTexture
    }
}
;
"use strict";
const C3$jscomp$59 = self.C3
  , mat4$jscomp$8 = self.glMatrix.mat4
  , tempRect = C3$jscomp$59.New(C3$jscomp$59.Rect)
  , tempRect2 = C3$jscomp$59.New(C3$jscomp$59.Rect)
  , tempRect3 = C3$jscomp$59.New(C3$jscomp$59.Rect)
  , tempRect4 = C3$jscomp$59.New(C3$jscomp$59.Rect)
  , tempMat4a = mat4$jscomp$8.create()
  , tempMat4b$jscomp$1 = mat4$jscomp$8.create()
  , DEFAULT_CTOR_OPTS$jscomp$1 = {
    drawContent: null,
    getSourceTextureInfo: null,
    getShaderParameters: null,
    invalidateRenderTargets: !1
}
  , DEFAULT_BUILDSTEPS_OPTS = {
    indexMap: null,
    forcePreDraw: !1,
    forcePostDraw: !1,
    is3D: !1,
    isSourceTextureRotated: !1,
    isRotatedOrNegativeSizeInstance: !1,
    useFullSurface: !1
};
C3$jscomp$59.Gfx.EffectChain = class {
    constructor(a, b) {
        b = Object.assign({}, DEFAULT_CTOR_OPTS$jscomp$1, b);
        this._manager = a;
        this._cbDrawContent = b.drawContent;
        this._cbGetSourceTextureInfo = b.getSourceTextureInfo;
        this._cbGetShaderParameters = b.getShaderParameters;
        this._cbDrawContentHook = null;
        this._shaderProgramList = [];
        this._shaderProgramIndices = [];
        this._steps = [];
        this._needsRebuild = !1;
        this._blendMode = 0;
        this._isSourceTextureRotated = this._useFullSurface = this._canUseFastPath = this._coplanarColorPassAtStart = this._depthEnabledAtStart = this._didChangeTransform = this._useCopyTextureBackgroundSampling = this._isAnyIsSrcTexRotated = this._isAnyShaderCrossSampling = this._isAnyShaderBackgroundBlending = this._isAnyShaderDepthSampling = this._isAnyShaderAnimated = !1;
        this._numTempSurfacesRequired = 0;
        this._renderTargets = [null, null, null];
        this._invalidateRenderTargets = !!b.invalidateRenderTargets;
        this._drawHeight = this._drawWidth = this._boxExtendVertical = this._boxExtendHorizontal = 0;
        this._contextObject = this._contentObject = null;
        this._layoutRect = C3$jscomp$59.New(C3$jscomp$59.Rect);
        this._drawSurfaceRect = C3$jscomp$59.New(C3$jscomp$59.Rect);
        this._rcTexOriginal = C3$jscomp$59.New(C3$jscomp$59.Rect);
        this._rcTexBounce = C3$jscomp$59.New(C3$jscomp$59.Rect);
        this._rcTexDest = C3$jscomp$59.New(C3$jscomp$59.Rect);
        this._layerScale = this._devicePixelRatio = 1;
        this._time = this._layerAngle = 0;
        this._backTex = this._destRenderTarget = null;
        this._compositOffY = this._compositOffX = 0;
        this._updateOwnProjection = !1;
        this._projectionMatrix = mat4$jscomp$8.create();
        this._modelViewMatrix = mat4$jscomp$8.create();
        this._manager._AddEffectChain(this)
    }
    Release() {
        this._manager._RemoveEffectChain(this);
        C3$jscomp$59.clearArray(this._steps);
        C3$jscomp$59.clearArray(this._shaderProgramList);
        C3$jscomp$59.clearArray(this._shaderProgramIndices);
        this._cbGetShaderParameters = this._cbGetSourceTextureInfo = this._cbDrawContent = this._contextObject = this._contentObject = null
    }
    OnContextLost() {
        this._needsRebuild = !0;
        C3$jscomp$59.clearArray(this._steps);
        C3$jscomp$59.clearArray(this._shaderProgramList);
        C3$jscomp$59.clearArray(this._shaderProgramIndices)
    }
    NeedsRebuild() {
        return this._needsRebuild
    }
    BuildSteps(a, b) {
        b = Object.assign({}, DEFAULT_BUILDSTEPS_OPTS, b);
        C3$jscomp$59.clearArray(this._steps);
        this._boxExtendVertical = this._boxExtendHorizontal = 0;
        this._useCopyTextureBackgroundSampling = this._isAnyIsSrcTexRotated = this._isAnyShaderCrossSampling = this._isAnyShaderBackgroundBlending = this._isAnyShaderDepthSampling = this._isAnyShaderAnimated = !1;
        this._numTempSurfacesRequired = 0;
        this._isSourceTextureRotated = !!b.isSourceTextureRotated;
        this._useFullSurface = !!b.useFullSurface;
        this._needsRebuild = !1;
        C3$jscomp$59.shallowAssignArray(this._shaderProgramList, a);
        if (0 !== a.length) {
            if (b.indexMap) {
                if (b.indexMap.length !== a.length)
                    throw Error("incorrect indexMap length");
                C3$jscomp$59.shallowAssignArray(this._shaderProgramIndices, b.indexMap)
            } else {
                C3$jscomp$59.clearArray(this._shaderProgramIndices);
                for (let e = 0, f = a.length; e < f; ++e)
                    this._shaderProgramIndices.push(e)
            }
            for (var c of a)
                this._boxExtendHorizontal += c.GetBoxExtendHorizontal(),
                this._boxExtendVertical += c.GetBoxExtendVertical(),
                c.IsAnimated() && (this._isAnyShaderAnimated = !0),
                c.UsesDepth() && (this._isAnyShaderDepthSampling = !0),
                c.BlendsBackground() && (this._isAnyShaderBackgroundBlending = !0),
                c.UsesCrossSampling() && (this._isAnyShaderCrossSampling = !0),
                c.UsesIsSrcTexRotated() && (this._isAnyIsSrcTexRotated = !0);
            this._useCopyTextureBackgroundSampling = this._ShouldUseCopyTextureBackgroundSampling(a[0].GetRenderer());
            c = this._ShouldPreDraw(a[0], b);
            b = this._ShouldPostDraw(a.at(-1), b);
            if (1 !== a.length || c || b) {
                this._canUseFastPath = !1;
                var d = 0;
                c && (this._numTempSurfacesRequired = 1,
                this._steps.push(C3$jscomp$59.New(C3$jscomp$59.Gfx.EffectChain.Step.PreDraw, this, -1, 1)),
                d = 1);
                for (let e = 0, f = a.length; e < f; ++e)
                    0 !== e || c ? (a = 1 === d ? 2 : 1,
                    e !== f - 1 || b || (a = 0),
                    this._numTempSurfacesRequired = Math.max(this._numTempSurfacesRequired, a),
                    this._steps.push(C3$jscomp$59.New(C3$jscomp$59.Gfx.EffectChain.Step.Bounce, this, d, a, e)),
                    d = a) : (this._numTempSurfacesRequired = 1,
                    this._steps.push(C3$jscomp$59.New(C3$jscomp$59.Gfx.EffectChain.Step.FirstBounce, this, -1, 1, e)),
                    d = 1);
                b && this._steps.push(C3$jscomp$59.New(C3$jscomp$59.Gfx.EffectChain.Step.PostDraw, this, d, 0))
            } else
                this._canUseFastPath = !0
        }
    }
    _ShouldPreDraw(a, b) {
        return b.forcePreDraw || a.MustPreDraw() || b.is3D && !a.Supports3DDirectRendering() || a.UsesDepth() && !this._useFullSurface || 0 !== this._boxExtendHorizontal || 0 !== this._boxExtendVertical ? !0 : a.GetRenderer().IsWebGL() ? a.BlendsBackground() && (b.isRotatedOrNegativeSizeInstance || b.isSourceTextureRotated) || a.UsesAnySrcRectOrPixelSize() && b.isSourceTextureRotated : a.BlendsBackground() && !this._useCopyTextureBackgroundSampling && b.isRotatedOrNegativeSizeInstance
    }
    _ShouldPostDraw(a, b) {
        return b.forcePostDraw ? !0 : a.GetRenderer().IsWebGL() ? a.BlendsBackground() || a.UsesCrossSampling() : (a.BlendsBackground() || a.UsesCrossSampling()) && this._UseRenderTargetBackgroundSampling()
    }
    _ShouldUseCopyTextureBackgroundSampling(a) {
        return a.IsWebGPU() && this._isAnyShaderBackgroundBlending && !this._isAnyShaderCrossSampling
    }
    Render(a, b, c) {
        a.IsWebGPU() && null === b && (b = a.GetBackbufferRenderTarget());
        this._destRenderTarget = b;
        this._contentObject = c.contentObject || null;
        this._contextObject = c.contextObject || null;
        this._blendMode = c.blendMode || 0;
        this._devicePixelRatio = c.devicePixelRatio || 1;
        this._layerScale = c.layerScale || 1;
        this._layerAngle = c.layerAngle || 0;
        this._time = "number" === typeof c.time ? c.time : this._manager.GetTime();
        this._didChangeTransform = !1;
        a.ResetDidChangeTransformFlag();
        this._isAnyShaderAnimated && this._Redraw();
        let d = !1;
        this._UseCopyTextureBackgroundSampling() && (this._CalculateDrawSizeAndRectangles(a, c),
        d = !0,
        this._backTex = this._manager._GetWebGPUBackTexture(a, this._drawWidth, this._drawHeight),
        tempRect.copy(this._drawSurfaceRect),
        tempRect.roundOuter(),
        a.IsWebGPU() && a._MaybeDoPendingClearRenderPass(this._destRenderTarget),
        a.CopyTextureToTexture(this._destRenderTarget.GetTexture(), this._backTex, tempRect.getLeft(), tempRect.getTop(), tempRect.width(), tempRect.height()));
        if (this._canUseFastPath)
            this._Render_FastPath(a, c);
        else if (d || this._CalculateDrawSizeAndRectangles(a, c),
        0 !== this._rcTexOriginal.width() || 0 !== this._rcTexOriginal.height()) {
            a.SetAlphaBlend();
            a.ResetColor();
            a.SetBaseZ(0);
            a.SetCurrentZ(0);
            this._cbDrawContentHook = c.drawContentHook || null;
            this._compositOffX = c.compositOffX || 0;
            this._compositOffY = c.compositOffY || 0;
            this._updateOwnProjection = !!c.updateOwnProjection;
            this._OnBeforeStartEffectChain(a);
            this._renderTargets[0] = b;
            this._renderTargets[1] = 1 <= this._numTempSurfacesRequired ? this._GetRenderTarget() : null;
            this._renderTargets[2] = 2 === this._numTempSurfacesRequired ? this._GetRenderTarget() : null;
            for (const e of this._steps)
                b = this._GetRenderTargetForId(e.GetSrcTargetId()),
                c = this._GetRenderTargetForId(e.GetDestTargetId()),
                a.IsWebGPU() ? e.Run_WebGPU(a, b, c) : e.Run_WebGL(a, b, c);
            a.SetTexture(null);
            this._renderTargets[1] && this._ReleaseRenderTarget(this._renderTargets[1]);
            this._renderTargets[2] && this._ReleaseRenderTarget(this._renderTargets[2]);
            this._renderTargets.fill(null);
            this._OnAfterEndEffectChain(a);
            this._cbDrawContentHook = this._contextObject = this._contentObject = this._backTex = this._destRenderTarget = null
        }
    }
    _CalculateDrawSizeAndRectangles(a, b) {
        const [c,d] = this._manager.GetDrawSize(a);
        this._SetDrawSize(a, c, d);
        this._CalculateRectangles(b)
    }
    _SetDrawSize(a, b, c) {
        if (0 >= b || 0 >= c)
            throw Error("invalid draw size");
        this._drawWidth === b && this._drawHeight === c || this._CalculateDeviceTransformMatrices(a, b, c, 0, 0, this._projectionMatrix, this._modelViewMatrix);
        this._drawWidth = b;
        this._drawHeight = c
    }
    _CalculateDeviceTransformMatrices(a, b, c, d, e, f, h) {
        d = b / 2 + d;
        e = c / 2 + e;
        a.CalculatePerspectiveMatrix(f, b / c);
        a = a.CalculateLookAtModelView2(d, e, a.GetDefaultCameraZ(c), d, e, 0, c);
        mat4$jscomp$8.copy(h, a)
    }
    _CalculateRectangles(a) {
        this._layoutRect.copy(a.layoutRect);
        a.drawSurfaceRect ? this._drawSurfaceRect.copy(a.drawSurfaceRect) : this._drawSurfaceRect.set(0, 0, this._drawWidth, this._drawHeight);
        this._rcTexOriginal.copy(this._drawSurfaceRect);
        this._rcTexOriginal.divide(this._drawWidth, this._drawHeight);
        a = this._layerScale * this._devicePixelRatio;
        this._drawSurfaceRect.inflate(this._boxExtendHorizontal * a, this._boxExtendVertical * a);
        this._rcTexDest.copy(this._drawSurfaceRect);
        this._rcTexDest.divide(this._drawWidth, this._drawHeight);
        this._drawSurfaceRect.clampBoth(0, 0, this._drawWidth, this._drawHeight);
        this._rcTexBounce.copy(this._drawSurfaceRect);
        this._rcTexBounce.divide(this._drawWidth, this._drawHeight)
    }
    _OnBeforeStartEffectChain(a) {
        this._depthEnabledAtStart = a.IsDepthEnabled();
        this._coplanarColorPassAtStart = a.IsCoplanarColorPass();
        if (this._useFullSurface)
            a.SetDepthEnabled(!1),
            this._isAnyShaderDepthSampling && a.SetDepthSamplingEnabled(!0);
        else {
            tempRect.copy(this._drawSurfaceRect);
            if (a.IsWebGL()) {
                const b = this._layerScale * this._devicePixelRatio;
                tempRect.inflate(Math.max(this._boxExtendHorizontal, 1) * b, Math.max(this._boxExtendVertical, 1) * b);
                tempRect.roundOuter();
                tempRect.clamp(0, 0, this._drawWidth, this._drawHeight)
            } else
                tempRect.roundOuter();
            a.SetScissorRect(tempRect.getLeft(), tempRect.getTop(), tempRect.width(), tempRect.height(), this._drawHeight)
        }
    }
    _OnAfterEffectChainDrawContent(a) {
        a.ResetColor();
        this._useFullSurface || (this._coplanarColorPassAtStart && a.CoplanarRestoreStandardRendering(),
        a.SetDepthEnabled(!1),
        this._isAnyShaderDepthSampling && a.SetDepthSamplingEnabled(!0));
        a.IsWebGPU() && a.SetNormalizedCoordsProgramVariant(!0)
    }
    _OnAfterEndEffectChain(a) {
        a.SetDepthSamplingEnabled(!1);
        this._coplanarColorPassAtStart && a.CoplanarStartColorPass();
        a.SetDepthEnabled(this._depthEnabledAtStart);
        this._useFullSurface || a.RemoveScissorRect();
        a.IsWebGPU() && a.SetNormalizedCoordsProgramVariant(!1);
        this._didChangeTransform = a.DidChangeTransform()
    }
    _ClampRcTexDest() {
        this._rcTexDest.clamp(0, 0, 1, 1)
    }
    _GetRenderTargetForId(a) {
        return 0 > a ? null : this._renderTargets[a]
    }
    _GetRenderTarget() {
        return this._manager.GetRenderTarget(this)
    }
    _GetDestRenderTarget() {
        return this._destRenderTarget
    }
    _ReleaseRenderTarget(a) {
        this._manager.ReleaseRenderTarget(a, this)
    }
    _GetShaderProgramAt(a) {
        return this._shaderProgramList[a]
    }
    _DrawContent(a) {
        this._cbDrawContentHook ? this._cbDrawContentHook(this, a, () => this._cbDrawContent(a, this)) : this._cbDrawContent(a, this);
        this._canUseFastPath || this._OnAfterEffectChainDrawContent(a)
    }
    _IsRenderTargetSameSizeAndOffset(a) {
        if (this._useFullSurface)
            return !0;
        if (0 !== this._compositOffX || 0 !== this._compositOffY)
            return !1;
        const [b,c] = a.GetRenderTargetSize(a.GetRenderTarget());
        return b !== this._drawWidth || c !== this._drawHeight ? !1 : !0
    }
    _SetDeviceTransform(a, b) {
        let c = this._projectionMatrix
          , d = this._modelViewMatrix;
        if (b && !this._IsRenderTargetSameSizeAndOffset(a)) {
            c = tempMat4a;
            d = tempMat4b$jscomp$1;
            const [e,f] = a.GetRenderTargetSize(a.GetRenderTarget());
            this._CalculateDeviceTransformMatrices(a, e, f, this._compositOffX, this._compositOffY, c, d);
            this._useFullSurface || a.RemoveScissorRect()
        }
        a.SetProjectionMatrix(c);
        a.SetModelViewMatrix(d)
    }
    _Redraw() {
        this._manager.Redraw(this)
    }
    _GetShaderParameters(a, b) {
        return this._cbGetShaderParameters(this._shaderProgramIndices[a], b)
    }
    _SetProgramParameters(a, b) {
        let c = this._rcTexDest
          , d = this._rcTexBounce
          , e = this._rcTexOriginal;
        a.IsWebGL() && (tempRect2.copy(c),
        tempRect2.flipAround(1),
        c = tempRect2,
        tempRect3.copy(d),
        tempRect3.flipAround(1),
        d = tempRect3,
        tempRect4.copy(e),
        tempRect4.flipAround(1),
        e = tempRect4);
        this._DoSetProgramParameters(a, b, d, e, c, 1 / this._drawWidth, 1 / this._drawHeight)
    }
    _SetFirstBounceProgramParameters(a, b) {
        let c = this._rcTexBounce
          , d = this._rcTexOriginal
          , e = 1 / this._drawWidth
          , f = 1 / this._drawHeight;
        if (this._cbGetSourceTextureInfo) {
            let {srcTexRect: l, srcWidth: m, srcHeight: p} = this._cbGetSourceTextureInfo(this._contentObject);
            l || (tempRect.set(0, 0, 0, 0),
            l = tempRect);
            m || (m = this._drawWidth);
            p || (p = this._drawHeight);
            d = c = l;
            e = 1 / m;
            f = 1 / p
        } else
            a.IsWebGL() && (tempRect3.copy(c),
            tempRect3.flipAround(1),
            c = tempRect3,
            tempRect4.copy(d),
            tempRect4.flipAround(1),
            d = tempRect4);
        let h = this._rcTexDest;
        a.IsWebGL() && (h = tempRect2,
        h.copy(this._rcTexDest),
        h.flipAround(1));
        this._DoSetProgramParameters(a, b, c, d, h, e, f);
        a.IsWebGPU() && this._isAnyIsSrcTexRotated && a.SetProgramParameter_IsSrcTexRotated(this._isSourceTextureRotated)
    }
    _GetBackTex(a) {
        return this._isAnyShaderBackgroundBlending ? a.IsWebGPU() ? this._UseCopyTextureBackgroundSampling() ? this._backTex : this._destRenderTarget.GetTexture() : this._destRenderTarget : null
    }
    _DoSetProgramParameters(a, b, c, d, e, f, h) {
        a.SetProgramParameters(this._GetBackTex(a), e, c, d, this._layoutRect, f, h, this._devicePixelRatio, this._layerScale, this._layerAngle, this._time);
        a.SetProgramCustomParameters(this._GetShaderParameters(b, a))
    }
    _Render_FastPath(a, b) {
        var c = this._shaderProgramList[0];
        const d = a.IsDepthEnabled()
          , e = c.UsesDepth();
        e && (a.SetDepthEnabled(!1),
        a.SetDepthSamplingEnabled(!0),
        this._rcTexDest.set(0, 0, 1, 1),
        this._rcTexOriginal.set(0, 0, 1, 1));
        a.SetProgram(c);
        a.SetBlendMode(this._blendMode);
        a.SetRenderTarget(this._destRenderTarget);
        let f;
        this._rcTexOriginal.set(0, 0, 1, 1);
        if (c.UsesAnySrcRectOrPixelSize() && this._cbGetSourceTextureInfo) {
            const {srcTexRect: h, srcWidth: l, srcHeight: m} = this._cbGetSourceTextureInfo(this._contentObject);
            h && this._rcTexOriginal.copy(h);
            c = Number.isFinite(l) ? 1 / l : 0;
            f = Number.isFinite(m) ? 1 / m : 0
        } else {
            const [h,l] = this._manager.GetDrawSize(a);
            c = 1 / h;
            f = 1 / l
        }
        b.layoutRect ? this._layoutRect.copy(b.layoutRect) : this._layoutRect.set(0, 0, 0, 0);
        a.SetProgramParameters(this._GetBackTex(a), this._rcTexDest, this._rcTexOriginal, this._rcTexOriginal, this._layoutRect, c, f, this._devicePixelRatio, this._layerScale, this._layerAngle, this._time);
        a.SetProgramCustomParameters(this._GetShaderParameters(0, a));
        a.IsWebGPU() && this._isAnyIsSrcTexRotated && a.SetProgramParameter_IsSrcTexRotated(this._isSourceTextureRotated);
        a.SetBaseZ(0);
        this._DrawContent(a);
        e && (a.SetDepthSamplingEnabled(!1),
        a.SetDepthEnabled(d))
    }
    _UseCopyTextureBackgroundSampling() {
        return this._useCopyTextureBackgroundSampling
    }
    _UseRenderTargetBackgroundSampling() {
        return !this._useCopyTextureBackgroundSampling
    }
    IsAnyShaderBackgroundBlending() {
        return this._isAnyShaderBackgroundBlending
    }
    CanSkipCalculatingDrawSurfaceRect() {
        return !this._canUseFastPath || this._UseCopyTextureBackgroundSampling() ? !1 : !0
    }
    UseFullSurface() {
        return this._useFullSurface
    }
    GetContentObject() {
        return this._contentObject
    }
    GetContextObject() {
        return this._contextObject
    }
    _GetBlendMode() {
        return this._blendMode
    }
    _UpdateOwnProjection() {
        return this._updateOwnProjection
    }
    DidChangeTransform() {
        return this._didChangeTransform
    }
    _GetDrawSurfaceRect() {
        return this._drawSurfaceRect
    }
    _GetRcTexBounce() {
        return this._rcTexBounce
    }
    _ShouldInvalidateRenderTargets() {
        return this._invalidateRenderTargets
    }
    async DebugLogRenderTargetContents(a, b, c) {}
}
;
"use strict";
self.C3.Gfx.EffectChain.Step = class {
    constructor(a, b, c, d=-1) {
        this._effectChain = a;
        this._srcTargetId = b;
        this._destTargetId = c;
        this._index = d
    }
    GetEffectChain() {
        return this._effectChain
    }
    GetSrcTargetId() {
        return this._srcTargetId
    }
    GetDestTargetId() {
        return this._destTargetId
    }
    GetIndex() {
        return this._index
    }
    GetShaderProgram() {
        return this.GetEffectChain()._GetShaderProgramAt(this.GetIndex())
    }
    Run_WebGL(a, b, c) {}
    Run_WebGPU(a, b, c) {}
}
;
"use strict";
const C3$jscomp$61 = self.C3;
C3$jscomp$61.Gfx.EffectChain.Step.PreDraw = class extends C3$jscomp$61.Gfx.EffectChain.Step {
    constructor(a, b, c, d) {
        super(a, b, c, d)
    }
    Run_WebGL(a, b, c) {
        b = this.GetEffectChain();
        a.SetAlphaBlend();
        a.SetTextureFillMode();
        a.SetRenderTarget(c, b._UpdateOwnProjection());
        a.ClearRgba(0, 0, 0, 0);
        b._DrawContent(a);
        b._ClampRcTexDest()
    }
    Run_WebGPU(a, b, c) {
        b = this.GetEffectChain();
        a.SetAlphaBlend();
        a.SetTextureFillMode();
        a.SetRenderTarget(c, !1);
        a.ClearRgba(0, 0, 0, 0);
        b._DrawContent(a);
        b._ClampRcTexDest()
    }
}
;
"use strict";
const C3$jscomp$62 = self.C3
  , tempRect$jscomp$1 = C3$jscomp$62.New(C3$jscomp$62.Rect)
  , tempQuad$jscomp$1 = C3$jscomp$62.New(C3$jscomp$62.Quad);
C3$jscomp$62.Gfx.EffectChain.Step.PostDraw = class extends C3$jscomp$62.Gfx.EffectChain.Step {
    constructor(a, b, c, d) {
        super(a, b, c, d)
    }
    Run_WebGL(a, b, c) {
        const d = this.GetEffectChain();
        a.SetTextureFillMode();
        a.SetRenderTarget(c);
        d._SetDeviceTransform(a, !0);
        a.SetBlendMode(d._GetBlendMode());
        a.SetTexture(b.GetTexture());
        tempQuad$jscomp$1.setFromRect(d._GetDrawSurfaceRect());
        tempRect$jscomp$1.copy(d._GetRcTexBounce());
        tempRect$jscomp$1.flipAround(1);
        a.Quad3(tempQuad$jscomp$1, tempRect$jscomp$1);
        d._ShouldInvalidateRenderTargets() && a.InvalidateRenderTarget(b)
    }
    Run_WebGPU(a, b, c) {
        const d = this.GetEffectChain();
        a.SetTextureFillMode();
        a.SetRenderTarget(c, !1);
        d._IsRenderTargetSameSizeAndOffset(a) ? tempQuad$jscomp$1.setFromRect(d._GetRcTexBounce()) : (a.SetNormalizedCoordsProgramVariant(!1),
        d._SetDeviceTransform(a, !0),
        tempQuad$jscomp$1.setFromRect(d._GetDrawSurfaceRect()));
        a.SetBackTexture(null);
        a.SetBlendMode(d._GetBlendMode());
        a.SetTexture(b.GetTexture());
        d.UseFullSurface() ? a.FullscreenQuad() : a.Quad3(tempQuad$jscomp$1, d._GetRcTexBounce())
    }
}
;
"use strict";
const C3$jscomp$63 = self.C3;
C3$jscomp$63.Gfx.EffectChain.Step.FirstBounce = class extends C3$jscomp$63.Gfx.EffectChain.Step {
    constructor(a, b, c, d) {
        super(a, b, c, d)
    }
    Run_WebGL(a, b, c) {
        b = this.GetEffectChain();
        a.SetRenderTarget(c, b._UpdateOwnProjection());
        a.ClearRgba(0, 0, 0, 0);
        a.SetCopyBlend();
        a.SetProgram(this.GetShaderProgram());
        b._SetFirstBounceProgramParameters(a, this.GetIndex());
        b._DrawContent(a);
        b._ClampRcTexDest()
    }
    Run_WebGPU(a, b, c) {
        b = this.GetEffectChain();
        a.SetRenderTarget(c, !1);
        a.ClearRgba(0, 0, 0, 0);
        a.SetCopyBlend();
        a.SetProgram(this.GetShaderProgram());
        b._SetFirstBounceProgramParameters(a, this.GetIndex());
        b._DrawContent(a);
        b._ClampRcTexDest()
    }
}
;
"use strict";
const C3$jscomp$64 = self.C3
  , tempRect$jscomp$2 = C3$jscomp$64.New(C3$jscomp$64.Rect)
  , tempQuad$jscomp$2 = C3$jscomp$64.New(C3$jscomp$64.Quad);
C3$jscomp$64.Gfx.EffectChain.Step.Bounce = class extends C3$jscomp$64.Gfx.EffectChain.Step {
    constructor(a, b, c, d) {
        super(a, b, c, d)
    }
    Run_WebGL(a, b, c) {
        const d = this.GetEffectChain();
        a.SetRenderTarget(c);
        (c = 0 === this.GetDestTargetId()) ? a.SetBlendMode(d._GetBlendMode()) : (a.ClearRgba(0, 0, 0, 0),
        a.SetCopyBlend());
        a.SetProgram(this.GetShaderProgram());
        d._SetProgramParameters(a, this.GetIndex());
        a.SetTexture(b.GetTexture());
        d._SetDeviceTransform(a, c);
        tempQuad$jscomp$2.setFromRect(d._GetDrawSurfaceRect());
        tempRect$jscomp$2.copy(d._GetRcTexBounce());
        tempRect$jscomp$2.flipAround(1);
        a.Quad3(tempQuad$jscomp$2, tempRect$jscomp$2);
        d._ShouldInvalidateRenderTargets() && a.InvalidateRenderTarget(b)
    }
    Run_WebGPU(a, b, c) {
        const d = this.GetEffectChain();
        a.SetRenderTarget(c, !1);
        0 === this.GetDestTargetId() ? (a.SetBlendMode(d._GetBlendMode()),
        a.SetBackTexture(null),
        d._IsRenderTargetSameSizeAndOffset(a) ? tempQuad$jscomp$2.setFromRect(d._GetRcTexBounce()) : (a.SetNormalizedCoordsProgramVariant(!1),
        d._SetDeviceTransform(a, !0),
        tempQuad$jscomp$2.setFromRect(d._GetDrawSurfaceRect()))) : (a.ClearRgba(0, 0, 0, 0),
        a.SetCopyBlend(),
        tempQuad$jscomp$2.setFromRect(d._GetRcTexBounce()));
        a.SetProgram(this.GetShaderProgram());
        d._SetProgramParameters(a, this.GetIndex());
        a.SetTexture(b.GetTexture());
        d.UseFullSurface() ? a.FullscreenQuad() : a.Quad3(tempQuad$jscomp$2, d._GetRcTexBounce())
    }
}
;
"use strict";
const C3$jscomp$65 = self.C3
  , C3X$jscomp$1 = self.C3X;
let runtime$jscomp$1 = null;
const keysDownByKey = new Set;
function SortZOrderList(a, b) {
    const c = a[0] - b[0];
    return 0 !== c ? c : a[1] - b[1]
}
const tempZOrderList = []
  , tempInstances = [];
let didWarnInAlertPolyfill = !1
  , didWarnFpsDeprecated = !1;
const VALID_FRAMERATE_MODES = new Set(["vsync", "unlimited-tick", "unlimited-frame"]);
self.IRuntime = class {
    constructor(a) {
        runtime$jscomp$1 = a;
        Object.defineProperties(this, {
            assets: {
                value: runtime$jscomp$1.GetAssetManager().GetIAssetManager(),
                writable: !1
            },
            collisions: {
                value: runtime$jscomp$1.GetCollisionEngine().GetICollisionEngine(),
                writable: !1
            },
            objects: {
                value: {},
                writable: !1
            },
            globalVars: {
                value: {},
                writable: !1
            },
            projectName: {
                value: runtime$jscomp$1.GetProjectName(),
                writable: !1
            },
            projectVersion: {
                value: runtime$jscomp$1.GetProjectVersion(),
                writable: !1
            },
            storage: {
                value: new self.IStorage(runtime$jscomp$1),
                writable: !1
            },
            isInWorker: {
                value: runtime$jscomp$1.IsInWorker(),
                writable: !1
            },
            viewportWidth: {
                value: runtime$jscomp$1.GetOriginalViewportWidth(),
                writable: !1
            },
            viewportHeight: {
                value: runtime$jscomp$1.GetOriginalViewportHeight(),
                writable: !1
            },
            sampling: {
                value: runtime$jscomp$1.GetSampling(),
                writable: !1
            },
            isPixelRoundingEnabled: {
                value: runtime$jscomp$1.IsPixelRoundingEnabled(),
                writable: !1
            }
        });
        runtime$jscomp$1.UserScriptDispatcher().addEventListener("keydown", b => {
            keysDownByKey.has(b.key) ? b.stopPropagation() : keysDownByKey.add(b.key)
        }
        );
        runtime$jscomp$1.UserScriptDispatcher().addEventListener("keyup", b => keysDownByKey.delete(b.key));
        runtime$jscomp$1.Dispatcher().addEventListener("window-blur", () => keysDownByKey.clear());
        runtime$jscomp$1.IsInWorker() && (self.alert = b => {
            didWarnInAlertPolyfill || (didWarnInAlertPolyfill = !0,
            console.warn("[Construct] alert() was called from a Web Worker, because the project 'Use worker' setting is enabled. This method is not normally available in a Web Worker. Construct has implemented the alert for you, but note that other features may be missing in worker mode. You may wish to disable 'Use worker', or use a more convenient function like console.log(). For more information please refer to the scripting section of the manual."));
            return this.alert(b)
        }
        )
    }
    _InitObjects(a) {
        Object.defineProperties(this.objects, a)
    }
    _InitGlobalVars(a) {
        Object.defineProperties(this.globalVars, a)
    }
    addEventListener(a, b) {
        runtime$jscomp$1.UserScriptDispatcher().addEventListener(a, b)
    }
    removeEventListener(a, b) {
        runtime$jscomp$1.UserScriptDispatcher().removeEventListener(a, b)
    }
    callFunction(a, ...b) {
        C3X$jscomp$1.RequireString(a);
        const c = runtime$jscomp$1.GetEventSheetManager()
          , d = c.GetFunctionBlockByName(a);
        if (!d)
            throw Error(`cannot find function name '${a}'`);
        if (!d.IsEnabled())
            return d.GetDefaultReturnValue();
        if (b.length < d.GetFunctionParameterCount())
            throw Error(`not enough function parameters passed for '${a}' (${b.length} passed, ${d.GetFunctionParameterCount()} expected)`);
        a = d.GetEventBlock();
        let e = a.GetSolModifiersIncludingParents();
        const f = c.GetCurrentEvent();
        if (f) {
            e = e.slice(0);
            const h = new Set(e);
            for (const l of f.GetSolModifiersIncludingParents())
                h.has(l) || (e.push(l),
                h.add(l));
            for (const l of c.GetDynamicSolModifiersSet())
                h.has(l) || (e.push(l),
                h.add(l))
        }
        return a.RunAsExpressionFunctionCall(e, d.IsCopyPicked(), d.GetReturnType(), d.GetDefaultReturnValue(), ...b)
    }
    setReturnValue(a) {
        const b = runtime$jscomp$1.GetEventStack().GetCurrentExpFuncStackFrame();
        if (!b)
            throw Error("not in a function which returns a value");
        switch (b.GetFunctionReturnType()) {
        case 1:
            "number" === typeof a && b.SetFunctionReturnValue(a);
            break;
        case 2:
            "string" === typeof a && b.SetFunctionReturnValue(a);
            break;
        case 3:
            "number" !== typeof a && "string" !== typeof a || b.SetFunctionReturnValue(a)
        }
    }
    getViewportSize() {
        return [runtime$jscomp$1.GetOriginalViewportWidth(), runtime$jscomp$1.GetOriginalViewportHeight()]
    }
    get dt() {
        return runtime$jscomp$1.GetDt()
    }
    get dtRaw() {
        return runtime$jscomp$1.GetDtRaw()
    }
    get gameTime() {
        return runtime$jscomp$1.GetGameTime()
    }
    get wallTime() {
        return runtime$jscomp$1.GetWallTime()
    }
    get timeScale() {
        return runtime$jscomp$1.GetTimeScale()
    }
    set timeScale(a) {
        C3X$jscomp$1.RequireFiniteNumber(a);
        runtime$jscomp$1.SetTimeScale(a)
    }
    get fps() {
        didWarnFpsDeprecated || (console.warn("IRuntime.fps is deprecated. Use IRuntime.framesPerSecond instead."),
        didWarnFpsDeprecated = !0);
        return runtime$jscomp$1.GetFramesPerSecond()
    }
    get framesPerSecond() {
        return runtime$jscomp$1.GetFramesPerSecond()
    }
    get ticksPerSecond() {
        return runtime$jscomp$1.GetTicksPerSecond()
    }
    get cpuUtilisation() {
        return runtime$jscomp$1.GetMainThreadTime()
    }
    get gpuUtilisation() {
        return runtime$jscomp$1.GetGPUUtilisation()
    }
    get framerateMode() {
        return runtime$jscomp$1.GetFramerateMode()
    }
    set framerateMode(a) {
        if (!VALID_FRAMERATE_MODES.has(a))
            throw Error("invalid framerate mode");
        runtime$jscomp$1._SetFramerateMode(a)
    }
    get minDt() {
        return runtime$jscomp$1.GetMinDt()
    }
    set minDt(a) {
        C3X$jscomp$1.RequireFiniteNumber(a);
        runtime$jscomp$1.SetMinDt(a)
    }
    get maxDt() {
        return runtime$jscomp$1.GetMaxDt()
    }
    set maxDt(a) {
        runtime$jscomp$1.SetMaxDt(a)
    }
    random() {
        return runtime$jscomp$1.Random()
    }
    get layout() {
        const a = runtime$jscomp$1.GetMainRunningLayout();
        if (!a)
            throw Error("no layout is running - make sure a layout is loaded before accessing");
        return a.GetILayout()
    }
    getLayout(a) {
        const b = runtime$jscomp$1.GetLayoutManager();
        if ("number" === typeof a || "string" === typeof a)
            a = b.GetLayout(a);
        else
            throw new TypeError("expected string or number");
        if (!a)
            throw Error("invalid layout");
        return a.GetILayout()
    }
    getAllLayouts() {
        return runtime$jscomp$1.GetLayoutManager().GetAllLayouts().map(a => a.GetILayout())
    }
    goToLayout(a) {
        const b = runtime$jscomp$1.GetLayoutManager();
        if ("number" === typeof a || "string" === typeof a)
            a = b.GetLayout(a);
        else
            throw new TypeError("expected string or number");
        if (!a)
            throw Error("invalid layout");
        b.IsPendingChangeMainLayout() || b.ChangeMainLayout(a)
    }
    get keyboard() {
        const a = runtime$jscomp$1._GetCommonScriptInterfaces().keyboard;
        if (!a)
            throw Error("runtime.keyboard used but Keyboard object missing - add it to your project first");
        return a
    }
    get mouse() {
        const a = runtime$jscomp$1._GetCommonScriptInterfaces().mouse;
        if (!a)
            throw Error("runtime.mouse used but Mouse object missing - add it to your project first");
        return a
    }
    get touch() {
        const a = runtime$jscomp$1._GetCommonScriptInterfaces().touch;
        if (!a)
            throw Error("runtime.touch used but Touch object missing - add it to your project first");
        return a
    }
    get timelineController() {
        const a = runtime$jscomp$1._GetCommonScriptInterfaces().timelineController;
        if (!a)
            throw Error("runtime.timelineController used but Timeline Controller object missing - add it to your project first");
        return a
    }
    get platformInfo() {
        const a = runtime$jscomp$1._GetCommonScriptInterfaces().platformInfo;
        if (!a)
            throw Error("runtime.platformInfo used but Platform Info object missing - add it to your project first");
        return a
    }
    invokeDownload(a, b) {
        C3X$jscomp$1.RequireString(a);
        C3X$jscomp$1.RequireString(b);
        runtime$jscomp$1.InvokeDownload(a, b)
    }
    getInstanceByUid(a) {
        C3X$jscomp$1.RequireFiniteNumber(a);
        return (a = runtime$jscomp$1.GetInstanceByUID(a)) ? a.GetInterfaceClass() : null
    }
    sortZOrder(a, b) {
        C3X$jscomp$1.RequireFunction(b);
        const c = runtime$jscomp$1.GetCurrentLayout();
        for (var d of a) {
            a = runtime$jscomp$1._UnwrapIWorldInstance(d);
            var e = a.GetWorldInfo();
            tempZOrderList.push([e.GetLayer().GetIndex(), e.GetZIndex()]);
            tempInstances.push(a)
        }
        if (0 !== tempZOrderList.length) {
            tempZOrderList.sort(SortZOrderList);
            tempInstances.sort( (f, h) => b(f.GetInterfaceClass(), h.GetInterfaceClass()));
            d = !1;
            for (let f = 0, h = tempZOrderList.length; f < h; ++f) {
                a = tempInstances[f];
                e = c.GetLayerByIndex(tempZOrderList[f][0]);
                const l = tempZOrderList[f][1]
                  , m = e._GetInstances();
                m[l] !== a && (m[l] = a,
                a.GetWorldInfo()._SetLayer(e, !0),
                e.SetZIndicesChanged(a),
                d = !0)
            }
            d && runtime$jscomp$1.UpdateRender();
            C3$jscomp$65.clearArray(tempZOrderList);
            C3$jscomp$65.clearArray(tempInstances)
        }
    }
    async createWorker(a, b) {
        var c = new MessageChannel;
        const d = c.port1;
        c = c.port2;
        await runtime$jscomp$1.PostComponentMessageToDOMAsync("runtime", "script-create-worker", {
            url: a,
            opts: b,
            port2: c
        }, [c]);
        return d
    }
    alert(a) {
        return runtime$jscomp$1.PostComponentMessageToDOMAsync("runtime", "alert", {
            message: a + (runtime$jscomp$1.IsInWorker() ? " [via Web Worker]" : "")
        })
    }
    getHTMLLayer(a) {
        C3X$jscomp$1.RequireFiniteNumber(a);
        return runtime$jscomp$1._GetHTMLLayerWrapElement(a)
    }
    addLoadPromise(a) {
        runtime$jscomp$1.AddLoadPromise(a)
    }
}
;
"use strict";
const C3$jscomp$66 = self.C3;
let assetManager = null;
self.IAssetManager = class {
    constructor(a) {
        assetManager = a;
        Object.defineProperties(this, {
            isWebMOpusSupported: {
                value: assetManager.IsAudioFormatSupported("audio/webm; codecs=opus"),
                writable: !1
            }
        })
    }
    loadImageAsset(a) {
        a = self.IImageInfo._Unwrap(a);
        if (!a)
            throw Error("invalid IImageInfo");
        a.LoadAsset(assetManager.GetRuntime())
    }
    fetchText(a) {
        return assetManager.FetchText(a)
    }
    fetchJson(a) {
        return assetManager.FetchJson(a)
    }
    fetchBlob(a) {
        return assetManager.FetchBlob(a)
    }
    fetchArrayBuffer(a) {
        return assetManager.FetchArrayBuffer(a)
    }
    getProjectFileUrl(a) {
        return assetManager.GetProjectFileUrl(a)
    }
    getMediaFileUrl(a) {
        "flat" === assetManager.GetFileStructure() && C3$jscomp$66.IsRelativeURL(a) && (a = a.toLowerCase());
        return assetManager.GetMediaFileUrl(a)
    }
    get mediaFolder() {
        return assetManager.GetMediaSubfolder()
    }
    async decodeWebMOpus(a, b) {
        if (this.isWebMOpusSupported)
            throw Error("decodeWebMOpus(): not supported because WebM Opus is supported by the platform");
        b = await assetManager.GetRuntime()._WasmDecodeWebMOpus(b);
        b = new Float32Array(b);
        a = a.createBuffer(1, b.length, 48E3);
        a.getChannelData(0).set(b);
        return a
    }
    loadScripts(...a) {
        return assetManager.LoadScripts(...a)
    }
    compileWebAssembly(a) {
        return assetManager.CompileWebAssembly(a)
    }
    loadStyleSheet(a) {
        return assetManager.LoadStyleSheet(a)
    }
}
;
"use strict";
const C3$jscomp$67 = self.C3
  , C3X$jscomp$3 = self.C3X;
let collisionEngine = null;
self.ICollisionEngine = class {
    constructor(a) {
        collisionEngine = a;
        Object.defineProperties(this, {
            runtime: {
                value: collisionEngine.GetRuntime(),
                writable: !1
            }
        })
    }
    testOverlap(a, b) {
        const c = collisionEngine.GetRuntime();
        a = c._UnwrapIWorldInstance(a);
        b = c._UnwrapIWorldInstance(b);
        return collisionEngine.TestOverlap(a, b)
    }
    testOverlapAny(a, b) {
        const c = collisionEngine.GetRuntime();
        a = c._UnwrapIWorldInstance(a);
        for (const d of b)
            if (b = c._UnwrapIWorldInstance(d),
            collisionEngine.TestOverlap(a, b))
                return d;
        return null
    }
    testOverlapSolid(a) {
        a = collisionEngine.GetRuntime()._UnwrapIWorldInstance(a);
        return (a = collisionEngine.TestOverlapSolid(a)) ? a.GetInterfaceClass() : null
    }
    setCollisionCellSize(a, b) {
        C3X$jscomp$3.RequireFiniteNumber(a);
        C3X$jscomp$3.RequireFiniteNumber(b);
        a = Math.floor(a);
        b = Math.floor(b);
        if (0 >= a || 0 >= b)
            throw Error("invalid cell size");
        collisionEngine.SetCollisionCellSize(a, b)
    }
    getCollisionCellSize() {
        return collisionEngine.GetCollisionCellSize()
    }
    getCollisionCandidates(a, b) {
        const c = collisionEngine.GetRuntime();
        a = Array.isArray(a) ? a.map(e => c._UnwrapIObjectClass(e)) : [c._UnwrapIObjectClass(a)];
        b = C3$jscomp$67.Rect.FromObject(b);
        const d = [];
        collisionEngine.GetObjectClassesCollisionCandidates(null, a, b, d);
        return d.map(e => e.GetInterfaceClass())
    }
}
;
"use strict";
const C3X$jscomp$4 = self.C3X;
self.IStorage = class {
    constructor(a) {
        this._storage = a._GetProjectStorage()
    }
    getItem(a) {
        C3X$jscomp$4.RequireString(a);
        return this._storage.getItem(a)
    }
    setItem(a, b) {
        C3X$jscomp$4.RequireString(a);
        return this._storage.setItem(a, b)
    }
    removeItem(a) {
        C3X$jscomp$4.RequireString(a);
        return this._storage.removeItem(a)
    }
    clear() {
        return this._storage.clear()
    }
    keys() {
        return this._storage.keys()
    }
}
;
"use strict";
const C3$jscomp$69 = self.C3
  , internalApiToken$jscomp$1 = C3$jscomp$69._GetInternalAPIToken();
self.IPlugin = class {
    constructor() {
        const a = C3$jscomp$69.AddonManager._GetInitObject2(internalApiToken$jscomp$1);
        Object.defineProperties(this, {
            runtime: {
                value: a.GetRuntime().GetIRuntime(),
                writable: !1
            },
            isSingleGlobal: {
                value: a.IsSingleGlobal(),
                writable: !1
            },
            isWorldType: {
                value: a.IsWorldType(),
                writable: !1
            },
            isHTMLElementType: {
                value: a.IsHTMLElementType(),
                writable: !1
            },
            isRotatable: {
                value: a.IsRotatable(),
                writable: !1
            },
            hasEffects: {
                value: a.HasEffects(),
                writable: !1
            },
            is3d: {
                value: a.Is3D(),
                writable: !1
            },
            supportsHierarchies: {
                value: a.SupportsSceneGraph(),
                writable: !1
            },
            supportsMesh: {
                value: a.SupportsMesh(),
                writable: !1
            }
        })
    }
}
;
"use strict";
const C3$jscomp$70 = self.C3
  , C3X$jscomp$6 = self.C3X
  , map$jscomp$2 = new WeakMap
  , internalApiToken$jscomp$2 = C3$jscomp$70._GetInternalAPIToken();
self.IObjectClass = class {
    constructor() {
        const a = C3$jscomp$70.AddonManager._GetInitObject2(internalApiToken$jscomp$2);
        map$jscomp$2.set(this, a);
        Object.defineProperties(this, {
            name: {
                value: a.GetName(),
                writable: !1
            },
            runtime: {
                value: a.GetRuntime().GetIRuntime(),
                writable: !1
            },
            plugin: {
                value: a.GetPlugin().GetIPlugin(),
                writable: !1
            }
        });
        a.GetRuntime()._MapScriptInterface(this, a)
    }
    addEventListener(a, b) {
        C3X$jscomp$6.RequireString(a);
        C3X$jscomp$6.RequireFunction(b);
        map$jscomp$2.get(this).UserScriptDispatcher().addEventListener(a, b)
    }
    removeEventListener(a, b) {
        C3X$jscomp$6.RequireString(a);
        C3X$jscomp$6.RequireFunction(b);
        map$jscomp$2.get(this).UserScriptDispatcher().removeEventListener(a, b)
    }
    getAllInstances() {
        return [...this.instances()]
    }
    getFirstInstance() {
        return C3$jscomp$70.first(this.instances())
    }
    getPickedInstances() {
        return [...this.pickedInstances()]
    }
    getFirstPickedInstance() {
        return C3$jscomp$70.first(this.pickedInstances())
    }
    *instances() {
        for (const a of map$jscomp$2.get(this).instancesIncludingPendingCreate())
            yield a.GetInterfaceClass()
    }
    *pickedInstances() {
        for (const a of map$jscomp$2.get(this).GetCurrentSol().GetInstances())
            yield a.GetInterfaceClass()
    }
    setInstanceClass(a) {
        C3X$jscomp$6.RequireFunction(a);
        if (0 < map$jscomp$2.get(this).GetInstanceCount())
            throw Error("setInstanceClass() called too late, because instances have already been created - call in runOnStartup");
        map$jscomp$2.get(this)._SetUserScriptInstanceClass(a)
    }
    createInstance(a, b, c, d, e) {
        C3X$jscomp$6.RequireNumber(b);
        C3X$jscomp$6.RequireNumber(c);
        if ("number" !== typeof a && "string" !== typeof a)
            throw new TypeError("invalid layer parameter");
        const f = map$jscomp$2.get(this)
          , h = f.GetRuntime();
        a = h.GetMainRunningLayout().GetLayer(a);
        if (!a)
            throw Error("invalid layer");
        b = h.CreateInstance(f, a, b, c, d, e);
        d && a.SortAndAddInstancesByZIndex(b);
        d = h.GetEventSheetManager();
        d.BlockFlushingInstances(!0);
        b._TriggerOnCreatedOnSelfAndRelated();
        d.BlockFlushingInstances(!1);
        d.IsInEventEngine() || h.GetLayoutManager().IsEndingLayout() || h.FlushPendingInstances();
        return b.GetInterfaceClass()
    }
}
;
"use strict";
const C3X$jscomp$7 = self.C3X
  , map$jscomp$3 = new WeakMap
  , VALID_WHERE_STRINGS = ["above", "below", "top-sublayer", "bottom-sublayer"];
self.ILayout = class {
    constructor(a) {
        map$jscomp$3.set(this, a);
        const b = []
          , c = a.GetEffectList()
          , d = c.GetAllEffectTypes().length;
        for (let e = 0; e < d; ++e)
            b.push(new self.IEffectInstance(c,e));
        Object.defineProperties(this, {
            name: {
                value: a.GetName(),
                writable: !1
            },
            index: {
                value: a.GetIndex(),
                writable: !1
            },
            effects: {
                value: b,
                writable: !1
            }
        })
    }
    addEventListener(a, b) {
        C3X$jscomp$7.RequireString(a);
        C3X$jscomp$7.RequireFunction(b);
        map$jscomp$3.get(this).UserScriptDispatcher().addEventListener(a, b)
    }
    removeEventListener(a, b) {
        C3X$jscomp$7.RequireString(a);
        C3X$jscomp$7.RequireFunction(b);
        map$jscomp$3.get(this).UserScriptDispatcher().removeEventListener(a, b)
    }
    get width() {
        return map$jscomp$3.get(this).GetWidth()
    }
    set width(a) {
        C3X$jscomp$7.RequireFiniteNumber(a);
        map$jscomp$3.get(this).SetWidth(a)
    }
    get height() {
        return map$jscomp$3.get(this).GetHeight()
    }
    set height(a) {
        C3X$jscomp$7.RequireFiniteNumber(a);
        map$jscomp$3.get(this).SetHeight(a)
    }
    setSize(a, b) {
        C3X$jscomp$7.RequireFiniteNumber(a);
        C3X$jscomp$7.RequireFiniteNumber(b);
        const c = map$jscomp$3.get(this);
        c.SetWidth(a);
        c.SetHeight(b)
    }
    getSize() {
        const a = map$jscomp$3.get(this);
        return [a.GetWidth(), a.GetHeight()]
    }
    set scale(a) {
        C3X$jscomp$7.RequireFiniteNumber(a);
        map$jscomp$3.get(this).SetScale(a)
    }
    get scale() {
        return map$jscomp$3.get(this).GetScale()
    }
    set angle(a) {
        C3X$jscomp$7.RequireFiniteNumber(a);
        map$jscomp$3.get(this).SetAngle(a)
    }
    get angle() {
        return map$jscomp$3.get(this).GetAngle()
    }
    set scrollX(a) {
        C3X$jscomp$7.RequireNumber(a);
        map$jscomp$3.get(this).SetScrollX(a)
    }
    get scrollX() {
        return map$jscomp$3.get(this).GetScrollX()
    }
    set scrollY(a) {
        C3X$jscomp$7.RequireNumber(a);
        map$jscomp$3.get(this).SetScrollY(a)
    }
    get scrollY() {
        return map$jscomp$3.get(this).GetScrollY()
    }
    scrollTo(a, b) {
        C3X$jscomp$7.RequireNumber(a);
        C3X$jscomp$7.RequireNumber(b);
        const c = map$jscomp$3.get(this);
        c.SetScrollX(a);
        c.SetScrollY(b)
    }
    getScrollPosition() {
        const a = map$jscomp$3.get(this);
        return [a.GetScrollX(), a.GetScrollY()]
    }
    getLayer(a) {
        const b = map$jscomp$3.get(this);
        if ("number" === typeof a || "string" === typeof a)
            a = b.GetLayer(a);
        else
            throw new TypeError("expected string or number");
        return a ? a.GetILayer() : null
    }
    getAllLayers() {
        return map$jscomp$3.get(this).GetLayers().map(a => a.GetILayer())
    }
    *allLayers() {
        for (const a of map$jscomp$3.get(this).allLayers())
            yield a.GetILayer()
    }
    addLayer(a, b, c) {
        const d = map$jscomp$3.get(this)
          , e = self.ILayer;
        C3X$jscomp$7.RequireString(a);
        C3X$jscomp$7.RequireOptionalInstanceOf(b, e);
        b = b ? d.GetRuntime()._UnwrapScriptInterface(b) : null;
        c = VALID_WHERE_STRINGS.indexOf(c);
        if (0 > c)
            throw Error("invalid location");
        d.AddLayer(a, b, c)
    }
    moveLayer(a, b, c) {
        const d = map$jscomp$3.get(this)
          , e = d.GetRuntime()
          , f = self.ILayer;
        C3X$jscomp$7.RequireInstanceOf(a, f);
        a = e._UnwrapScriptInterface(a);
        if (!a)
            throw Error("invalid layer");
        C3X$jscomp$7.RequireOptionalInstanceOf(b, f);
        b = b ? e._UnwrapScriptInterface(b) : null;
        c = VALID_WHERE_STRINGS.indexOf(c);
        if (0 > c)
            throw Error("invalid location");
        d.MoveLayer(a, b, c)
    }
    removeLayer(a) {
        const b = map$jscomp$3.get(this);
        C3X$jscomp$7.RequireInstanceOf(a, self.ILayer);
        a = b.GetRuntime()._UnwrapScriptInterface(a);
        if (!a)
            throw Error("invalid layer");
        const c = a.GetRuntime();
        b.RemoveLayer(a);
        c.GetEventSheetManager().IsInEventEngine() || c.FlushPendingInstances()
    }
    removeAllDynamicLayers() {
        const a = map$jscomp$3.get(this)
          , b = a.GetRuntime();
        a.RemoveAllDynamicLayers();
        b.GetEventSheetManager().IsInEventEngine() || b.FlushPendingInstances()
    }
    setVanishingPoint(a, b) {
        C3X$jscomp$7.RequireFiniteNumber(a);
        C3X$jscomp$7.RequireFiniteNumber(b);
        map$jscomp$3.get(this).SetVanishingPointXY(a, b)
    }
    getVanishingPoint() {
        return map$jscomp$3.get(this)._GetVanishingPoint()
    }
    set projection(a) {
        C3X$jscomp$7.RequireString(a);
        const b = map$jscomp$3.get(this);
        if ("perspective" === a)
            b.SetPerspectiveProjection();
        else if ("orthographic" === a)
            b.SetOrthographicProjection();
        else
            throw Error("invalid projection");
    }
    get projection() {
        return map$jscomp$3.get(this).IsOrthographicProjection() ? "orthographic" : "perspective"
    }
}
;
"use strict";
const C3$jscomp$72 = self.C3
  , C3X$jscomp$8 = self.C3X
  , map$jscomp$4 = new WeakMap
  , BLEND_MODE_TO_INDEX = new Map([["normal", 0], ["additive", 1], ["copy", 3], ["destination-over", 4], ["source-in", 5], ["destination-in", 6], ["source-out", 7], ["destination-out", 8], ["source-atop", 9], ["destination-atop", 10]])
  , INDEX_TO_BLEND_MODE = new Map([...BLEND_MODE_TO_INDEX.entries()].map(a => [a[1], a[0]]))
  , tempColor$jscomp$1 = C3$jscomp$72.New(C3$jscomp$72.Color);
self.ILayer = class {
    constructor(a) {
        map$jscomp$4.set(this, a);
        const b = []
          , c = a.GetEffectList()
          , d = c.GetAllEffectTypes().length;
        for (let e = 0; e < d; ++e)
            b.push(new self.IEffectInstance(c,e));
        Object.defineProperties(this, {
            name: {
                value: a.GetName(),
                writable: !1
            },
            layout: {
                value: a.GetLayout().GetILayout(),
                writable: !1
            },
            effects: {
                value: b,
                writable: !1
            }
        });
        a.GetRuntime()._MapScriptInterface(this, a)
    }
    get parentLayer() {
        const a = map$jscomp$4.get(this).GetParentLayer();
        return a ? a.GetILayer() : null
    }
    *parentLayers() {
        for (const a of map$jscomp$4.get(this).parentLayers())
            yield a.GetILayer()
    }
    *subLayers() {
        for (const a of map$jscomp$4.get(this).GetSubLayers())
            yield a.GetILayer()
    }
    *allSubLayers() {
        for (const a of map$jscomp$4.get(this).GetSubLayers())
            for (const b of a.selfAndAllSubLayers())
                yield b.GetILayer()
    }
    get index() {
        return map$jscomp$4.get(this).GetIndex()
    }
    get isVisible() {
        return map$jscomp$4.get(this)._IsVisibleFlagSet()
    }
    set isVisible(a) {
        map$jscomp$4.get(this).SetVisible(a)
    }
    get isSelfAndParentsVisible() {
        return map$jscomp$4.get(this).IsVisible()
    }
    get isInteractive() {
        return map$jscomp$4.get(this).IsInteractive()
    }
    set isInteractive(a) {
        map$jscomp$4.get(this).SetInteractive(a)
    }
    get isHTMLElementsLayer() {
        return map$jscomp$4.get(this).IsHTMLElementsLayer()
    }
    set isHTMLElementsLayer(a) {
        map$jscomp$4.get(this).SetIsHTMLElementsLayer(!!a)
    }
    get isSelfAndParentsInteractive() {
        return map$jscomp$4.get(this).IsSelfAndParentsInteractive()
    }
    get opacity() {
        return map$jscomp$4.get(this).GetOpacity()
    }
    set opacity(a) {
        a = C3$jscomp$72.clamp(+a, 0, 1);
        isNaN(a) || map$jscomp$4.get(this).SetOpacity(a)
    }
    set scale(a) {
        C3X$jscomp$8.RequireFiniteNumber(a);
        map$jscomp$4.get(this).SetOwnScale(a)
    }
    get scale() {
        return map$jscomp$4.get(this).GetOwnScale()
    }
    set scaleRate(a) {
        C3X$jscomp$8.RequireFiniteNumber(a);
        map$jscomp$4.get(this).SetScaleRate(a)
    }
    get scaleRate() {
        return map$jscomp$4.get(this).GetScaleRate()
    }
    set angle(a) {
        C3X$jscomp$8.RequireFiniteNumber(a);
        map$jscomp$4.get(this).SetAngle(a)
    }
    get angle() {
        return map$jscomp$4.get(this).GetOwnAngle()
    }
    set parallaxX(a) {
        C3X$jscomp$8.RequireFiniteNumber(a);
        map$jscomp$4.get(this).SetParallaxX(a)
    }
    get parallaxX() {
        return map$jscomp$4.get(this).GetParallaxX()
    }
    set parallaxY(a) {
        C3X$jscomp$8.RequireFiniteNumber(a);
        map$jscomp$4.get(this).SetParallaxY(a)
    }
    get parallaxY() {
        return map$jscomp$4.get(this).GetParallaxY()
    }
    set zElevation(a) {
        C3X$jscomp$8.RequireFiniteNumber(a);
        map$jscomp$4.get(this).SetZElevation(a)
    }
    get zElevation() {
        return map$jscomp$4.get(this).GetZElevation()
    }
    set isTransparent(a) {
        map$jscomp$4.get(this).SetTransparent(a)
    }
    get isTransparent() {
        return map$jscomp$4.get(this).IsTransparent()
    }
    set isForceOwnTexture(a) {
        map$jscomp$4.get(this).SetForceOwnTexture(a)
    }
    get isForceOwnTexture() {
        return map$jscomp$4.get(this).IsForceOwnTexture()
    }
    set blendMode(a) {
        C3X$jscomp$8.RequireString(a);
        a = BLEND_MODE_TO_INDEX.get(a);
        if ("number" !== typeof a)
            throw Error("invalid blend mode");
        map$jscomp$4.get(this).SetBlendMode(a)
    }
    get blendMode() {
        return INDEX_TO_BLEND_MODE.get(map$jscomp$4.get(this).GetBlendMode())
    }
    set backgroundColor(a) {
        C3X$jscomp$8.RequireArray(a);
        if (3 > a.length)
            throw Error("expected 3 elements");
        tempColor$jscomp$1.setRgb(a[0], a[1], a[2]);
        a = map$jscomp$4.get(this);
        const b = a.GetBackgroundColor();
        b.equalsIgnoringAlpha(tempColor$jscomp$1) || (b.copyRgb(tempColor$jscomp$1),
        a.GetRuntime().UpdateRender())
    }
    get backgroundColor() {
        const a = map$jscomp$4.get(this).GetBackgroundColor();
        return [a.getR(), a.getG(), a.getB()]
    }
    set scrollX(a) {
        C3X$jscomp$8.RequireNumber(a);
        const b = map$jscomp$4.get(this);
        b.SetOwnScrollPositionEnabled(!0);
        b.SetScrollX(a)
    }
    get scrollX() {
        return map$jscomp$4.get(this).GetScrollX()
    }
    set scrollY(a) {
        C3X$jscomp$8.RequireNumber(a);
        const b = map$jscomp$4.get(this);
        b.SetOwnScrollPositionEnabled(!0);
        b.SetScrollY(a)
    }
    get scrollY() {
        return map$jscomp$4.get(this).GetScrollY()
    }
    scrollTo(a, b) {
        C3X$jscomp$8.RequireNumber(a);
        C3X$jscomp$8.RequireNumber(b);
        const c = map$jscomp$4.get(this);
        c.SetOwnScrollPositionEnabled(!0);
        c.SetScrollX(a);
        c.SetScrollY(b)
    }
    getScrollPosition() {
        const a = map$jscomp$4.get(this);
        return [a.GetScrollX(), a.GetScrollY()]
    }
    restoreScrollPosition() {
        map$jscomp$4.get(this).SetOwnScrollPositionEnabled(!1)
    }
    getViewport() {
        return map$jscomp$4.get(this).GetViewport().toDOMRect()
    }
    cssPxToLayer(a, b, c=0) {
        C3X$jscomp$8.RequireNumber(a);
        C3X$jscomp$8.RequireNumber(b);
        C3X$jscomp$8.RequireNumber(c);
        const d = map$jscomp$4.get(this)
          , e = d.GetRuntime();
        return d.CanvasCssToLayer(a - e.GetCanvasClientX(), b - e.GetCanvasClientY(), c)
    }
    layerToCssPx(a, b, c=0) {
        C3X$jscomp$8.RequireNumber(a);
        C3X$jscomp$8.RequireNumber(b);
        C3X$jscomp$8.RequireNumber(c);
        const d = map$jscomp$4.get(this)
          , e = d.GetRuntime()
          , [f,h] = d.LayerToCanvasCss(a, b, c);
        return [f + e.GetCanvasClientX(), h + e.GetCanvasClientY()]
    }
    drawSurfaceToLayer(a, b, c=0) {
        C3X$jscomp$8.RequireNumber(a);
        C3X$jscomp$8.RequireNumber(b);
        C3X$jscomp$8.RequireNumber(c);
        return map$jscomp$4.get(this).DrawSurfaceToLayer(a, b, c)
    }
    layerToDrawSurface(a, b, c=0) {
        C3X$jscomp$8.RequireNumber(a);
        C3X$jscomp$8.RequireNumber(b);
        C3X$jscomp$8.RequireNumber(c);
        return map$jscomp$4.get(this).LayerToDrawSurface(a, b, c)
    }
    get renderScale() {
        return map$jscomp$4.get(this).GetRenderScale()
    }
}
;
"use strict";
const C3$jscomp$73 = self.C3
  , C3X$jscomp$9 = self.C3X
  , map$jscomp$5 = new WeakMap
  , dispatchers = new WeakMap
  , internalApiToken$jscomp$3 = C3$jscomp$73._GetInternalAPIToken();
function GetDispatcher(a) {
    let b = dispatchers.get(a);
    if (b)
        return b;
    b = C3$jscomp$73.New(C3$jscomp$73.Event.Dispatcher);
    dispatchers.set(a, b);
    return b
}
self.IInstance = class {
    constructor() {
        const a = C3$jscomp$73.AddonManager._GetInitObject2(internalApiToken$jscomp$3);
        map$jscomp$5.set(this, a);
        const b = {
            runtime: {
                value: a.GetRuntime().GetIRuntime(),
                writable: !1
            },
            objectType: {
                value: a.GetObjectClass().GetIObjectClass(),
                writable: !1
            },
            plugin: {
                value: a.GetPlugin().GetIPlugin(),
                writable: !1
            },
            uid: {
                value: a.GetUID(),
                writable: !1
            }
        };
        a._GetInstVarsScriptDescriptor(b);
        a._GetBehaviorsScriptDescriptor(b);
        Object.defineProperties(this, b);
        a.GetRuntime()._MapScriptInterface(this, a)
    }
    static _GetInitInst() {
        return C3$jscomp$73.AddonManager._GetInitObject()
    }
    _release() {
        const a = dispatchers.get(this);
        a && (a.Release(),
        dispatchers.delete(this));
        map$jscomp$5.delete(this)
    }
    addEventListener(a, b, c) {
        C3X$jscomp$9.RequireString(a);
        C3X$jscomp$9.RequireFunction(b);
        GetDispatcher(this).addEventListener(a, b, c)
    }
    removeEventListener(a, b, c) {
        C3X$jscomp$9.RequireString(a);
        C3X$jscomp$9.RequireFunction(b);
        GetDispatcher(this).removeEventListener(a, b, c)
    }
    dispatchEvent(a) {
        GetDispatcher(this).dispatchEvent(a)
    }
    destroy() {
        const a = map$jscomp$5.get(this)
          , b = a.GetRuntime();
        b.DestroyInstance(a);
        b.GetEventSheetManager().IsInEventEngine() || b.GetLayoutManager().IsEndingLayout() || b.GetEventSheetManager().IsFlushingBlocked() || b.FlushPendingInstances()
    }
    getOtherContainerInstances() {
        const a = map$jscomp$5.get(this).GetSiblings();
        return a ? a.map(b => b.GetInterfaceClass()) : []
    }
    *otherContainerInstances() {
        const a = map$jscomp$5.get(this);
        if (a.IsInContainer())
            for (const b of a.siblings())
                yield b.GetInterfaceClass()
    }
    get templateName() {
        return map$jscomp$5.get(this).GetTemplateName()
    }
    set timeScale(a) {
        C3X$jscomp$9.RequireFiniteNumber(a);
        map$jscomp$5.get(this).SetTimeScale(a)
    }
    get timeScale() {
        return map$jscomp$5.get(this).GetActiveTimeScale()
    }
    restoreTimeScale() {
        map$jscomp$5.get(this).RestoreTimeScale()
    }
    get dt() {
        const a = map$jscomp$5.get(this);
        return a.GetRuntime().GetDt(a)
    }
}
;
"use strict";
const C3$jscomp$74 = self.C3
  , C3X$jscomp$10 = self.C3X
  , map$jscomp$6 = new WeakMap
  , internalApiToken$jscomp$4 = C3$jscomp$74._GetInternalAPIToken();
self.ISDKInstanceBase = class extends self.IInstance {
    constructor(a) {
        super();
        map$jscomp$6.set(this, C3$jscomp$74.AddonManager._GetInitObject2(internalApiToken$jscomp$4));
        this._p_isTicking = !1;
        this._p_tickFunc = null;
        this._p_isTicking2 = !1;
        this._p_tickFunc2 = null;
        this._p_domComponentId = a?.domComponentId;
        this._p_wrapperComponentId = a?.wrapperComponentId
    }
    _release() {
        this._setTicking(!1);
        this._setTicking2(!1);
        super._release();
        map$jscomp$6.delete(this)
    }
    _getInitProperties() {
        return C3$jscomp$74.AddonManager._GetInitProperties()
    }
    _trigger(a) {
        const b = map$jscomp$6.get(this);
        b.GetRuntime().Trigger(a, b)
    }
    _addDOMMessageHandler(a, b) {
        C3X$jscomp$10.RequireString(a);
        C3X$jscomp$10.RequireFunction(b);
        if (!this._p_domComponentId)
            throw Error("no DOM component id set");
        map$jscomp$6.get(this).GetRuntime().AddDOMComponentMessageHandler(this._p_domComponentId, a, b)
    }
    _addDOMMessageHandlers(a) {
        C3X$jscomp$10.RequireArray(a);
        for (const [b,c] of a)
            this._addDOMMessageHandler(b, c)
    }
    _postToDOM(a, b) {
        C3X$jscomp$10.RequireString(a);
        if (!this._p_domComponentId)
            throw Error("no DOM component id set");
        map$jscomp$6.get(this).GetRuntime().PostComponentMessageToDOM(this._p_domComponentId, a, b)
    }
    _postToDOMAsync(a, b) {
        C3X$jscomp$10.RequireString(a);
        if (!this._p_domComponentId)
            throw Error("no DOM component id set");
        return map$jscomp$6.get(this).GetRuntime().PostComponentMessageToDOMAsync(this._p_domComponentId, a, b)
    }
    _postToDOMMaybeSync(a, b) {
        if (map$jscomp$6.get(this).GetRuntime().IsInWorker())
            this._postToDOM(a, b);
        else
            return window.c3_runtimeInterface._OnMessageFromRuntime({
                type: "event",
                component: this._p_domComponentId,
                handler: a,
                data: b,
                responseId: null
            })
    }
    _setTicking(a) {
        a = !!a;
        if (this._p_isTicking !== a) {
            this._p_isTicking = a;
            var b = map$jscomp$6.get(this).GetRuntime();
            a ? (this._p_tickFunc || (this._p_tickFunc = () => this._tick()),
            b.Dispatcher().addEventListener("tick", this._p_tickFunc)) : b.Dispatcher().removeEventListener("tick", this._p_tickFunc)
        }
    }
    _isTicking() {
        return this._p_isTicking
    }
    _tick() {}
    _setTicking2(a) {
        a = !!a;
        if (this._p_isTicking2 !== a) {
            this._p_isTicking2 = a;
            var b = map$jscomp$6.get(this).GetRuntime();
            a ? (this._p_tickFunc2 || (this._p_tickFunc2 = () => this._tick2()),
            b.Dispatcher().addEventListener("tick2", this._p_tickFunc2)) : b.Dispatcher().removeEventListener("tick2", this._p_tickFunc2)
        }
    }
    _isTicking2() {
        return this._p_isTicking2
    }
    _tick2() {}
    _getDebuggerProperties() {
        return []
    }
    _saveToJson() {
        return null
    }
    _loadFromJson(a) {}
    _isWrapperExtensionAvailable() {
        if (!this._p_wrapperComponentId)
            throw Error("no wrapper component id set");
        return map$jscomp$6.get(this).GetRuntime().HasWrapperComponentId(this._p_wrapperComponentId)
    }
    _addWrapperExtensionMessageHandler(a, b) {
        C3X$jscomp$10.RequireString(a);
        C3X$jscomp$10.RequireFunction(b);
        if (!this._p_wrapperComponentId)
            throw Error("no wrapper component id set");
        map$jscomp$6.get(this).GetRuntime().AddWrapperExtensionMessageHandler(this._p_wrapperComponentId, a, b)
    }
    _addWrapperMessageHandlers(a) {
        C3X$jscomp$10.RequireArray(a);
        for (const [b,c] of a)
            this._addWrapperExtensionMessageHandler(b, c)
    }
    _sendWrapperExtensionMessage(a, b) {
        C3X$jscomp$10.RequireString(a);
        C3X$jscomp$10.RequireOptionalArray(b);
        if (!this._p_wrapperComponentId)
            throw Error("no wrapper component id set");
        map$jscomp$6.get(this).GetRuntime().SendWrapperExtensionMessage(this._p_wrapperComponentId, a, b)
    }
    _sendWrapperExtensionMessageAsync(a, b) {
        C3X$jscomp$10.RequireString(a);
        C3X$jscomp$10.RequireOptionalArray(b);
        if (!this._p_wrapperComponentId)
            throw Error("no wrapper component id set");
        return map$jscomp$6.get(this).GetRuntime().SendWrapperExtensionMessageAsync(this._p_wrapperComponentId, a, b)
    }
}
;
"use strict";
const C3$jscomp$75 = self.C3
  , C3X$jscomp$11 = self.C3X
  , ILayer$jscomp$4 = self.ILayer
  , map$jscomp$7 = new WeakMap
  , internalApiToken$jscomp$5 = C3$jscomp$75._GetInternalAPIToken()
  , BLEND_MODE_TO_INDEX$jscomp$1 = new Map([["normal", 0], ["additive", 1], ["copy", 3], ["destination-over", 4], ["source-in", 5], ["destination-in", 6], ["source-out", 7], ["destination-out", 8], ["source-atop", 9], ["destination-atop", 10]])
  , INDEX_TO_BLEND_MODE$jscomp$1 = new Map([...BLEND_MODE_TO_INDEX$jscomp$1.entries()].map(a => [a[1], a[0]]))
  , tempColor$jscomp$2 = C3$jscomp$75.New(C3$jscomp$75.Color);
function MakeIWorldInstanceClass(a) {
    return class b extends a {
        constructor(c) {
            super(c);
            var d = C3$jscomp$75.AddonManager._GetInitObject2(internalApiToken$jscomp$5);
            map$jscomp$7.set(this, d);
            c = [];
            var e = d.GetWorldInfo();
            if (d = e.GetInstanceEffectList()) {
                e = e.GetObjectClass().GetEffectList().GetAllEffectTypes().length;
                for (let f = 0; f < e; ++f)
                    c.push(new self.IEffectInstance(d,f))
            }
            Object.defineProperties(this, {
                effects: {
                    value: c,
                    writable: !1
                }
            })
        }
        get layout() {
            return map$jscomp$7.get(this).GetWorldInfo().GetLayout().GetILayout()
        }
        get layer() {
            return map$jscomp$7.get(this).GetWorldInfo().GetLayer().GetILayer()
        }
        get x() {
            return map$jscomp$7.get(this).GetWorldInfo().GetX()
        }
        set x(c) {
            c = +c;
            const d = map$jscomp$7.get(this).GetWorldInfo();
            isNaN(c) || d.GetX() === c || (d.SetX(c),
            d.SetBboxChanged())
        }
        get y() {
            return map$jscomp$7.get(this).GetWorldInfo().GetY()
        }
        set y(c) {
            c = +c;
            const d = map$jscomp$7.get(this).GetWorldInfo();
            isNaN(c) || d.GetY() === c || (d.SetY(c),
            d.SetBboxChanged())
        }
        setPosition(c, d) {
            c = +c;
            d = +d;
            const e = map$jscomp$7.get(this).GetWorldInfo();
            isNaN(c) || isNaN(d) || e.GetX() === c && e.GetY() === d || (e.SetXY(c, d),
            e.SetBboxChanged())
        }
        getPosition() {
            const c = map$jscomp$7.get(this).GetWorldInfo();
            return [c.GetX(), c.GetY()]
        }
        offsetPosition(c, d) {
            c = +c;
            d = +d;
            if (!(isNaN(c) || isNaN(d) || 0 === c && 0 === d)) {
                var e = map$jscomp$7.get(this).GetWorldInfo();
                e.OffsetXY(c, d);
                e.SetBboxChanged()
            }
        }
        get zElevation() {
            return map$jscomp$7.get(this).GetWorldInfo().GetZElevation()
        }
        set zElevation(c) {
            c = +c;
            const d = map$jscomp$7.get(this)
              , e = d.GetWorldInfo();
            isNaN(c) || e.GetZElevation() === c || (e.SetZElevation(c),
            d.GetRuntime().UpdateRender())
        }
        get totalZElevation() {
            return map$jscomp$7.get(this).GetWorldInfo().GetTotalZElevation()
        }
        get width() {
            return map$jscomp$7.get(this).GetWorldInfo().GetWidth()
        }
        set width(c) {
            c = +c;
            const d = map$jscomp$7.get(this).GetWorldInfo();
            isNaN(c) || d.GetWidth() === c || (d.SetWidth(c),
            d.SetBboxChanged())
        }
        get height() {
            return map$jscomp$7.get(this).GetWorldInfo().GetHeight()
        }
        set height(c) {
            c = +c;
            const d = map$jscomp$7.get(this).GetWorldInfo();
            isNaN(c) || d.GetHeight() === c || (d.SetHeight(c),
            d.SetBboxChanged())
        }
        setSize(c, d) {
            c = +c;
            d = +d;
            const e = map$jscomp$7.get(this).GetWorldInfo();
            isNaN(c) || isNaN(d) || e.GetWidth() === c && e.GetHeight() === d || (e.SetSize(c, d),
            e.SetBboxChanged())
        }
        getSize() {
            const c = map$jscomp$7.get(this).GetWorldInfo();
            return [c.GetWidth(), c.GetHeight()]
        }
        get angle() {
            return map$jscomp$7.get(this).GetWorldInfo().GetAngle()
        }
        set angle(c) {
            c = C3$jscomp$75.clampAngle(+c);
            const d = map$jscomp$7.get(this).GetWorldInfo();
            isNaN(c) || d.GetAngle() === c || (d.SetAngle(c),
            d.SetBboxChanged())
        }
        get angleDegrees() {
            return C3$jscomp$75.toDegrees(this.angle)
        }
        set angleDegrees(c) {
            this.angle = C3$jscomp$75.toRadians(c)
        }
        getBoundingBox() {
            return map$jscomp$7.get(this).GetWorldInfo().GetBoundingBox().toDOMRect()
        }
        getBoundingQuad() {
            return map$jscomp$7.get(this).GetWorldInfo().GetBoundingQuad().toDOMQuad()
        }
        isOnScreen() {
            return map$jscomp$7.get(this).GetWorldInfo().IsInViewport2()
        }
        get isVisible() {
            return map$jscomp$7.get(this).GetWorldInfo().IsVisible()
        }
        set isVisible(c) {
            c = !!c;
            const d = map$jscomp$7.get(this)
              , e = d.GetWorldInfo();
            e.IsVisible() !== c && (e.SetVisible(c),
            d.GetRuntime().UpdateRender())
        }
        get opacity() {
            return map$jscomp$7.get(this).GetWorldInfo().GetOpacity()
        }
        set opacity(c) {
            c = C3$jscomp$75.clamp(+c, 0, 1);
            const d = map$jscomp$7.get(this)
              , e = d.GetWorldInfo();
            isNaN(c) || e.GetOpacity() === c || (e.SetOpacity(c),
            d.GetRuntime().UpdateRender())
        }
        set colorRgb(c) {
            C3X$jscomp$11.RequireArray(c);
            if (3 > c.length)
                throw Error("expected 3 elements");
            tempColor$jscomp$2.setRgb(c[0], c[1], c[2]);
            c = map$jscomp$7.get(this);
            const d = c.GetWorldInfo();
            d.GetUnpremultipliedColor().equalsIgnoringAlpha(tempColor$jscomp$2) || (d.SetUnpremultipliedColor(tempColor$jscomp$2),
            c.GetRuntime().UpdateRender())
        }
        get colorRgb() {
            const c = map$jscomp$7.get(this).GetWorldInfo().GetUnpremultipliedColor();
            return [c.getR(), c.getG(), c.getB()]
        }
        set blendMode(c) {
            C3X$jscomp$11.RequireString(c);
            c = BLEND_MODE_TO_INDEX$jscomp$1.get(c);
            if ("number" !== typeof c)
                throw Error("invalid blend mode");
            const d = map$jscomp$7.get(this);
            d.GetWorldInfo().SetBlendMode(c);
            d.GetRuntime().UpdateRender()
        }
        get blendMode() {
            return INDEX_TO_BLEND_MODE$jscomp$1.get(map$jscomp$7.get(this).GetWorldInfo().GetBlendMode())
        }
        moveToTop() {
            map$jscomp$7.get(this).GetWorldInfo().ZOrderMoveToTop()
        }
        moveToBottom() {
            map$jscomp$7.get(this).GetWorldInfo().ZOrderMoveToBottom()
        }
        moveToLayer(c) {
            C3X$jscomp$11.RequireInstanceOf(c, ILayer$jscomp$4);
            const d = map$jscomp$7.get(this);
            c = d.GetRuntime()._UnwrapScriptInterface(c);
            if (!c)
                throw Error("invalid layer");
            d.GetWorldInfo().ZOrderMoveToLayer(c)
        }
        moveAdjacentToInstance(c, d) {
            C3X$jscomp$11.RequireInstanceOf(c, b);
            map$jscomp$7.get(this).GetWorldInfo().ZOrderMoveAdjacentToInstance(map$jscomp$7.get(c), d)
        }
        get zIndex() {
            return map$jscomp$7.get(this).GetWorldInfo().GetZIndex()
        }
        get isCollisionEnabled() {
            return map$jscomp$7.get(this).GetWorldInfo().IsCollisionEnabled()
        }
        set isCollisionEnabled(c) {
            map$jscomp$7.get(this).GetWorldInfo().SetCollisionEnabled(!!c)
        }
        containsPoint(c, d) {
            C3X$jscomp$11.RequireNumber(c);
            C3X$jscomp$11.RequireNumber(d);
            return map$jscomp$7.get(this).GetWorldInfo().ContainsPoint(+c, +d)
        }
        testOverlap(c) {
            C3X$jscomp$11.RequireInstanceOf(c, b);
            const d = map$jscomp$7.get(this);
            c = map$jscomp$7.get(c);
            return d.GetRuntime().GetCollisionEngine().TestOverlap(d, c)
        }
        testOverlapSolid() {
            var c = map$jscomp$7.get(this);
            return (c = c.GetRuntime().GetCollisionEngine().TestOverlapSolid(c)) ? c.GetInterfaceClass() : null
        }
        getParent() {
            const c = map$jscomp$7.get(this).GetParent();
            return c ? c.GetInterfaceClass() : null
        }
        getTopParent() {
            const c = map$jscomp$7.get(this).GetTopParent();
            return c ? c.GetInterfaceClass() : null
        }
        *parents() {
            for (const c of map$jscomp$7.get(this).parents())
                yield c.GetInterfaceClass()
        }
        getChildCount() {
            return map$jscomp$7.get(this).GetChildCount()
        }
        getChildAt(c) {
            return (c = map$jscomp$7.get(this).GetChildAt(c)) ? c.GetInterfaceClass() : null
        }
        *children() {
            for (const c of map$jscomp$7.get(this).children())
                yield c.GetInterfaceClass()
        }
        *allChildren() {
            for (const c of map$jscomp$7.get(this).allChildren())
                yield c.GetInterfaceClass()
        }
        addChild(c, d) {
            C3X$jscomp$11.RequireInstanceOf(c, b);
            C3X$jscomp$11.RequireOptionalObject(d);
            d || (d = {});
            const e = map$jscomp$7.get(this);
            c = map$jscomp$7.get(c);
            e.AddChild(c, d)
        }
        removeChild(c) {
            C3X$jscomp$11.RequireInstanceOf(c, b);
            const d = map$jscomp$7.get(this);
            c = map$jscomp$7.get(c);
            d.RemoveChild(c)
        }
        removeFromParent() {
            const c = map$jscomp$7.get(this);
            c.HasParent() && c.GetParent().RemoveChild(c)
        }
        createMesh(c, d) {
            C3X$jscomp$11.RequireFiniteNumber(c);
            C3X$jscomp$11.RequireFiniteNumber(d);
            map$jscomp$7.get(this).GetWorldInfo().CreateMesh(c, d)
        }
        releaseMesh() {
            const c = map$jscomp$7.get(this).GetWorldInfo();
            c.ReleaseMesh();
            c.SetBboxChanged()
        }
        setMeshPoint(c, d, e) {
            C3X$jscomp$11.RequireFiniteNumber(c);
            C3X$jscomp$11.RequireFiniteNumber(d);
            C3X$jscomp$11.RequireObject(e);
            const f = map$jscomp$7.get(this).GetWorldInfo();
            f.SetMeshPoint(c, d, e) && f.SetBboxChanged()
        }
        getMeshSize() {
            var c = map$jscomp$7.get(this).GetWorldInfo();
            if (!c.HasMesh())
                return [0, 0];
            c = c.GetSourceMesh();
            return [c.GetHSize(), c.GetVSize()]
        }
    }
}
self.IWorldInstance = MakeIWorldInstanceClass(self.IInstance);
self.IWorldInstanceSDKBase = MakeIWorldInstanceClass(self.ISDKInstanceBase);
"use strict";
const C3X$jscomp$12 = self.C3X
  , map$jscomp$8 = new WeakMap;
self.IDOMInstance = class extends self.IWorldInstance {
    constructor() {
        super();
        map$jscomp$8.set(this, self.IInstance._GetInitInst())
    }
    getElement() {
        return map$jscomp$8.get(this).GetSdkInstance()._GetElementInDOMMode()
    }
    focus() {
        map$jscomp$8.get(this).GetSdkInstance().FocusElement()
    }
    blur() {
        map$jscomp$8.get(this).GetSdkInstance().BlurElement()
    }
    setCssStyle(a, b) {
        C3X$jscomp$12.RequireString(a);
        map$jscomp$8.get(this).GetSdkInstance().SetElementCSSStyle(a, b)
    }
}
;
"use strict";
const C3$jscomp$77 = self.C3
  , C3X$jscomp$13 = self.C3X
  , map$jscomp$9 = new WeakMap
  , dispatchers$jscomp$1 = new WeakMap
  , internalApiToken$jscomp$6 = C3$jscomp$77._GetInternalAPIToken();
function GetDispatcher$jscomp$1(a) {
    let b = dispatchers$jscomp$1.get(a);
    if (b)
        return b;
    b = C3$jscomp$77.New(C3$jscomp$77.Event.Dispatcher);
    dispatchers$jscomp$1.set(a, b);
    return b
}
self.IBehaviorInstance = class {
    constructor() {
        const a = C3$jscomp$77.AddonManager._GetInitObject2(internalApiToken$jscomp$6);
        map$jscomp$9.set(this, a);
        const b = {
            runtime: {
                value: a.GetRuntime().GetIRuntime(),
                writable: !1
            },
            behavior: {
                value: a.GetBehavior().GetIBehavior(),
                writable: !1
            },
            behaviorType: {
                value: a.GetBehaviorType().GetIBehaviorType(),
                writable: !1
            }
        };
        Object.defineProperties(this, b);
        a.GetRuntime()._MapScriptInterface(this, a)
    }
    static _GetInitInst() {
        return C3$jscomp$77.AddonManager._GetInitObject()
    }
    get instance() {
        return map$jscomp$9.get(this).GetObjectInstance().GetInterfaceClass()
    }
    _release() {
        const a = dispatchers$jscomp$1.get(this);
        a && (a.Release(),
        dispatchers$jscomp$1.delete(this));
        map$jscomp$9.delete(this)
    }
    addEventListener(a, b, c) {
        C3X$jscomp$13.RequireString(a);
        C3X$jscomp$13.RequireFunction(b);
        GetDispatcher$jscomp$1(this).addEventListener(a, b, c)
    }
    removeEventListener(a, b, c) {
        C3X$jscomp$13.RequireString(a);
        C3X$jscomp$13.RequireFunction(b);
        GetDispatcher$jscomp$1(this).removeEventListener(a, b, c)
    }
    dispatchEvent(a) {
        GetDispatcher$jscomp$1(this).dispatchEvent(a)
    }
}
;
"use strict";
const C3$jscomp$78 = self.C3
  , internalApiToken$jscomp$7 = C3$jscomp$78._GetInternalAPIToken();
self.IBehaviorType = class {
    constructor() {
        var a = C3$jscomp$78.AddonManager._GetInitObject2(internalApiToken$jscomp$7);
        a = {
            runtime: {
                value: a.GetRuntime().GetIRuntime(),
                writable: !1
            },
            behavior: {
                value: a.GetBehavior().GetIBehavior(),
                writable: !1
            },
            name: {
                value: a.GetName(),
                writable: !1
            }
        };
        Object.defineProperties(this, a)
    }
}
;
"use strict";
const C3$jscomp$79 = self.C3
  , map$jscomp$10 = new WeakMap
  , internalApiToken$jscomp$8 = C3$jscomp$79._GetInternalAPIToken();
self.IBehavior = class {
    constructor() {
        var a = C3$jscomp$79.AddonManager._GetInitObject2(internalApiToken$jscomp$8);
        map$jscomp$10.set(this, a);
        a = {
            runtime: {
                value: a.GetRuntime().GetIRuntime(),
                writable: !1
            }
        };
        Object.defineProperties(this, a)
    }
    getAllInstances() {
        return map$jscomp$10.get(this).GetInstances().map(a => a.GetInterfaceClass())
    }
    static getByConstructor(a) {
        return a ? (a = C3$jscomp$79.AddonManager.GetBehaviorByConstructorFunction(a)) ? a.GetIBehavior() : null : null
    }
}
;
"use strict";
const C3$jscomp$80 = self.C3
  , C3X$jscomp$16 = self.C3X
  , map$jscomp$11 = new WeakMap
  , tempColor$jscomp$3 = C3$jscomp$80.New(C3$jscomp$80.Color);
self.IEffectInstance = class {
    constructor(a, b) {
        map$jscomp$11.set(this, a);
        Object.defineProperties(this, {
            index: {
                value: b,
                writable: !1
            }
        })
    }
    get name() {
        return map$jscomp$11.get(this).GetAllEffectTypes()[this.index].GetName()
    }
    get isActive() {
        return map$jscomp$11.get(this).IsEffectIndexActive(this.index)
    }
    set isActive(a) {
        a = !!a;
        const b = map$jscomp$11.get(this);
        b.IsEffectIndexActive(this.index) !== a && (b.SetEffectIndexActive(this.index, a),
        b.UpdateActiveEffects(),
        b.GetRuntime().UpdateRender())
    }
    setParameter(a, b) {
        C3X$jscomp$16.RequireFiniteNumber(a);
        a = Math.floor(+a);
        const c = map$jscomp$11.get(this)
          , d = c.GetEffectParameter(this.index, a);
        if (null === d)
            throw new RangeError("invalid index");
        if (d instanceof C3$jscomp$80.Color) {
            if (!Array.isArray(b) || 3 > b.length)
                throw new TypeError("expected array with 3 elements");
            tempColor$jscomp$3.setRgb(b[0], b[1], b[2]);
            b = tempColor$jscomp$3
        } else if ("number" !== typeof b)
            throw new TypeError("expected number");
        c.SetEffectParameter(this.index, a, b) && c.IsEffectIndexActive(this.index) && c.GetRuntime().UpdateRender()
    }
    getParameter(a) {
        C3X$jscomp$16.RequireFiniteNumber(a);
        a = Math.floor(+a);
        a = map$jscomp$11.get(this).GetEffectParameter(this.index, a);
        if (null === a)
            throw new RangeError("invalid index");
        return a instanceof C3$jscomp$80.Color ? [a.getR(), a.getG(), a.getB()] : a
    }
}
;
"use strict";
const map$jscomp$12 = new WeakMap;
self.IAnimation = class {
    constructor(a) {
        map$jscomp$12.set(this, a);
        Object.defineProperties(this, {
            name: {
                value: a.GetName(),
                writable: !1
            }
        })
    }
    get speed() {
        return map$jscomp$12.get(this).GetSpeed()
    }
    get isLooping() {
        return map$jscomp$12.get(this).IsLooping()
    }
    get repeatCount() {
        return map$jscomp$12.get(this).GetRepeatCount()
    }
    get repeatTo() {
        return map$jscomp$12.get(this).GetRepeatTo()
    }
    get isPingPong() {
        return map$jscomp$12.get(this).IsPingPong()
    }
    get frameCount() {
        return map$jscomp$12.get(this).GetFrameCount()
    }
    getFrames() {
        return map$jscomp$12.get(this).GetFrames().map(a => a.GetIAnimationFrame())
    }
    *frames() {
        for (const a of map$jscomp$12.get(this).GetFrames())
            yield a.GetIAnimationFrame()
    }
}
;
"use strict";
const map$jscomp$13 = new WeakMap;
self.IImageInfo = class {
    constructor(a) {
        map$jscomp$13.set(this, a)
    }
    static _Unwrap(a) {
        return map$jscomp$13.get(a)
    }
    get width() {
        return map$jscomp$13.get(this).GetWidth()
    }
    get height() {
        return map$jscomp$13.get(this).GetHeight()
    }
    getSize() {
        const a = map$jscomp$13.get(this);
        return [a.GetWidth(), a.GetHeight()]
    }
    getTexture(a) {
        return a.getTextureForImageInfo(this)
    }
    getTexRect() {
        return map$jscomp$13.get(this).GetTexRect().toDOMRect()
    }
}
;
"use strict";
const C3X$jscomp$19 = self.C3X
  , map$jscomp$14 = new WeakMap;
self.IAnimationFrame = class extends self.IImageInfo {
    constructor(a) {
        super(a.GetImageInfo());
        map$jscomp$14.set(this, a);
        Object.defineProperties(this, {
            duration: {
                value: a.GetDuration(),
                writable: !1
            },
            originX: {
                value: a.GetOriginX(),
                writable: !1
            },
            originY: {
                value: a.GetOriginY(),
                writable: !1
            }
        })
    }
    getOrigin() {
        const a = map$jscomp$14.get(this);
        return [a.GetOriginX(), a.GetOriginY()]
    }
    getImagePointCount() {
        return map$jscomp$14.get(this).GetImagePointCount()
    }
    getImagePointX(a) {
        return this.getImagePoint(a)[0]
    }
    getImagePointY(a) {
        return this.getImagePoint(a)[1]
    }
    getImagePoint(a) {
        const b = map$jscomp$14.get(this);
        if ("number" === typeof a)
            a = b.GetImagePointByIndex(Math.floor(a));
        else if ("string" === typeof a)
            a = b.GetImagePointByName(a);
        else
            throw new TypeError("expected string or number");
        return a ? [a.GetX(), a.GetY()] : this.getOrigin()
    }
    getPolyPointCount() {
        const a = map$jscomp$14.get(this).GetCollisionPoly();
        return a ? a.pointCount() : 0
    }
    getPolyPointX(a) {
        return this.getPolyPoint(a)[0]
    }
    getPolyPointY(a) {
        return this.getPolyPoint(a)[1]
    }
    getPolyPoint(a) {
        C3X$jscomp$19.RequireFiniteNumber(a);
        a = Math.floor(a);
        var b = map$jscomp$14.get(this).GetCollisionPoly();
        if (!b || 0 > a || a >= b.pointCount())
            return [0, 0];
        b = b.pointsArr();
        return [b[2 * a], b[2 * a + 1]]
    }
    get tag() {
        return map$jscomp$14.get(this).GetTag()
    }
}
;
"use strict";
const C3X$jscomp$20 = self.C3X
  , map$jscomp$15 = new WeakMap;
function GetTimelineState(a) {
    a = map$jscomp$15.get(a);
    if (a.IsReleased())
        throw Error("timeline/tween was released and is no longer valid");
    return a
}
self.ITimelineStateBase = class {
    constructor(a) {
        map$jscomp$15.set(this, a);
        a.GetRuntime()._MapScriptInterface(this, a)
    }
    pause() {
        GetTimelineState(this).Stop()
    }
    resume() {
        GetTimelineState(this).Resume()
    }
    stop() {
        GetTimelineState(this).Reset()
    }
    hasTags(a) {
        return GetTimelineState(this).HasTags(a)
    }
    set time(a) {
        C3X$jscomp$20.RequireFiniteNumber(a);
        GetTimelineState(this).SetTime(a)
    }
    get time() {
        return GetTimelineState(this).GetTime()
    }
    set totalTime(a) {
        C3X$jscomp$20.RequireFiniteNumber(a);
        GetTimelineState(this).SetTotalTime(a)
    }
    get totalTime() {
        return GetTimelineState(this).GetTotalTime()
    }
    set isLooping(a) {
        GetTimelineState(this).SetLoop(!!a)
    }
    get isLooping() {
        return GetTimelineState(this).GetLoop()
    }
    set isPingPong(a) {
        GetTimelineState(this).SetPingPong(!!a)
    }
    get isPingPong() {
        return GetTimelineState(this).GetPingPong()
    }
    set playbackRate(a) {
        C3X$jscomp$20.RequireFiniteNumber(a);
        GetTimelineState(this).SetPlaybackRate(a)
    }
    get playbackRate() {
        return GetTimelineState(this).GetPlaybackRate()
    }
    get progress() {
        const a = GetTimelineState(this);
        return a.GetTime() / a.GetTotalTime()
    }
    get tags() {
        return GetTimelineState(this).GetTags()
    }
    get finished() {
        return GetTimelineState(this).GetPlayPromise()
    }
    get isPlaying() {
        return GetTimelineState(this).IsPlaying()
    }
    get isPaused() {
        return GetTimelineState(this).IsPaused()
    }
    get isReleased() {
        return map$jscomp$15.get(this).IsReleased()
    }
}
;
"use strict";
const map$jscomp$16 = new WeakMap;
self.ITimelineState = class extends self.ITimelineStateBase {
    constructor(a) {
        super(a);
        map$jscomp$16.set(this, a);
        a = {
            name: {
                value: a.GetName(),
                writable: !1
            }
        };
        Object.defineProperties(this, a)
    }
}
;
"use strict";
const C3X$jscomp$22 = self.C3X
  , map$jscomp$17 = new WeakMap
  , behInstMap = new WeakMap;
let easeToIndexFunc$jscomp$1 = null;
function GetTweenState(a) {
    a = map$jscomp$17.get(a);
    if (a.IsReleased())
        throw Error("tween was released and is no longer valid");
    return a
}
self.ITweenState = class extends self.ITimelineStateBase {
    constructor(a, b, c) {
        super(a);
        easeToIndexFunc$jscomp$1 || (easeToIndexFunc$jscomp$1 = c.easeToIndexFunc);
        map$jscomp$17.set(this, a);
        b && behInstMap.set(this, b)
    }
    stop() {
        const a = GetTweenState(this);
        behInstMap.get(this).ReleaseTween(a)
    }
    setEase(a) {
        C3X$jscomp$22.RequireString(a);
        a = self.Ease.GetEaseFromIndex(easeToIndexFunc$jscomp$1(a));
        GetTweenState(this).SetEase(a)
    }
    get instance() {
        const a = GetTweenState(this).GetInstance();
        return a ? a.GetInterfaceClass() : null
    }
    get isDestroyOnComplete() {
        return GetTweenState(this).GetDestroyInstanceOnComplete()
    }
    set isDestroyOnComplete(a) {
        GetTweenState(this).SetDestroyInstanceOnComplete(!!a)
    }
    get value() {
        const a = GetTweenState(this);
        if ("value" !== a.GetId())
            throw Error("not a value tween");
        return a.GetPropertyTrack("value").GetSourceAdapterValue()
    }
}
;
"use strict";
self.ISDKPluginBase = class extends self.IPlugin {
    constructor() {
        super()
    }
}
;
"use strict";
const C3$jscomp$88 = self.C3
  , C3X$jscomp$24 = self.C3X
  , map$jscomp$18 = new WeakMap
  , internalApiToken$jscomp$9 = C3$jscomp$88._GetInternalAPIToken();
self.ISDKDOMPluginBase = class extends self.ISDKPluginBase {
    constructor(a) {
        super();
        map$jscomp$18.set(this, C3$jscomp$88.AddonManager._GetInitObject2(internalApiToken$jscomp$9));
        if (!a?.domComponentId)
            throw Error("no DOM component ID specified");
        this._p_domComponentId = a.domComponentId;
        this._p_nextElementId = 0;
        this._p_instMap = new Map;
        this._addElementMessageHandler("elem-focused", b => b._onElemFocused());
        this._addElementMessageHandler("elem-blurred", b => {
            b && b._onElemBlurred()
        }
        )
    }
    _addElement(a) {
        const b = this._p_nextElementId++;
        this._p_instMap.set(b, a);
        return b
    }
    _removeElement(a) {
        this._p_instMap.delete(a)
    }
    _addElementMessageHandler(a, b) {
        map$jscomp$18.get(this).GetRuntime().AddDOMComponentMessageHandler(this._p_domComponentId, a, c => {
            const d = this._p_instMap.get(c.elementId);
            b(d, c)
        }
        )
    }
    _addElementMessageHandlers(a) {
        C3X$jscomp$24.RequireArray(a);
        for (const [b,c] of a)
            this._addElementMessageHandlers(b, c)
    }
}
;
"use strict";
const C3$jscomp$89 = self.C3
  , map$jscomp$19 = new WeakMap
  , internalApiToken$jscomp$10 = C3$jscomp$89._GetInternalAPIToken();
self.ISDKObjectTypeBase = class extends self.IObjectClass {
    constructor() {
        super();
        const a = C3$jscomp$89.AddonManager._GetInitObject2(internalApiToken$jscomp$10);
        map$jscomp$19.set(this, a)
    }
    _onCreate() {}
    getImageInfo() {
        return map$jscomp$19.get(this).GetImageInfo().GetIImageInfo()
    }
    _loadTextures(a) {}
    _releaseTextures(a) {}
    _onDynamicTextureLoadComplete() {}
    _preloadTexturesWithInstances(a) {}
}
;
"use strict";
const C3$jscomp$90 = self.C3
  , map$jscomp$20 = new WeakMap
  , internalApiToken$jscomp$11 = C3$jscomp$90._GetInternalAPIToken();
self.ISDKWorldInstanceBase = class extends self.IWorldInstanceSDKBase {
    constructor(a) {
        super(a);
        map$jscomp$20.set(this, C3$jscomp$90.AddonManager._GetInitObject2(internalApiToken$jscomp$11));
        this._p_renderercontextrestored_handler = this._p_renderercontextlost_handler = null
    }
    _release() {
        super._release();
        if (this._p_renderercontextlost_handler) {
            const a = map$jscomp$20.get(this).GetRuntime().Dispatcher();
            a.removeEventListener("renderercontextlost", this._p_renderercontextlost_handler);
            a.removeEventListener("renderercontextrestored", this._p_renderercontextrestored_handler);
            this._p_renderercontextrestored_handler = this._p_renderercontextlost_handler = null
        }
        map$jscomp$20.delete(this)
    }
    _handleRendererContextLoss() {
        if (!this._p_renderercontextlost_handler) {
            this._p_renderercontextlost_handler = () => this._onRendererContextLost();
            this._p_renderercontextrestored_handler = () => this._onRendererContextRestored();
            var a = map$jscomp$20.get(this).GetRuntime().Dispatcher();
            a.addEventListener("renderercontextlost", this._p_renderercontextlost_handler);
            a.addEventListener("renderercontextrestored", this._p_renderercontextrestored_handler)
        }
    }
    _onRendererContextLost() {}
    _onRendererContextRestored() {}
    _draw(a) {}
}
;
"use strict";
const C3$jscomp$91 = self.C3
  , tempRect$jscomp$3 = C3$jscomp$91.New(C3$jscomp$91.Rect)
  , map$jscomp$21 = new WeakMap
  , internalApiToken$jscomp$12 = C3$jscomp$91._GetInternalAPIToken();
self.ISDKDOMInstanceBase = class extends self.ISDKWorldInstanceBase {
    constructor(a) {
        if (!a?.domComponentId)
            throw Error("no DOM component ID specified");
        super(a);
        a = C3$jscomp$91.AddonManager._GetInitObject2(internalApiToken$jscomp$12);
        map$jscomp$21.set(this, a);
        this._p_elementId = this.plugin._addElement(this);
        this._p_isElementShowing = !0;
        this._p_autoFontSize = this._p_elemHasFocus = !1;
        this._p_autoFontSizeOffset = -.2;
        this._p_lastRect = C3$jscomp$91.New(C3$jscomp$91.Rect, 0, 0, -1, -1);
        a = a.GetRuntime().GetCanvasManager();
        this._p_lastWindowWidth = a.GetLastWidth();
        this._p_lastWindowHeight = a.GetLastHeight();
        this._p_lastHTMLZIndex = this._p_lastHTMLIndex = -1;
        this._p_isPendingUpdateState = !1;
        this._setTicking(!0)
    }
    _release() {
        super._release();
        this.plugin._removeElement(this._p_elementId);
        this._postToDOMElement("destroy");
        this._p_elementId = -1;
        map$jscomp$21.delete(this)
    }
    _getElementInDOMMode() {
        if (map$jscomp$21.get(this).GetRuntime().IsInWorker())
            throw Error("not valid in worker mode");
        return this._postToDOMElementMaybeSync("get-element")
    }
    _postToDOMElement(a, b) {
        b || (b = {});
        b.elementId = this._p_elementId;
        this._postToDOM(a, b)
    }
    _postToDOMElementMaybeSync(a, b) {
        b || (b = {});
        b.elementId = this._p_elementId;
        return this._postToDOMMaybeSync(a, b)
    }
    _postToDOMElementAsync(a, b) {
        b || (b = {});
        b.elementId = this._p_elementId;
        return this._postToDOMAsync(a, b)
    }
    _createElement(a) {
        a || (a = {});
        const b = map$jscomp$21.get(this).GetWorldInfo();
        a.elementId = this._p_elementId;
        a.isVisible = b.IsVisible();
        a.htmlIndex = b.GetLayer().GetHTMLIndex();
        a.htmlZIndex = b.GetHTMLZIndex();
        Object.assign(a, this._getElementState());
        this._p_isElementShowing = !!a.isVisible;
        this._postToDOMMaybeSync("create", a);
        this._updatePosition(!0)
    }
    setElementVisible(a) {
        a = !!a;
        this._p_isElementShowing !== a && (this._p_isElementShowing = a,
        this._postToDOMElement("set-visible", {
            isVisible: a
        }))
    }
    _tick() {
        this._updatePosition(!1)
    }
    _shouldPreserveElement() {
        const a = map$jscomp$21.get(this).GetRuntime().GetCanvasManager().GetFullscreenMode();
        return "Android" === C3$jscomp$91.Platform.OS && ("scale-inner" === a || "scale-outer" === a || "crop" === a)
    }
    _updatePosition(a) {
        var b = map$jscomp$21.get(this);
        if (!b.IsDestroyed()) {
            var c = b.GetWorldInfo()
              , d = c.GetLayer()
              , e = c.GetBoundingBox()
              , [f,h] = d.LayerToCanvasCss(e.getLeft(), e.getTop())
              , [l,m] = d.LayerToCanvasCss(e.getRight(), e.getBottom());
            e = b.GetRuntime().GetCanvasManager();
            b = e.GetCssWidth();
            var p = e.GetCssHeight();
            c.IsVisible() && d.IsVisible() ? !this._shouldPreserveElement() && (0 >= l || 0 >= m || f >= b || h >= p) ? this.setElementVisible(!1) : (tempRect$jscomp$3.set(f, h, l, m),
            b = e.GetLastWidth(),
            p = e.GetLastHeight(),
            e = d.GetHTMLIndex(),
            c = c.GetHTMLZIndex(),
            !a && tempRect$jscomp$3.equals(this._p_lastRect) && this._p_lastWindowWidth === b && this._p_lastWindowHeight === p && this._p_lastHTMLIndex === e && this._p_lastHTMLZIndex === c ? this.setElementVisible(!0) : (this._p_lastRect.copy(tempRect$jscomp$3),
            this._p_lastWindowWidth = b,
            this._p_lastWindowHeight = p,
            this._p_lastHTMLIndex = e,
            this._p_lastHTMLZIndex = c,
            this.setElementVisible(!0),
            a = null,
            this._p_autoFontSize && (a = d.GetDisplayScale() + this._p_autoFontSizeOffset),
            this._postToDOMElement("update-position", {
                left: Math.round(this._p_lastRect.getLeft()),
                top: Math.round(this._p_lastRect.getTop()),
                width: Math.round(this._p_lastRect.width()),
                height: Math.round(this._p_lastRect.height()),
                htmlIndex: e,
                htmlZIndex: c,
                fontSize: a
            }))) : this.setElementVisible(!1)
        }
    }
    focusElement() {
        this._postToDOMElementMaybeSync("focus", {
            focus: !0
        })
    }
    blurElement() {
        this._postToDOMElementMaybeSync("focus", {
            focus: !1
        })
    }
    _onElemFocused() {
        this._p_elemHasFocus = !0
    }
    _onElemBlurred() {
        this._p_elemHasFocus = !1
    }
    isElementFocused() {
        return this._p_elemHasFocus
    }
    setElementCSSStyle(a, b) {
        this.postToDOMElement("set-css-style", {
            prop: C3$jscomp$91.CSSToCamelCase(a),
            val: b
        })
    }
    setElementAttribute(a, b) {
        this.postToDOMElement("set-attribute", {
            name: a,
            val: b
        })
    }
    removeElementAttribute(a) {
        this.postToDOMElement("remove-attribute", {
            name: a
        })
    }
    _updateElementState() {
        this._p_isPendingUpdateState || (this._p_isPendingUpdateState = !0,
        Promise.resolve().then( () => {
            this._p_isPendingUpdateState = !1;
            this._postToDOMElement("update-state", this._getElementState())
        }
        ))
    }
    _getElementState() {}
    _getElementId() {
        return this._p_elementId
    }
}
;
"use strict";
self.ISDKBehaviorBase = class extends self.IBehavior {
    constructor() {
        super()
    }
}
;
"use strict";
self.ISDKBehaviorTypeBase = class extends globalThis.IBehaviorType {
    constructor() {
        super()
    }
    _onCreate() {}
}
;
"use strict";
const C3$jscomp$94 = self.C3
  , map$jscomp$22 = new WeakMap
  , internalApiToken$jscomp$13 = C3$jscomp$94._GetInternalAPIToken();
self.ISDKBehaviorInstanceBase = class extends self.IBehaviorInstance {
    constructor() {
        super();
        map$jscomp$22.set(this, C3$jscomp$94.AddonManager._GetInitObject2(internalApiToken$jscomp$13));
        this._p_isPostTicking = this._p_isTicking2 = this._p_isTicking = !1
    }
    _release() {
        super._release();
        this._setTicking(!1);
        this._setTicking2(!1);
        this._setPostTicking(!1);
        map$jscomp$22.delete(this)
    }
    _getInitProperties() {
        return C3$jscomp$94.AddonManager._GetInitProperties()
    }
    _postCreate() {}
    _trigger(a) {
        const b = map$jscomp$22.get(this);
        b.GetRuntime().Trigger(a, b.GetObjectInstance(), b.GetBehaviorType())
    }
    _setTicking(a) {
        a = !!a;
        if (this._p_isTicking !== a) {
            this._p_isTicking = a;
            var b = map$jscomp$22.get(this).GetRuntime();
            a ? b._AddBehInstToTick(this) : b._RemoveBehInstToTick(this)
        }
    }
    _isTicking() {
        return this._p_isTicking
    }
    _tick() {}
    _setTicking2(a) {
        a = !!a;
        if (this._p_isTicking2 !== a) {
            this._p_isTicking2 = a;
            var b = map$jscomp$22.get(this).GetRuntime();
            a ? b._AddBehInstToTick2(this) : b._RemoveBehInstToTick2(this)
        }
    }
    _isTicking2() {
        return this._p_isTicking2
    }
    _tick2() {}
    _setPostTicking(a) {
        a = !!a;
        if (this._p_isPostTicking !== a) {
            this._p_isPostTicking = a;
            var b = map$jscomp$22.get(this).GetRuntime();
            a ? b._AddBehInstToPostTick(this) : b._RemoveBehInstToPostTick(this)
        }
    }
    _isPostTicking() {
        return this._p_isPostTicking
    }
    _postTick() {}
    _getDebuggerProperties() {
        return []
    }
    _saveToJson() {
        return null
    }
    _loadFromJson(a) {}
}
;
"use strict";
const C3$jscomp$95 = self.C3
  , C3X$jscomp$31 = self.C3X;
let renderer$jscomp$57 = null
  , runtime$jscomp$29 = null;
self.IRenderer = class {
    constructor(a, b) {
        runtime$jscomp$29 = a;
        renderer$jscomp$57 = b
    }
    setAlphaBlendMode() {
        renderer$jscomp$57.SetAlphaBlend()
    }
    setBlendMode(a) {
        renderer$jscomp$57.SetNamedBlendMode(a)
    }
    setColorFillMode() {
        renderer$jscomp$57.SetColorFillMode()
    }
    setTextureFillMode() {
        renderer$jscomp$57.SetTextureFillMode()
    }
    setSmoothLineFillMode() {
        renderer$jscomp$57.SetSmoothLineFillMode()
    }
    setColor(a) {
        renderer$jscomp$57.SetColorRgba(a[0], a[1], a[2], a[3])
    }
    setColorRgba(a, b, c, d) {
        renderer$jscomp$57.SetColorRgba(a, b, c, d)
    }
    resetColor() {
        renderer$jscomp$57.ResetColor()
    }
    setOpacity(a) {
        renderer$jscomp$57.SetOpacity(a)
    }
    setCurrentZ(a) {
        renderer$jscomp$57.SetCurrentZ(a)
    }
    getCurrentZ() {
        renderer$jscomp$57.GetCurrentZ()
    }
    rect(a) {
        renderer$jscomp$57.Rect2(a.left, a.top, a.right, a.bottom)
    }
    rect2(a, b, c, d) {
        renderer$jscomp$57.Rect2(a, b, c, d)
    }
    quad(a) {
        renderer$jscomp$57.Quad(C3$jscomp$95.Quad.fromDOMQuad(a))
    }
    quad2(a, b, c, d, e, f, h, l) {
        renderer$jscomp$57.Quad2(a, b, c, d, e, f, h, l)
    }
    quad3(a, b) {
        renderer$jscomp$57.Quad3(C3$jscomp$95.Quad.fromDOMQuad(a), C3$jscomp$95.Rect.fromDOMRect(b))
    }
    quad4(a, b) {
        renderer$jscomp$57.Quad4(C3$jscomp$95.Quad.fromDOMQuad(a), C3$jscomp$95.Quad.fromDOMQuad(b))
    }
    quad3D(a, b, c, d, e, f, h, l, m, p, r, v, x) {
        renderer$jscomp$57.Quad3D(a, b, c, d, e, f, h, l, m, p, r, v, C3$jscomp$95.Rect.fromDOMRect(x))
    }
    quad3D2(a, b, c, d, e, f, h, l, m, p, r, v, x) {
        renderer$jscomp$57.Quad3D2(a, b, c, d, e, f, h, l, m, p, r, v, C3$jscomp$95.Quad.fromDOMQuad(x))
    }
    drawMesh(a, b, c) {
        renderer$jscomp$57.DrawMesh(a, b, c)
    }
    convexPoly(a) {
        renderer$jscomp$57.ConvexPoly(a)
    }
    line(a, b, c, d) {
        renderer$jscomp$57.Line(a, b, c, d)
    }
    texturedLine(a, b, c, d, e, f) {
        renderer$jscomp$57.TexturedLine(a, b, c, d, e, f)
    }
    lineRect(a, b, c, d) {
        renderer$jscomp$57.LineRect(a, b, c, d)
    }
    lineRect2(a) {
        renderer$jscomp$57.LineRect2(C3$jscomp$95.Rect.fromDOMRect(a))
    }
    lineQuad(a) {
        renderer$jscomp$57.LineQuad(C3$jscomp$95.Quad.fromDOMQuad(a))
    }
    pushLineWidth(a) {
        renderer$jscomp$57.PushLineWidth(a)
    }
    popLineWidth() {
        renderer$jscomp$57.PopLineWidth()
    }
    pushLineCap(a) {
        renderer$jscomp$57.PushLineCap(a)
    }
    popLineCap() {
        renderer$jscomp$57.PopLineCap()
    }
    setTexture(a) {
        C3X$jscomp$31.RequireOptionalInstanceOf(a, self.ITexture);
        a = a ? runtime$jscomp$29._UnwrapScriptInterface(a) : null;
        renderer$jscomp$57.SetTexture(a)
    }
    loadTextureForImageInfo(a, b) {
        a = self.IImageInfo._Unwrap(a);
        if (!a)
            throw Error("invalid IImageInfo");
        return a.LoadStaticTexture(renderer$jscomp$57, {
            wrapX: b?.wrapX ?? "clamp-to-edge",
            wrapY: b?.wrapY ?? "clamp-to-edge",
            sampling: b?.sampling ?? "trilinear",
            mipMap: b?.mipMap ?? !0
        })
    }
    releaseTextureForImageInfo(a) {
        a = self.IImageInfo._Unwrap(a);
        if (!a)
            throw Error("invalid IImageInfo");
        a.ReleaseTexture()
    }
    getTextureForImageInfo(a) {
        a = self.IImageInfo._Unwrap(a);
        if (!a)
            throw Error("invalid IImageInfo");
        a = a.GetTexture();
        return self.ITexture.GetInterface(runtime$jscomp$29, a)
    }
    createDynamicTexture(a, b, c) {
        C3X$jscomp$31.RequireFiniteNumber(a);
        C3X$jscomp$31.RequireFiniteNumber(b);
        a = renderer$jscomp$57.CreateDynamicTexture(a, b, {
            wrapX: c?.wrapX ?? "clamp-to-edge",
            wrapY: c?.wrapY ?? "clamp-to-edge",
            sampling: c?.sampling ?? "trilinear",
            mipMap: c?.mipMap ?? !0
        });
        return self.ITexture.GetInterface(runtime$jscomp$29, a)
    }
    updateTexture(a, b, c) {
        C3X$jscomp$31.RequireInstanceOf(b, self.ITexture);
        b = runtime$jscomp$29._UnwrapScriptInterface(b);
        renderer$jscomp$57.UpdateTexture(a, b, {
            premultiplyAlpha: c?.premultiplyAlpha ?? !0
        })
    }
    deleteTexture(a) {
        C3X$jscomp$31.RequireInstanceOf(a, self.ITexture);
        a = runtime$jscomp$29._UnwrapScriptInterface(a);
        renderer$jscomp$57.DeleteTexture(a)
    }
    createRendererText() {
        const a = renderer$jscomp$57.CreateRendererText();
        return new self.IRendererText(runtime$jscomp$29,a)
    }
    setDeviceTransform() {
        runtime$jscomp$29.GetCanvasManager().SetDeviceTransform(renderer$jscomp$57)
    }
    setLayerTransform(a) {
        C3X$jscomp$31.RequireInstanceOf(a, globalThis.ILayer);
        runtime$jscomp$29._UnwrapScriptInterface(a)._SetTransform(renderer$jscomp$57)
    }
}
;
"use strict";
const map$jscomp$23 = new WeakMap
  , reverseMap = new WeakMap;
self.ITexture = class {
    constructor(a, b) {
        map$jscomp$23.set(this, {
            runtime: a,
            texture: b
        });
        reverseMap.set(b, this);
        a._MapScriptInterface(this, b);
        Object.defineProperties(this, {
            width: {
                value: b.GetWidth(),
                writable: !1
            },
            height: {
                value: b.GetHeight(),
                writable: !1
            }
        })
    }
    static GetInterface(a, b) {
        if (!b)
            return null;
        const c = reverseMap.get(b);
        return c ? c : new self.ITexture(a,b)
    }
}
;
"use strict";
const C3X$jscomp$33 = self.C3X
  , map$jscomp$24 = new WeakMap;
function getActual(a) {
    return map$jscomp$24.get(a).rendererText
}
self.IRendererText = class {
    constructor(a, b) {
        map$jscomp$24.set(this, {
            runtime: a,
            rendererText: b
        });
        a._MapScriptInterface(this, b)
    }
    release() {
        getActual(this).Release()
    }
    set fontFace(a) {
        C3X$jscomp$33.RequireString(a);
        getActual(this).SetFontName(a)
    }
    get fontFace() {
        return getActual(this).GetFontName()
    }
    set sizePt(a) {
        C3X$jscomp$33.RequireFiniteNumber(a);
        getActual(this).SetFontSize(a)
    }
    get sizePt() {
        return getActual(this).GetFontSize()
    }
    set lineHeight(a) {
        C3X$jscomp$33.RequireFiniteNumber(a);
        getActual(this).SetLineHeight(a)
    }
    get lineHeight() {
        return getActual(this).GetLineHeight()
    }
    set isBold(a) {
        getActual(this).SetBold(a)
    }
    get isBold() {
        return getActual(this).IsBold()
    }
    set isItalic(a) {
        getActual(this).SetItalic(a)
    }
    get isItalic() {
        return getActual(this).IsItalic()
    }
    setColor(a) {
        C3X$jscomp$33.RequireArray(a);
        this.setColorRgb(a[0], a[1], a[2])
    }
    setColorRgb(a, b, c) {
        getActual(this).SetColorRgb(a, b, c)
    }
    setCssColor(a) {
        C3X$jscomp$33.RequireString(a);
        getActual(this).SetColor(a)
    }
    set horizontalAlign(a) {
        getActual(this).SetHorizontalAlignment(a)
    }
    get horizontalAlign() {
        return getActual(this).GetHorizontalAlignment()
    }
    set verticalAlign(a) {
        getActual(this).SetVerticalAlignment(a)
    }
    get verticalAlign() {
        return getActual(this).GetVerticalAlignment()
    }
    set wordWrapMode(a) {
        getActual(this).SetWordWrapMode(a)
    }
    get wordWrapMode() {
        return getActual(this).GetWordWrapMode()
    }
    set textDirection(a) {
        getActual(this).SetTextDirection(a)
    }
    get textDirection() {
        return getActual(this).GetTextDirection()
    }
    set text(a) {
        C3X$jscomp$33.RequireString(a);
        getActual(this).SetText(a)
    }
    get text() {
        return getActual(this).GetText()
    }
    setSize(a, b, c) {
        C3X$jscomp$33.RequireFiniteNumber(a);
        C3X$jscomp$33.RequireFiniteNumber(b);
        C3X$jscomp$33.RequireFiniteNumber(c);
        getActual(this).SetSize(a, b, c)
    }
    getTexture() {
        const {runtime: a, rendererText: b} = map$jscomp$24.get(this)
          , c = b.GetTexture();
        return self.ITexture.GetInterface(a, c)
    }
    getTexRect() {
        return getActual(this).GetTexRect().toDOMRect()
    }
    setTextureUpdateCallback(a) {
        C3X$jscomp$33.RequireFunction(a);
        getActual(this).ontextureupdate = a
    }
    releaseTexture() {
        getActual(this).ReleaseTexture()
    }
    get textWidth() {
        return getActual(this).GetTextWidth()
    }
    get textHeight() {
        return getActual(this).GetTextHeight()
    }
}
;
"use strict";
const C3$jscomp$98 = self.C3
  , VALID_LOAD_POLICIES = new Set(["local", "remote"])
  , EXT_TO_TYPE = new Map([["mp4", "video/mp4"], ["webm", "video/webm"], ["m4a", "audio/mp4"], ["mp3", "audio/mpeg"], ["js", "application/javascript"], ["wasm", "application/wasm"], ["svg", "image/svg+xml"], ["html", "text/html"]]);
function GetTypeFromFileExtension(a) {
    if (!a)
        return "";
    a = a.split(".");
    if (2 > a.length)
        return "";
    a = a.at(-1).toLowerCase();
    return EXT_TO_TYPE.get(a) || ""
}
function AddScript(a) {
    return new Promise( (b, c) => {
        const d = document.createElement("script");
        d.onload = b;
        d.onerror = c;
        d.async = !1;
        d.type = "module";
        d.src = a;
        document.head.appendChild(d)
    }
    )
}
C3$jscomp$98.AssetManager = class extends C3$jscomp$98.DefendedBase {
    constructor(a, b) {
        super();
        var c = b.exportType;
        this._runtime = a;
        this._fileStructure = "folders";
        this._localUrlBlobs = new Map;
        this._localBlobUrlCache = new Map;
        this._localBlobSWUrls = new Map;
        this._isCordova = "cordova" === c;
        this._isiOSCordova = !!b.isiOSCordova;
        this._isFileProtocol = !!b.isFileProtocol;
        this._swClientId = b.swClientId;
        this._supportedAudioFormats = b.supportedAudioFormats || {};
        this._audioFiles = new Map;
        this._preloadSounds = !1;
        this._iconsSubfolder = this._fontsSubfolder = this._mediaSubfolder = "";
        this._defaultLoadPolicy = "html5" === c || "scirra-arcade" === c || "instant-games" === c ? "remote" : "local";
        this._assetsByUrl = new Map;
        this._webFonts = [];
        this._loadPromises = [];
        this._hasFinishedInitialLoad = !1;
        this._lastLoadProgress = this._assetSizeLoaded = this._totalAssetSizeToLoad = 0;
        this._hasHadErrorLoading = !1;
        this._loadingRateLimiter = C3$jscomp$98.New(C3$jscomp$98.RateLimiter, () => this._FireLoadingProgressEvent(), 50);
        this._localPromiseThrottle = C3$jscomp$98.New(C3$jscomp$98.PromiseThrottle, Math.max(C3$jscomp$98.hardwareConcurrency, 8));
        this._remotePromiseThrottle = C3$jscomp$98.New(C3$jscomp$98.PromiseThrottle, 20);
        if (a = b.previewImageBlobs) {
            (c = b.previewProjectFileBlobs) && Object.assign(a, c);
            (c = b.projectData) && (a["data.json"] = c);
            for (const [d,e] of Object.entries(a))
                this._localUrlBlobs.set(d, e)
        }
        if (b = b.previewProjectFileSWUrls)
            for (const [d,e] of Object.entries(b))
                this._localBlobSWUrls.set(d, e);
        this._iAssetManager = new self.IAssetManager(this)
    }
    Release() {
        this._localUrlBlobs.clear();
        for (const a of this._localBlobUrlCache.values())
            a.startsWith("blob:") && URL.revokeObjectURL(a);
        this._localBlobUrlCache.clear();
        for (const a of this._assetsByUrl.values())
            a.Release();
        this._assetsByUrl.clear();
        C3$jscomp$98.clearArray(this._loadPromises);
        this._runtime = null
    }
    GetRuntime() {
        return this._runtime
    }
    _SetFileStructure(a) {
        this._fileStructure = a;
        if ("flat" === a) {
            a = new Map;
            for (const [b,c] of this._localUrlBlobs.entries())
                a.set(b.toLowerCase(), c);
            this._localUrlBlobs = a
        }
    }
    GetFileStructure() {
        return this._fileStructure
    }
    _SetMediaSubfolder(a) {
        this._mediaSubfolder = a
    }
    GetMediaSubfolder() {
        return this._mediaSubfolder
    }
    _SetFontsSubfolder(a) {
        this._fontsSubfolder = a
    }
    GetFontsSubfolder() {
        return this._fontsSubfolder
    }
    _SetIconsSubfolder(a) {
        this._iconsSubfolder = a
    }
    GetIconsSubfolder() {
        return this._iconsSubfolder
    }
    IsFileProtocol() {
        return this._isFileProtocol
    }
    _HasLocalUrlBlob(a) {
        "flat" === this._fileStructure && (a = a.toLowerCase());
        return this._localUrlBlobs.has(a)
    }
    _GetLocalUrlBlob(a) {
        "flat" === this._fileStructure && (a = a.toLowerCase());
        return this._localUrlBlobs.get(a) || null
    }
    GetLocalUrlAsBlobUrl(a) {
        "flat" === this._fileStructure && (a = a.toLowerCase());
        if (!this._HasLocalUrlBlob(a))
            return a;
        var b = this._localBlobUrlCache.get(a);
        b || (b = this._GetLocalUrlBlob(a),
        b = URL.createObjectURL(b),
        this._localBlobUrlCache.set(a, b));
        return b
    }
    FetchBlob(a, b) {
        b = b || this._defaultLoadPolicy;
        const c = this._GetLocalUrlBlob(a);
        return c ? Promise.resolve(c) : C3$jscomp$98.IsRelativeURL(a) ? ("flat" === this._fileStructure && (a = a.toLowerCase()),
        this._isCordova && this._isFileProtocol ? this.CordovaFetchLocalFileAsBlob(a) : "local" === b ? this._localPromiseThrottle.Add( () => C3$jscomp$98.FetchBlob(a)) : this._remotePromiseThrottle.Add( () => C3$jscomp$98.FetchBlob(a))) : C3$jscomp$98.FetchBlob(a)
    }
    FetchArrayBuffer(a) {
        const b = this._GetLocalUrlBlob(a);
        return b ? C3$jscomp$98.BlobToArrayBuffer(b) : C3$jscomp$98.IsRelativeURL(a) ? ("flat" === this._fileStructure && (a = a.toLowerCase()),
        this._isCordova && this._isFileProtocol ? this.CordovaFetchLocalFileAsArrayBuffer(a) : "local" === this._defaultLoadPolicy ? this._localPromiseThrottle.Add( () => C3$jscomp$98.FetchArrayBuffer(a)) : this._remotePromiseThrottle.Add( () => C3$jscomp$98.FetchArrayBuffer(a))) : C3$jscomp$98.FetchArrayBuffer(a)
    }
    FetchText(a) {
        const b = this._GetLocalUrlBlob(a);
        return b ? C3$jscomp$98.BlobToString(b) : C3$jscomp$98.IsRelativeURL(a) ? ("flat" === this._fileStructure && (a = a.toLowerCase()),
        this._isCordova && this._isFileProtocol ? this.CordovaFetchLocalFileAsText(a) : "local" === this._defaultLoadPolicy ? this._localPromiseThrottle.Add( () => C3$jscomp$98.FetchText(a)) : this._remotePromiseThrottle.Add( () => C3$jscomp$98.FetchText(a))) : C3$jscomp$98.FetchText(a)
    }
    async FetchJson(a) {
        a = await this.FetchText(a);
        return JSON.parse(a)
    }
    _CordovaFetchLocalFileAs(a, b) {
        "flat" === this._fileStructure && (a = a.toLowerCase());
        return this._runtime.PostComponentMessageToDOMAsync("runtime", "cordova-fetch-local-file", {
            filename: a,
            as: b
        })
    }
    CordovaFetchLocalFileAsText(a) {
        return this._CordovaFetchLocalFileAs(a, "text")
    }
    async CordovaFetchLocalFileAsBlob(a) {
        const b = await this._CordovaFetchLocalFileAs(a, "buffer");
        a = GetTypeFromFileExtension(a);
        return new Blob([b],{
            type: a
        })
    }
    async CordovaFetchLocalFileAsBlobURL(a) {
        "flat" === this._fileStructure && (a = a.toLowerCase());
        var b = this._localBlobUrlCache.get(a);
        if (b)
            return b;
        b = await this.CordovaFetchLocalFileAsBlob(a);
        b = URL.createObjectURL(b);
        this._localBlobUrlCache.set(a, b);
        return b
    }
    CordovaFetchLocalFileAsArrayBuffer(a) {
        return this._CordovaFetchLocalFileAs(a, "buffer")
    }
    GetMediaFileUrl(a) {
        "flat" === this._fileStructure && (a = a.toLowerCase());
        a = this._mediaSubfolder + a;
        return this._HasLocalUrlBlob(a) ? this.GetLocalUrlAsBlobUrl(a) : a
    }
    GetProjectFileUrl(a) {
        if (C3$jscomp$98.IsAbsoluteURL(a))
            return Promise.resolve(a);
        if (this._HasLocalUrlBlob(a))
            return Promise.resolve(this.GetLocalUrlAsBlobUrl(a));
        if (this._isCordova && this._isFileProtocol)
            return this.CordovaFetchLocalFileAsBlobURL(a);
        "flat" === this._fileStructure && (a = a.toLowerCase());
        return Promise.resolve(a)
    }
    GetProjectFileIframeUrl(a) {
        if (C3$jscomp$98.IsAbsoluteURL(a))
            return Promise.resolve(a);
        var b = a.indexOf("?")
          , c = -1 === b ? "" : a.substr(b);
        b = -1 === b ? a : a.substr(0, b);
        if (this._HasLocalUrlBlob(b))
            return a = this._localBlobSWUrls.get(b) || this.GetLocalUrlAsBlobUrl(b),
            !a.startsWith("blob:") && this._swClientId && (a = new URL(a),
            c = new URLSearchParams(c),
            c.set("__c3_client_id", this._swClientId),
            a.search = c.toString(),
            a = a.toString()),
            Promise.resolve(a);
        if (this._isCordova && this._isFileProtocol)
            return this.CordovaFetchLocalFileAsBlobURL(b);
        "flat" === this._fileStructure && (a = a.toLowerCase());
        return Promise.resolve(a)
    }
    LoadProjectFileUrl(a) {
        return this.GetProjectFileUrl(a)
    }
    LoadImage(a) {
        if (a.loadPolicy && !VALID_LOAD_POLICIES.has(a.loadPolicy))
            throw Error("invalid load policy");
        let b = this._assetsByUrl.get(a.url);
        if (b)
            return b;
        b = C3$jscomp$98.New(C3$jscomp$98.ImageAsset, this, {
            url: a.url,
            size: a.size || 0,
            loadPolicy: a.loadPolicy || this._defaultLoadPolicy
        });
        this._assetsByUrl.set(b.GetURL(), b);
        this._hasFinishedInitialLoad || (this._totalAssetSizeToLoad += b.GetSize(),
        this._loadPromises.push(b.Load().then( () => this._AddLoadedSize(b.GetSize()))));
        return b
    }
    _ReleaseAsset(a) {
        this._assetsByUrl.delete(a.GetURL())
    }
    async WaitForAllToLoad() {
        try {
            await Promise.all(this._loadPromises),
            this._lastLoadProgress = 1
        } catch (a) {
            console.error("Error loading: ", a),
            this._hasHadErrorLoading = !0,
            this._FireLoadingProgressEvent()
        }
    }
    SetInitialLoadFinished() {
        this._hasFinishedInitialLoad = !0
    }
    HasHadErrorLoading() {
        return this._hasHadErrorLoading
    }
    _AddLoadedSize(a) {
        this._assetSizeLoaded += a;
        this._loadingRateLimiter.Call()
    }
    _FireLoadingProgressEvent() {
        const a = C3$jscomp$98.New(C3$jscomp$98.Event, "loadingprogress");
        this._lastLoadProgress = C3$jscomp$98.clamp(this._assetSizeLoaded / this._totalAssetSizeToLoad, 0, 1);
        a.progress = this._lastLoadProgress;
        this._runtime.Dispatcher().dispatchEvent(a)
    }
    GetLoadProgress() {
        return this._lastLoadProgress
    }
    _SetWebFonts(a) {
        C3$jscomp$98.shallowAssignArray(this._webFonts, a);
        this._webFonts.length && this._loadPromises.push(this._LoadWebFonts())
    }
    async _LoadWebFonts() {
        const a = []
          , b = [];
        for (const [c,d,e] of this._webFonts)
            this._totalAssetSizeToLoad += e,
            a.push(this._LoadWebFont(c, d, b).then( () => this._AddLoadedSize(e)));
        await Promise.all(a);
        this._runtime.IsInWorker() && 0 < b.length && await this._runtime.PostComponentMessageToDOMAsync("runtime", "load-webfonts", {
            webfonts: b
        })
    }
    async _LoadWebFont(a, b, c) {
        try {
            const d = await this.GetProjectFileUrl(b);
            "Gecko" === C3$jscomp$98.Platform.BrowserEngine && (a = `'${a}'`);
            const e = new FontFace(a,`url('${d}')`);
            this._runtime.IsInWorker() ? self.fonts.add(e) : document.fonts.add(e);
            await e.load();
            this._runtime.IsInWorker() && c.push({
                name: a,
                url: d
            })
        } catch (d) {
            console.warn(`[C3 runtime] Failed to load web font '${a}': `, d)
        }
    }
    IsAudioFormatSupported(a) {
        return !!this._supportedAudioFormats[a]
    }
    _SetAudioFiles(a, b) {
        this._preloadSounds = !!b;
        for (const [c,d,e] of a)
            this._audioFiles.set(c, {
                fileName: c,
                formats: d.map(f => ({
                    type: f[0],
                    fileExtension: f[1],
                    fullName: c + f[1],
                    fileSize: f[2]
                })),
                isMusic: e
            })
    }
    GetPreferredAudioFile(a) {
        "flat" === this._fileStructure && (a = a.toLowerCase());
        a = this._audioFiles.get(a);
        if (!a)
            return null;
        let b = null;
        for (const c of a.formats)
            if (b || "audio/webm; codecs=opus" !== c.type || (b = c),
            this.IsAudioFormatSupported(c.type))
                return c;
        return b
    }
    GetProjectAudioFileUrl(a) {
        return (a = this.GetPreferredAudioFile(a)) ? {
            url: this.GetMediaFileUrl(a.fullName),
            type: a.type
        } : null
    }
    GetAudioToPreload() {
        if (this._preloadSounds) {
            const a = [];
            for (const b of this._audioFiles.values()) {
                if (b.isMusic)
                    continue;
                const c = this.GetPreferredAudioFile(b.fileName);
                c && a.push({
                    originalUrl: b.fileName,
                    url: this.GetMediaFileUrl(c.fullName),
                    type: c.type,
                    fileSize: c.fileSize
                })
            }
            return a
        }
        return []
    }
    GetIAssetManager() {
        return this._iAssetManager
    }
    async LoadScripts(...a) {
        const b = await Promise.all(a.map(c => this.GetProjectFileUrl(c)));
        this._runtime.IsInWorker() ? 1 === a.length ? (a = a[0],
        await self.c3_import((C3$jscomp$98.IsRelativeURL(a) ? "./" : "") + a)) : (a = a.map(c => `import "${C3$jscomp$98.IsRelativeURL(c) ? "./" : ""}${c}";`).join("\n"),
        a = URL.createObjectURL(new Blob([a],{
            type: "application/javascript"
        })),
        await self.c3_import(a)) : await Promise.all(b.map(c => AddScript(c)))
    }
    async CompileWebAssembly(a) {
        if (WebAssembly.compileStreaming)
            return a = await this.GetProjectFileUrl(a),
            await WebAssembly.compileStreaming(fetch(a));
        a = await C3$jscomp$98.FetchArrayBuffer(a);
        return await WebAssembly.compile(a)
    }
    async LoadStyleSheet(a) {
        a = await this.GetProjectFileUrl(a);
        return await this._runtime.PostComponentMessageToDOMAsync("runtime", "add-stylesheet", {
            url: a
        })
    }
}
;
"use strict";
const C3$jscomp$99 = self.C3;
C3$jscomp$99.Asset = class extends C3$jscomp$99.DefendedBase {
    constructor(a, b) {
        super();
        this._assetManager = a;
        this._runtime = a.GetRuntime();
        this._url = b.url || "";
        this._size = b.size;
        this._loadPolicy = b.loadPolicy;
        this._blob = b.blob || null;
        this._isLoaded = !!this._blob;
        this._loadPromise = null
    }
    Release() {
        this._blob = this._runtime = this._assetManager = this._loadPromise = null
    }
    GetURL() {
        return this._url
    }
    GetSize() {
        return this._size
    }
    Load() {
        return "local" === this._loadPolicy || this._blob ? (this._isLoaded = !0,
        Promise.resolve()) : this._loadPromise ? this._loadPromise : this._loadPromise = this._assetManager.FetchBlob(this._url, this._loadPolicy).then(a => {
            this._isLoaded = !0;
            this._loadPromise = null;
            return this._blob = a
        }
        ).catch(a => {
            console.error("Error loading resource: ", a);
            this._loadPromise = null
        }
        )
    }
    IsLoaded() {
        return this._isLoaded
    }
    GetBlob() {
        return this._blob ? Promise.resolve(this._blob) : this._loadPromise ? this._loadPromise : this._assetManager.FetchBlob(this._url, this._loadPolicy)
    }
}
;
"use strict";
const C3$jscomp$100 = self.C3
  , promiseThrottle = new C3$jscomp$100.PromiseThrottle
  , allImageAssets = new Set;
C3$jscomp$100.ImageAsset = class extends C3$jscomp$100.Asset {
    constructor(a, b) {
        super(a, b);
        this._webglTexture = this._texturePromise = null;
        this._refCount = 0;
        this._imageHeight = this._imageWidth = -1;
        allImageAssets.add(this)
    }
    Release() {
        if (0 !== this._refCount)
            throw Error("released image asset which still has texture references");
        this._assetManager._ReleaseAsset(this);
        this._texturePromise = null;
        allImageAssets.delete(this);
        super.Release()
    }
    static OnRendererContextLost() {
        for (const a of allImageAssets)
            a._texturePromise = null,
            a._webglTexture = null,
            a._refCount = 0
    }
    LoadStaticTexture(a, b) {
        b = b || {};
        this._refCount++;
        if (this._webglTexture)
            return Promise.resolve(this._webglTexture);
        if (this._texturePromise)
            return this._texturePromise;
        b.anisotropy = this._runtime.GetCanvasManager().GetTextureAnisotropy();
        return this._texturePromise = this._DoLoadStaticTexture(a, b)
    }
    async _DoLoadStaticTexture(a, b) {
        try {
            const c = await this.GetBlob();
            return 0 === this._refCount ? null : await promiseThrottle.Add(async () => {
                const d = await a.CreateStaticTextureAsync(c, b);
                this._texturePromise = null;
                if (0 === this._refCount)
                    return a.DeleteTexture(d),
                    null;
                this._webglTexture = d;
                this._imageWidth = d.GetWidth();
                this._imageHeight = d.GetHeight();
                return this._webglTexture
            }
            )
        } catch (c) {
            throw console.error("Failed to load texture: ", c),
            c;
        }
    }
    ReleaseTexture() {
        if (0 >= this._refCount)
            throw Error("texture released too many times");
        this._refCount--;
        0 === this._refCount && this._webglTexture && (this._webglTexture.GetRenderer().DeleteTexture(this._webglTexture),
        this._webglTexture = null)
    }
    GetRefCount() {
        return this._refCount
    }
    GetTexture() {
        return this._webglTexture
    }
    GetWidth() {
        return this._imageWidth
    }
    GetHeight() {
        return this._imageHeight
    }
    async LoadToDrawable() {
        const a = await this.GetBlob();
        return C3$jscomp$100.Supports.ImageBitmap ? await createImageBitmap(a) : await C3$jscomp$100.BlobToImage(a)
    }
}
;
"use strict";
const C3$jscomp$101 = self.C3;
function SortByInstLastCachedZIndex(a, b) {
    return a.GetWorldInfo()._GetLastCachedZIndex() - b.GetWorldInfo()._GetLastCachedZIndex()
}
C3$jscomp$101.RenderCell = class extends C3$jscomp$101.DefendedBase {
    constructor(a, b, c) {
        super();
        this._grid = a;
        this._x = b;
        this._y = c;
        this._instances = [];
        this._isSorted = !0;
        this._pendingRemoval = new Set;
        this._isAnyPendingRemoval = !1
    }
    Release() {
        C3$jscomp$101.clearArray(this._instances);
        this._pendingRemoval.clear();
        this._grid = null
    }
    Reset() {
        C3$jscomp$101.clearArray(this._instances);
        this._isSorted = !0;
        this._pendingRemoval.clear();
        this._isAnyPendingRemoval = !1
    }
    SetChanged() {
        this._isSorted = !1
    }
    IsEmpty() {
        if (!this._instances.length)
            return !0;
        if (this._instances.length > this._pendingRemoval.size)
            return !1;
        this._FlushPending();
        return !0
    }
    Insert(a) {
        this._pendingRemoval.has(a) ? (this._pendingRemoval.delete(a),
        0 === this._pendingRemoval.size && (this._isAnyPendingRemoval = !1)) : (this._instances.push(a),
        this._isSorted = 1 === this._instances.length)
    }
    Remove(a) {
        this._pendingRemoval.add(a);
        this._isAnyPendingRemoval = !0;
        50 <= this._pendingRemoval.size && this._FlushPending()
    }
    _FlushPending() {
        this._isAnyPendingRemoval && (this._instances.length === this._pendingRemoval.size ? this.Reset() : (C3$jscomp$101.arrayRemoveAllInSet(this._instances, this._pendingRemoval),
        this._pendingRemoval.clear(),
        this._isAnyPendingRemoval = !1))
    }
    _EnsureSorted() {
        this._isSorted || (this._instances.sort(SortByInstLastCachedZIndex),
        this._isSorted = !0)
    }
    Dump(a) {
        this._FlushPending();
        this._EnsureSorted();
        this._instances.length && a.push(this._instances)
    }
}
;
"use strict";
const C3$jscomp$102 = self.C3;
C3$jscomp$102.RenderGrid = class extends C3$jscomp$102.DefendedBase {
    constructor(a, b) {
        super();
        this._cellWidth = a;
        this._cellHeight = b;
        this._cells = C3$jscomp$102.New(C3$jscomp$102.PairMap)
    }
    Release() {
        this._cells.Release();
        this._cells = null
    }
    GetCell(a, b, c) {
        let d = this._cells.Get(a, b);
        return d ? d : c ? (d = C3$jscomp$102.New(C3$jscomp$102.RenderCell, this, a, b),
        this._cells.Set(a, b, d),
        d) : null
    }
    XToCell(a) {
        return Math.floor(a / this._cellWidth)
    }
    YToCell(a) {
        return Math.floor(a / this._cellHeight)
    }
    Update(a, b, c) {
        if (b)
            for (let d = b.getLeft(), e = b.getRight(); d <= e; ++d)
                for (let f = b.getTop(), h = b.getBottom(); f <= h; ++f) {
                    if (c && c.containsPoint(d, f))
                        continue;
                    const l = this.GetCell(d, f, !1);
                    l && (l.Remove(a),
                    l.IsEmpty() && this._cells.Delete(d, f))
                }
        if (c)
            for (let d = c.getLeft(), e = c.getRight(); d <= e; ++d)
                for (let f = c.getTop(), h = c.getBottom(); f <= h; ++f)
                    b && b.containsPoint(d, f) || this.GetCell(d, f, !0).Insert(a)
    }
    QueryRange(a, b) {
        let c = this.XToCell(a.getLeft());
        const d = this.YToCell(a.getTop())
          , e = this.XToCell(a.getRight());
        for (a = this.YToCell(a.getBottom()); c <= e; ++c)
            for (let f = d; f <= a; ++f) {
                const h = this.GetCell(c, f, !1);
                h && h.Dump(b)
            }
    }
    MarkRangeChanged(a) {
        let b = a.getLeft();
        const c = a.getTop()
          , d = a.getRight();
        for (a = a.getBottom(); b <= d; ++b)
            for (let e = c; e <= a; ++e) {
                const f = this.GetCell(b, e, !1);
                f && f.SetChanged()
            }
    }
}
;
"use strict";
const C3$jscomp$103 = self.C3
  , tmpRect$jscomp$2 = new C3$jscomp$103.Rect
  , tmpQuad$jscomp$2 = new C3$jscomp$103.Quad
  , renderCellArr = [];
new C3$jscomp$103.Rect;
new C3$jscomp$103.Rect;
const glMatrix$jscomp$8 = self.glMatrix
  , vec3$jscomp$6 = glMatrix$jscomp$8.vec3
  , vec4$jscomp$5 = glMatrix$jscomp$8.vec4
  , mat4$jscomp$9 = glMatrix$jscomp$8.mat4
  , tempMat4$jscomp$4 = mat4$jscomp$9.create()
  , tempVec3 = vec3$jscomp$6.create()
  , tempVec4$jscomp$1 = vec4$jscomp$5.create()
  , camVector = vec3$jscomp$6.create()
  , lookVector = vec3$jscomp$6.create()
  , upVector = vec3$jscomp$6.create()
  , tempVec2 = C3$jscomp$103.New(C3$jscomp$103.Vector2);
C3$jscomp$103.New(C3$jscomp$103.Rect);
function SortByInstLastCachedZIndex$jscomp$1(a, b) {
    return a.GetWorldInfo()._GetLastCachedZIndex() - b.GetWorldInfo()._GetLastCachedZIndex()
}
function SortByInstZElevation(a, b) {
    return a.GetWorldInfo().GetZElevation() - b.GetWorldInfo().GetZElevation()
}
const tempInstanceList1 = []
  , tempInstanceList2 = []
  , tempInstancesByCameraDist = []
  , DEFAULT_LAYER_OPTIONS = {
    name: "",
    sid: -1,
    isDynamic: !1,
    isVisible: !0,
    isInteractive: !0,
    isHTMLElementsLayer: !1,
    backgroundColor: [1, 1, 1, 1],
    isTransparent: !0,
    parallax: [1, 1],
    opacity: 1,
    isForceOwnTexture: !1,
    renderAs3d: !1,
    useCameraDistanceDrawOrder: !1,
    useRenderCells: !1,
    scaleRate: 1,
    blendMode: 0,
    zElevation: 0,
    initialInstancesData: [],
    effectListData: [],
    subLayersData: []
};
C3$jscomp$103.Layer = class extends C3$jscomp$103.DefendedBase {
    constructor(a, b, c) {
        super();
        c = Object.assign({}, DEFAULT_LAYER_OPTIONS, c);
        this._layout = a;
        this._runtime = a.GetRuntime();
        this._parentLayer = b;
        this._name = c.name;
        this._index = -1;
        this._isHTMLElementsLayer = !!c.isHTMLElementsLayer;
        this._htmlIndex = -1;
        this._sid = c.sid;
        this._isDynamic = !!c.isDynamic;
        this._isVisible = !!c.isVisible;
        this._isInteractive = !!c.isInteractive;
        this._backgroundColor = C3$jscomp$103.New(C3$jscomp$103.Color);
        this._backgroundColor.setFromJSON(c.backgroundColor);
        this._isTransparent = !!c.isTransparent;
        this._parallaxX = c.parallax[0];
        this._parallaxY = c.parallax[1];
        this._color = C3$jscomp$103.New(C3$jscomp$103.Color, 1, 1, 1, c.opacity);
        this._premultipliedColor = C3$jscomp$103.New(C3$jscomp$103.Color);
        this._isForceOwnTexture = !!c.isForceOwnTexture;
        this._renderAs3d = !!c.renderAs3d;
        this._useCameraDistanceDrawOrder = !!c.useCameraDistanceDrawOrder;
        this._useRenderCells = !!c.useRenderCells;
        this._scaleRate = c.scaleRate;
        this._blendMode = c.blendMode;
        this._curRenderTarget = null;
        this._scale = 1;
        this._zElevation = c.zElevation;
        this._scrollY = this._scrollX = this._angle = 0;
        this._hasOwnScrollPosition = !1;
        this._viewport = C3$jscomp$103.New(C3$jscomp$103.Rect);
        this._viewportZ0 = C3$jscomp$103.New(C3$jscomp$103.Rect);
        this._viewport3D = C3$jscomp$103.New(C3$jscomp$103.Rect);
        this._isViewportChanged = !0;
        this._projectionMatrix = mat4$jscomp$9.create();
        this._isProjectionMatrixChanged = !0;
        this._modelViewMatrix = mat4$jscomp$9.create();
        this._isMVMatrixChanged = !0;
        this._viewFrustum = C3$jscomp$103.New(C3$jscomp$103.Gfx.ViewFrustum);
        this._isViewFrustumChanged = !0;
        this._startupInitialInstances = [];
        this._initialInstancesData = c.initialInstancesData;
        this._initialInstances = [];
        this._createdGlobalUids = [];
        this._initialUIDsToInstanceData = new Map;
        this._instances = [];
        this._anyInstanceZElevated = this._htmlZIndicesUpToDate = this._zIndicesUpToDate = !1;
        const d = this._runtime.GetCanvasManager();
        this._effectList = C3$jscomp$103.New(C3$jscomp$103.EffectList, this, c.effectListData);
        this._effectChain = C3$jscomp$103.New(C3$jscomp$103.Gfx.EffectChain, d.GetEffectChainManager(), {
            drawContent: (e, f) => {
                f = f.GetContentObject();
                const h = f.GetRenderTarget();
                e.SetColor(f.GetPremultipliedColor());
                e.DrawRenderTarget(h);
                e.InvalidateRenderTarget(h);
                d.ReleaseAdditionalRenderTarget(h)
            }
            ,
            getShaderParameters: e => this.GetEffectList()._GetEffectChainShaderParametersForIndex(e)
        });
        this._wasDefaultColor = this._needsRebuildEffectChainSteps = !0;
        this._renderGrid = null;
        this._lastRenderList = [];
        this._isRenderListUpToDate = !1;
        this._lastRenderCells = C3$jscomp$103.New(C3$jscomp$103.Rect, 0, 0, -1, -1);
        this._curRenderCells = C3$jscomp$103.New(C3$jscomp$103.Rect, 0, 0, -1, -1);
        this._iLayer = new self.ILayer(this);
        this._UpdatePremultipliedColor();
        this.UsesRenderCells() && (this._renderGrid = C3$jscomp$103.New(C3$jscomp$103.RenderGrid, this._runtime.GetOriginalViewportWidth(), this._runtime.GetOriginalViewportHeight()));
        this._subLayers = c.subLayersData.map(e => C3$jscomp$103.Layer.CreateFromExportData(this._layout, this, e))
    }
    _InitInitialInstances() {
        for (const a of this._initialInstancesData) {
            const b = this._runtime.GetObjectClassByIndex(a[1]);
            this._layout._AddInitialObjectClass(b);
            b.GetDefaultInstanceData() || (b.SetDefaultInstanceData(a),
            b._SetDefaultLayerIndex(this._index));
            this._initialInstances.push(a);
            this._initialUIDsToInstanceData.set(a[2], a)
        }
        C3$jscomp$103.shallowAssignArray(this._startupInitialInstances, this._initialInstances);
        this._initialInstancesData = null
    }
    static CreateFromExportData(a, b, c) {
        return C3$jscomp$103.New(C3$jscomp$103.Layer, a, b, {
            name: c[0],
            sid: c[2],
            isVisible: c[3],
            isInteractive: c[13],
            isHTMLElementsLayer: c[19],
            backgroundColor: c[4].map(d => d / 255),
            isTransparent: c[5],
            parallax: [c[6], c[7]],
            opacity: c[8],
            isForceOwnTexture: c[9],
            renderAs3d: c[17],
            useCameraDistanceDrawOrder: c[18],
            useRenderCells: c[10],
            scaleRate: c[11],
            blendMode: c[12],
            zElevation: c[16],
            initialInstancesData: c[14],
            effectListData: c[15],
            subLayersData: c[20]
        })
    }
    Release() {
        for (const a of this._subLayers)
            a.Release();
        C3$jscomp$103.clearArray(this._subLayers);
        for (const a of this._instances)
            this._runtime.DestroyInstance(a);
        C3$jscomp$103.clearArray(this._instances);
        this._effectList.Release();
        this._effectList = null;
        this._effectChain.Release();
        this._runtime = this._layout = this._parentLayer = this._iLayer = this._effectChain = null
    }
    GetInitialInstanceData(a) {
        return this._initialUIDsToInstanceData.get(a)
    }
    CreateInitialInstances(a) {
        const b = this._layout.IsFirstVisit();
        let c = 0;
        const d = this._initialInstances;
        for (let f = 0, h = d.length; f < h; ++f) {
            var e = d[f];
            const l = this._runtime.GetObjectClassByIndex(e[1]);
            let m = !0;
            if (!l.HasPersistBehavior() || b)
                e = this._runtime.CreateInstanceFromData(e, this, !0),
                a.push(e),
                l.IsGlobal() && (m = !1,
                this._createdGlobalUids.push(e.GetUID()));
            m && (d[c] = d[f],
            ++c)
        }
        C3$jscomp$103.truncateArray(d, c);
        this._runtime.FlushPendingInstances();
        this.SetZIndicesChanged()
    }
    _AddInstance(a, b) {
        if (!a.GetPlugin().IsWorldType())
            throw Error("instance is not of world type");
        const c = a.GetWorldInfo();
        if (c.GetLayer() !== this)
            throw Error("instance added to wrong layer");
        this._instances.push(a);
        0 !== c.GetZElevation() && (this._anyInstanceZElevated = !0);
        b && this.UsesRenderCells() && a.GetWorldInfo().SetBboxChanged();
        this.SetZIndicesChanged(a)
    }
    _MaybeAddInstance(a) {
        this._instances.includes(a) || (this._instances.push(a),
        0 !== a.GetWorldInfo().GetZElevation() && (this._anyInstanceZElevated = !0),
        this.SetZIndicesChanged(a))
    }
    _PrependInstance(a, b) {
        const c = a.GetWorldInfo();
        if (c.GetLayer() !== this)
            throw Error("instance added to wrong layer");
        this._instances.unshift(a);
        0 !== c.GetZElevation() && (this._anyInstanceZElevated = !0);
        this.SetZIndicesChanged(a);
        b && this.UsesRenderCells() && a.GetWorldInfo().SetBboxChanged()
    }
    _RemoveInstance(a, b) {
        const c = this._instances.indexOf(a);
        0 > c || (b && this.UsesRenderCells() && a.GetWorldInfo()._RemoveFromRenderCells(),
        this._instances.splice(c, 1),
        this.SetZIndicesChanged(a),
        this._MaybeResetAnyInstanceZElevatedFlag())
    }
    _SetAnyInstanceZElevated() {
        this._anyInstanceZElevated = !0
    }
    _MaybeResetAnyInstanceZElevatedFlag() {
        0 === this._instances.length && (this._anyInstanceZElevated = !1)
    }
    _SortInstancesByLastCachedZIndex(a) {
        if (a) {
            a = new Set;
            for (var b of this._instances) {
                var c = b.GetWorldInfo()._GetLastCachedZIndex();
                0 <= c && a.add(c)
            }
            b = -1;
            for (const d of this._instances)
                if (c = d.GetWorldInfo(),
                !(0 <= c._GetLastCachedZIndex())) {
                    for (++b; a.has(b); )
                        ++b;
                    c._SetZIndex(b)
                }
        }
        this._instances.sort(SortByInstLastCachedZIndex$jscomp$1)
    }
    _Start() {}
    _End() {
        for (const a of this._instances)
            a.GetObjectClass().IsGlobal() || this._runtime.DestroyInstance(a);
        this._runtime.FlushPendingInstances();
        C3$jscomp$103.clearArray(this._instances);
        this._anyInstanceZElevated = !1;
        this.SetZIndicesChanged()
    }
    RecreateInitialObjects(a, b, c, d, e) {
        const f = this._runtime.GetEventSheetManager()
          , h = this._runtime.GetAllObjectClasses()
          , l = a.IsFamily()
          , m = [];
        for (const v of this._initialInstances) {
            var p = v[0];
            if (b.containsPoint(p[0], p[1])) {
                p = h[v[1]];
                if (p !== a)
                    if (l) {
                        if (!a.FamilyHasMember(p))
                            continue
                    } else
                        continue;
                p = this;
                var r = this._runtime.GetCurrentLayout();
                this.GetLayout() !== r && ((p = r.GetLayerByName(this.GetName())) || (p = r.GetLayerByIndex(this.GetIndex())));
                r = this._runtime.CreateInstanceFromData(v, p, !1, void 0, void 0, !1, e);
                p.SortAndAddInstancesByZIndex(r);
                p = r.GetWorldInfo();
                p.OffsetXY(c, d);
                p.SetBboxChanged();
                f.BlockFlushingInstances(!0);
                r._TriggerOnCreatedOnSelfAndRelated();
                f.BlockFlushingInstances(!1);
                m.push(r)
            }
        }
        return m
    }
    GetInstanceCount() {
        return this._instances.length
    }
    GetLayout() {
        return this._layout
    }
    GetName() {
        return this._name
    }
    _SetIndex(a) {
        this._index = a
    }
    GetIndex() {
        return this._index
    }
    _SetHTMLIndex(a) {
        this._htmlIndex = a
    }
    GetHTMLIndex() {
        return this._htmlIndex
    }
    IsHTMLElementsLayer() {
        return this._isHTMLElementsLayer
    }
    SetIsHTMLElementsLayer(a) {
        a = !!a;
        this._isHTMLElementsLayer !== a && (this._isHTMLElementsLayer = a,
        this._layout._ReindexAndUpdateAllLayers(),
        this._runtime.UpdateRender())
    }
    _GetSiblingIndex() {
        const a = this.GetParentLayer();
        return a ? a.GetSubLayers().indexOf(this) : this.GetLayout()._GetRootLayers().indexOf(this)
    }
    GetSID() {
        return this._sid
    }
    GetRuntime() {
        return this._runtime
    }
    IsDynamic() {
        return this._isDynamic
    }
    HasAnyDynamicParentLayer() {
        for (const a of this.parentLayers())
            if (a.IsDynamic())
                return !0;
        return !1
    }
    GetDevicePixelRatio() {
        return this._runtime.GetDevicePixelRatio()
    }
    GetEffectList() {
        return this._effectList
    }
    GetEffectChain() {
        this._MaybeRebuildEffectChainSteps();
        return this._effectChain
    }
    _MaybeRebuildEffectChainSteps() {
        const a = this.HasDefaultColor();
        if (this._needsRebuildEffectChainSteps || a !== this._wasDefaultColor || this._effectChain.NeedsRebuild()) {
            var b = this.GetEffectList().GetActiveEffectTypes();
            this._effectChain.BuildSteps(b.map(c => c.GetShaderProgram()), {
                indexMap: b.map(c => c.GetIndex()),
                forcePreDraw: !a,
                useFullSurface: !0
            });
            this._needsRebuildEffectChainSteps = !1;
            this._wasDefaultColor = a
        }
    }
    UpdateActiveEffects() {
        this.GetEffectList().UpdateActiveEffects();
        this._needsRebuildEffectChainSteps = !0
    }
    UsesRenderCells() {
        return this._useRenderCells && !this._useCameraDistanceDrawOrder
    }
    GetRenderGrid() {
        return this._renderGrid
    }
    SetRenderListStale() {
        this._isRenderListUpToDate = !1
    }
    IsVisible() {
        for (const a of this.selfAndParentLayers())
            if (!a._IsVisibleFlagSet())
                return !1;
        return !0
    }
    _IsVisibleFlagSet() {
        return this._isVisible
    }
    SetVisible(a) {
        a = !!a;
        this._isVisible !== a && (this._isVisible = a,
        this._runtime.UpdateRender())
    }
    SetInteractive(a) {
        this._isInteractive = !!a
    }
    IsInteractive() {
        return this._isInteractive
    }
    IsSelfAndParentsInteractive() {
        for (const a of this.selfAndParentLayers())
            if (!a.IsInteractive())
                return !1;
        return !0
    }
    SetOwnScrollPositionEnabled(a) {
        a = !!a;
        if (this._hasOwnScrollPosition !== a) {
            if (this._hasOwnScrollPosition = a)
                a = this.GetLayout(),
                this._scrollX = a.GetScrollX(),
                this._scrollY = a.GetScrollY();
            this._SetMVMatrixChanged();
            this._runtime.UpdateRender()
        }
    }
    IsOwnScrollPositionEnabled() {
        return this._hasOwnScrollPosition
    }
    SetScrollX(a) {
        var b = this.GetLayout();
        const c = b.GetScrollLeftBound();
        b = b.GetScrollRightBound();
        a > b && (a = b);
        a < c && (a = c);
        this._scrollX !== a && (this._scrollX = a,
        this.IsOwnScrollPositionEnabled() && (this._SetMVMatrixChanged(),
        this._runtime.UpdateRender()))
    }
    SetScrollY(a) {
        var b = this.GetLayout();
        const c = b.GetScrollTopBound();
        b = b.GetScrollBottomBound();
        a > b && (a = b);
        a < c && (a = c);
        this._scrollY !== a && (this._scrollY = a,
        this.IsOwnScrollPositionEnabled() && (this._SetMVMatrixChanged(),
        this._runtime.UpdateRender()))
    }
    GetScrollX() {
        return this.IsOwnScrollPositionEnabled() ? this._scrollX : this.GetLayout().GetScrollX()
    }
    GetScrollY() {
        return this.IsOwnScrollPositionEnabled() ? this._scrollY : this.GetLayout().GetScrollY()
    }
    GetViewport() {
        this._MaybeUpdateViewport();
        return this._viewport
    }
    _GetViewportZ0() {
        this._MaybeUpdateViewport();
        return this._viewportZ0
    }
    GetViewport3D() {
        this._MaybeUpdateViewport();
        return this._viewport3D
    }
    _GetVanishingPoint() {
        const a = this.GetLayout();
        return [a.GetVanishingPointX(), a.GetVanishingPointY()]
    }
    GetDefaultCameraZ(a) {
        return this._runtime.GetDefaultCameraZ(a)
    }
    GetViewportForZ(a, b) {
        var c = this._GetViewportZ0();
        if (0 === a)
            b.copy(c);
        else {
            let h = c.midX()
              , l = c.midY();
            var d = this.Get2DScaleFactorToZ(a);
            const m = c.width() / d;
            c = c.height() / d;
            const [p,r] = this._GetVanishingPoint();
            if (.5 !== p || .5 !== r) {
                const v = this.GetCameraZ();
                var e = this._runtime
                  , f = this.GetDefaultCameraZ() / v;
                d = (p - .5) * e.GetViewportWidth() / f;
                e = (r - .5) * e.GetViewportHeight() / f;
                f = this.GetAngle();
                0 !== f && (tempVec2.set(d, e),
                tempVec2.rotate(f),
                d = tempVec2.getX(),
                e = tempVec2.getY());
                a = C3$jscomp$103.unlerp(v, 0, a);
                h += C3$jscomp$103.lerp(d, 0, a);
                l += C3$jscomp$103.lerp(e, 0, a)
            }
            b.set(h - m / 2, l - c / 2, h + m / 2, l + c / 2)
        }
    }
    GetOpacity() {
        return this._color.getA()
    }
    SetOpacity(a) {
        a = C3$jscomp$103.clamp(a, 0, 1);
        this._color.getA() !== a && (this._color.setA(a),
        this._UpdatePremultipliedColor(),
        this._runtime.UpdateRender())
    }
    _UpdatePremultipliedColor() {
        this._premultipliedColor.copy(this._color);
        this._premultipliedColor.premultiply()
    }
    GetPremultipliedColor() {
        return this._premultipliedColor
    }
    HasDefaultColor() {
        return this._color.equalsRgba(1, 1, 1, 1)
    }
    GetScaleRate() {
        return this._scaleRate
    }
    SetScaleRate(a) {
        this._scaleRate !== a && (this._scaleRate = a,
        this._SetMVMatrixChanged(),
        this._runtime.UpdateRender())
    }
    GetParallaxX() {
        return this._parallaxX
    }
    GetParallaxY() {
        return this._parallaxY
    }
    SetParallax(a, b) {
        if (this._parallaxX !== a || this._parallaxY !== b)
            if (this._parallaxX = a,
            this._parallaxY = b,
            this._SetMVMatrixChanged(),
            this._runtime.UpdateRender(),
            1 !== this._parallaxX || 1 !== this._parallaxY)
                for (const c of this._instances)
                    c.GetObjectClass()._SetAnyInstanceParallaxed(!0)
    }
    SetParallaxX(a) {
        this.SetParallax(a, this.GetParallaxY())
    }
    SetParallaxY(a) {
        this.SetParallax(this.GetParallaxX(), a)
    }
    SetZElevation(a) {
        this._zElevation !== a && (this._zElevation = a,
        this._runtime.UpdateRender())
    }
    GetZElevation() {
        return this._zElevation
    }
    SetAngle(a) {
        a = C3$jscomp$103.clampAngle(a);
        this._angle !== a && (this._angle = a,
        this._SetMVMatrixChanged(),
        this._runtime.UpdateRender())
    }
    GetAngle() {
        return C3$jscomp$103.clampAngle(this._layout.GetAngle() + this._angle)
    }
    GetOwnAngle() {
        return this._angle
    }
    HasInstances() {
        return 0 < this._instances.length
    }
    _GetInstances() {
        return this._instances
    }
    _GetInstancesInDrawOrder() {
        return this.RendersIn3DMode() && this._useCameraDistanceDrawOrder ? (C3$jscomp$103.shallowAssignArray(tempInstancesByCameraDist, this._GetInstances()),
        tempInstancesByCameraDist.sort( (a, b) => this._SortInstancesByCameraDistance(a, b)),
        tempInstancesByCameraDist) : this._GetInstances()
    }
    _AppendAllInstancesIncludingSubLayersInDrawOrder(a) {
        C3$jscomp$103.appendArray(a, this._GetInstancesInDrawOrder());
        for (const b of this._subLayers)
            b.IsVisible() && 0 < b.GetOpacity() && b._AppendAllInstancesIncludingSubLayersInDrawOrder(a)
    }
    _SortInstancesByCameraDistance(a, b) {
        var c = this.GetLayout().Get3DCameraPosition()
          , d = c[0]
          , e = c[1];
        c = c[2];
        var f = a.GetWorldInfo();
        const h = b.GetWorldInfo();
        b = f.GetX() - d;
        a = f.GetY() - e;
        f = f.GetZElevation() - c;
        d = h.GetX() - d;
        e = h.GetY() - e;
        c = h.GetZElevation() - c;
        return d * d + e * e + c * c - (b * b + a * a + f * f)
    }
    GetBackgroundColor() {
        return this._backgroundColor
    }
    IsTransparent() {
        return this._isTransparent
    }
    SetTransparent(a) {
        a = !!a;
        this._isTransparent !== a && (this._isTransparent = a,
        this._runtime.UpdateRender())
    }
    IsForceOwnTexture() {
        return this._isForceOwnTexture
    }
    SetForceOwnTexture(a) {
        a = !!a;
        this._isForceOwnTexture !== a && (this._isForceOwnTexture = a,
        this._runtime.UpdateRender())
    }
    RendersIn2DMode() {
        return !this.GetRuntime().Uses3DFeatures() || !this._renderAs3d
    }
    RendersIn3DMode() {
        return !this.RendersIn2DMode()
    }
    Has3DCamera() {
        return this.RendersIn3DMode() && this.GetLayout().Is3DCameraEnabled()
    }
    SelfAndAllSubLayersHave3DCamera() {
        if (!this.Has3DCamera())
            return !1;
        for (const a of this._subLayers)
            if (!a.SelfAndAllSubLayersHave3DCamera())
                return !1;
        return !0
    }
    SetBlendMode(a) {
        this._blendMode !== a && (this._blendMode = a,
        this._runtime.UpdateRender())
    }
    GetBlendMode() {
        return this._blendMode
    }
    IsRootLayer() {
        return !this._parentLayer
    }
    GetParentLayer() {
        return this._parentLayer
    }
    _SetParentLayer(a) {
        this._parentLayer = a
    }
    GetSubLayers() {
        return this._subLayers
    }
    HasAnySubLayers() {
        return 0 < this._subLayers.length
    }
    _AddSubLayer(a, b=!0) {
        b ? this._subLayers.push(a) : this._subLayers.unshift(a)
    }
    _InsertSubLayer(a, b, c) {
        b = this._subLayers.indexOf(b);
        if (-1 === b)
            throw Error("cannot find layer to insert by");
        c && ++b;
        this._subLayers.splice(b, 0, a)
    }
    _RemoveSubLayer(a) {
        a = this._subLayers.indexOf(a);
        if (-1 === a)
            throw Error("cannot find layer to remove");
        this._subLayers.splice(a, 1)
    }
    HasAnyVisibleSubLayer() {
        for (const a of this._subLayers)
            if (a.ShouldDraw())
                return !0;
        return !1
    }
    *selfAndAllSubLayers() {
        for (const a of this._subLayers)
            yield*a.selfAndAllSubLayers();
        yield this
    }
    *parentLayers() {
        let a = this.GetParentLayer();
        for (; a; )
            yield a,
            a = a.GetParentLayer()
    }
    *selfAndParentLayers() {
        yield this;
        yield*this.parentLayers()
    }
    HasParentLayer(a) {
        for (const b of this.parentLayers())
            if (b === a)
                return !0;
        return !1
    }
    IsTransformCompatibleWith(a) {
        return this === a || this._parallaxX === a._parallaxX && this._parallaxY === a._parallaxY && this._scale === a._scale && this._scaleRate === a._scaleRate && this._angle === a._angle && this.GetScrollX() === a.GetScrollX() && this.GetScrollY() === a.GetScrollY()
    }
    SaveTransform() {
        return {
            parallaxX: this.GetParallaxX(),
            parallaxY: this.GetParallaxY(),
            scale: this.GetOwnScale(),
            scaleRate: this.GetScaleRate(),
            angle: this.GetOwnAngle(),
            hasOwnScroll: this.IsOwnScrollPositionEnabled(),
            scrollX: this.GetScrollX(),
            scrollY: this.GetScrollY()
        }
    }
    RestoreTransform(a) {
        this.SetParallax(a.parallaxX, a.parallaxY);
        this.SetOwnScale(a.scale);
        this.SetScaleRate(a.scaleRate);
        this.SetAngle(a.angle);
        this.SetOwnScrollPositionEnabled(a.hasOwnScroll);
        this.SetScrollX(a.scrollX);
        this.SetScrollY(a.scrollY);
        this._MaybeUpdateViewport()
    }
    _RemoveAllInstancesInSet(a) {
        0 !== a.size && 0 < C3$jscomp$103.arrayRemoveAllInSet(this._instances, a) && (this._MaybeResetAnyInstanceZElevatedFlag(),
        this.SetZIndicesChanged())
    }
    SetZIndicesChanged(a) {
        this._isRenderListUpToDate = this._zIndicesUpToDate = !1;
        if (!a || a.GetObjectClass().GetPlugin().IsHTMLElementType())
            this._htmlZIndicesUpToDate = !1
    }
    _UpdateZIndices() {
        if (!this._zIndicesUpToDate) {
            this._instances.sort(SortByInstZElevation);
            if (this.UsesRenderCells())
                for (let a = 0, b = this._instances.length; a < b; ++a) {
                    const c = this._instances[a].GetWorldInfo();
                    c._SetZIndex(a);
                    this._renderGrid.MarkRangeChanged(c.GetRenderCellRange())
                }
            else
                for (let a = 0, b = this._instances.length; a < b; ++a)
                    this._instances[a].GetWorldInfo()._SetZIndex(a);
            this._zIndicesUpToDate = !0
        }
    }
    _UpdateHTMLZIndices() {
        if (!this._htmlZIndicesUpToDate) {
            var a = this._layout.GetRootLayersForHTMLLayer(this.GetHTMLIndex()).map(c => [...c.selfAndAllSubLayers()]).flat()
              , b = 0;
            for (const c of a) {
                for (const d of c._GetInstances())
                    d.GetObjectClass().GetPlugin().IsHTMLElementType() && d.GetWorldInfo()._SetHTMLZIndex(b++);
                c._SetHTMLZIndicesUpToDate()
            }
        }
    }
    _SetHTMLZIndicesUpToDate() {
        this._htmlZIndicesUpToDate = !0
    }
    MoveInstanceAdjacent(a, b, c) {
        var d = a.GetWorldInfo();
        b = b.GetWorldInfo();
        if (d.GetLayer() !== this || b.GetLayer() !== this)
            throw Error("can't arrange Z order unless both objects on this layer");
        d = d.GetZIndex();
        b = b.GetZIndex();
        if (d === b + (c ? 1 : -1))
            return !1;
        C3$jscomp$103.arrayRemove(this._instances, d);
        d < b && b--;
        c && b++;
        b === this._instances.length ? this._instances.push(a) : this._instances.splice(b, 0, a);
        this.SetZIndicesChanged(a);
        return !0
    }
    _MergeSortedZArrays(a, b) {
        const c = [];
        let d = 0
          , e = 0
          , f = a.length
          , h = b.length;
        for (; d < f && e < h; ) {
            const l = a[d]
              , m = b[e];
            l.GetWorldInfo()._GetLastCachedZIndex() < m.GetWorldInfo()._GetLastCachedZIndex() ? (c.push(l),
            ++d) : (c.push(m),
            ++e)
        }
        for (; d < f; ++d)
            c.push(a[d]);
        for (; e < h; ++e)
            c.push(b[e]);
        return c
    }
    _MergeAllSortedZArrays_pass(a) {
        const b = []
          , c = a.length;
        for (let d = 0; d < c - 1; d += 2)
            b.push(this._MergeSortedZArrays(a[d], a[d + 1]));
        1 === c % 2 && b.push(a[c - 1]);
        return b
    }
    _MergeAllSortedZArrays(a) {
        for (; 1 < a.length; )
            a = this._MergeAllSortedZArrays_pass(a);
        return a[0]
    }
    _GetRenderCellInstancesToDraw() {
        this._UpdateZIndices();
        C3$jscomp$103.clearArray(renderCellArr);
        this._renderGrid.QueryRange(this.GetViewport(), renderCellArr);
        return renderCellArr.length ? 1 === renderCellArr.length ? renderCellArr[0] : this._MergeAllSortedZArrays(renderCellArr) : []
    }
    ShouldDraw() {
        return this.IsVisible() && 0 < this.GetOpacity() && this._DrawsAnyContentInSelfOrSubLayers()
    }
    _DrawsAnyContentInSelfOrSubLayers() {
        if (this.HasInstances() || !this.IsTransparent())
            return !0;
        for (const a of this._subLayers)
            if (a._DrawsAnyContentInSelfOrSubLayers())
                return !0;
        return !1
    }
    UsesOwnTexture() {
        return this.IsForceOwnTexture() || !this.HasDefaultColor() || 0 !== this.GetBlendMode() || this._effectList.HasAnyActiveEffect()
    }
    SelfOrAnySubLayerUsesOwnTexture() {
        if (this.UsesOwnTexture())
            return !0;
        for (const a of this._subLayers)
            if (a.SelfOrAnySubLayerUsesOwnTexture())
                return !0;
        return !1
    }
    GetRenderTarget() {
        return this._curRenderTarget
    }
    Get2DScaleFactorToZ(a) {
        if (this._layout.IsOrthographicProjection())
            return 1;
        const b = this.GetCameraZ();
        return b / (b - a)
    }
    GetCameraZ(a) {
        return this.GetDefaultCameraZ(a) / this.GetNormalScale()
    }
    _SetMVMatrixChanged() {
        this._isViewportChanged = this._isViewFrustumChanged = this._isMVMatrixChanged = !0
    }
    _GetModelViewMatrix(a) {
        this._isMVMatrixChanged && (this._CalculateModelViewMatrix(a, this._modelViewMatrix, 0, 0, null),
        this._isMVMatrixChanged = !1);
        return this._modelViewMatrix
    }
    GetCameraPosition() {
        if (this.Has3DCamera()) {
            const a = this.GetLayout().Get3DCameraPosition();
            return [a[0], a[1], a[2]]
        }
        return this._Get2DCameraPosition()
    }
    _Get2DCameraPosition(a=0, b=0, c=0) {
        var d = this._runtime
          , e = this.GetLayout()
          , f = d.GetParallaxXOrigin()
          , h = d.GetParallaxYOrigin();
        f = (this.GetScrollX() - f) * this._parallaxX + f;
        h = (this.GetScrollY() - h) * this._parallaxY + h;
        d.IsPixelRoundingEnabled() && (f = Math.round(f),
        h = Math.round(h));
        a = f + a;
        b = h + b;
        e = e.IsOrthographicProjection() ? this.GetDefaultCameraZ(c) : this.GetCameraZ(c);
        const [l,m] = this._GetVanishingPoint();
        if (.5 !== l || .5 !== m)
            h = this.GetDefaultCameraZ(c) / e,
            c = (l - .5) * d.GetViewportWidth() / h,
            d = (m - .5) * d.GetViewportHeight() / h,
            h = this.GetAngle(),
            0 !== h && (tempVec2.set(c, d),
            tempVec2.rotate(h),
            c = tempVec2.getX(),
            d = tempVec2.getY()),
            a += c,
            b += d;
        return [a, b, e]
    }
    _CalculateModelViewMatrix(a, b, c, d, e) {
        const f = this._runtime;
        var h = this.GetLayout();
        if (this.Has3DCamera()) {
            vec3$jscomp$6.copy(camVector, h.Get3DCameraPosition());
            vec3$jscomp$6.copy(lookVector, h.Get3DCameraLookAt());
            vec3$jscomp$6.copy(upVector, h.Get3DCameraUpVector());
            c = f.GetParallaxXOrigin();
            d = f.GetParallaxYOrigin();
            h = lookVector[0] - camVector[0];
            const l = lookVector[1] - camVector[1]
              , m = lookVector[2] - camVector[2];
            camVector[0] = (camVector[0] - c) * this._parallaxX + c;
            camVector[1] = (camVector[1] - d) * this._parallaxY + d;
            camVector[2] *= Math.max(this._parallaxX, this._parallaxY);
            lookVector[0] = camVector[0] + h;
            lookVector[1] = camVector[1] + l;
            lookVector[2] = camVector[2] + m
        } else {
            const [l,m,p] = this._Get2DCameraPosition(c, d, e);
            vec3$jscomp$6.set(camVector, l, m, p);
            vec3$jscomp$6.set(lookVector, l, m, p - 100);
            c = this.GetAngle();
            0 === c ? vec3$jscomp$6.set(upVector, 0, 1, 0) : vec3$jscomp$6.set(upVector, Math.sin(c), Math.cos(c), 0)
        }
        a.CalculateLookAtModelView(b, camVector, lookVector, upVector, e || f.GetViewportHeight())
    }
    _SetProjectionMatrixChanged() {
        this._isViewportChanged = this._isViewFrustumChanged = this._isProjectionMatrixChanged = !0
    }
    _GetProjectionMatrix(a) {
        this._isProjectionMatrixChanged && (this._CalculateProjectionMatrix(a),
        this._isProjectionMatrixChanged = !1);
        return this._projectionMatrix
    }
    _CalculateProjectionMatrix(a) {
        var b = this._runtime.GetCanvasManager();
        const [c,d] = this._GetVanishingPoint();
        if (this._layout.IsOrthographicProjection())
            a.CalculateOrthographicMatrix(this._projectionMatrix, b.GetDrawWidth(), b.GetDrawHeight());
        else if (.5 === c && .5 === d)
            mat4$jscomp$9.copy(this._projectionMatrix, b.GetDefaultProjectionMatrix());
        else {
            const e = b.GetDrawWidth();
            b = b.GetDrawHeight();
            a.CalculatePerspectiveMatrix(this._projectionMatrix, e / b, c, d)
        }
    }
    _SetTransform(a, b=!0, c=0, d=0, e=0) {
        b && a.SetProjectionMatrix(this._GetProjectionMatrix(a));
        0 === c && 0 === d && 0 === e ? b = this._GetModelViewMatrix(a) : (this._CalculateModelViewMatrix(a, tempMat4$jscomp$4, c, d, e),
        b = tempMat4$jscomp$4);
        a.SetModelViewMatrix(b)
    }
    PrepareForDraw(a) {
        this._SetTransform(a);
        a.SetBaseZ(this.GetZElevation())
    }
    _MaybeStartWebGLProfiling(a) {
        let b = null;
        if (a.IsWebGL() && this._runtime.IsGPUProfiling()) {
            const c = this._runtime.GetCanvasManager().GetLayerTimingsBuffer(this);
            c && (b = c.AddTimeElapsedQuery(),
            a.StartQuery(b))
        }
        return b
    }
    _MaybeStartWebGPUProfiling(a) {
        if (a.IsWebGPU() && this._runtime.IsGPUProfiling()) {
            const b = 2 * (this.GetIndex() + 1);
            a.StartMeasuringRenderPassTime(b, b + 1)
        }
    }
    Draw(a, b, c) {
        var d = this._runtime.GetCanvasManager();
        const e = this.UsesOwnTexture();
        var f = null;
        const h = this._MaybeStartWebGLProfiling(a);
        this._MaybeStartWebGPUProfiling(a);
        e ? (f = {
            sampling: this._runtime.GetSampling(),
            isSampled: !0,
            canReadPixels: a.IsWebGPU() ? this._runtime.UsesAnyBackgroundBlending() : !1
        },
        "low" === d.GetCurrentFullscreenScalingQuality() && (f.width = d.GetDrawWidth(),
        f.height = d.GetDrawHeight()),
        this._curRenderTarget = f = this._runtime.GetAdditionalRenderTarget(f),
        a.SetRenderTarget(f),
        this.IsTransparent() && a.ClearRgba(0, 0, 0, 0)) : (this._curRenderTarget = b,
        a.SetRenderTarget(b));
        this.IsTransparent() || a.Clear(this._backgroundColor);
        this._layout._DrawLayerList(a, this._curRenderTarget, this._subLayers, e && this.IsTransparent());
        this._MaybeStartWebGPUProfiling(a);
        this._SetTransform(a);
        a.SetBaseZ(this.GetZElevation());
        a.SetDepthEnabled(this.RendersIn3DMode());
        this.GetNormalScale() > Number.EPSILON && (this._UpdateZIndices(),
        d = this.UsesRenderCells() && 0 === this.GetZElevation() && !this._anyInstanceZElevated,
        this.Has3DCamera() ? this._DrawInstances_3DCamera(a) : d ? this._DrawInstances_RenderCells(a) : this._DrawInstances(a, this._GetInstancesInDrawOrder()));
        a.SetBaseZ(0);
        a.SetCurrentZ(0);
        e && (a.SetDepthEnabled(!1),
        this._DrawLayerOwnTextureToRenderTarget(a, f, b, c));
        h && a.EndQuery(h);
        this._curRenderTarget = null
    }
    _DrawInstances(a, b) {
        const c = this.GetViewport()
          , d = this._curRenderTarget
          , e = this.GetLayout().IsOrthographicProjection()
          , f = this.GetLayout().HasVanishingPointOutsideViewport();
        let h = null;
        for (let l = 0, m = b.length; l < m; ++l) {
            const p = b[l];
            if (p === h)
                continue;
            h = p;
            const r = p.GetWorldInfo();
            r.IsVisible() && r.IsInViewport(c, f, e) && this._DrawInstanceMaybeWithEffects(p, r, a, d)
        }
    }
    _DrawInstances_3DCamera(a) {
        const b = this._curRenderTarget
          , c = this._GetViewFrustum()
          , d = this._GetInstancesInDrawOrder();
        for (let l = 0, m = d.length; l < m; ) {
            var e = d[l]
              , f = e.GetWorldInfo();
            if (!f.IsVisible() || !f.IsInViewport3D(c)) {
                ++l;
                continue
            }
            (!e.RendersToOwnZPlane() || 0 < f.GetDepth()) && tempInstanceList2.push(e);
            var h = e.GetWorldInfo().GetTotalZElevation();
            tempInstanceList1.push(e);
            let p = l + 1;
            for (; p < m; ++p) {
                const r = d[p]
                  , v = r.GetWorldInfo();
                if (v.IsVisible() && v.IsInViewport3D(c)) {
                    if (v.GetTotalZElevation() !== h)
                        break;
                    r.RendersToOwnZPlane() ? (0 < v.GetDepth() && tempInstanceList2.push(r),
                    tempInstanceList1.push(r)) : tempInstanceList2.push(r)
                }
            }
            if (1 !== tempInstanceList1.length || tempInstanceList1[0].MustMitigateZFighting()) {
                this._DrawCoplanarInstances_3DCamera(a, tempInstanceList1);
                for (let r = 0, v = tempInstanceList2.length; r < v; ++r)
                    e = tempInstanceList2[r],
                    f = e.GetWorldInfo(),
                    f._SetDrawNonBackFacesOnly(!0),
                    this._DrawInstanceMaybeWithEffects(e, f, a, b),
                    f._SetDrawNonBackFacesOnly(!1)
            } else {
                this._DrawInstanceMaybeWithEffects(e, f, a, b);
                for (let r = 0, v = tempInstanceList2.length; r < v; ++r)
                    f = tempInstanceList2[r],
                    f !== e && (h = f.GetWorldInfo(),
                    h.GetLayer()._DrawInstanceMaybeWithEffects(f, h, a, b))
            }
            l = p;
            C3$jscomp$103.clearArray(tempInstanceList1);
            C3$jscomp$103.clearArray(tempInstanceList2)
        }
    }
    _DrawCoplanarInstances_3DCamera(a, b) {
        const c = this._curRenderTarget;
        a.CoplanarStartStencilPass();
        for (let f = 0, h = b.length; f < h; ++f) {
            var d = b[f]
              , e = d.GetWorldInfo();
            e._SetDrawBackFaceOnly(!0);
            this._DrawInstance(d, e, a)
        }
        a.CoplanarStartColorPass();
        for (let f = 0, h = b.length; f < h; ++f)
            d = b[f],
            e = d.GetWorldInfo(),
            this._DrawInstanceMaybeWithEffects(d, e, a, c),
            e._SetDrawBackFaceOnly(!1);
        a.CoplanarRestoreStandardRendering()
    }
    _DrawInstances_RenderCells(a) {
        var b = this._renderGrid;
        const c = this._curRenderCells
          , d = this._lastRenderCells
          , e = this.GetViewport();
        c.set(b.XToCell(e.getLeft()), b.YToCell(e.getTop()), b.XToCell(e.getRight()), b.YToCell(e.getBottom()));
        this._isRenderListUpToDate && c.equals(d) ? b = this._lastRenderList : (b = this._GetRenderCellInstancesToDraw(),
        this._isRenderListUpToDate = !0,
        d.copy(c));
        this._DrawInstances(a, b);
        b !== this._lastRenderList && C3$jscomp$103.shallowAssignArray(this._lastRenderList, b)
    }
    _DrawInstanceMaybeWithEffects(a, b, c, d) {
        b.HasAnyActiveEffect() ? this._DrawInstanceWithEffectsAndRestore(a, b, c, d) : this._DrawInstance(a, b, c)
    }
    _DrawInstance(a, b, c) {
        b = b.GetRendererStateGroup();
        c.GetCurrentStateGroup() !== b && b.Apply();
        a.Draw(c)
    }
    _DrawInstanceWithEffectsAndRestore(a, b, c, d) {
        this._DrawInstanceWithEffects(a, b, c, d, null) && this._SetTransform(c)
    }
    _DrawInstanceWithEffects(a, b, c, d, e) {
        const f = b.GetInstanceEffectList().GetEffectChain();
        f.Render(c, d, {
            contentObject: a,
            blendMode: b.GetBlendMode(),
            devicePixelRatio: this._runtime.GetEffectDevicePixelRatioParam(),
            time: a.GetInstanceGameTime(),
            layerScale: this._runtime.GetEffectLayerScaleParam() * this.GetNormalScale(),
            layerAngle: this.GetAngle(),
            layoutRect: b.GetBoundingBox(),
            drawSurfaceRect: f.CanSkipCalculatingDrawSurfaceRect() ? null : this._InstanceBoxToDrawSurface(b),
            drawContentHook: e && e.drawContentHook,
            compositOffX: e && e.compositOffX,
            compositOffY: e && e.compositOffY,
            updateOwnProjection: e && e.updateOwnProjection
        });
        c.SetBaseZ(this.GetZElevation());
        return f.DidChangeTransform()
    }
    _DrawLayerOwnTextureToRenderTarget(a, b, c, d) {
        const e = this._effectList.GetActiveEffectTypes()
          , f = this._runtime;
        0 === e.length ? (a.SetRenderTarget(c),
        a.SetTextureFillMode(),
        d && 0 === this._blendMode && this.HasDefaultColor() ? a.CopyRenderTarget(b) : (a.SetBlendMode(this._blendMode),
        a.SetColor(this._premultipliedColor),
        a.DrawRenderTarget(b)),
        a.InvalidateRenderTarget(b),
        f.ReleaseAdditionalRenderTarget(b)) : this.GetEffectChain().Render(a, c, {
            contentObject: this,
            blendMode: this.GetBlendMode(),
            devicePixelRatio: f.GetEffectDevicePixelRatioParam(),
            layerScale: f.GetEffectLayerScaleParam() * this.GetNormalScale(),
            layerAngle: this.GetAngle(),
            layoutRect: this.GetViewport(),
            drawSurfaceRect: null,
            invalidateRenderTargets: !0
        })
    }
    GetOwnScale() {
        return this._scale
    }
    SetOwnScale(a) {
        this._scale !== a && (this._scale = a,
        this._layout.BoundScrolling(),
        this._SetMVMatrixChanged(),
        this._runtime.UpdateRender())
    }
    GetRenderScale() {
        return this.GetNormalScale() * this._runtime.GetRenderScale()
    }
    GetDisplayScale() {
        return this.GetNormalScale() * this._runtime.GetDisplayScale()
    }
    GetNormalScale() {
        return (this._scale * this._layout.GetScale() - 1) * this._scaleRate + 1
    }
    _MaybeUpdateViewport() {
        if (this._isViewportChanged) {
            this._isViewportChanged = !1;
            var a = this._runtime.GetParallaxXOrigin()
              , b = this._runtime.GetParallaxYOrigin()
              , c = (this.GetScrollX() - a) * this._parallaxX + a
              , d = (this.GetScrollY() - b) * this._parallaxY + b;
            a = this.GetNormalScale();
            b = this._runtime.GetViewportWidth() / a;
            a = this._runtime.GetViewportHeight() / a;
            c -= b / 2;
            var e = d - a / 2;
            this._runtime.IsPixelRoundingEnabled() && (c = Math.round(c),
            e = Math.round(e));
            d = this._viewportZ0;
            d.set(c, e, c + b, e + a);
            b = this.GetAngle();
            0 !== b && (tmpRect$jscomp$2.copy(d),
            tmpRect$jscomp$2.offset(-d.midX(), -d.midY()),
            tmpQuad$jscomp$2.setFromRotatedRect(tmpRect$jscomp$2, b),
            tmpQuad$jscomp$2.getBoundingBox(tmpRect$jscomp$2),
            tmpRect$jscomp$2.offset(d.midX(), d.midY()),
            d.copy(tmpRect$jscomp$2));
            b = this._zElevation;
            this.GetViewportForZ(b, this._viewport);
            this.Has3DCamera() ? this.CalculateViewport3D(b, this._viewport3D) : this._viewport3D.copy(this._viewport)
        }
    }
    CalculateViewport3D(a, b) {
        var c = this._runtime.GetCanvasManager()
          , d = c.GetCssWidth();
        c = c.GetCssHeight();
        const [e,f] = this.CanvasCssToLayer(0, 0, a)
          , [h,l] = this.CanvasCssToLayer(d, 0, a)
          , [m,p] = this.CanvasCssToLayer(d, c, a)
          , [r,v] = this.CanvasCssToLayer(0, c, a);
        a = Math.min(e, h, m, r);
        d = Math.min(f, l, p, v);
        c = Math.max(e, h, m, r);
        let x = Math.max(f, l, p, v);
        isFinite(a) || (a = -Infinity);
        isFinite(d) || (d = -Infinity);
        isFinite(c) || (c = Infinity);
        isFinite(x) || (x = Infinity);
        b.set(a, d, c, x)
    }
    CanvasCssToLayer(a, b, c=0) {
        return this._CanvasToLayer(a, b, c, this.GetDisplayScale())
    }
    DrawSurfaceToLayer(a, b, c=0) {
        return this._CanvasToLayer(a, b, c, this.GetRenderScale() * this.GetDevicePixelRatio())
    }
    _CanvasToLayer(a, b, c, d) {
        var e = this._runtime
          , f = e.GetRenderer();
        const h = this.GetNormalScale()
          , l = e.GetViewportWidth() / h;
        e = e.GetViewportHeight() / h;
        vec4$jscomp$5.set(tempVec4$jscomp$1, 0, 0, l, e);
        a /= d;
        b = tempVec4$jscomp$1[3] - b / d;
        d = this._GetProjectionMatrix(f);
        f = this._GetModelViewMatrix(f);
        return C3$jscomp$103.Gfx.UnprojectScreenToWorldZ(a, b, c, f, d, tempVec4$jscomp$1, tempVec3) ? [tempVec3[0], tempVec3[1]] : [NaN, NaN]
    }
    CanvasCssToLayer_DefaultTransform(a, b) {
        const c = this._scale
          , d = this._scaleRate
          , e = this._parallaxX
          , f = this._parallaxY
          , h = this._angle;
        this._parallaxY = this._parallaxX = this._scaleRate = this._scale = 1;
        this._angle = 0;
        this._SetMVMatrixChanged();
        a = this.CanvasCssToLayer(a, b);
        this._scale = c;
        this._scaleRate = d;
        this._parallaxX = e;
        this._parallaxY = f;
        this._angle = h;
        this._SetMVMatrixChanged();
        return a
    }
    LayerToCanvasCss(a, b, c=0) {
        return this._LayerToCanvas(a, b, c, this.GetDisplayScale())
    }
    LayerToDrawSurface(a, b, c=0) {
        return this._LayerToCanvas(a, b, c, this.GetRenderScale() * this.GetDevicePixelRatio())
    }
    _LayerToCanvas(a, b, c, d) {
        var e = this._runtime
          , f = e.GetRenderer();
        const h = this.GetNormalScale();
        var l = e.GetViewportWidth() / h;
        e = e.GetViewportHeight() / h;
        vec4$jscomp$5.set(tempVec4$jscomp$1, 0, 0, l, e);
        l = this._GetProjectionMatrix(f);
        f = this._GetModelViewMatrix(f);
        return C3$jscomp$103.Gfx.Project(a, b, c, f, l, tempVec4$jscomp$1, tempVec3) ? [tempVec3[0] * d, (tempVec4$jscomp$1[3] - tempVec3[1]) * d] : [NaN, NaN]
    }
    _GetLayerToDrawSurfaceScale(a, b) {
        a *= this.GetRenderScale() * this.GetDevicePixelRatio();
        0 !== b && (a *= this.Get2DScaleFactorToZ(b));
        return a
    }
    _InstanceBoxToDrawSurface(a) {
        var b = a.GetBoundingBox()
          , c = a.GetTotalZElevation();
        a = a.GetDepth();
        const d = c + a
          , e = b.getLeft()
          , f = b.getTop()
          , h = b.getRight();
        b = b.getBottom();
        if (this.Has3DCamera()) {
            if (this._IsPointBehindNearPlane(e, f, c) || this._IsPointBehindNearPlane(h, f, c) || this._IsPointBehindNearPlane(h, b, c) || this._IsPointBehindNearPlane(e, b, c) || 0 < a && (this._IsPointBehindNearPlane(e, f, d) || this._IsPointBehindNearPlane(h, f, d) || this._IsPointBehindNearPlane(h, b, d) || this._IsPointBehindNearPlane(e, b, d)))
                return null
        } else if (d >= this.GetCameraZ())
            return null;
        let[l,m] = this.LayerToDrawSurface(e, f, c)
          , [p,r] = this.LayerToDrawSurface(h, b, c);
        if (0 !== this.GetAngle() || 0 < a || this.Has3DCamera()) {
            const [v,x] = this.LayerToDrawSurface(h, f, c)
              , [B,A] = this.LayerToDrawSurface(e, b, c);
            if (0 < a) {
                const [D,F] = this.LayerToDrawSurface(e, f, d)
                  , [I,K] = this.LayerToDrawSurface(h, f, d)
                  , [M,Q] = this.LayerToDrawSurface(h, b, d)
                  , [W,ca] = this.LayerToDrawSurface(e, b, d);
                c = Math.min(l, p, v, B, D, I, M, W);
                p = Math.max(l, p, v, B, D, I, M, W);
                l = c;
                c = Math.min(m, r, x, A, F, K, Q, ca);
                r = Math.max(m, r, x, A, F, K, Q, ca);
                m = c
            } else
                c = Math.min(l, p, v, B),
                p = Math.max(l, p, v, B),
                l = c,
                c = Math.min(m, r, x, A),
                r = Math.max(m, r, x, A),
                m = c
        }
        tmpRect$jscomp$2.set(l, m, p, r);
        return tmpRect$jscomp$2
    }
    _GetViewFrustum() {
        this._isViewFrustumChanged && (this._UpdateViewFrustum(),
        this._isViewFrustumChanged = !1);
        return this._viewFrustum
    }
    _UpdateViewFrustum() {
        var a = this._runtime.GetRenderer();
        const b = this._GetProjectionMatrix(a);
        a = this._GetModelViewMatrix(a);
        this._viewFrustum.CalculatePlanes(a, b)
    }
    _IsPointBehindNearPlane(a, b, c) {
        return this._GetViewFrustum().IsBehindNearPlane(a, b, c)
    }
    _SaveToJson() {
        return {
            d: this.IsDynamic(),
            s: this.GetOwnScale(),
            a: this.GetOwnAngle(),
            v: this._IsVisibleFlagSet(),
            i: this.IsInteractive(),
            html: this.IsHTMLElementsLayer(),
            bc: this._backgroundColor.toJSON(),
            t: this.IsTransparent(),
            sx: this._scrollX,
            sy: this._scrollY,
            hosp: this._hasOwnScrollPosition,
            px: this.GetParallaxX(),
            py: this.GetParallaxY(),
            c: this._color.toJSON(),
            sr: this.GetScaleRate(),
            fx: this._effectList.SaveToJson(),
            cg: this._createdGlobalUids
        }
    }
    _LoadFromJson(a) {
        this._isDynamic = !!a.d;
        this._scale = a.s;
        this._angle = a.a;
        this._isVisible = !!a.v;
        this._isInteractive = a.hasOwnProperty("i") ? a.i : !0;
        this._isHTMLElementsLayer = !!a.html;
        this._backgroundColor.setFromJSON(a.bc);
        this._isTransparent = !!a.t;
        a.hasOwnProperty("sx") && (this._scrollX = a.sx);
        a.hasOwnProperty("sy") && (this._scrollY = a.sy);
        a.hasOwnProperty("hosp") && (this._hasOwnScrollPosition = !!a.hosp);
        this._parallaxX = a.px;
        this._parallaxY = a.py;
        this._color.setFromJSON(a.c);
        this._UpdatePremultipliedColor();
        this._scaleRate = a.sr;
        C3$jscomp$103.shallowAssignArray(this._createdGlobalUids, a.cg);
        C3$jscomp$103.shallowAssignArray(this._initialInstances, this._startupInitialInstances);
        const b = new Set(this._createdGlobalUids);
        let c = 0;
        for (let d = 0, e = this._initialInstances.length; d < e; ++d)
            b.has(this._initialInstances[d][2]) || (this._initialInstances[c] = this._initialInstances[d],
            ++c);
        C3$jscomp$103.truncateArray(this._initialInstances, c);
        this._effectList.LoadFromJson(a.fx);
        this._needsRebuildEffectChainSteps = !0
    }
    _LoadFromJsonAfterInstances() {
        this._SortInstancesByLastCachedZIndex(!1);
        this.SetZIndicesChanged();
        this._SetMVMatrixChanged();
        this._SetProjectionMatrixChanged()
    }
    GetILayer() {
        return this._iLayer
    }
    SortAndAddInstancesByZIndex(a, b=!1) {
        if (this._instances.includes(a))
            b && this._instances.sort( (e, f) => {
                e = e.GetWorldInfo().GetSceneGraphZIndex();
                f = f.GetWorldInfo().GetSceneGraphZIndex();
                return e - f
            }
            );
        else if (a.HasChildren()) {
            var c = [...a.allChildren()];
            c.push(a);
            c.sort( (e, f) => {
                e = e.GetWorldInfo().GetSceneGraphZIndex();
                f = f.GetWorldInfo().GetSceneGraphZIndex();
                return e - f
            }
            );
            for (var d of c)
                if (d.IsInContainer())
                    for (const e of d.siblings())
                        c.includes(e) || (a = [...e.allChildren()],
                        a.push(e),
                        a.sort( (f, h) => {
                            f = f.GetWorldInfo().GetSceneGraphZIndex();
                            h = h.GetWorldInfo().GetSceneGraphZIndex();
                            return f - h
                        }
                        ),
                        a && a.length && c.splice(c.length, 0, ...a));
            for (const e of c)
                e.GetPlugin().IsWorldType() && this._AddInstance(e, !0)
        } else if (a.GetPlugin().IsWorldType() && this._AddInstance(a, !0),
        a.IsInContainer())
            for (c of a.siblings())
                if (d = [...c.allChildren()],
                d.push(c),
                d.sort( (e, f) => {
                    e = e.GetWorldInfo().GetSceneGraphZIndex();
                    f = f.GetWorldInfo().GetSceneGraphZIndex();
                    return e - f
                }
                ),
                d && d.length)
                    for (const e of d)
                        e.GetPlugin().IsWorldType() && this._AddInstance(e, !0)
    }
}
;
"use strict";
const C3$jscomp$104 = self.C3
  , C3Debugger = self.C3Debugger;
C3$jscomp$104.New(C3$jscomp$104.Rect);
C3$jscomp$104.New(C3$jscomp$104.Rect);
const tempLayoutRect = C3$jscomp$104.New(C3$jscomp$104.Rect)
  , tempColor$jscomp$4 = C3$jscomp$104.New(C3$jscomp$104.Color)
  , vec3$jscomp$7 = self.glMatrix.vec3
  , tempRender3dList = []
  , tempInstanceList1$jscomp$1 = []
  , tempInstanceList2$jscomp$1 = []
  , tempInstanceList3 = [];
function vec3EqualsXYZ(a, b, c, d) {
    return a[0] === Math.fround(b) && a[1] === Math.fround(c) && a[2] === Math.fround(d)
}
let lastLayerPreparedForDrawing = null;
function MaybePrepareLayerDraw(a, b) {
    lastLayerPreparedForDrawing !== a && (a.PrepareForDraw(b),
    lastLayerPreparedForDrawing = a)
}
C3$jscomp$104.Layout = class extends C3$jscomp$104.DefendedBase {
    constructor(a, b, c) {
        super();
        this._layoutManager = a;
        this._runtime = a.GetRuntime();
        this._name = c[0];
        this._originalWidth = c[1];
        this._originalHeight = c[2];
        this._width = c[1];
        this._height = c[2];
        this._isUnboundedScrolling = !!c[3];
        this._isOrthographicProjection = !!c[4];
        this._vanishingPointX = c[5];
        this._vanishingPointY = c[6];
        this._eventSheetName = c[7];
        this._eventSheet = null;
        this._sid = c[8];
        this._index = b;
        this._scrollY = this._scrollX = 0;
        this._scale = 1;
        this._angle = 0;
        this._initialObjectClasses = new Set;
        this._textureLoadedTypes = new Set;
        this._textureLoadPendingPromises = new Set;
        this._createdInstances = [];
        this._createdPersistedInstances = [];
        this._createdPersistedInstancesToDataMap = new Map;
        this._createdPersistedIndexToInstanceMap = new Map;
        this._initialNonWorld = [];
        this._is3dCameraEnabled = !1;
        this._cam3dposition = vec3$jscomp$7.create();
        this._cam3dlook = vec3$jscomp$7.create();
        this._cam3dup = vec3$jscomp$7.create();
        this._rootLayers = [];
        this._allLayersFlat = [];
        this._layersByName = new Map;
        this._layersBySid = new Map;
        this._pendingSetHTMLLayerCount = -1;
        const d = this._runtime.GetCanvasManager();
        this._effectList = C3$jscomp$104.New(C3$jscomp$104.EffectList, this, c[11]);
        this._effectChain = C3$jscomp$104.New(C3$jscomp$104.Gfx.EffectChain, d.GetEffectChainManager(), {
            drawContent: (e, f) => {
                f = f.GetContentObject().GetRenderTarget();
                e.ResetColor();
                e.DrawRenderTarget(f);
                e.InvalidateRenderTarget(f);
                d.ReleaseAdditionalRenderTarget(f)
            }
            ,
            getShaderParameters: e => this.GetEffectList()._GetEffectChainShaderParametersForIndex(e)
        });
        this._needsRebuildEffectChainSteps = !0;
        this._wasFullScreenQualityLow = !1;
        this._curRenderTarget = null;
        this._persistData = {};
        this._persistedIntances = new Map;
        this._isFirstVisit = !0;
        this._iLayout = new self.ILayout(this);
        this._userScriptDispatcher = C3$jscomp$104.New(C3$jscomp$104.Event.Dispatcher);
        for (const e of c[9])
            this._rootLayers.push(C3$jscomp$104.Layer.CreateFromExportData(this, null, e));
        this._ReindexLayers();
        for (const e of this.allLayers())
            e._InitInitialInstances();
        for (const e of c[10]) {
            a = this._runtime.GetObjectClassByIndex(e[1]);
            if (!a)
                throw Error("missing nonworld object class");
            a.GetDefaultInstanceData() || a.SetDefaultInstanceData(e);
            this._initialNonWorld.push(e);
            this._AddInitialObjectClass(a)
        }
    }
    Release() {
        for (const a of this._allLayersFlat)
            a.Release();
        C3$jscomp$104.clearArray(this._allLayersFlat);
        this._textureLoadPendingPromises.clear();
        this._runtime = this._layoutManager = this._eventSheet = null
    }
    GetRuntime() {
        return this._runtime
    }
    GetName() {
        return this._name
    }
    GetSID() {
        return this._sid
    }
    GetIndex() {
        return this._index
    }
    GetEffectList() {
        return this._effectList
    }
    GetEffectChain() {
        this._MaybeRebuildEffectChainSteps();
        return this._effectChain
    }
    _MaybeRebuildEffectChainSteps() {
        const a = "low" === this._runtime.GetCanvasManager().GetCurrentFullscreenScalingQuality();
        if (this._needsRebuildEffectChainSteps || this._wasFullScreenQualityLow !== a || this._effectChain.NeedsRebuild()) {
            var b = this.GetEffectList().GetActiveEffectTypes();
            this._effectChain.BuildSteps(b.map(c => c.GetShaderProgram()), {
                indexMap: b.map(c => c.GetIndex()),
                forcePostDraw: a,
                useFullSurface: !0
            });
            this._needsRebuildEffectChainSteps = !1;
            this._wasFullScreenQualityLow = a
        }
    }
    UpdateActiveEffects() {
        this.GetEffectList().UpdateActiveEffects();
        this._needsRebuildEffectChainSteps = !0
    }
    GetMinLayerScale() {
        let a = this._allLayersFlat[0].GetNormalScale();
        for (let b = 1, c = this._allLayersFlat.length; b < c; ++b) {
            const d = this._allLayersFlat[b];
            if (0 !== d.GetParallaxX() || 0 !== d.GetParallaxY())
                a = Math.min(a, d.GetNormalScale())
        }
        return a
    }
    _GetScrollBoundMarginHorizontal() {
        return .5 * this._runtime.GetViewportWidth() / this.GetMinLayerScale()
    }
    _GetScrollBoundMarginVertical() {
        return .5 * this._runtime.GetViewportHeight() / this.GetMinLayerScale()
    }
    GetScrollLeftBound() {
        return this.IsUnboundedScrolling() ? -Infinity : this._GetScrollBoundMarginHorizontal()
    }
    GetScrollRightBound() {
        return this.IsUnboundedScrolling() ? Infinity : this.GetWidth() - this._GetScrollBoundMarginHorizontal()
    }
    GetScrollTopBound() {
        return this.IsUnboundedScrolling() ? -Infinity : this._GetScrollBoundMarginVertical()
    }
    GetScrollBottomBound() {
        return this.IsUnboundedScrolling() ? Infinity : this.GetHeight() - this._GetScrollBoundMarginVertical()
    }
    SetScrollX(a) {
        const b = this.GetScrollLeftBound()
          , c = this.GetScrollRightBound();
        a > c && (a = c);
        a < b && (a = b);
        this._scrollX !== a && (this._scrollX = a,
        this._SetAllLayersMVChanged(),
        this._runtime.UpdateRender())
    }
    GetScrollX() {
        return this._scrollX
    }
    SetScrollY(a) {
        const b = this.GetScrollTopBound()
          , c = this.GetScrollBottomBound();
        a > c && (a = c);
        a < b && (a = b);
        this._scrollY !== a && (this._scrollY = a,
        this._SetAllLayersMVChanged(),
        this._runtime.UpdateRender())
    }
    GetScrollY() {
        return this._scrollY
    }
    IsUnboundedScrolling() {
        return this._isUnboundedScrolling
    }
    BoundScrolling() {
        this.SetScrollX(this.GetScrollX());
        this.SetScrollY(this.GetScrollY());
        for (const a of this._allLayersFlat)
            a.IsOwnScrollPositionEnabled() && (a.SetScrollX(a.GetScrollX()),
            a.SetScrollY(a.GetScrollY()))
    }
    SetVanishingPointXY(a, b) {
        if (this._vanishingPointX !== a || this._vanishingPointY !== b)
            this._vanishingPointX = a,
            this._vanishingPointY = b,
            this.IsPerspectiveProjection() && (this._SetAllLayersProjectionChanged(),
            this._SetAllLayersMVChanged(),
            this._runtime.UpdateRender())
    }
    GetVanishingPointX() {
        return this.IsOrthographicProjection() ? .5 : this._vanishingPointX
    }
    GetVanishingPointY() {
        return this.IsOrthographicProjection() ? .5 : this._vanishingPointY
    }
    HasVanishingPointOutsideViewport() {
        const a = this.GetVanishingPointX()
          , b = this.GetVanishingPointY();
        return 0 > a || 1 < a || 0 > b || 1 < b
    }
    SetPerspectiveProjection() {
        this._isOrthographicProjection && (this._isOrthographicProjection = !1,
        this._SetAllLayersProjectionChanged(),
        this._SetAllLayersMVChanged(),
        this._runtime.UpdateRender())
    }
    SetOrthographicProjection() {
        this._isOrthographicProjection || (this._isOrthographicProjection = !0,
        this._SetAllLayersProjectionChanged(),
        this._SetAllLayersMVChanged(),
        this._runtime.UpdateRender())
    }
    IsOrthographicProjection() {
        return this._isOrthographicProjection
    }
    IsPerspectiveProjection() {
        return !this.IsOrthographicProjection()
    }
    Set3DCameraEnabled(a) {
        a = !!a;
        this._is3dCameraEnabled !== a && (this._is3dCameraEnabled = a,
        this._SetAllLayersMVChanged(),
        this._runtime.UpdateRender())
    }
    Is3DCameraEnabled() {
        return this._is3dCameraEnabled
    }
    Set3DCameraOrientation(a, b, c, d, e, f, h, l, m) {
        vec3EqualsXYZ(this._cam3dposition, a, b, c) && vec3EqualsXYZ(this._cam3dlook, d, e, f) && vec3EqualsXYZ(this._cam3dup, h, l, m) || (vec3$jscomp$7.set(this._cam3dposition, a, b, c),
        vec3$jscomp$7.set(this._cam3dlook, d, e, f),
        vec3$jscomp$7.set(this._cam3dup, h, l, m),
        this.Set3DCameraChanged())
    }
    Set3DCameraChanged() {
        this._SetAllLayersMVChanged();
        this._runtime.UpdateRender()
    }
    Get3DCameraPosition() {
        return this._cam3dposition
    }
    Get3DCameraLookAt() {
        return this._cam3dlook
    }
    Get3DCameraUpVector() {
        return this._cam3dup
    }
    GetScale() {
        return this._scale
    }
    SetScale(a) {
        this._scale !== a && (this._scale = a,
        this._SetAllLayersMVChanged(),
        this.BoundScrolling(),
        this._runtime.UpdateRender())
    }
    SetAngle(a) {
        a = C3$jscomp$104.clampAngle(a);
        this._angle !== a && (this._angle = a,
        this._SetAllLayersMVChanged(),
        this._runtime.UpdateRender())
    }
    GetAngle() {
        return this._angle
    }
    GetWidth() {
        return this._width
    }
    SetWidth(a) {
        !isFinite(a) || 1 > a || (this._width = a)
    }
    GetHeight() {
        return this._height
    }
    SetHeight(a) {
        !isFinite(a) || 1 > a || (this._height = a)
    }
    GetEventSheet() {
        return this._eventSheet
    }
    _GetRootLayers() {
        return this._rootLayers
    }
    *allLayers() {
        for (const a of this._rootLayers)
            yield*a.selfAndAllSubLayers()
    }
    GetLayers() {
        return this._allLayersFlat
    }
    GetLayerCount() {
        return this._allLayersFlat.length
    }
    GetLayer(a) {
        return "number" === typeof a ? this.GetLayerByIndex(a) : this.GetLayerByName(a.toString())
    }
    GetLayerByIndex(a) {
        a = C3$jscomp$104.clamp(Math.floor(a), 0, this._allLayersFlat.length - 1);
        return this._allLayersFlat[a]
    }
    GetLayerByName(a) {
        return this._layersByName.get(a.toLowerCase()) || null
    }
    HasLayerByName(a) {
        return !!this.GetLayerByName(a)
    }
    GetLayerBySID(a) {
        return this._layersBySid.get(a) || null
    }
    _SetAllLayersProjectionChanged() {
        for (const a of this._allLayersFlat)
            a._SetProjectionMatrixChanged()
    }
    _SetAllLayersMVChanged() {
        for (const a of this._allLayersFlat)
            a._SetMVMatrixChanged()
    }
    AddLayer(a, b, c) {
        if (this.HasLayerByName(a))
            throw Error(`layer name '${a}' already in use`);
        if (!b && 2 > c)
            throw Error("invalid insert position");
        const d = 2 <= c ? b : b.GetParentLayer();
        a = C3$jscomp$104.New(C3$jscomp$104.Layer, this, d, {
            name: a,
            sid: Math.floor(1E15 * Math.random()),
            isDynamic: !0
        });
        this._InsertLayer(a, b, c);
        this.GetRuntime().UpdateRender();
        this._ReindexAndUpdateAllLayers()
    }
    MoveLayer(a, b, c) {
        if (!b && 2 > c)
            throw Error("invalid insert position");
        a === b && 2 > c || (this._RemoveLayer(a),
        this._InsertLayer(a, b, c),
        this.GetRuntime().UpdateRender(),
        this._ReindexAndUpdateAllLayers())
    }
    RemoveLayer(a) {
        if (this._RemoveLayer(a)) {
            const b = this._runtime.GetEventSheetManager();
            b.BlockFlushingInstances(!0);
            a.Release();
            b.BlockFlushingInstances(!1);
            this.GetRuntime().UpdateRender();
            this._ReindexAndUpdateAllLayers()
        }
    }
    RemoveAllDynamicLayers() {
        const a = new Set;
        for (var b of this.allLayers())
            b.IsDynamic() && !b.HasAnyDynamicParentLayer() && a.add(b);
        if (0 !== a.size) {
            b = this._runtime.GetEventSheetManager();
            b.BlockFlushingInstances(!0);
            for (const c of a)
                this._RemoveLayer(c),
                c.Release();
            b.BlockFlushingInstances(!1);
            this.GetRuntime().UpdateRender();
            this._ReindexAndUpdateAllLayers()
        }
    }
    _InsertLayer(a, b, c) {
        if (2 <= c)
            if (b) {
                if (b === a || b.HasParentLayer(a))
                    throw Error(`cannot move layer '${a.GetName()}' to sub-layer of itself`);
                b._AddSubLayer(a, 2 === c);
                a._SetParentLayer(b)
            } else
                2 === c ? this._rootLayers.push(a) : this._rootLayers.unshift(a),
                a._SetParentLayer(null);
        else {
            const d = b.GetParentLayer();
            if (d) {
                if (b.HasParentLayer(a))
                    throw Error(`cannot move layer '${a.GetName()}' to sub-layer of itself`);
                d._InsertSubLayer(a, b, 0 === c);
                a._SetParentLayer(d)
            } else {
                b = this._rootLayers.indexOf(b);
                if (-1 === b)
                    throw Error("cannot find layer to insert by");
                0 === c && ++b;
                this._rootLayers.splice(b, 0, a);
                a._SetParentLayer(null)
            }
        }
    }
    _RemoveLayer(a) {
        const b = a.GetParentLayer();
        if (b)
            return b._RemoveSubLayer(a),
            !0;
        if (1 < this._rootLayers.length) {
            a = this._rootLayers.indexOf(a);
            if (-1 === a)
                throw Error("cannot find layer to remove");
            this._rootLayers.splice(a, 1);
            return !0
        }
        return !1
    }
    _ReindexLayers() {
        this._allLayersFlat = [...this.allLayers()];
        this._layersByName.clear();
        this._layersBySid.clear();
        for (let a = 0, b = this._allLayersFlat.length; a < b; ++a) {
            const c = this._allLayersFlat[a];
            c._SetIndex(a);
            this._layersByName.set(c.GetName().toLowerCase(), c);
            this._layersBySid.set(c.GetSID(), c)
        }
    }
    _ReindexHTMLLayers() {
        let a = 0;
        for (const b of this._rootLayers) {
            for (const c of b.selfAndAllSubLayers())
                c._SetHTMLIndex(a);
            b.IsHTMLElementsLayer() && a++
        }
    }
    GetHTMLLayerCount() {
        return this._rootLayers.at(-1).GetHTMLIndex() + 1
    }
    async _ReindexAndUpdateAllLayers() {
        this._ReindexLayers();
        this._ReindexHTMLLayers();
        this._pendingSetHTMLLayerCount = this.GetHTMLLayerCount()
    }
    _GetPendingSetHTMLLayerCount() {
        return this._pendingSetHTMLLayerCount
    }
    _ResetPendingHTMLLayerCount() {
        this._pendingSetHTMLLayerCount = -1
    }
    GetRootLayersForHTMLLayer(a) {
        const b = [];
        for (const c of this._rootLayers) {
            const d = c.GetHTMLIndex();
            if (d === a)
                b.push(c);
            else if (d > a)
                break
        }
        return b
    }
    SaveTransform() {
        return {
            scrollX: this.GetScrollX(),
            scrollY: this.GetScrollY(),
            scale: this.GetScale(),
            angle: this.GetAngle(),
            vpX: this.GetVanishingPointX(),
            vpY: this.GetVanishingPointY()
        }
    }
    RestoreTransform(a) {
        this.SetScrollX(a.scrollX);
        this.SetScrollY(a.scrollY);
        this.SetScale(a.scale);
        this.SetAngle(a.angle);
        this.SetVanishingPointXY(a.vpX, a.vpY)
    }
    GetLayoutBackgroundColor() {
        let a = this._rootLayers.filter(b => b.ShouldDraw())[0];
        for (; a; ) {
            if (!a.IsTransparent())
                return tempColor$jscomp$4.copyRgb(a.GetBackgroundColor()),
                tempColor$jscomp$4.setA(1),
                tempColor$jscomp$4;
            if (a.UsesOwnTexture())
                return tempColor$jscomp$4.setRgba(0, 0, 0, 0),
                tempColor$jscomp$4;
            a = a.GetSubLayers().filter(b => b.ShouldDraw())[0]
        }
        tempColor$jscomp$4.setRgba(0, 0, 0, 0);
        return tempColor$jscomp$4
    }
    IsFirstVisit() {
        return this._isFirstVisit
    }
    _GetInitialObjectClasses() {
        return [...this._initialObjectClasses]
    }
    _AddInitialObjectClass(a) {
        if (a.IsInContainer())
            for (const b of a.GetContainer().GetObjectTypes())
                this._initialObjectClasses.add(b);
        else
            this._initialObjectClasses.add(a)
    }
    _GetTextureLoadedObjectTypes() {
        return [...this._textureLoadedTypes]
    }
    _Load(a, b) {
        if (a === this || !b)
            return Promise.resolve();
        a && (C3$jscomp$104.CopySet(this._textureLoadedTypes, a._textureLoadedTypes),
        a._textureLoadedTypes.clear());
        a = [];
        for (const c of this._initialObjectClasses)
            this._textureLoadedTypes.has(c) || (a.push(c.LoadTextures(b)),
            this._textureLoadedTypes.add(c));
        return Promise.all(a)
    }
    async MaybeLoadTexturesFor(a) {
        if (a.IsFamily())
            throw Error("cannot load textures for family");
        var b = this._runtime.GetRenderer();
        !b || b.IsContextLost() || this._textureLoadedTypes.has(a) || (this._textureLoadedTypes.add(a),
        b = a.LoadTextures(b),
        this._AddPendingTextureLoadPromise(b),
        await b,
        a.OnDynamicTextureLoadComplete(),
        this._runtime.UpdateRender())
    }
    _AddPendingTextureLoadPromise(a) {
        this._textureLoadPendingPromises.add(a);
        a.then( () => this._textureLoadPendingPromises.delete(a)).catch( () => this._textureLoadPendingPromises.delete(a))
    }
    WaitForPendingTextureLoadsToComplete() {
        return Promise.all([...this._textureLoadPendingPromises])
    }
    MaybeUnloadTexturesFor(a) {
        if (a.IsFamily() || 0 < a.GetInstanceCount())
            throw Error("cannot unload textures");
        const b = this._runtime.GetRenderer();
        b && this._textureLoadedTypes.has(a) && (this._textureLoadedTypes.delete(a),
        a.ReleaseTextures(b))
    }
    _Unload(a, b) {
        if (a !== this && b)
            for (const c of this._textureLoadedTypes)
                c.IsGlobal() || a._initialObjectClasses.has(c) || (c.ReleaseTextures(),
                this._textureLoadedTypes.delete(c))
    }
    _OnRendererContextLost() {
        this._textureLoadedTypes.clear()
    }
    async _StartRunning(a) {
        const b = this._runtime
          , c = this._layoutManager
          , d = b.GetEventSheetManager();
        this._eventSheetName && (this._eventSheet = d.GetEventSheetByName(this._eventSheetName),
        this._eventSheet._UpdateDeepIncludes());
        c._SetMainRunningLayout(this);
        this._width = this._originalWidth;
        this._height = this._originalHeight;
        this._scrollX = b.GetOriginalViewportWidth() / 2;
        this._scrollY = b.GetOriginalViewportHeight() / 2;
        this.BoundScrolling();
        this._SetAllLayersProjectionChanged();
        this._SetAllLayersMVChanged();
        this._ReindexHTMLLayers();
        await this._runtime.GetCanvasManager().SetHTMLLayerCount(this.GetHTMLLayerCount(), !0);
        this._MoveGlobalObjectsToThisLayout(a);
        this._runtime.SetUsingCreatePromises(!0);
        this._CreateInitialInstances();
        this._isFirstVisit || this._CreatePersistedInstances();
        this._CreateAndLinkContainerInstances(this._createdInstances);
        this._CreateAndLinkContainerInstances(this._createdPersistedInstances);
        this._CreateInitialNonWorldInstances();
        c.ClearPendingChangeLayout();
        b.FlushPendingInstances();
        this._runtime.SetUsingCreatePromises(!1);
        var e = this._runtime.GetCreatePromises();
        await Promise.all(e);
        C3$jscomp$104.clearArray(e);
        if (!b.IsLoadingState()) {
            for (const f of this._createdInstances)
                f.SetupInitialSceneGraphConnections();
            for (const f of this._createdPersistedInstances)
                f.SetupPersistedSceneGraphConnections(this._createdPersistedInstancesToDataMap, this._createdPersistedIndexToInstanceMap);
            for (const [f,h] of Object.entries(this._persistData))
                (e = this._runtime.GetObjectClassBySID(parseInt(f, 10))) && !e.IsFamily() && e.HasPersistBehavior() && C3$jscomp$104.clearArray(h);
            for (const f of this._createdInstances)
                f._TriggerOnCreated();
            for (const f of this._createdPersistedInstances)
                f._TriggerOnCreated()
        }
        C3$jscomp$104.clearArray(this._createdInstances);
        C3$jscomp$104.clearArray(this._createdPersistedInstances);
        this._createdPersistedInstancesToDataMap.clear();
        this._createdPersistedIndexToInstanceMap.clear();
        await Promise.all([...this._initialObjectClasses].map(f => f.PreloadTexturesWithInstances(this._runtime.GetRenderer())));
        a && (b.Dispatcher().dispatchEvent(new C3$jscomp$104.Event("beforefirstlayoutstart")),
        await b.DispatchUserScriptEventAsyncWait(new C3$jscomp$104.Event("beforeprojectstart")));
        await this.DispatchRuntimeUserScriptEventAsyncWait(new C3$jscomp$104.Event("beforeanylayoutstart"));
        b.Dispatcher().dispatchEvent(new C3$jscomp$104.Event("beforelayoutstart"));
        await this.DispatchUserScriptEventAsyncWait(new C3$jscomp$104.Event("beforelayoutstart"));
        b.IsLoadingState() || await b.TriggerAsync(C3$jscomp$104.Plugins.System.Cnds.OnLayoutStart, null, null);
        b.Dispatcher().dispatchEvent(new C3$jscomp$104.Event("afterlayoutstart"));
        await this.DispatchUserScriptEventAsyncWait(new C3$jscomp$104.Event("afterlayoutstart"));
        await this.DispatchRuntimeUserScriptEventAsyncWait(new C3$jscomp$104.Event("afteranylayoutstart"));
        a && (b.Dispatcher().dispatchEvent(new C3$jscomp$104.Event("afterfirstlayoutstart")),
        await b.DispatchUserScriptEventAsyncWait(new C3$jscomp$104.Event("afterprojectstart")));
        d._RunQueuedTriggers(c);
        await this.WaitForPendingTextureLoadsToComplete();
        this._isFirstVisit = !1
    }
    _MoveGlobalObjectsToThisLayout(a) {
        for (const c of this._runtime.GetAllObjectClasses())
            if (!c.IsFamily() && c.IsWorldType())
                for (const d of c.GetInstances()) {
                    const e = d.GetWorldInfo();
                    var b = e.GetLayer();
                    b = C3$jscomp$104.clamp(b.GetIndex(), 0, this._allLayersFlat.length - 1);
                    b = this._allLayersFlat[b];
                    e._SetLayer(b, !0);
                    b._MaybeAddInstance(d)
                }
        if (!a)
            for (const c of this._allLayersFlat)
                c._SortInstancesByLastCachedZIndex(!1)
    }
    _CreateInitialInstances() {
        for (const a of this._allLayersFlat)
            a.CreateInitialInstances(this._createdInstances),
            a._Start()
    }
    _CreatePersistedInstances() {
        let a = !1;
        for (const [c,d] of Object.entries(this._persistData)) {
            const e = this._runtime.GetObjectClassBySID(parseInt(c, 10));
            if (e && !e.IsFamily() && e.HasPersistBehavior())
                for (const f of d) {
                    var b = null;
                    if (e.IsWorldType() && (b = f.hasOwnProperty("instJson") ? this.GetLayerBySID(f.instJson.w.l) : this.GetLayerBySID(f.w.l),
                    !b))
                        continue;
                    b = this._runtime.CreateInstanceFromData(e, b, !1, 0, 0, !0);
                    f.hasOwnProperty("instJson") ? b.LoadFromJson(f.instJson) : b.LoadFromJson(f);
                    a = !0;
                    this._createdPersistedInstances.push(b);
                    f.hasOwnProperty("instJson") && (this._createdPersistedInstancesToDataMap.set(b, f),
                    this._createdPersistedIndexToInstanceMap.set(f.index, b))
                }
        }
        for (const c of this._allLayersFlat)
            c._SortInstancesByLastCachedZIndex(!0),
            c.SetZIndicesChanged();
        a && (this._runtime.FlushPendingInstances(),
        this._runtime._RefreshUidMap())
    }
    _CreateAndLinkContainerInstances(a) {
        for (const c of a) {
            if (!c.IsInContainer())
                continue;
            const d = c.GetWorldInfo()
              , e = c.GetIID();
            for (const f of c.GetObjectClass().GetContainer().objectTypes())
                if (f !== c.GetObjectClass()) {
                    var b = f.GetInstances();
                    b.length > e ? c._AddSibling(b[e]) : (b = d ? this._runtime.CreateInstanceFromData(f, d.GetLayer(), !0, d.GetX(), d.GetY(), !0) : this._runtime.CreateInstanceFromData(f, null, !0, 0, 0, !0),
                    this._runtime.FlushPendingInstances(),
                    f._UpdateIIDs(),
                    c._AddSibling(b),
                    a.push(b))
                }
        }
    }
    _CreateInitialNonWorldInstances() {
        for (const a of this._initialNonWorld)
            this._runtime.GetObjectClassByIndex(a[1]).IsInContainer() || this._runtime.CreateInstanceFromData(a, null, !0)
    }
    _CreateGlobalNonWorlds() {
        const a = []
          , b = this._initialNonWorld;
        let c = 0;
        for (let d = 0, e = b.length; d < e; ++d) {
            const f = b[d]
              , h = this._runtime.GetObjectClassByIndex(f[1]);
            h.IsGlobal() ? h.IsInContainer() && h.GetContainer().HasAnyWorldType() || a.push(this._runtime.CreateInstanceFromData(f, null, !0)) : (b[c] = f,
            ++c)
        }
        C3$jscomp$104.truncateArray(b, c);
        this._runtime.FlushPendingInstances();
        this._CreateAndLinkContainerInstances(a)
    }
    RecreateInitialObjects(a, b, c, d, e, f) {
        if (c)
            return c.RecreateInitialObjects(a, b, d, e, f);
        c = [];
        for (const h of this._allLayersFlat)
            c.push(h.RecreateInitialObjects(a, b, d, e, f));
        return c.flat()
    }
    async _StopRunning() {
        const a = this._layoutManager;
        this._runtime.IsLoadingState() || (await this.DispatchRuntimeUserScriptEventAsyncWait(new C3$jscomp$104.Event("beforeanylayoutend")),
        await this.DispatchUserScriptEventAsyncWait(new C3$jscomp$104.Event("beforelayoutend")),
        await this._runtime.TriggerAsync(C3$jscomp$104.Plugins.System.Cnds.OnLayoutEnd, null, null),
        await this.DispatchUserScriptEventAsyncWait(new C3$jscomp$104.Event("afterlayoutend")),
        await this.DispatchRuntimeUserScriptEventAsyncWait(new C3$jscomp$104.Event("afteranylayoutend")));
        a.SetIsEndingLayout(!0);
        this._runtime.GetEventSheetManager().ClearAllScheduledWaits();
        this._isFirstVisit || this._SavePersistData();
        for (const b of this._allLayersFlat)
            b._End();
        for (const b of this._runtime.GetAllObjectClasses())
            if (!(b.IsGlobal() || b.IsWorldType() || b.GetPlugin().IsSingleGlobal() || b.IsFamily())) {
                for (const c of b.GetInstances())
                    this._runtime.DestroyInstance(c);
                this._runtime.FlushPendingInstances()
            }
        a.SetIsEndingLayout(!1);
        a.GetMainRunningLayout() === this && a._SetMainRunningLayout(null)
    }
    _SaveInstanceToPersist(a, b) {
        var c = a.GetObjectClass().GetSID().toString();
        this._persistData.hasOwnProperty(c) || (this._persistData[c] = []);
        c = this._persistData[c];
        b = {
            index: b,
            instJson: a.SaveToJson(),
            sceneGraphJson: {
                children: []
            }
        };
        c.push(b);
        this._persistedIntances.set(a, b)
    }
    _SaveSceneGraphInfoToPersist(a) {
        const b = this._persistedIntances.get(a);
        for (const c of a.GetChildren())
            (a = this._persistedIntances.get(c)) && b.sceneGraphJson.children.push({
                index: a.index,
                flags: C3$jscomp$104.SceneGraphInfo._GetFlagsNumber(c.GetWorldInfo())
            })
    }
    _SavePersistData() {
        this._persistedIntances.clear();
        var a = 0;
        for (const b of this._allLayersFlat) {
            b._UpdateZIndices();
            for (const c of b._GetInstances()) {
                const d = c.GetObjectClass();
                !d.IsGlobal() && d.HasPersistBehavior() && (this._SaveInstanceToPersist(c, a),
                a++)
            }
        }
        for (const b of this._allLayersFlat)
            for (const c of b._GetInstances())
                a = c.GetObjectClass(),
                !a.IsGlobal() && a.HasPersistBehavior() && this._SaveSceneGraphInfoToPersist(c);
        this._persistedIntances.clear()
    }
    ResetPersistData() {
        this._persistData = {};
        this._isFirstVisit = !0
    }
    GetRenderTarget() {
        return this._curRenderTarget
    }
    UsesOwnTexture() {
        const a = this._runtime
          , b = a.GetRenderer().IsWebGL();
        return "low" === a.GetCanvasManager().GetCurrentFullscreenScalingQuality() || b && a.UsesAnyBackgroundBlending() || this._effectList.HasAnyActiveEffect() || b && a.Uses3DFeatures()
    }
    _MaybeStartDrawToOwnTexture(a) {
        const b = this._runtime.GetCanvasManager();
        this.UsesOwnTexture() ? (a.SetRenderTarget(null),
        a.ClearRgba(0, 0, 0, 0),
        a = {
            sampling: this._runtime.GetSampling(),
            isSampled: a.IsWebGPU() || this._runtime.UsesAnyBackgroundBlending() || this._effectList.HasAnyActiveEffect(),
            canReadPixels: a.IsWebGPU() ? this._runtime.UsesAnyBackgroundBlending() : !1
        },
        "low" === b.GetCurrentFullscreenScalingQuality() && (a.width = b.GetDrawWidth(),
        a.height = b.GetDrawHeight()),
        this._curRenderTarget = this._runtime.GetAdditionalRenderTarget(a)) : this._curRenderTarget = null
    }
    _MaybeCopyOwnTextureToBackbuffer(a) {
        this._runtime._NeedsHTMLLayerCompositing(a) && (a.SetDepthEnabled(!1),
        a.SetRenderTarget(null),
        a.SetTextureFillMode(),
        a.CopyRenderTarget(this._curRenderTarget))
    }
    _MaybeEndDrawToOwnTexture(a) {
        this.UsesOwnTexture() && (a.SetDepthEnabled(!1),
        this._DrawLayoutOwnTextureToRenderTarget(a, this._curRenderTarget))
    }
    DrawMain(a) {
        a.SetRenderTarget(this._curRenderTarget);
        a.Clear(this.GetLayoutBackgroundColor());
        this._runtime.Uses3DFeatures() && a.ClearDepth();
        const b = this.GetRootLayersForHTMLLayer(0);
        this._DrawLayerList(a, this._curRenderTarget, b, !0);
        a.IsWebGPU() && a.StartMeasuringRenderPassTime(0, 1);
        this._MaybeEndDrawToOwnTexture(a);
        this._curRenderTarget = null
    }
    DrawForHTMLLayerIndex(a, b) {
        let c = null;
        this._runtime._NeedsHTMLLayerCompositing(a) && (c = this._curRenderTarget);
        a.SetRenderTarget(c);
        a.ClearRgba(0, 0, 0, 0);
        this._runtime.Uses3DFeatures() && a.ClearDepth();
        const d = this.GetRootLayersForHTMLLayer(b);
        this._DrawLayerList(a, c, d, !0);
        this._MaybeCopyOwnTextureToBackbuffer(a);
        a.EndBatch();
        this._runtime.GetCanvasManager().BlitMainCanvasToHTMLLayerCanvas(b)
    }
    _DrawLayerList(a, b, c, d) {
        c = c.filter(e => e.ShouldDraw());
        for (let e = 0, f = c.length; e < f; ) {
            const h = c[e];
            if (h.SelfAndAllSubLayersHave3DCamera() && !h.SelfOrAnySubLayerUsesOwnTexture()) {
                tempRender3dList.push(h);
                for (let l = e + 1; l < f; ++l) {
                    const m = c[l];
                    if (m.SelfAndAllSubLayersHave3DCamera() && !m.SelfOrAnySubLayerUsesOwnTexture())
                        tempRender3dList.push(c[l]);
                    else
                        break
                }
                if (2 <= tempRender3dList.length || 1 === tempRender3dList.length && tempRender3dList[0].HasAnyVisibleSubLayer()) {
                    this._Draw3DLayers(a, b, tempRender3dList);
                    e += tempRender3dList.length;
                    C3$jscomp$104.clearArray(tempRender3dList);
                    continue
                }
                C3$jscomp$104.clearArray(tempRender3dList)
            }
            h.Draw(a, b, d && 0 === e);
            ++e
        }
    }
    _DrawLayoutOwnTextureToRenderTarget(a, b) {
        const c = this._effectList.GetActiveEffectTypes()
          , d = this._runtime;
        0 === c.length ? (a.SetRenderTarget(null),
        a.SetTextureFillMode(),
        a.CopyRenderTarget(b),
        a.InvalidateRenderTarget(b),
        d.ReleaseAdditionalRenderTarget(b)) : (tempLayoutRect.set(0, 0, d.GetViewportWidth(), d.GetViewportHeight()),
        this.GetEffectChain().Render(a, null, {
            contentObject: this,
            blendMode: 3,
            devicePixelRatio: this._runtime.GetEffectDevicePixelRatioParam(),
            layerScale: this._runtime.GetEffectLayerScaleParam() * this.GetScale(),
            layerAngle: this.GetAngle(),
            layoutRect: tempLayoutRect,
            drawSurfaceRect: null,
            invalidateRenderTargets: !0
        }))
    }
    _Draw3DLayers(a, b, c) {
        c[0].IsTransparent() || (tempColor$jscomp$4.copyRgb(c[0].GetBackgroundColor()),
        tempColor$jscomp$4.setA(1),
        a.Clear(tempColor$jscomp$4));
        this._runtime.GetCanvasManager();
        a.SetDepthEnabled(!0);
        for (var d of c)
            d._UpdateZIndices(),
            d._AppendAllInstancesIncludingSubLayersInDrawOrder(tempInstanceList1$jscomp$1);
        d = c[0];
        c = d._MaybeStartWebGLProfiling(a);
        d._MaybeStartWebGPUProfiling(a);
        for (let m = 0, p = tempInstanceList1$jscomp$1.length; m < p; ) {
            var e = tempInstanceList1$jscomp$1[m]
              , f = e.GetWorldInfo()
              , h = f.GetLayer();
            if (f.IsVisible() && f.IsInViewport3D(h._GetViewFrustum())) {
                (!e.RendersToOwnZPlane() || 0 < f.GetDepth()) && tempInstanceList3.push(e);
                var l = e.GetWorldInfo().GetTotalZElevation();
                tempInstanceList2$jscomp$1.push(e);
                for (d = m + 1; d < p; ++d) {
                    const r = tempInstanceList1$jscomp$1[d]
                      , v = r.GetWorldInfo();
                    if (v.IsVisible() && v.IsInViewport3D(v.GetLayer()._GetViewFrustum())) {
                        if (v.GetTotalZElevation() !== l)
                            break;
                        r.RendersToOwnZPlane() ? (0 < v.GetDepth() && tempInstanceList3.push(r),
                        tempInstanceList2$jscomp$1.push(r)) : tempInstanceList3.push(r)
                    }
                }
                if (1 !== tempInstanceList2$jscomp$1.length || tempInstanceList2$jscomp$1[0].MustMitigateZFighting()) {
                    this._Draw3DLayersCoplanarInstances(a, b, tempInstanceList2$jscomp$1);
                    for (let r = 0, v = tempInstanceList3.length; r < v; ++r)
                        e = tempInstanceList3[r],
                        f = e.GetWorldInfo(),
                        h = f.GetLayer(),
                        f._SetDrawNonBackFacesOnly(!0),
                        MaybePrepareLayerDraw(h, a),
                        h._DrawInstanceMaybeWithEffects(e, f, a, b),
                        f._SetDrawNonBackFacesOnly(!1)
                } else {
                    MaybePrepareLayerDraw(h, a);
                    h._DrawInstanceMaybeWithEffects(e, f, a, b);
                    for (let r = 0, v = tempInstanceList3.length; r < v; ++r)
                        f = tempInstanceList3[r],
                        f !== e && (h = f.GetWorldInfo(),
                        l = h.GetLayer(),
                        MaybePrepareLayerDraw(l, a),
                        l._DrawInstanceMaybeWithEffects(f, h, a, b))
                }
                m = d;
                C3$jscomp$104.clearArray(tempInstanceList2$jscomp$1);
                C3$jscomp$104.clearArray(tempInstanceList3)
            } else
                ++m
        }
        c && a.EndQuery(c);
        C3$jscomp$104.clearArray(tempInstanceList1$jscomp$1);
        lastLayerPreparedForDrawing = null
    }
    _Draw3DLayersCoplanarInstances(a, b, c) {
        a.CoplanarStartStencilPass();
        for (let h = 0, l = c.length; h < l; ++h) {
            var d = c[h]
              , e = d.GetWorldInfo()
              , f = e.GetLayer();
            e._SetDrawBackFaceOnly(!0);
            MaybePrepareLayerDraw(f, a);
            f._DrawInstance(d, e, a)
        }
        a.CoplanarStartColorPass();
        for (let h = 0, l = c.length; h < l; ++h)
            d = c[h],
            e = d.GetWorldInfo(),
            f = e.GetLayer(),
            MaybePrepareLayerDraw(f, a),
            f._DrawInstanceMaybeWithEffects(d, e, a, b),
            e._SetDrawBackFaceOnly(!1);
        a.CoplanarRestoreStandardRendering()
    }
    _SaveToJson() {
        const a = {
            sx: this.GetScrollX(),
            sy: this.GetScrollY(),
            s: this.GetScale(),
            a: this.GetAngle(),
            w: this.GetWidth(),
            h: this.GetHeight(),
            ortho: this.IsOrthographicProjection(),
            vpX: this.GetVanishingPointX(),
            vpY: this.GetVanishingPointY(),
            fv: this._isFirstVisit,
            persist: this._persistData,
            fx: this._effectList.SaveToJson(),
            layers: {},
            dynamicLayers: []
        };
        for (const b of this._allLayersFlat)
            if (b.IsDynamic()) {
                const c = b.GetParentLayer();
                a.dynamicLayers.push({
                    sid: b.GetSID(),
                    name: b.GetName(),
                    parentSid: c ? c.GetSID() : null,
                    siblingIndex: b._GetSiblingIndex(),
                    data: b._SaveToJson()
                })
            } else
                a.layers[b.GetSID().toString()] = b._SaveToJson();
        return a
    }
    _LoadFromJson(a) {
        this._scrollX = a.sx;
        this._scrollY = a.sy;
        this._scale = a.s;
        this._angle = a.a;
        this._width = a.w;
        this._height = a.h;
        this._isOrthographicProjection = !!a.ortho;
        a.hasOwnProperty("vpX") && (this._vanishingPointX = a.vpX);
        a.hasOwnProperty("vpY") && (this._vanishingPointY = a.vpY);
        this._isFirstVisit = !!a.fv;
        this._persistData = a.persist;
        this._effectList.LoadFromJson(a.fx);
        this._needsRebuildEffectChainSteps = !0;
        for (const [l,m] of Object.entries(a.layers)) {
            var b = parseInt(l, 10);
            (b = this.GetLayerBySID(b)) && b._LoadFromJson(m)
        }
        if (a.hasOwnProperty("dynamicLayers")) {
            this.RemoveAllDynamicLayers();
            this._runtime.FlushPendingInstances();
            b = new Map;
            a = a.dynamicLayers;
            for (var c = a.length - 1; 0 <= c; --c) {
                var d = a[c]
                  , e = d.sid
                  , f = d.name
                  , h = d.parentSid;
                const l = d.siblingIndex;
                d = d.data;
                this._ReindexLayers();
                if (this.HasLayerByName(f) || this.GetLayerBySID(e))
                    continue;
                let m;
                if (null === h)
                    m = null,
                    h = this._rootLayers;
                else {
                    m = this.GetLayerBySID(h);
                    if (!m)
                        continue;
                    h = m.GetSubLayers()
                }
                e = C3$jscomp$104.New(C3$jscomp$104.Layer, this, m, {
                    name: f,
                    sid: e,
                    isDynamic: !0
                });
                h.push(e);
                f = b.get(h);
                f || (f = [],
                b.set(h, f));
                f.push({
                    layer: e,
                    siblingIndex: l
                });
                e._LoadFromJson(d)
            }
            for (const [l,m] of b) {
                m.sort( (p, r) => p.siblingIndex - r.siblingIndex);
                for (const p of m)
                    b = p.layer,
                    a = p.siblingIndex,
                    c = l.indexOf(b),
                    l.splice(c, 1),
                    l.splice(a, 0, b)
            }
        }
        this._ReindexAndUpdateAllLayers();
        this._SetAllLayersProjectionChanged();
        this._SetAllLayersMVChanged()
    }
    GetILayout() {
        return this._iLayout
    }
    UserScriptDispatcher() {
        return this._userScriptDispatcher
    }
    DispatchUserScriptEvent(a) {
        a.layout = this.GetILayout();
        var b = this._runtime;
        (b = b.IsDebug() && !b.GetEventSheetManager().IsInEventEngine()) && C3Debugger.StartMeasuringScriptTime();
        this._userScriptDispatcher.dispatchEvent(a);
        b && C3Debugger.AddScriptTime()
    }
    DispatchUserScriptEventAsyncWait(a) {
        a.layout = this.GetILayout();
        return this._userScriptDispatcher.dispatchEventAndWaitAsync(a)
    }
    DispatchRuntimeUserScriptEventAsyncWait(a) {
        a.layout = this.GetILayout();
        return this._runtime.DispatchUserScriptEventAsyncWait(a)
    }
    _LogLayerTree() {
        this._LogLayerList(this._rootLayers)
    }
    _LogLayerList(a, b=0) {
        a = a.slice(0);
        a.reverse();
        for (const c of a)
            console.log(`${"\t".repeat(b)}- ${c.GetName()}`),
            this._LogLayerList(c.GetSubLayers(), b + 1)
    }
}
;
"use strict";
const C3$jscomp$105 = self.C3;
C3$jscomp$105.LayoutManager = class extends C3$jscomp$105.DefendedBase {
    constructor(a) {
        super();
        this._runtime = a;
        this._allLayouts = [];
        this._layoutsByName = new Map;
        this._layoutsBySid = new Map;
        this._mainRunningLayout = null;
        this._runningSubLayouts = [];
        this._firstLayout = null;
        this._isEndingLayout = 0;
        this._pendingChangeLayout = null
    }
    Release() {
        this._pendingChangeLayout = this._firstLayout = this._mainRunningLayout = this._runtime = null;
        C3$jscomp$105.clearArray(this._allLayouts);
        this._layoutsByName.clear();
        this._layoutsBySid.clear();
        C3$jscomp$105.clearArray(this._runningSubLayouts)
    }
    Create(a) {
        a = C3$jscomp$105.New(C3$jscomp$105.Layout, this, this._allLayouts.length, a);
        this._allLayouts.push(a);
        this._layoutsByName.set(a.GetName().toLowerCase(), a);
        this._layoutsBySid.set(a.GetSID(), a)
    }
    GetRuntime() {
        return this._runtime
    }
    SetFirstLayout(a) {
        this._firstLayout = a
    }
    GetFirstLayout() {
        if (this._firstLayout)
            return this._firstLayout;
        if (this._allLayouts.length)
            return this._allLayouts[0];
        throw Error("no first layout");
    }
    GetLayoutByName(a) {
        return this._layoutsByName.get(a.toLowerCase()) || null
    }
    GetLayoutBySID(a) {
        return this._layoutsBySid.get(a) || null
    }
    GetLayoutByIndex(a) {
        a = C3$jscomp$105.clamp(Math.floor(a), 0, this._allLayouts.length - 1);
        return this._allLayouts[a]
    }
    GetLayout(a) {
        return "number" === typeof a ? this.GetLayoutByIndex(a) : this.GetLayoutByName(a.toString())
    }
    GetAllLayouts() {
        return this._allLayouts
    }
    _SetMainRunningLayout(a) {
        this._mainRunningLayout = a
    }
    GetMainRunningLayout() {
        return this._mainRunningLayout
    }
    _AddRunningSubLayout(a) {
        if (this._runningSubLayouts.includes(a))
            throw Error("layout already running");
        this._runningSubLayouts.push(a)
    }
    _RemoveRunningSubLayout(a) {
        a = this._runningSubLayouts.indexOf(a);
        if (-1 === a)
            throw Error("layout not running");
        this._runningSubLayouts.splice(a, 1)
    }
    *runningLayouts() {
        this._mainRunningLayout && (yield this._mainRunningLayout);
        this._runningSubLayouts.length && (yield*this._runningSubLayouts)
    }
    IsLayoutRunning(a) {
        return this._mainRunningLayout === a || this._runningSubLayouts.includes(a)
    }
    SetIsEndingLayout(a) {
        if (a)
            this._isEndingLayout++;
        else {
            if (0 >= this._isEndingLayout)
                throw Error("already unset");
            this._isEndingLayout--
        }
    }
    IsEndingLayout() {
        return 0 < this._isEndingLayout
    }
    ChangeMainLayout(a) {
        this._pendingChangeLayout = a
    }
    ClearPendingChangeLayout() {
        this._pendingChangeLayout = null
    }
    IsPendingChangeMainLayout() {
        return !!this._pendingChangeLayout
    }
    GetPendingChangeMainLayout() {
        return this._pendingChangeLayout
    }
    SetAllLayerProjectionChanged() {
        const a = this.GetMainRunningLayout();
        a && a._SetAllLayersProjectionChanged()
    }
    SetAllLayerMVChanged() {
        const a = this.GetMainRunningLayout();
        a && a._SetAllLayersMVChanged()
    }
}
;
"use strict";
const C3$jscomp$106 = self.C3
  , NAMES_REGEXP = RegExp("<(.+?)>", "g");
C3$jscomp$106.TimelineManager = class extends C3$jscomp$106.DefendedBase {
    constructor(a) {
        super();
        this._runtime = a;
        this._timelineDataManager = C3$jscomp$106.New(C3$jscomp$106.TimelineDataManager);
        this._pluginInstance = null;
        this._timelines = [];
        this._timelinesByName = new Map;
        this._objectClassToTimelineMap = new Map;
        this._timelinesCreatedByTemplate = new Map;
        this._scheduledTimelines = [];
        this._playingTimelines = [];
        this._markedForRemovalTimelines = [];
        this._isTickingTimelines = this._changingLayout = this._hasRuntimeListeners = !1;
        this._tickFunc = () => this._OnTick();
        this._tick2Func = () => this._OnTick2();
        this._beforeLayoutChange = () => this._OnBeforeChangeLayout();
        this._layoutChange = () => this._OnAfterChangeLayout();
        this._instanceDestroy = b => this._OnInstanceDestroy(b.instance);
        this._beforeLoad = b => this._OnBeforeLoad();
        this._afterLoad = b => this._OnAfterLoad();
        this._afterLayoutStart = b => this._OnAfterLayoutStart();
        this._destroyedWhileLoadingState = [];
        this._renderChange = 0
    }
    Release() {
        this.RemoveRuntimeListeners();
        this._afterLoad = this._instanceDestroy = this._layoutChange = this._beforeLayoutChange = this._tick2Func = this._tickFunc = null;
        for (const a of this._timelines)
            a.Stop(),
            a.Release();
        C3$jscomp$106.clearArray(this._timelines);
        this._timelines = null;
        this._timelineDataManager.Release();
        this._timelineDataManager = null;
        C3$jscomp$106.clearArray(this._scheduledTimelines);
        this._scheduledTimelines = null;
        C3$jscomp$106.clearArray(this._playingTimelines);
        this._playingTimelines = null;
        C3$jscomp$106.clearArray(this._markedForRemovalTimelines);
        this._markedForRemovalTimelines = null;
        this._timelinesByName.clear();
        this._timelinesByName = null;
        this._objectClassToTimelineMap.clear();
        this._objectClassToTimelineMap = null;
        this._timelinesCreatedByTemplate.clear();
        this._timelinesCreatedByTemplate = null;
        C3$jscomp$106.clearArray(this._destroyedWhileLoadingState);
        this._runtime = this._destroyedWhileLoadingState = null
    }
    AddRuntimeListeners() {
        const a = this._runtime.Dispatcher();
        a.addEventListener("pretick", this._tickFunc);
        a.addEventListener("tick2", this._tick2Func);
        a.addEventListener("beforelayoutchange", this._beforeLayoutChange);
        a.addEventListener("layoutchange", this._layoutChange);
        a.addEventListener("instancedestroy", this._instanceDestroy);
        a.addEventListener("beforeload", this._beforeLoad);
        a.addEventListener("afterload", this._afterLoad);
        a.addEventListener("afterlayoutstart", this._afterLayoutStart)
    }
    RemoveRuntimeListeners() {
        const a = this._runtime.Dispatcher();
        a.removeEventListener("pretick", this._tickFunc);
        a.removeEventListener("tick2", this._tick2Func);
        a.removeEventListener("beforelayoutchange", this._beforeLayoutChange);
        a.removeEventListener("layoutchange", this._layoutChange);
        a.removeEventListener("instancedestroy", this._instanceDestroy);
        a.removeEventListener("beforeload", this._beforeLoad);
        a.removeEventListener("afterload", this._afterLoad);
        a.removeEventListener("afterlayoutstart", this._afterLayoutStart)
    }
    Create(a) {
        this._timelineDataManager.Add(a);
        a = C3$jscomp$106.TimelineState.CreateInitial(a, this);
        this.Add(a);
        this.SetTimelineObjectClassesToMap(a);
        this._timelinesCreatedByTemplate.set(a.GetName(), 0)
    }
    CreateFromTemplate(a) {
        var b = this.GetTimelineDataManager();
        a = a.GetTemplateName();
        b = b.Get(a);
        b = C3$jscomp$106.TimelineState.CreateFromTemplate(`${a}:${this._timelinesCreatedByTemplate.get(a)}`, b, this);
        this._IncreaseTemplateTimelinesCount(a);
        this.Add(b);
        return b
    }
    _IncreaseTemplateTimelinesCount(a) {
        this._timelinesCreatedByTemplate.set(a, this._timelinesCreatedByTemplate.get(a) + 1)
    }
    _SetCreatedTemplateTimelinesCount() {
        for (const a of this._timelines) {
            if (a.IsTemplate())
                continue;
            const b = a.GetTemplateName();
            this._IncreaseTemplateTimelinesCount(b)
        }
    }
    _ClearCreatedTemplateTimelinesCount() {
        for (const a of this._timelinesCreatedByTemplate.keys())
            this._timelinesCreatedByTemplate.set(a, 0)
    }
    Add(a) {
        this._timelines.push(a);
        this._timelinesByName.set(a.GetName().toLowerCase(), a)
    }
    Remove(a) {
        a.Removed();
        a.IsTemplate() || (C3$jscomp$106.arrayFindRemove(this._timelines, a),
        C3$jscomp$106.arrayFindRemove(this._scheduledTimelines, a),
        C3$jscomp$106.arrayFindRemove(this._playingTimelines, a),
        C3$jscomp$106.arrayFindRemove(this._markedForRemovalTimelines, a),
        this._timelinesByName.delete(a.GetName().toLowerCase()),
        this.RemoveTimelineFromObjectClassMap(a),
        a.IsReleased() || a.Release())
    }
    Trigger(a) {
        this._runtime.Trigger(a, this._pluginInstance, null)
    }
    GetRuntime() {
        return this._runtime
    }
    GetTimelineDataManager() {
        return this._timelineDataManager
    }
    SetPluginInstance(a) {
        this._pluginInstance = a
    }
    GetPluginInstance() {
        return this._pluginInstance
    }
    *GetTimelines() {
        for (const a of this._timelines)
            yield a
    }
    *GetPlayingTimelines() {
        for (const a of this._playingTimelines)
            yield a
    }
    SetTimelineObjectClassToMap(a, b) {
        this._objectClassToTimelineMap.has(a) || this._objectClassToTimelineMap.set(a, new Set);
        this._objectClassToTimelineMap.get(a).add(b)
    }
    SetTimelineObjectClassesToMap(a) {
        for (const b of a.GetObjectClasses())
            this.SetTimelineObjectClassToMap(b, a)
    }
    RemoveTimelineFromObjectClassMap(a) {
        for (const [b,c] of this._objectClassToTimelineMap.entries())
            c.has(a) && (c.delete(a),
            0 === c.size && this._objectClassToTimelineMap.delete(b))
    }
    GetTimelinesForObjectClass(a) {
        if (this._objectClassToTimelineMap.has(a))
            return this._objectClassToTimelineMap.get(a)
    }
    GetTimelineOfTemplateForInstances(a, b) {
        if (b)
            for (const c of this._timelines)
                if (b.every(d => c.HasTrackInstance(d.instance, d.trackId)) && c.GetName().includes(a.GetName()))
                    return c
    }
    GetTimelineByName(a) {
        return this._timelinesByName.get(a.toLowerCase()) || null
    }
    GetScheduledOrPlayingTimelineByName(a) {
        for (const b of this._scheduledTimelines)
            if (b.GetName() === a)
                return b;
        for (const b of this._playingTimelines)
            if (b.GetName() === a)
                return b;
        return null
    }
    *GetTimelinesByName(a) {
        if (NAMES_REGEXP.test(a)) {
            NAMES_REGEXP.lastIndex = 0;
            let c;
            var b = new Set;
            do
                if (c = NAMES_REGEXP.exec(a)) {
                    const d = c[1].split(",");
                    for (const e of d)
                        b.add(e)
                }
            while (c);
            for (const d of b.values())
                (a = this.GetTimelineByName(d)) && (yield a);
            b.clear()
        } else
            (b = this.GetTimelineByName(a)) && (yield b)
    }
    *GetTimelinesByTags(a) {
        for (const b of this._timelines)
            b.HasTags(a) && (yield b)
    }
    AddScheduledTimeline(a) {
        this._scheduledTimelines.includes(a) || this._scheduledTimelines.push(a);
        this._MaybeEnableRuntimeListeners()
    }
    RemovePlayingTimeline(a) {
        C3$jscomp$106.arrayFindRemove(this._playingTimelines, a);
        this._MaybeDisableRuntimeListeners()
    }
    ScheduleTimeline(a) {
        this._playingTimelines.includes(a) ? (a.SetPlaying(!0),
        a.SetScheduled(!1),
        a.SetMarkedForRemoval(!1)) : (a.SetPlaying(!1),
        a.SetScheduled(!0),
        a.SetMarkedForRemoval(!1),
        this._scheduledTimelines.includes(a) || this._scheduledTimelines.push(a));
        this._MaybeEnableRuntimeListeners()
    }
    DeScheduleTimeline(a) {
        a.SetPlaying(!1);
        a.SetScheduled(!1);
        a.ResolvePlayPromise();
        C3$jscomp$106.arrayFindRemove(this._scheduledTimelines, a);
        this._MaybeDisableRuntimeListeners()
    }
    CompleteTimeline(a) {
        a.SetPlaying(!1);
        a.SetScheduled(!1);
        this._playingTimelines.includes(a) && (a.SetMarkedForRemoval(!0),
        this._markedForRemovalTimelines.push(a),
        C3$jscomp$106.arrayFindRemove(this._playingTimelines, a))
    }
    CompleteTimelineBeforeChangeOfLayout(a) {
        a.SetPlaying(!1);
        a.SetScheduled(!1);
        a.SetMarkedForRemoval(!1);
        a.SetPlaybackRate(1);
        C3$jscomp$106.arrayFindRemove(this._playingTimelines, a)
    }
    CompleteTimelineAndResolve(a) {
        this.CompleteTimeline(a);
        a.ResolvePlayPromise()
    }
    _OnTick() {
        if (!this.GetRuntime().IsLoadingState() && this._hasRuntimeListeners && !this._changingLayout) {
            for (this._isTickingTimelines = !0; this._scheduledTimelines.length; ) {
                var a = this._scheduledTimelines.pop();
                a.SetInitialState();
                0 !== a.GetRenderChange() && (this._renderChange = 1);
                this._playingTimelines.push(a)
            }
            a = this._runtime._GetDtFast();
            var b = this._runtime.GetDt1()
              , c = this._runtime.GetTimeScale();
            for (let d = this._playingTimelines.length - 1; 0 <= d; d--) {
                const e = this._playingTimelines[d];
                e && e.Tick(a, c, b)
            }
            this._isTickingTimelines = !1;
            0 !== this._renderChange && this.GetRuntime().UpdateRender()
        }
    }
    _OnTick2() {
        if (!this.GetRuntime().IsLoadingState() && this._hasRuntimeListeners && !this._changingLayout) {
            var a;
            for (let b = 0, c = this._markedForRemovalTimelines.length; b < c; b++) {
                const d = this._markedForRemovalTimelines[b];
                a || (a = new Set);
                d.Removed();
                this._MaybeExecuteTimelineFinishTriggers(d);
                a.add(d)
            }
            if (a) {
                C3$jscomp$106.arrayRemoveAllInSet(this._markedForRemovalTimelines, a);
                this._renderChange = 0;
                for (let b = 0, c = this._playingTimelines.length; b < c; b++)
                    if (0 !== this._playingTimelines[b].GetRenderChange()) {
                        this._renderChange = 1;
                        break
                    }
            }
            this._MaybeDisableRuntimeListeners()
        }
    }
    _MaybeExecuteTimelineFinishTriggers(a) {
        a.IsReleased() || a.HasValidTracks() && a.IsComplete() && a.InitialStateSet() && a.FinishTriggers()
    }
    _MaybeEnableRuntimeListeners() {
        this._hasRuntimeListeners || (this._hasRuntimeListeners = !0)
    }
    _MaybeDisableRuntimeListeners() {
        this._markedForRemovalTimelines.length || this._playingTimelines.length || this._scheduledTimelines.length || this._isTickingTimelines || (this._hasRuntimeListeners = !1)
    }
    _OnBeforeChangeLayout() {
        for (this._changingLayout = !0; this._scheduledTimelines.length; )
            this.DeScheduleTimeline(this._scheduledTimelines.pop());
        const a = new Set;
        for (const b of this._playingTimelines)
            b._OnBeforeChangeLayout() && (b.Removed(),
            a.add(b));
        C3$jscomp$106.arrayRemoveAllInSet(this._playingTimelines, a);
        a.clear();
        for (const b of this._markedForRemovalTimelines)
            b._OnBeforeChangeLayout() && (b.Removed(),
            a.add(b));
        C3$jscomp$106.arrayRemoveAllInSet(this._markedForRemovalTimelines, a);
        this._MaybeDisableRuntimeListeners();
        for (const b of this._timelines)
            b.CleanCaches()
    }
    _OnAfterChangeLayout() {
        this._changingLayout = !1
    }
    _OnInstanceDestroy(a) {
        var b = a.GetObjectClass();
        if (b = this.GetTimelinesForObjectClass(b))
            if (this._runtime.IsLoadingState())
                this._destroyedWhileLoadingState.push(a);
            else
                for (const c of b)
                    c.IsTemplate() || (c.IsReleased() ? this.Remove(c) : c.HasValidTracks() || (this._MaybeExecuteTimelineFinishTriggers(c),
                    this.Remove(c)))
    }
    _OnBeforeLoad() {
        for (const a of this._scheduledTimelines.map(b => b))
            this._MaybeExecuteTimelineFinishTriggers(a),
            this.Remove(a);
        for (const a of this._playingTimelines.map(b => b))
            this._MaybeExecuteTimelineFinishTriggers(a),
            this.Remove(a)
    }
    _OnAfterLoad() {
        for (const a of this._destroyedWhileLoadingState)
            this._OnInstanceDestroy(a);
        C3$jscomp$106.clearArray(this._destroyedWhileLoadingState);
        for (const a of this._timelines)
            a._OnAfterLoad()
    }
    _OnAfterLayoutStart() {
        const a = this._runtime.GetLayoutManager().GetMainRunningLayout();
        if (a)
            for (const b of this._timelines) {
                const c = b.GetStartOnLayout();
                c && a.GetName() === c && this.ScheduleTimeline(b)
            }
    }
    _SaveToJson() {
        return {
            timelinesJson: this._SaveTimelinesToJson(),
            scheduledTimelinesJson: this._SaveScheduledTimelinesToJson(),
            playingTimelinesJson: this._SavePlayingTimelinesToJson(),
            markedForRemovalTimelinesJson: this._SaveMarkedForRemovalTimelinesToJson(),
            hasRuntimeListeners: this._hasRuntimeListeners,
            changingLayout: this._changingLayout,
            isTickingTimelines: this._isTickingTimelines
        }
    }
    _LoadFromJson(a) {
        a && (this._ClearCreatedTemplateTimelinesCount(),
        this._LoadTimelinesFromJson(a.timelinesJson),
        this._LoadScheduledTimelinesFromJson(a.scheduledTimelinesJson),
        this._LoadPlayingTimelinesFromJson(a.playingTimelinesJson),
        this._LoadMarkedForRemovalTimelinesFromJson(a.markedForRemovalTimelinesJson),
        this._hasRuntimeListeners = !a.hasRuntimeListeners,
        this._changingLayout = !!a.changingLayout,
        this._isTickingTimelines = !!a.isTickingTimelines,
        this._SetCreatedTemplateTimelinesCount(),
        this._MaybeEnableRuntimeListeners(),
        this._MaybeDisableRuntimeListeners())
    }
    _SaveTimelinesToJson() {
        return this._timelines.map(a => a._SaveToJson())
    }
    _LoadTimelinesFromJson(a) {
        for (const b of a) {
            a = this.GetTimelineByName(b.name);
            if (!a) {
                a = this._GetTemplateNameFromJson(b);
                if (!a)
                    continue;
                a = this.GetTimelineByName(a);
                a = this.CreateFromTemplate(a)
            }
            a._LoadFromJson(b);
            a.HasTracks() || this.Remove(a)
        }
    }
    _GetTemplateNameFromJson(a) {
        return (a = a.name.split(":")) && 2 === a.length ? a[0] : null
    }
    _SaveScheduledTimelinesToJson() {
        return this._SaveTimelines(this._scheduledTimelines)
    }
    _LoadScheduledTimelinesFromJson(a) {
        this._LoadTimelines(a, this._scheduledTimelines)
    }
    _SavePlayingTimelinesToJson() {
        return this._SaveTimelines(this._playingTimelines)
    }
    _LoadPlayingTimelinesFromJson(a) {
        this._LoadTimelines(a, this._playingTimelines)
    }
    _SaveMarkedForRemovalTimelinesToJson() {
        return this._SaveTimelines(this._markedForRemovalTimelines)
    }
    _LoadMarkedForRemovalTimelinesFromJson(a) {
        this._LoadTimelines(a, this._markedForRemovalTimelines)
    }
    _IsTimelineInJson(a, b) {
        if (!b)
            return !1;
        for (const c of b)
            if (c === a.GetName())
                return !0;
        return !1
    }
    _SaveTimelines(a) {
        return a.map(b => b.GetName())
    }
    _LoadTimelines(a, b) {
        var c = new Set;
        for (const d of b)
            this._IsTimelineInJson(d, a) || c.add(d);
        C3$jscomp$106.arrayRemoveAllInSet(b, c);
        if (a) {
            c = d => e => e.GetName() === d;
            for (const d of a)
                (a = this.GetTimelineByName(d)) && (b.find(c(d)) || b.push(a))
        }
    }
}
;
"use strict";
const C3$jscomp$107 = self.C3
  , TANGENT_RESULT = [0, 0]
  , MAP_RESULT = [0, 0]
  , PROJECTION_RESULT = [0, 0, 0, 0, 0];
C3$jscomp$107.TimelineInfo = class {
    constructor(a, b) {
        this._initialized = !1;
        this._timeline = a;
        this._segments = [];
        if (b = b ? this._timeline.GetTrackById(b) : C3$jscomp$107.first(this._timeline.GetTracks()))
            if (a = b.GetPropertyTrack("offsetX"),
            b = b.GetPropertyTrack("offsetY"),
            a && b) {
                this._xTrack = a;
                this._yTrack = b;
                a = a.GetPropertyKeyframeDataItemArrayIncludingDisabled();
                b = b.GetPropertyKeyframeDataItemArrayIncludingDisabled();
                for (let c = 1, d = Math.min(a.length, b.length); c < d; ++c) {
                    const e = a[c];
                    e.GetNext();
                    const f = e.GetPrevious()
                      , h = b[c];
                    h.GetNext();
                    const l = h.GetPrevious();
                    f && "cubic-bezier" === f.GetPathMode() && l && "cubic-bezier" === l.GetPathMode() ? this._segments.push(C3$jscomp$107.New(C3$jscomp$107.TimelineCubicBezierSegmentInfo, f, l, e, h, this._segments.length)) : (f && "line" === f.GetPathMode() && l && l.GetPathMode(),
                    this._segments.push(C3$jscomp$107.New(C3$jscomp$107.TimelineLineSegmentInfo, e, h, this._segments.length)))
                }
                this._initialized = !0
            }
    }
    Release() {
        for (const a of this._segments)
            a.Release();
        C3$jscomp$107.clearArray(this._segments);
        this._yTrack = this._xTrack = this._timeline = this._segments = null
    }
    WasInitialized() {
        return this._initialized
    }
    segments() {
        return this._segments
    }
    SetOrigin(a) {
        const b = "relative" === this._xTrack.GetResultMode() ? a.GetX() : 0;
        a = "relative" === this._yTrack.GetResultMode() ? a.GetY() : 0;
        for (const c of this._segments)
            c.SetOrigin(b, a)
    }
    Project(a, b, c) {
        c && c.tRange && (C3$jscomp$107.IsFiniteNumber(c.tRange[0]) || (c.tRange[0] = 0),
        C3$jscomp$107.IsFiniteNumber(c.tRange[1]) || (c.tRange[1] = 1));
        const d = [];
        for (const e of this._segments)
            if ("cubic-bezier" === e.GetType()) {
                const f = e.Project(a, b, c ? c.tRange : null);
                f[4] = e.GetIndex();
                d.push(JSON.parse(JSON.stringify(f)))
            }
        d.sort( (e, f) => e[3] - f[3]);
        return d[0]
    }
    Tangent(a, b) {
        return this._segments[b].Tangent(a)
    }
    TangentAngle(a, b, c, d) {
        return this._segments[d].TangentAngle(a, b, c)
    }
}
;
C3$jscomp$107.TimelineCubicBezierSegmentInfo = class {
    constructor(a, b, c, d, e) {
        this._index = e;
        e = a.GetAddOn("cubic-bezier");
        const f = c.GetAddOn("cubic-bezier")
          , h = b.GetAddOn("cubic-bezier")
          , l = d.GetAddOn("cubic-bezier");
        this._aX = a.GetValueWithResultMode();
        this._aY = b.GetValueWithResultMode();
        this._bX = a.GetValueWithResultMode() + e.GetStartAnchor();
        this._bY = b.GetValueWithResultMode() + h.GetStartAnchor();
        this._cX = c.GetValueWithResultMode() + f.GetEndAnchor();
        this._cY = d.GetValueWithResultMode() + l.GetEndAnchor();
        this._dX = c.GetValueWithResultMode();
        this._dY = d.GetValueWithResultMode();
        this._initialized = !1;
        this._len = 100;
        this._arcLengths = Array(this._len + 1);
        this._length = this._arcLengths[0] = 0;
        this._lut = [];
        this._CalculateLength()
    }
    Release() {
        C3$jscomp$107.clearArray(this._arcLengths);
        this._arcLengths = null;
        C3$jscomp$107.clearArray(this._lut);
        this._lut = null
    }
    GetType() {
        return "cubic-bezier"
    }
    GetIndex() {
        return this._index
    }
    GetStepCount() {
        return Math.floor(this._length / 30)
    }
    GetStepIncrement() {
        return 1 / this.GetStepCount()
    }
    SetOrigin(a, b) {
        this._originX = a;
        this._originY = b;
        this._arcLengths = Array(this._len + 1);
        this._arcLengths[0] = 0;
        this._CalculateLength()
    }
    Map(a) {
        if (!this._initialized)
            return NaN;
        a = this._Map(a);
        MAP_RESULT[0] = this._X(a);
        MAP_RESULT[1] = this._Y(a);
        return MAP_RESULT
    }
    Project(a, b, c) {
        const d = this._GenerateLUT(100);
        c = this._FindClosestFromLUT(a, b, d, c);
        a = this._RefineProjection(a, b, d, c);
        PROJECTION_RESULT[0] = a.x;
        PROJECTION_RESULT[1] = a.y;
        PROJECTION_RESULT[2] = a.t;
        PROJECTION_RESULT[3] = a.distance;
        return PROJECTION_RESULT
    }
    Tangent(a) {
        var b = 1 - a
          , c = b * b;
        b = 2 * b * a;
        const d = a * a;
        a = 3 * c * (this._bX + this._originX - (this._aX + this._originX)) + 3 * b * (this._cX + this._originX - (this._bX + this._originX)) + 3 * d * (this._dX + this._originX - (this._cX + this._originX));
        c = 3 * c * (this._bY + this._originY - (this._aY + this._originY)) + 3 * b * (this._cY + this._originY - (this._bY + this._originY)) + 3 * d * (this._dY + this._originY - (this._cY + this._originY));
        b = Math.hypot(a, c);
        TANGENT_RESULT[0] = a / b;
        TANGENT_RESULT[1] = c / b;
        return TANGENT_RESULT
    }
    TangentAngle(a, b, c) {
        c = this.Tangent(c);
        return C3$jscomp$107.angleTo(a, b, a + c[0], b + c[1])
    }
    _Map(a) {
        if (this._initialized) {
            a *= this._arcLengths[this._len];
            for (var b = 0, c = this._len, d = 0; b < c; )
                d = b + ((c - b) / 2 | 0),
                this._arcLengths[d] < a ? b = d + 1 : c = d;
            this._arcLengths[d] > a && d--;
            b = this._arcLengths[d];
            return b === a ? d / this._len : (d + (a - b) / (this._arcLengths[d + 1] - b)) / this._len
        }
    }
    _X(a) {
        return this._initialized ? self.Ease.GetRuntimeEase("cubicbezier")(a, this._aX + this._originX, this._bX + this._originX, this._cX + this._originX, this._dX + this._originX) : NaN
    }
    _Y(a) {
        return this._initialized ? self.Ease.GetRuntimeEase("cubicbezier")(a, this._aY + this._originY, this._bY + this._originY, this._cY + this._originY, this._dY + this._originY) : NaN
    }
    _GenerateLUT(a) {
        a = a || 100;
        if (this._lut.length === a)
            return this._lut;
        this._lut = [];
        a++;
        for (let b = 0; b < a; b++) {
            const c = b / (a - 1)
              , d = this._X(c)
              , e = this._Y(c);
            this._lut.push({
                x: d,
                y: e,
                t: c,
                distance: 0
            })
        }
        return this._lut
    }
    _FindClosestFromLUT(a, b, c, d=null, e=Number.MAX_SAFE_INTEGER) {
        let f = 0;
        c.forEach( (h, l) => {
            h.t = l / (c.length - 1);
            h.distance = C3$jscomp$107.distanceTo(a, b, h.x, h.y);
            d && C3$jscomp$107.IsArray(d) && C3$jscomp$107.IsFiniteNumber(d[0]) && C3$jscomp$107.IsFiniteNumber(d[1]) ? h.t >= d[0] && h.t <= d[1] && h.distance < e && (e = h.distance,
            f = l) : h.distance < e && (e = h.distance,
            f = l)
        }
        );
        return f
    }
    _RefineProjection(a, b, c, d, e=0, f=1) {
        let h = c[d]
          , l = 1
          , m = Number.MAX_SAFE_INTEGER;
        do {
            var p = 0 === d ? 0 : d - 1;
            let r = d === c.length - 1 ? c.length - 1 : d + 1
              , v = c[p].t
              , x = []
              , B = (c[r].t - v) / 4;
            if (.001 > B)
                break;
            x.push(c[p]);
            for (p = 1; 3 >= p; p++) {
                const A = v + p * B
                  , D = this._X(A)
                  , F = this._Y(A)
                  , I = Math.abs(C3$jscomp$107.distanceTo(D, F, a, b) - e);
                I < m && (m = I,
                h = {
                    x: D,
                    y: F,
                    t: A,
                    distance: I
                },
                d = p);
                x.push({
                    x: D,
                    y: F,
                    t: A,
                    distance: I
                })
            }
            x.push(c[r]);
            c = x
        } while (25 > l++);
        e && m > f && (h = null);
        return h
    }
    _CalculateLength() {
        this._initialized = !0;
        let a = this._X(0)
          , b = this._Y(0)
          , c = 0;
        for (let d = 1; d <= this._len; d++) {
            const e = this._X(.01 * d)
              , f = this._Y(.01 * d);
            c += Math.hypot(a - e, b - f);
            this._arcLengths[d] = c;
            a = e;
            b = f
        }
        this._length = c
    }
}
;
C3$jscomp$107.TimelineLineSegmentInfo = class {
    constructor(a, b, c) {
        this._index = c;
        this._targetX = a.GetValueWithResultMode();
        this._targetY = b.GetValueWithResultMode();
        this._originY = this._originX = 0
    }
    Release() {}
    GetType() {
        return "line"
    }
    GetIndex() {
        return this._index
    }
    SetOrigin(a, b) {
        this._originX = a;
        this._originY = b
    }
    GetX() {
        return this._targetX + this._originX
    }
    GetY() {
        return this._targetY + this._originY
    }
}
;
"use strict";
const C3$jscomp$108 = self.C3;
C3$jscomp$108.TimelineState = class extends C3$jscomp$108.DefendedBase {
    constructor(a, b, c) {
        super();
        this._runtime = c.GetRuntime();
        this._timelineManager = c;
        this._timelineDataItem = b;
        this._name = a;
        this._tracks = [];
        this._tracksLength = 0;
        this._beforeAndAfterTracks = null;
        this._beforeAndAfterTracksLength = 0;
        this.CreateTrackStates();
        this._playResolve = this._playPromise = null;
        this._overshoot = this._playheadTime = 0;
        this._playbackRate = 1;
        this._pingPongState = 0;
        this._currentRepeatCount = 1;
        this._initialStateSet = this._isScheduled = this._isPlaying = !1;
        this._complete = !0;
        this._markedForRemoval = this._released = !1;
        this._completedTick = -1;
        this._firstTick = this._finishedTriggers = this._isTemplate = this._implicitPause = !1;
        this._lastDelta = NaN;
        this._tags = [""];
        this._stringTags = "";
        this._tagsChanged = !1;
        this._hasNestedContent = this._renderChange = 0;
        this._iTimelineState = null
    }
    static CreateInitial(a, b) {
        var c = b.GetTimelineDataManager();
        const d = c.GetNameId();
        c = c.Get(a[d]);
        a = C3$jscomp$108.New(C3$jscomp$108.TimelineState, a[d], c, b);
        a.SetIsTemplate(!0);
        return a
    }
    static CreateFromTemplate(a, b, c) {
        return C3$jscomp$108.New(C3$jscomp$108.TimelineState, a, b, c)
    }
    Release() {
        if (!this.IsReleased()) {
            var a = this._runtime.Dispatcher();
            this._timelineManager.DeScheduleTimeline(this);
            this._timelineManager.CompleteTimelineAndResolve(this);
            for (const b of this._tracks)
                b.Release();
            C3$jscomp$108.clearArray(this._tracks);
            this._timelineDataItem = this._timelineManager = this._runtime = this._tracks = null;
            this._released = !0;
            this._playResolve = this._playPromise = null;
            this.FireReleaseEvent(a)
        }
    }
    FireReleaseEvent(a) {
        const b = C3$jscomp$108.New(C3$jscomp$108.Event, "timelinestatereleased");
        b.timelineState = this;
        a.dispatchEvent(b)
    }
    GetType() {
        return 0
    }
    CreateTrackStates() {
        for (const a of this._timelineDataItem.GetTrackData().trackDataItems())
            this._tracksLength = this._tracks.push(C3$jscomp$108.TrackState.Create(this, a))
    }
    GetTimelineManager() {
        return this._timelineManager
    }
    GetRuntime() {
        return this._runtime
    }
    GetTracks() {
        return this._tracks
    }
    GetSimilarPropertyTracks(a, b, c, d) {
        if (this._hasNestedContent) {
            var e;
            for (let h = 0; h < this._tracks.length; h++) {
                var f = this._tracks[h];
                a === f.GetInstance() && (f = f.GetPropertyTrack(c)) && b.constructor === f.GetSourceAdapter().constructor && f.GetResultMode() === d.GetResultMode() && (e || (e = []),
                e.push(f))
            }
            return e
        }
    }
    HasTracks() {
        return !!this._tracks.length
    }
    GetTrackById(a) {
        for (const b of this._tracks)
            if (C3$jscomp$108.equalsNoCase(b.GetId(), a))
                return b;
        return null
    }
    GetTrackByName(a) {
        for (const b of this._tracks)
            if (!b.IsInstanceTrack() && C3$jscomp$108.equalsNoCase(b.GetName(), a))
                return b;
        return null
    }
    SetName(a) {
        this._name = a
    }
    GetName() {
        return this._name
    }
    GetTimelineDataItem() {
        return this._timelineDataItem
    }
    GetTemplateName() {
        return this._timelineDataItem.GetName()
    }
    GetTotalTime() {
        return this._timelineDataItem.GetTotalTime()
    }
    SetTotalTime(a) {
        this._timelineDataItem.SetTotalTime(a)
    }
    GetStep() {
        return this._timelineDataItem.GetStep()
    }
    SetStep(a) {
        this._timelineDataItem.SetStep(a)
    }
    GetInterpolationMode() {
        return this._timelineDataItem.GetInterpolationMode()
    }
    SetInterpolationMode(a) {
        this._timelineDataItem.SetInterpolationMode(a)
    }
    GetResultMode() {
        return this._timelineDataItem.GetResultMode()
    }
    SetResultMode(a) {
        this._timelineDataItem.GetResultMode(a)
    }
    SetEase(a) {
        for (const b of this.GetTracks())
            b.SetEase(a)
    }
    GetLoop() {
        return this._timelineDataItem.GetLoop()
    }
    SetLoop(a) {
        return this._timelineDataItem.SetLoop(a)
    }
    GetPingPong() {
        return this._timelineDataItem.GetPingPong()
    }
    SetPingPong(a) {
        return this._timelineDataItem.SetPingPong(a)
    }
    GetRepeatCount() {
        return this._timelineDataItem.GetRepeatCount()
    }
    SetRepeatCount(a) {
        return this._timelineDataItem.SetRepeatCount(a)
    }
    SetPlaybackRate(a) {
        return this._playbackRate = a
    }
    GetPlaybackRate() {
        return this._playbackRate
    }
    GetStartOnLayout() {
        return this._timelineDataItem.GetStartOnLayout()
    }
    GetTransformWithSceneGraph() {
        return this._timelineDataItem.GetTransformWithSceneGraph()
    }
    GetUseSystemTimescale() {
        return this._timelineDataItem.GetUseSystemTimescale()
    }
    GetPingPongState() {
        return this._pingPongState
    }
    IsForwardPlayBack() {
        return this.IsPlaying() ? 0 < this._playbackRate : !0
    }
    GetPlayPromise() {
        return this._playPromise ? this._playPromise : this._playPromise = new Promise(a => {
            this._playResolve = a
        }
        )
    }
    ResolvePlayPromise() {
        this._playPromise && (this._playResolve(),
        this._playResolve = this._playPromise = null)
    }
    SetTags(a) {
        this._tags = C3$jscomp$108.TimelineState._GetTagArray(a);
        this._tagsChanged = !0
    }
    GetTags() {
        return this._tags
    }
    GetStringTags() {
        this._tagsChanged && (this._stringTags = this._tags.join(" "));
        this._tagsChanged = !1;
        return this._stringTags
    }
    HasTags(a) {
        return this._tags && this._tags.length ? (a = C3$jscomp$108.TimelineState._GetTagArray(a)) && a.length ? a.every(C3$jscomp$108.TimelineState._HasTag, this) : !1 : !1
    }
    OnStarted() {
        C3$jscomp$108.Plugins.Timeline && this.constructor === C3$jscomp$108.TimelineState && (C3$jscomp$108.Plugins.Timeline.Cnds.PushTriggerTimeline(this),
        this._timelineManager.Trigger(C3$jscomp$108.Plugins.Timeline.Cnds.OnTimelineStarted),
        this._timelineManager.Trigger(C3$jscomp$108.Plugins.Timeline.Cnds.OnTimelineStartedByName),
        this._timelineManager.Trigger(C3$jscomp$108.Plugins.Timeline.Cnds.OnTimelineStartedByTags),
        this._timelineManager.Trigger(C3$jscomp$108.Plugins.Timeline.Cnds.OnAnyTimelineStarted),
        C3$jscomp$108.Plugins.Timeline.Cnds.PopTriggerTimeline())
    }
    OnCompleted() {
        this._completedTick = this._runtime.GetTickCount()
    }
    FinishTriggers() {
        this._finishedTriggers || (this._finishedTriggers = !0,
        C3$jscomp$108.Plugins.Timeline && this.constructor === C3$jscomp$108.TimelineState && (C3$jscomp$108.Plugins.Timeline.Cnds.PushTriggerTimeline(this),
        this._timelineManager.Trigger(C3$jscomp$108.Plugins.Timeline.Cnds.OnTimelineFinished),
        this._timelineManager.Trigger(C3$jscomp$108.Plugins.Timeline.Cnds.OnTimelineFinishedByName),
        this._timelineManager.Trigger(C3$jscomp$108.Plugins.Timeline.Cnds.OnTimelineFinishedByTags),
        this._timelineManager.Trigger(C3$jscomp$108.Plugins.Timeline.Cnds.OnAnyTimelineFinished),
        C3$jscomp$108.Plugins.Timeline.Cnds.PopTriggerTimeline()))
    }
    SetPlaying(a) {
        this._isPlaying = a
    }
    IsCompletedTick() {
        return this._completedTick === this._runtime.GetTickCount()
    }
    IsPlaying(a=!1) {
        return this.IsCompletedTick() || this.IsScheduled() && !a ? !0 : this._isPlaying
    }
    _IsPlaying() {
        return this.IsPlaying(!0)
    }
    IsPaused() {
        return this._IsPaused()
    }
    _IsPaused() {
        return this.IsReleased() || this.IsScheduled() || this._IsPlaying() || this.IsComplete() ? !1 : !0
    }
    SetScheduled(a) {
        this._isScheduled = a
    }
    IsScheduled() {
        return this._isScheduled
    }
    SetComplete(a) {
        this._complete = a;
        a = this.GetTime();
        if (0 >= a || a >= this.GetTotalTime())
            this._complete = !0
    }
    IsComplete() {
        return this._complete
    }
    IsReleased() {
        return this._released
    }
    SetMarkedForRemoval(a) {
        this._markedForRemoval = a
    }
    IsMarkedForRemoval() {
        return this._markedForRemoval
    }
    SetImplicitPause(a) {
        this._implicitPause = a
    }
    IsImplicitPause() {
        return this._implicitPause
    }
    SetIsTemplate(a) {
        this._isTemplate = !!a
    }
    IsTemplate() {
        return this._isTemplate
    }
    InitialStateSet() {
        return this._initialStateSet
    }
    GetTime() {
        return this._playheadTime
    }
    SetTime(a) {
        const b = this.GetTime();
        this._SetTime(a);
        this.SetComplete(!1);
        this.IsComplete() || this.SetImplicitPause(!0);
        if (this._IsPlaying() || this.IsScheduled() || !this._initialStateSet)
            this._IsPlaying() || this.IsScheduled() || this._initialStateSet ? this._IsPlaying() ? this.Stop() : this.IsScheduled() && (this._timelineManager.DeScheduleTimeline(this),
            this.SetInitialStateFromSetTime()) : this.SetInitialStateFromSetTime();
        this._SetUpdateStateBefore();
        this._Interpolate(this.GetTime(), !1, !0, !0, b);
        this._SetUpdateStateAfter();
        this._renderChange && this.GetRuntime().UpdateRender();
        this._OnSetTime()
    }
    _SetTime(a) {
        C3$jscomp$108.IsFiniteNumber(a) || (a = this.GetTotalTime());
        0 > a ? this._playheadTime = 0 : a >= this.GetTotalTime() ? this._playheadTime = this.GetTotalTime() : this._playheadTime = a
    }
    _SetTimeAndReset(a) {
        C3$jscomp$108.IsFiniteNumber(a) || (a = this.GetTotalTime());
        0 > a ? this._playheadTime = 0 : a >= this.GetTotalTime() ? this._playheadTime = this.GetTotalTime() : this._playheadTime = a;
        for (const b of this._tracks)
            b.SetResetState()
    }
    _OnSetTime() {
        C3$jscomp$108.Plugins.Timeline && this.constructor === C3$jscomp$108.TimelineState && (C3$jscomp$108.Plugins.Timeline.Cnds.PushTriggerTimeline(this),
        this._timelineManager.Trigger(C3$jscomp$108.Plugins.Timeline.Cnds.OnTimeSet),
        this._timelineManager.Trigger(C3$jscomp$108.Plugins.Timeline.Cnds.OnTimeSetByName),
        this._timelineManager.Trigger(C3$jscomp$108.Plugins.Timeline.Cnds.OnTimeSetByTags),
        C3$jscomp$108.Plugins.Timeline.Cnds.PopTriggerTimeline())
    }
    _CanResume() {
        if (!this.GetLoop())
            if (this.GetPingPong() && 1 === this._pingPongState)
                if (this.IsForwardPlayBack()) {
                    if (this.GetTime() >= this.GetTotalTime())
                        return !1
                } else {
                    if (0 >= this.GetTime())
                        return !1
                }
            else if (!this.GetLoop() && !this.GetPingPong())
                if (this.IsForwardPlayBack()) {
                    if (this.GetTime() >= this.GetTotalTime())
                        return !1
                } else if (0 >= this.GetTime())
                    return !1;
        return !0
    }
    Resume() {
        this.IsReleased() || this._CanResume() && this.Play(!0)
    }
    Play(a=!1) {
        return this.IsReleased() || this.IsScheduled() ? !1 : this._IsPlaying() && this.IsCompletedTick() ? this._SchedulePlayingTimeline() : this._IsPlaying() || !this.IsComplete() && !a && !this.IsImplicitPause() ? !1 : this._ScheduleStoppedTimeline()
    }
    _SchedulePlayingTimeline() {
        this.SetImplicitPause(!1);
        this._timelineManager.RemovePlayingTimeline(this);
        this._timelineManager.ScheduleTimeline(this);
        this.GetPlayPromise();
        return !0
    }
    _ScheduleStoppedTimeline() {
        this.SetImplicitPause(!1);
        this._timelineManager.ScheduleTimeline(this);
        this.GetPlayPromise();
        return !0
    }
    Stop(a=!1) {
        this.IsReleased() || (this.SetComplete(a),
        this._timelineManager.CompleteTimeline(this),
        this.IsComplete() && this.ResolvePlayPromise())
    }
    Reset(a=!0, b=!1) {
        if (!this.IsReleased()) {
            if (!this._IsPlaying() && this.IsScheduled())
                return this._timelineManager.DeScheduleTimeline(this);
            if (!this.IsComplete()) {
                this.Stop(!0);
                this.IsForwardPlayBack() ? this._SetTime(0) : this._SetTime(this.GetTotalTime());
                var c = this.GetTime();
                this._SetUpdateStateBefore();
                b ? this._InterpolateBeforeChangeLayout(c) : this._Interpolate(c, !1, !1, !0);
                a && this._OnSetTime();
                this._SetUpdateStateAfter();
                this._renderChange && a && this.GetRuntime().UpdateRender()
            }
        }
    }
    ResetBeforeChangeLayout() {
        this.Reset(!1, !0)
    }
    _InterpolateBeforeChangeLayout(a) {
        this._Interpolate(a, !1, !1, !0, NaN, !1, !0)
    }
    _OnBeforeChangeLayout() {
        if (this.IsReleased())
            return !0;
        if (!this.GetRuntime().IsLoadingState() && this.HasValidGlobalTracks())
            return !1;
        this._timelineManager.CompleteTimelineBeforeChangeOfLayout(this);
        this.GetRuntime().IsLoadingState() || this.ResetBeforeChangeLayout();
        return !0
    }
    SetInitialStateFromSetTime() {
        this.SetInitialState(!0)
    }
    SetInitialState(a) {
        if (!this.IsMarkedForRemoval()) {
            if (a) {
                this._finishedTriggers = !1;
                this._firstTick = this._initialStateSet = !0;
                this._SetUpdateStateBefore();
                for (const b of this._tracks)
                    b.SetInitialState()
            } else if (this.SetPlaying(!0),
            this.SetScheduled(!1),
            this.OnStarted(),
            this.IsComplete()) {
                this._completedTick = -1;
                0 !== this._pingPongState && (this._playbackRate = Math.abs(this._playbackRate));
                this._pingPongState = 0;
                this._currentRepeatCount = 1;
                this._finishedTriggers = this._complete = !1;
                this._firstTick = this._initialStateSet = !0;
                this.IsForwardPlayBack() ? this._SetTime(0) : this._SetTime(this.GetTotalTime());
                this._SetUpdateStateBefore();
                for (const b of this._tracks)
                    b.SetInitialState()
            } else {
                this._firstTick = !0;
                this._finishedTriggers = !1;
                this._SetUpdateStateBefore();
                for (const b of this._tracks)
                    b.SetResumeState()
            }
            this._SetUpdateStateAfter()
        }
    }
    GetRenderChange() {
        return this._renderChange
    }
    _SetUpdateStateBefore() {
        this._hasNestedContent = 0;
        for (const a of this._tracks)
            a.IsNested() && (this._hasNestedContent = 1)
    }
    _SetUpdateStateAfter() {
        this._renderChange = 0;
        for (const a of this._tracks)
            a._SetUpdateState(),
            0 === this._renderChange && 1 === a.GetRenderChange() && (this._renderChange = 1),
            this._beforeAndAfterTracks || 1 !== a.GetNeedsBeforeAndAfter() || (this._beforeAndAfterTracks || (this._beforeAndAfterTracks = []),
            this._beforeAndAfterTracksLength = this._beforeAndAfterTracks.push(a))
    }
    Tick(a, b, c) {
        if (this.GetUseSystemTimescale()) {
            if (0 === a && 0 === this._lastDelta)
                return;
            this._lastDelta = a;
            a = c
        } else {
            if (0 === c && 0 === this._lastDelta)
                return;
            a = this._lastDelta = c;
            b = 1
        }
        c = this._playheadTime + this._overshoot;
        b = c + a * b * this._playbackRate;
        a = this._timelineDataItem._totalTime;
        0 > b ? (this._playheadTime = 0,
        this._overshoot = -b) : b >= a ? (this._playheadTime = a,
        this._overshoot = this._playheadTime - b) : (this._playheadTime = b,
        this._overshoot = 0);
        var d = !1;
        b = !1;
        var e = this.GetLoop()
          , f = this.GetPingPong();
        e || f ? e && !f ? 0 < this._playbackRate ? this._playheadTime >= a && (this._SetTimeAndReset(0),
        b = !0) : 0 >= this._playheadTime && (this._SetTimeAndReset(a),
        b = !0) : !e && f ? 0 < this._playbackRate ? this._playheadTime >= a && (this._SetTime(a),
        this.SetPlaybackRate(-1 * this.GetPlaybackRate()),
        b = !0,
        1 === this._pingPongState ? this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++,
        this._pingPongState = 0) : d = !0 : 0 === this._pingPongState && (this._pingPongState = 1)) : 0 >= this._playheadTime && (this._SetTime(0),
        this.SetPlaybackRate(-1 * this.GetPlaybackRate()),
        b = !0,
        1 === this._pingPongState ? this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++,
        this._pingPongState = 0) : d = !0 : 0 === this._pingPongState && (this._pingPongState = 1)) : e && f && (0 < this._playbackRate ? this._playheadTime >= a && (this._SetTime(a),
        this.SetPlaybackRate(-1 * this.GetPlaybackRate()),
        b = !0,
        this._pingPongState++,
        C3$jscomp$108.wrap(this._pingPongState, 0, 2)) : 0 >= this._playheadTime && (this._SetTime(0),
        this.SetPlaybackRate(-1 * this.GetPlaybackRate()),
        b = !0,
        this._pingPongState++,
        C3$jscomp$108.wrap(this._pingPongState, 0, 2))) : 0 < this._playbackRate ? this._playheadTime >= a && (this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++,
        this._SetTimeAndReset(0),
        b = !0) : (this._SetTime(a),
        d = !0)) : 0 >= this._playheadTime && (this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++,
        this._SetTimeAndReset(a),
        b = !0) : (this._SetTime(0),
        d = !0));
        e = this._tracksLength;
        if (d) {
            for (d = 0; d < e; d++)
                this._tracks[d].SetEndState();
            this.Stop(!0);
            this.OnCompleted()
        } else {
            f = this._beforeAndAfterTracksLength;
            for (d = 0; d < f; d++)
                this._beforeAndAfterTracks[d].BeforeInterpolate();
            if (1 === this._hasNestedContent)
                for (d = 0; d < e; d++) {
                    const h = this._tracks[d]
                      , l = h.GetStartOffset()
                      , m = c - l;
                    0 > this._playheadTime - l && 0 < m ? (this._playheadTime = 0 > l ? 0 : l >= a ? a : l,
                    h.Interpolate(l, !0, !1, b, this._firstTick, !1)) : h.Interpolate(this._playheadTime, !0, !1, b, this._firstTick, !1)
                }
            else
                for (d = 0; d < e; d++)
                    this._tracks[d].Interpolate(this._playheadTime, !0, !1, b, this._firstTick, !1);
            for (d = 0; d < f; d++)
                this._beforeAndAfterTracks[d].AfterInterpolate();
            this._firstTick && (this._firstTick = !1)
        }
    }
    _Interpolate(a, b=!1, c=!1, d=!1, e=NaN, f=!1, h=!1) {
        for (var l of this._tracks)
            l.BeforeInterpolate();
        for (const m of this._tracks) {
            l = a;
            if ("number" === typeof e && !isNaN(e)) {
                const p = this.GetTime() - m.GetStartOffset()
                  , r = e - m.GetStartOffset();
                0 > p && 0 < r && (l = m.GetStartOffset(),
                this._SetTime(l))
            }
            m.Interpolate(l, b, c, d, this._firstTick, h)
        }
        for (const m of this._tracks)
            m.AfterInterpolate();
        this._firstTick && f && (this._firstTick = !1)
    }
    AddTrack() {
        var a = this._timelineDataItem.GetTrackData().AddEmptyTrackDataItem();
        a = C3$jscomp$108.TrackState.Create(this, a);
        this._tracksLength = this._tracks.push(a);
        return a
    }
    Removed() {
        if (!this.IsReleased())
            for (const a of this._tracks)
                a.TimelineRemoved()
    }
    CleanCaches() {
        for (const a of this._tracks)
            a.CleanCaches()
    }
    ClearTrackInstances() {
        for (const a of this._tracks)
            a.ClearInstance()
    }
    SetTrackInstance(a, b, c) {
        if (b)
            if ("number" === typeof c && 0 <= c) {
                if (a = this._tracks[c])
                    a.SetInstance(b),
                    this._timelineManager.SetTimelineObjectClassToMap(b.GetObjectClass(), this)
            } else
                for (const d of this._tracks)
                    if (d.IsInstanceTrack()) {
                        if (a) {
                            if (d.GetId() !== a)
                                continue
                        } else if (d.HasInstance())
                            continue;
                        d.SetInstance(b);
                        this._timelineManager.SetTimelineObjectClassToMap(b.GetObjectClass(), this);
                        break
                    }
    }
    HasTrackInstance(a, b) {
        for (const c of this._tracks)
            if (c.IsInstanceTrack())
                if (b) {
                    if (b === c.GetId() && a === c.GetInstance())
                        return !0
                } else if (a === c.GetInstance())
                    return !0;
        return !1
    }
    HasValidTracks() {
        return this._tracks.some(a => a.IsInstanceTrack() ? a.CanInstanceBeValid() : !0)
    }
    HasValidGlobalTracks() {
        return this._tracks.some(a => a.IsInstanceTrack() ? a.CanInstanceBeValid() ? (a = a.GetObjectClass()) ? a.IsGlobal() : !1 : !1 : !1)
    }
    GetPropertyTrack(a) {
        for (const b of this.GetTracks())
            for (const c of b.GetPropertyTracks())
                if (c.GetPropertyName() === a)
                    return c
    }
    GetTrackFromInstance(a) {
        for (const b of this._tracks)
            if (a === b.GetInstance())
                return b;
        return null
    }
    GetKeyframeWithTags(a) {
        a = a ? a.split(" ") : [];
        a = [...(new Set(a.map(b => b.toLowerCase().trim()))).values()];
        for (const b of this.GetTracks())
            for (const c of b.GetKeyframeDataItems())
                if (a.every(d => c.HasTag(d)))
                    return c
    }
    GetObjectClasses() {
        const a = [];
        for (const b of this.GetTracks())
            a.push(b.GetObjectClass());
        return a.filter(b => b)
    }
    _OnAfterLoad() {
        for (const a of this.GetTracks())
            a._OnAfterLoad()
    }
    _SaveToJson() {
        return {
            tracksJson: this._SaveTracksToJson(),
            name: this._name,
            playheadTime: this.GetTime(),
            playbackRate: this._playbackRate,
            pingPongState: this._pingPongState,
            currentRepeatCount: this._currentRepeatCount,
            isPlaying: this._isPlaying,
            isScheduled: this._isScheduled,
            initialStateSet: this._initialStateSet,
            finishedTriggers: this._finishedTriggers,
            complete: this._complete,
            released: this._released,
            markedForRemoval: this._markedForRemoval,
            completedTick: this._completedTick,
            implicitPause: this._implicitPause,
            isTemplate: this._isTemplate,
            tags: this._tags.join(" "),
            stringTags: this._stringTags,
            tagsChanged: this._tagsChanged,
            firstTick: this._firstTick
        }
    }
    _LoadFromJson(a) {
        a && (this._LoadTracksFromJson(a.tracksJson),
        this._name = a.name,
        this._playheadTime = a.playheadTime,
        this._playbackRate = a.playbackRate,
        this._pingPongState = a.pingPongState,
        this._currentRepeatCount = a.currentRepeatCount,
        this._isPlaying = !!a.isPlaying,
        this._isScheduled = !!a.isScheduled,
        this._initialStateSet = !!a.initialStateSet,
        this._finishedTriggers = a.hasOwnProperty("finishedTriggers") ? !!a.finishedTriggers : !1,
        this._complete = !!a.complete,
        this._released = !!a.released,
        this._markedForRemoval = !!a.markedForRemoval,
        this._completedTick = a.completedTick,
        this._implicitPause = !!a.implicitPause,
        this._isTemplate = !!a.isTemplate,
        this._tags = a.tags.split(" "),
        this._stringTags = a.stringTags,
        this._tagsChanged = !!a.tagsChanged,
        this._firstTick = !!a.firstTick)
    }
    _SaveTracksToJson() {
        return this._tracks.map(a => a._SaveToJson())
    }
    _LoadTracksFromJson(a) {
        this.ClearTrackInstances();
        a.forEach( (b, c) => {
            this._tracks[c]._LoadFromJson(b)
        }
        );
        this._tracks.filter(b => b.CanInstanceBeValid())
    }
    static _HasTag(a) {
        const b = this.GetTags();
        return "" === a ? 1 === b.length && "" === b[0] : b.map(c => c.toLowerCase()).includes(a.toLowerCase())
    }
    static _GetTagArray(a) {
        if (C3$jscomp$108.IsArray(a))
            return a.slice(0);
        if (C3$jscomp$108.IsString(a))
            return a.split(" ");
        throw Error("invalid tags");
    }
    GetITimelineState() {
        this._iTimelineState || (this._iTimelineState = C3$jscomp$108.New(self.ITimelineState, this));
        return this._iTimelineState
    }
}
;
"use strict";
const C3$jscomp$109 = self.C3;
C3$jscomp$109.TrackState = class extends C3$jscomp$109.DefendedBase {
    constructor(a, b) {
        super();
        this._timeline = a;
        this._trackDataItem = b;
        this._trackData = b.GetTrackData();
        this._objectClassIndex = this._instanceUid = NaN;
        this._worldInfo = this._instance = null;
        this._isNested = 0 < b.GetStartOffset();
        this._endStateOfNestedSet = this._initialStateOfNestedSet = !1;
        this._instanceUidToLoad = NaN;
        this._lastKeyframeDataItem = null;
        this._keyframeDataItems = this._trackDataItem.GetKeyframeData().GetKeyframeDataItemArray();
        this._propertyTracks = [];
        this.CreatePropertyTrackStates();
        this._needsBeforeAndAfter = this._renderChange = this._worldInfoChange = 0
    }
    static Create(a, b) {
        return C3$jscomp$109.New(C3$jscomp$109.TrackState, a, b)
    }
    Release() {
        this._keyframeDataItems = null;
        for (const a of this._propertyTracks)
            a.Release();
        C3$jscomp$109.clearArray(this._propertyTracks);
        this._lastKeyframeDataItem = this._trackDataItem = this._worldInfo = this._instance = this._timeline = this._propertyTracks = null
    }
    CreatePropertyTrackStates() {
        for (const a of this._trackDataItem.GetPropertyTrackData().propertyTrackDataItems())
            this._propertyTracks.push(C3$jscomp$109.PropertyTrackState.Create(this, a))
    }
    TimelineRemoved() {
        for (const a of this._propertyTracks)
            a.TimelineRemoved()
    }
    CleanCaches() {
        for (const a of this._propertyTracks)
            a.CleanCaches();
        this._worldInfo = this._instance = null
    }
    GetTimeline() {
        return this._timeline
    }
    GetRuntime() {
        return this._timeline.GetRuntime()
    }
    GetKeyframeDataItems() {
        return this._keyframeDataItems ? this._keyframeDataItems : this._keyframeDataItems = this._trackDataItem.GetKeyframeData().GetKeyframeDataItemArray()
    }
    GetPropertyTracks() {
        return this._propertyTracks
    }
    GetPropertyTrack(a) {
        for (let b = 0; b < this._propertyTracks.length; b++) {
            const c = this._propertyTracks[b];
            if (c.GetPropertyName() === a)
                return c
        }
    }
    MaybeGetInstance() {
        this._instance || this.GetInstance()
    }
    IsInstanceValid() {
        return this._instance ? !this._instance.IsDestroyed() : !1
    }
    CanInstanceBeValid() {
        if (!this.IsInstanceTrack())
            return !1;
        var a = this.GetInstanceUID();
        return (a = this.GetRuntime().GetInstanceByUID(a)) ? !a.IsDestroyed() : !1
    }
    GetObjectClass() {
        if (this.IsInstanceTrack()) {
            var a = this.GetObjectClassIndex();
            if (-1 !== a)
                return this.GetRuntime().GetObjectClassByIndex(a)
        }
    }
    GetTrackIndexInTimeline() {
        return this._timeline.GetTracks().indexOf(this)
    }
    ClearInstance() {
        this._instance = null;
        this._instanceUid = NaN;
        this._worldInfo = null;
        this._objectClassIndex = NaN
    }
    HasInstance() {
        return !!this._instance
    }
    GetInstance() {
        if (this._instance && this.IsInstanceValid())
            return this._instance;
        const a = this.GetInstanceUID();
        return this._instance = this.GetRuntime().GetInstanceByUID(a)
    }
    SetInstance(a) {
        if (this._instance !== a) {
            this.CleanCaches();
            this._instance = a;
            this._objectClassIndex = a.GetObjectClass().GetIndex();
            this._instanceUid = a.GetUID();
            this._worldInfo = a.GetWorldInfo();
            for (const f of this.propertyTrackItems()) {
                const h = f.sourceAdapter;
                switch (f.propertyTrack.GetSourceAdapterId()) {
                case "instance-variable":
                    h.GetEditorIndex();
                    var b = a.GetObjectClass()
                      , c = b.GetInstanceVariableIndexByName(f.name)
                      , d = b.GetInstanceVariableName(c);
                    b = b.GetInstanceVariableType(c);
                    d === f.name && b === f.type && h.UpdateInstanceVariableIndex(c);
                    break;
                case "behavior":
                    var e = f.behaviorType;
                    c = this.GetObjectClass();
                    d = a.GetObjectClass();
                    b = h.GetBehaviorType(d);
                    e && b && (e = e.GetName(),
                    c.GetBehaviorIndexByName(e),
                    d.GetBehaviorIndexByName(e),
                    h.GetEditorIndex(),
                    h.UpdateBehaviorTypeSid(b.GetSID()))
                }
            }
        }
    }
    *propertyTrackItems() {
        for (const c of this._propertyTracks) {
            var a = c.GetSourceAdapter()
              , b = this.GetObjectClass();
            const d = {
                propertyTrack: c,
                sourceAdapter: a
            };
            switch (c.GetSourceAdapterId()) {
            case "world-instance":
                d.property = c.GetPropertyName();
                break;
            case "instance-variable":
                a = a.GetEditorIndex();
                d.name = b.GetInstanceVariableName(a);
                d.type = b.GetInstanceVariableType(a);
                break;
            case "effect":
                b = b.GetEffectList();
                a = a.GetEffectType(b);
                d.effectType = a;
                break;
            case "behavior":
                a = a.GetBehaviorType(b);
                d.behaviorType = a;
                break;
            case "plugin":
                d.plugin = b.GetPlugin()
            }
            yield d
        }
    }
    GetWorldInfo() {
        if (this._worldInfo && this.IsInstanceValid())
            return this._worldInfo;
        const a = this.GetInstance();
        a && (this._worldInfo = a.GetWorldInfo());
        return this._worldInfo
    }
    GetTrackDataItem() {
        return this._trackDataItem
    }
    GetInstanceUID() {
        return isNaN(this._instanceUid) ? this._trackDataItem.GetInstanceUID() : this._instanceUid
    }
    SetInstanceUID(a) {
        this._trackDataItem.SetInstanceUID(a)
    }
    GetInterpolationMode() {
        return this._trackDataItem.GetInterpolationMode()
    }
    SetInterpolationMode(a) {
        this._trackDataItem.SetInterpolationMode(a)
    }
    GetResultMode() {
        return this._trackDataItem.GetResultMode()
    }
    GetId() {
        return this._trackDataItem.GetId()
    }
    GetStartOffset() {
        return this._trackDataItem.GetStartOffset()
    }
    GetLocalTotalTime() {
        return this._trackDataItem.GetLocalTotalTime()
    }
    SetLocalTotalTime(a) {
        this._trackDataItem.SetLocalTotalTime(a)
    }
    SetResultMode(a) {
        this._trackDataItem.SetResultMode(a)
    }
    SetEase(a) {
        for (const b of this.GetKeyframeDataItems())
            b.SetEase(a);
        for (const b of this.GetPropertyTracks())
            b.SetEase(a)
    }
    GetEnable() {
        return this._trackDataItem.GetEnable()
    }
    SetEnable(a) {
        this._trackDataItem.SetEnable(a)
    }
    GetObjectClassIndex() {
        return isNaN(this._objectClassIndex) ? this._trackDataItem.GetObjectClassIndex() : this._objectClassIndex
    }
    SetObjectClassIndex(a) {
        this._trackDataItem.SetObjectClassIndex(a)
    }
    SetOriginalWidth(a) {
        this._trackDataItem.SetOriginalWidth(a)
    }
    GetOriginalWidth() {
        const a = this.GetInstance();
        return a && a.GetSdkInstance().IsOriginalSizeKnown() ? a.GetSdkInstance().GetOriginalWidth() : this._trackDataItem.GetOriginalWidth()
    }
    SetOriginalHeight(a) {
        this._trackDataItem.SetOriginalHeight(a)
    }
    GetOriginalHeight() {
        const a = this.GetInstance();
        return a && a.GetSdkInstance().IsOriginalSizeKnown() ? a.GetSdkInstance().GetOriginalHeight() : this._trackDataItem.GetOriginalHeight()
    }
    GetType() {
        return this._trackDataItem.GetType()
    }
    GetName() {
        return this._trackDataItem.GetName()
    }
    IsInstanceTrack() {
        return 0 === this.GetType()
    }
    IsValueTrack() {
        return 1 === this.GetType()
    }
    IsAudioTrack() {
        return 2 === this.GetType()
    }
    GetWorldInfoChange() {
        return this._worldInfoChange
    }
    GetRenderChange() {
        return this._renderChange
    }
    GetNeedsBeforeAndAfter() {
        return this._needsBeforeAndAfter
    }
    IsNested() {
        return this._isNested
    }
    SetResetState() {
        for (const a of this._propertyTracks)
            a.SetResetState()
    }
    SetInitialState() {
        this.MaybeGetInstance();
        if (this.IsInstanceValid() || !this.IsInstanceTrack()) {
            var a = this.GetTimeline().IsForwardPlayBack() ? 0 : this.GetLocalTotalTime();
            for (const b of this._propertyTracks)
                b.SetInitialState(a),
                0 === this._worldInfoChange && 1 === b.GetWorldInfoChange() && (this._worldInfoChange = 1),
                0 === this._renderChange && 1 === b.GetRenderChange() && (this._renderChange = 1);
            this._needsBeforeAndAfter = 0;
            this._propertyTracks.some(b => b.GetNeedsBeforeAndAfter()) && (this._needsBeforeAndAfter = 1);
            this._lastKeyframeDataItem = this._GetLastKeyFrameBeforeTime(a);
            this._endStateOfNestedSet = this._initialStateOfNestedSet = !1;
            this.Interpolate(a);
            this.OnKeyframeReached(this._GetLastKeyFrameBeforeTime(a))
        }
    }
    SetResumeState() {
        this.MaybeGetInstance();
        if (this.IsInstanceValid() || !this.IsInstanceTrack()) {
            this._timeline.IsForwardPlayBack();
            var a = this._timeline.GetTime() - this.GetStartOffset();
            this._lastKeyframeDataItem = this._GetLastKeyFrameBeforeTime(a);
            for (const b of this._propertyTracks)
                b.SetResumeState(a)
        }
    }
    SetEndState() {
        if (!(this.GetTimeline().IsComplete() || (this.MaybeGetInstance(),
        !this.IsInstanceValid() && this.IsInstanceTrack() || this._isNested))) {
            const a = this._timeline.GetTime()
              , b = this.GetStartOffset() + this.GetLocalTotalTime();
            a >= b ? this.Interpolate(this.GetLocalTotalTime(), !0, !1, !0, !1, !1, !0) : 0 >= a && this.Interpolate(0, !0, !1, !0, !1, !1, !0)
        }
    }
    _SetUpdateState() {
        for (let a = 0, b = this._propertyTracks.length; a < b; a++) {
            const c = this._propertyTracks[a];
            c._SetUpdateState();
            0 === this._worldInfoChange && 1 === c.GetWorldInfoChange() && (this._worldInfoChange = 1);
            0 === this._renderChange && 1 === c.GetRenderChange() && (this._renderChange = 1)
        }
    }
    BeforeInterpolate() {
        const a = this._propertyTracks.length;
        for (let b = 0; b < a; b++)
            this._propertyTracks[b].BeforeInterpolate()
    }
    Interpolate(a, b=!1, c=!1, d=!1, e=!1, f=!1, h=!1) {
        this._instance || this.GetInstance();
        const l = this._instance && !this._instance.IsDestroyed()
          , m = 0 === this._trackDataItem._type;
        if (!(!l && m || f && m && this.GetObjectClass().IsGlobal() || (a -= this.GetStartOffset(),
        0 > a))) {
            this.MaybeSetInitialStateOfNestedTrack(a, b);
            this.MaybeTriggerKeyframeReachedConditions(a, b, e);
            for (let p = 0, r = this._propertyTracks.length; p < r; p++)
                this._propertyTracks[p].Interpolate(a, c, d, h);
            this.MaybeSetEndStateOfNestedTrack(a, b);
            0 !== this._worldInfoChange && (this._worldInfo || (this._worldInfo = this._instance.GetWorldInfo()),
            this._worldInfo && this._worldInfo.SetBboxChanged())
        }
    }
    AfterInterpolate() {
        const a = this._propertyTracks.length;
        for (let b = 0; b < a; b++)
            this._propertyTracks[b].AfterInterpolate()
    }
    MaybeSetInitialStateOfNestedTrack(a, b) {
        if (b && this._isNested && !this._initialStateOfNestedSet) {
            if (this.GetTimeline().IsForwardPlayBack()) {
                if (0 > a)
                    return
            } else if (a > this.GetLocalTotalTime())
                return;
            for (const c of this._propertyTracks)
                c.SetInitialState();
            this._initialStateOfNestedSet = !0
        }
    }
    MaybeSetEndStateOfNestedTrack(a, b) {
        if (b && this._isNested && !this._endStateOfNestedSet)
            if (this.GetTimeline().IsForwardPlayBack()) {
                if (a >= this.GetLocalTotalTime()) {
                    for (const c of this._propertyTracks)
                        c.Interpolate(this.GetLocalTotalTime(), !1, !0);
                    this._endStateOfNestedSet = !0
                }
            } else if (0 >= a) {
                for (const c of this._propertyTracks)
                    c.Interpolate(0, !1, !0);
                this._endStateOfNestedSet = !0
            }
    }
    MaybeTriggerKeyframeReachedConditions(a, b, c) {
        if (!c && b && C3$jscomp$109.Plugins.Timeline) {
            b = this.GetTimeline();
            c = this._lastKeyframeDataItem.GetNext();
            var d = this._lastKeyframeDataItem.GetTime()
              , e = c ? c.GetTime() : b.GetTotalTime();
            if (a <= d || a >= e)
                this._lastKeyframeDataItem = this._trackData.GetFirstKeyFrameDataItemLowerOrEqualThan(a, this._trackDataItem),
                b.IsForwardPlayBack() ? c && this.OnKeyframeReached(this._lastKeyframeDataItem) : (a = this._lastKeyframeDataItem.GetNext()) && this.OnKeyframeReached(a)
        }
    }
    _GetLastKeyFrameBeforeTime(a) {
        const b = this._trackData.GetKeyFrameDataItemAtTime(a, this._trackDataItem);
        return b ? b : this._trackData.GetFirstKeyFrameDataItemLowerOrEqualThan(a, this._trackDataItem)
    }
    OnKeyframeReached(a) {
        if (C3$jscomp$109.Plugins.Timeline) {
            var b = this.GetTimeline()
              , c = b.GetTimelineManager();
            C3$jscomp$109.Plugins.Timeline.Cnds.PushTriggerTimeline(b);
            C3$jscomp$109.Plugins.Timeline.Cnds.PushTriggerKeyframe(a);
            c.Trigger(C3$jscomp$109.Plugins.Timeline.Cnds.OnAnyKeyframeReached);
            c.Trigger(C3$jscomp$109.Plugins.Timeline.Cnds.OnKeyframeReached);
            C3$jscomp$109.Plugins.Timeline.Cnds.PopTriggerTimeline(b);
            C3$jscomp$109.Plugins.Timeline.Cnds.PopTriggerKeyframe(a)
        }
    }
    AddKeyframe() {
        return this._trackDataItem.GetKeyframeData().AddEmptyKeyframeDataItem()
    }
    AddPropertyTrack() {
        var a = this._trackDataItem.GetPropertyTrackData().AddEmptyPropertyTrackDataItem();
        a = C3$jscomp$109.PropertyTrackState.Create(this, a);
        this._propertyTracks.push(a);
        return a
    }
    DeleteKeyframes(a) {
        this._trackDataItem.GetKeyframeData().DeleteKeyframeDataItems(a)
    }
    DeletePropertyKeyframes(a) {
        for (const b of this._propertyTracks)
            b.DeletePropertyKeyframes(a)
    }
    SaveState() {
        for (const a of this._propertyTracks)
            a.SaveState()
    }
    CompareInitialStateWithCurrent() {
        this.MaybeGetInstance();
        if (this.IsInstanceValid() || !this.IsInstanceTrack())
            for (const a of this._propertyTracks)
                a.CompareInitialStateWithCurrent()
    }
    CompareSaveStateWithCurrent() {
        this.MaybeGetInstance();
        if (this.IsInstanceValid() || !this.IsInstanceTrack()) {
            var a = !1;
            for (const b of this._propertyTracks) {
                const c = b.CompareSaveStateWithCurrent();
                !a && c && (a = !0)
            }
            a && (a = this.AddKeyframe(),
            a.SetTime(this.GetTimeline().GetTime()),
            a.SetEase("noease"),
            a.SetEnable(!0),
            a.SetTags(""))
        }
    }
    _OnAfterLoad() {
        isNaN(this._instanceUidToLoad) || this._LoadInstanceFromJson(this._instanceUidToLoad);
        this._instanceUidToLoad = NaN
    }
    _SaveToJson() {
        var a = this.GetInstance();
        a = a ? a.GetUID() : this.GetInstanceUID();
        return {
            propertyTracksJson: this._SavePropertyTracksToJson(),
            lastKeyframeDataItemJson: this._SaveLastKeyframeDataItemToJson(),
            initialStateOfNestedSet: this._initialStateOfNestedSet,
            endStateOfNestedSet: this._endStateOfNestedSet,
            instanceUid: a
        }
    }
    _LoadFromJson(a) {
        if (a) {
            this._LoadPropertyTracksFromJson(a.propertyTracksJson);
            this._LoadLastKeyframeDataItemFromJson(a.lastKeyframeDataItemJson);
            this._instanceUidToLoad = a.instanceUid;
            this._initialStateOfNestedSet = !1;
            a.hasOwnProperty.initialStateOfNestedSet && (this._initialStateOfNestedSet = a.initialStateOfNestedSet);
            this._endStateOfNestedSet = !1;
            a.hasOwnProperty.endStateOfNestedSet && (this._endStateOfNestedSet = a.endStateOfNestedSet);
            for (const b of this._propertyTracks)
                0 === this._worldInfoChange && 1 === b.GetWorldInfoChange() && (this._worldInfoChange = 1),
                0 === this._renderChange && 1 === b.GetRenderChange() && (this._renderChange = 1);
            this._needsBeforeAndAfter = 0;
            this._propertyTracks.some(b => b.GetNeedsBeforeAndAfter()) && (this._needsBeforeAndAfter = 1)
        }
    }
    _SaveLastKeyframeDataItemToJson() {
        return this._trackDataItem.GetKeyframeData().GetKeyframeDataItemIndex(this._lastKeyframeDataItem)
    }
    _SavePropertyTracksToJson() {
        return this._propertyTracks.map(a => a._SaveToJson())
    }
    _LoadPropertyTracksFromJson(a) {
        a.forEach( (b, c) => {
            this._propertyTracks[c]._LoadFromJson(b)
        }
        )
    }
    _LoadInstanceFromJson(a) {
        C3$jscomp$109.IsFiniteNumber(a) && (a = this.GetRuntime().GetInstanceByUID(a)) && this.GetTimeline().SetTrackInstance(this._trackDataItem.GetId(), a, this.GetTrackIndexInTimeline())
    }
    _LoadLastKeyframeDataItemFromJson(a) {
        this._lastKeyframeDataItem = this._trackDataItem.GetKeyframeData().GetKeyframeDataItemFromIndex(a)
    }
}
;
"use strict";
const C3$jscomp$110 = self.C3;
C3$jscomp$110.PropertyTrackState = class extends C3$jscomp$110.DefendedBase {
    constructor(a, b) {
        super();
        this._track = a;
        this._propertyTrackDataItem = b;
        this._propertyTrackData = b.GetPropertyTrackData();
        this._needsBeforeAndAfter = this._renderChange = this._worldInfoChange = 0;
        this._sourceAdapter = this.GetSourceAdapter();
        this._propertyKeyframeDataItems = this._propertyTrackDataItem.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray();
        this._absoluteValueObject = this._lastPropertyKeyframeDataItem = null
    }
    static Create(a, b) {
        return C3$jscomp$110.New(C3$jscomp$110.PropertyTrackState, a, b)
    }
    Release() {
        this._track = null;
        this._sourceAdapter && (this._sourceAdapter.Release(),
        this._sourceAdapter = null);
        this._propertyTrackData = this._propertyTrackDataItem = this._propertyKeyframeDataItems = null
    }
    GetWorldInfoChange() {
        return this._worldInfoChange
    }
    GetRenderChange() {
        return this._renderChange
    }
    GetNeedsBeforeAndAfter() {
        return this._needsBeforeAndAfter
    }
    HasAbsoluteValueObject() {
        return !!this._absoluteValueObject
    }
    SetAbsoluteValueObject(a) {
        this._absoluteValueObject = a
    }
    GetAbsoluteValueObject() {
        return this._absoluteValueObject
    }
    GetTrack() {
        return this._track
    }
    GetPropertyTrackDataItem() {
        return this._propertyTrackDataItem
    }
    GetPropertyTrackData() {
        return this._propertyTrackData
    }
    GetTimeline() {
        return this._track.GetTimeline()
    }
    GetRuntime() {
        return this._track.GetRuntime()
    }
    GetInstance() {
        return this._track.GetInstance()
    }
    GetSourceAdapter() {
        if (this._sourceAdapter)
            return this._sourceAdapter;
        let a;
        switch (this._propertyTrackDataItem.GetSourceAdapterId()) {
        case "behavior":
            a = new C3$jscomp$110.PropertyTrackState.BehaviorSourceAdapter(this);
            break;
        case "effect":
            a = new C3$jscomp$110.PropertyTrackState.EffectSourceAdapter(this);
            this._renderChange = 1;
            break;
        case "instance-variable":
            a = new C3$jscomp$110.PropertyTrackState.InstanceVariableSourceAdapter(this);
            break;
        case "plugin":
            a = new C3$jscomp$110.PropertyTrackState.PluginSourceAdapter(this);
            this._renderChange = 1;
            break;
        case "world-instance":
            a = new C3$jscomp$110.PropertyTrackState.PropertySourceAdapter(this);
            this._worldInfoChange = this._renderChange = 1;
            break;
        case "value":
            a = new C3$jscomp$110.PropertyTrackState.ValueSourceAdapter(this);
            break;
        case "audio":
            a = new C3$jscomp$110.PropertyTrackState.AudioSourceAdapter(this)
        }
        return this._sourceAdapter = a
    }
    GetSourceAdapterId() {
        return this._propertyTrackDataItem.GetSourceAdapterId()
    }
    SetSourceAdapterId(a) {
        this._propertyTrackDataItem.SetSourceAdapterId(a)
    }
    GetSourceAdapterArgs() {
        return this._propertyTrackDataItem.GetSourceAdapterArguments()
    }
    SetSourceAdapterArgs(a) {
        this._propertyTrackDataItem.SetSourceAdapterArguments(a)
    }
    GetSourceAdapterValue() {
        return this.GetSourceAdapter().GetValue()
    }
    GetPropertyName() {
        return this._propertyTrackDataItem.GetProperty()
    }
    SetPropertyName(a) {
        this._propertyTrackDataItem.SetProperty(a)
    }
    GetPropertyType() {
        return this._propertyTrackDataItem.GetType()
    }
    SetPropertyType(a) {
        this._propertyTrackDataItem.SetType(a)
    }
    GetPropertyKeyframeType() {
        return this.GetPropertyTrackData().GetFirstPropertyKeyframeDataItem(this._propertyTrackDataItem).GetType()
    }
    GetMin() {
        return this._propertyTrackDataItem.GetMin()
    }
    SetMin(a) {
        this._propertyTrackDataItem.SetMin(a)
    }
    GetMax() {
        return this._propertyTrackDataItem.GetMax()
    }
    SetMax(a) {
        this._propertyTrackDataItem.SetMax(a)
    }
    GetEnable() {
        return this._propertyTrackDataItem.GetEnable()
    }
    SetEnable(a) {
        this._propertyTrackDataItem.SetEnable(a)
    }
    GetInterpolationMode() {
        return this._propertyTrackDataItem.GetInterpolationMode()
    }
    SetInterpolationMode(a) {
        this._propertyTrackDataItem.SetInterpolationMode(a)
    }
    GetResultMode() {
        return this._propertyTrackDataItem.GetResultMode()
    }
    SetResultMode(a) {
        this._propertyTrackDataItem.SetResultMode(a)
    }
    SetEase(a) {
        for (const b of this.GetPropertyKeyframeDataItems())
            b.SetEase(a)
    }
    CanHavePropertyKeyframes() {
        return this._propertyTrackDataItem.CanHavePropertyKeyframes()
    }
    GetPropertyKeyframeDataItems() {
        return this._propertyKeyframeDataItems ? this._propertyKeyframeDataItems : this._propertyKeyframeDataItems = this._propertyTrackDataItem.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray()
    }
    GetPropertyKeyframeDataItemArrayIncludingDisabled() {
        return this._propertyTrackDataItem.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArrayIncludingDisabled()
    }
    GetPropertyKeyFrameDataItemAtTime(a) {
        return this._propertyTrackData.GetPropertyKeyFrameDataItemAtTime(a, this._propertyTrackDataItem)
    }
    GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a) {
        return this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a, this._propertyTrackDataItem)
    }
    GetPropertyKeyframeDataItemPairForTime(a) {
        let b = this._propertyTrackData.GetPropertyKeyFrameDataItemAtTime(a, this._propertyTrackDataItem);
        b ? a = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemHigherThan(a, this._propertyTrackDataItem) : (b = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a, this._propertyTrackDataItem),
        a = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(a, this._propertyTrackDataItem));
        return {
            start: b,
            end: a
        }
    }
    *GetPropertyKeyframeValues() {
        for (const a of this.GetPropertyKeyframeDataItems())
            yield a.GetValueWithResultMode()
    }
    *GetPropertyKeyframeTimes() {
        for (const a of this.GetPropertyKeyframeDataItems())
            yield a.GetTime()
    }
    TimelineRemoved() {
        this.GetSourceAdapter().TimelineRemoved()
    }
    CleanCaches() {
        this.GetSourceAdapter().CleanCaches()
    }
    GetCurrentState() {
        return this.GetSourceAdapter().GetCurrentState()
    }
    SetResetState() {
        this.GetSourceAdapter().SetResetState()
    }
    SetInitialState(a) {
        this.GetSourceAdapter().SetInitialState();
        this._lastPropertyKeyframeDataItem = this._GetLastPropertyKeyFrameBeforeTime(a);
        this._SetUpdateState()
    }
    SetResumeState(a) {
        this.GetSourceAdapter().SetResumeState();
        this._lastPropertyKeyframeDataItem = this._GetLastPropertyKeyFrameBeforeTime(a)
    }
    _SetUpdateState() {
        var a = this.GetTrack();
        this._needsBeforeAndAfter = 0;
        if (a.IsInstanceTrack()) {
            var b = this.GetTimeline();
            a = a.GetInstance();
            const c = this.GetSourceAdapter()
              , d = this.GetPropertyName();
            c.MayNeedBeforeAndAfterInterpolate() ? (b = b.GetSimilarPropertyTracks(a, c, d, this)) && b.length && (this._needsBeforeAndAfter = 1) : this._needsBeforeAndAfter = 0
        }
    }
    _GetLastPropertyKeyFrameBeforeTime(a) {
        const b = this.GetTimeline()
          , c = this._propertyTrackData.GetPropertyKeyFrameDataItemAtTime(a, this._propertyTrackDataItem);
        return c ? c : b.IsForwardPlayBack() ? this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a, this._propertyTrackDataItem) : this._propertyTrackData.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(a, this._propertyTrackDataItem)
    }
    BeforeInterpolate() {
        this._sourceAdapter.BeforeInterpolate()
    }
    Interpolate(a, b=!1, c=!1, d=!1) {
        let e, f = !1;
        if (b)
            var h = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a, this._propertyTrackDataItem);
        else {
            if (this._lastPropertyKeyframeDataItem) {
                var l = this.GetTimeline();
                const m = this._lastPropertyKeyframeDataItem.GetNext();
                h = this._lastPropertyKeyframeDataItem.GetTime();
                l = m ? m.GetTime() : l.GetTotalTime();
                if (a <= h || a >= l)
                    this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a, this._propertyTrackDataItem),
                    f = !0
            } else
                this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a, this._propertyTrackDataItem),
                f = !0;
            h = this._lastPropertyKeyframeDataItem
        }
        h && (e = h.GetNext());
        this._sourceAdapter.Interpolate(a, h, e, b, c, d, f)
    }
    GetInterpolatedValue(a) {
        if (this._lastPropertyKeyframeDataItem) {
            var b = this.GetTimeline();
            const d = this._lastPropertyKeyframeDataItem.GetNext();
            var c = this._lastPropertyKeyframeDataItem.GetTime();
            b = d ? d.GetTime() : b.GetTotalTime();
            if (a <= c || a >= b)
                this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a, this._propertyTrackDataItem)
        } else
            this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a, this._propertyTrackDataItem);
        c = this._lastPropertyKeyframeDataItem;
        b = c.GetNext();
        return this._sourceAdapter.GetInterpolatedValue(a, c, b)
    }
    GetInterpolatedValueFast(a, b, c) {
        return this._sourceAdapter.GetInterpolatedValue(a, b, c)
    }
    AfterInterpolate() {
        this._sourceAdapter.AfterInterpolate()
    }
    static GetStartPropertyKeyframeForTime(a, b) {
        const c = b.GetPropertyTrackDataItem();
        return b._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a, c)
    }
    static GetEndPropertyKeyframeForTime(a, b) {
        const c = b.GetPropertyTrackDataItem();
        return b._propertyTrackData.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(a, c)
    }
    AddPropertyKeyframe() {
        const a = this._propertyTrackDataItem.GetPropertyKeyframeData().AddEmptyPropertyKeyframeDataItem();
        this._lastPropertyKeyframeDataItem = null;
        return a
    }
    DeletePropertyKeyframes(a) {
        this._lastPropertyKeyframeDataItem = null;
        this._propertyTrackDataItem.GetPropertyKeyframeData().DeletePropertyKeyframeDataItems(a)
    }
    SaveState() {
        this.GetSourceAdapter().SaveState()
    }
    CompareInitialStateWithCurrent() {
        if (this.GetSourceAdapter().CompareInitialStateWithCurrent()) {
            const a = this._propertyTrackData.GetFirstPropertyKeyframeDataItem(this._propertyTrackDataItem)
              , b = this.GetSourceAdapter().GetCurrentState();
            a.SetAbsoluteValue(b)
        }
    }
    CompareSaveStateWithCurrent() {
        const a = this.GetSourceAdapter().CompareSaveStateWithCurrent();
        a && this.AddPropertyKeyframeAtCurrentTime();
        this.GetSourceAdapter().ClearSaveState();
        return a
    }
    AddPropertyKeyframeAtCurrentTime() {
        const a = this.GetTimeline().GetTime()
          , b = this.GetSourceAdapter()
          , c = C3$jscomp$110.PropertyTrackState.GetStartPropertyKeyframeForTime(a, this)
          , d = this.AddPropertyKeyframe();
        d.SetType(c.GetType());
        d.SetTime(a);
        d.SetEase(c.GetEase());
        d.SetEnable(!0);
        d.SetValue(b.GetValueAtTime());
        d.SetAbsoluteValue(b.GetCurrentState())
    }
    _SaveToJson() {
        return {
            sourceAdapterJson: this.GetSourceAdapter()._SaveToJson()
        }
    }
    _LoadFromJson(a) {
        a && this.GetSourceAdapter()._LoadFromJson(a.sourceAdapterJson)
    }
}
;
"use strict";
const NS = self.C3.PropertyTrackState;
NS.PropertySourceAdapter = class {
    constructor(a) {
        this._propertyTrack = a;
        this._propertyAdapter = null;
        this.GetPropertyAdapter()
    }
    Release() {
        this._propertyAdapter && (this._propertyAdapter.Release(),
        this._propertyAdapter = null);
        this._propertyTrack = null
    }
    MayNeedBeforeAndAfterInterpolate() {
        return this._propertyAdapter.MayNeedBeforeAndAfterInterpolate()
    }
    GetPropertyTrack() {
        return this._propertyTrack
    }
    TimelineRemoved() {
        this._propertyAdapter && this._propertyAdapter.TimelineRemoved()
    }
    CleanCaches() {
        this._propertyAdapter && this._propertyAdapter.CleanCaches()
    }
    GetPropertyAdapter() {
        return this._propertyAdapter ? this._propertyAdapter : this._propertyAdapter = this._CreatePropertyAdapter()
    }
    GetEditorIndex() {}
    GetIndex() {
        return this.GetEditorIndex()
    }
    GetTarget() {}
    SetResetState() {
        this.GetPropertyAdapter().SetResetState()
    }
    SetInitialState() {
        this.GetPropertyAdapter().SetInitialState()
    }
    SetResumeState() {
        this.GetPropertyAdapter().SetResumeState()
    }
    BeforeInterpolate() {
        this._propertyAdapter.BeforeChangeProperty()
    }
    Interpolate(a, b, c, d, e, f, h) {
        let l;
        switch (this._propertyTrack.GetPropertyKeyframeType()) {
        case "numeric":
            l = NS.NumericTypeAdapter.Interpolate(a, b, c, this._propertyTrack);
            break;
        case "angle":
            l = NS.AngleTypeAdapter.Interpolate(a, b, c, this._propertyTrack);
            break;
        case "boolean":
            l = NS.BooleanTypeAdapter.Interpolate(a, b, c, this._propertyTrack);
            break;
        case "color":
            l = NS.ColorTypeAdapter.Interpolate(a, b, c, this._propertyTrack);
            break;
        case "text":
            l = NS.TextTypeAdapter.Interpolate(a, b, c, this._propertyTrack)
        }
        this._propertyAdapter.ChangeProperty(a, l, b, c, d, e, f, h)
    }
    GetInterpolatedValue(a, b, c) {
        switch (this._propertyTrack.GetPropertyKeyframeType()) {
        case "numeric":
            return NS.NumericTypeAdapter.Interpolate(a, b, c, this._propertyTrack);
        case "angle":
            return NS.AngleTypeAdapter.Interpolate(a, b, c, this._propertyTrack);
        case "boolean":
            return NS.BooleanTypeAdapter.Interpolate(a, b, c, this._propertyTrack);
        case "color":
            return NS.ColorTypeAdapter.Interpolate(a, b, c, this._propertyTrack);
        case "text":
            return NS.TextTypeAdapter.Interpolate(a, b, c, this._propertyTrack)
        }
    }
    AfterInterpolate() {
        this._propertyAdapter.AfterChangeProperty()
    }
    SaveState() {
        this.GetPropertyAdapter().SetSaveState()
    }
    ClearSaveState() {
        this.GetPropertyAdapter().ClearSaveState()
    }
    GetCurrentState() {
        return this.GetPropertyAdapter().GetCurrentState()
    }
    CompareInitialStateWithCurrent() {
        return this.GetPropertyAdapter().CompareInitialStateWithCurrent()
    }
    CompareSaveStateWithCurrent() {
        return this.GetPropertyAdapter().CompareSaveStateWithCurrent()
    }
    GetValueAtTime() {
        const a = this._propertyTrack
          , b = a.GetTrack().GetTimeline().GetTime()
          , c = NS.GetStartPropertyKeyframeForTime(b, a)
          , d = c.GetNext();
        switch (a.GetPropertyKeyframeType()) {
        case "numeric":
            return NS.NumericTypeAdapter.Interpolate(b, c, d, a);
        case "angle":
            return NS.AngleTypeAdapter.Interpolate(b, c, d, a);
        case "boolean":
            return NS.BooleanTypeAdapter.Interpolate(b, c, d, a);
        case "color":
            return NS.ColorTypeAdapter.Interpolate(b, c, d, a);
        case "text":
            return NS.TextTypeAdapter.Interpolate(b, c, d, a)
        }
    }
    _CreatePropertyAdapter() {
        const a = this._propertyTrack;
        switch (a.CanHavePropertyKeyframes() ? a.GetPropertyKeyframeType() : "") {
        case "combo":
        case "boolean":
        case "text":
        case "string":
            return new NS.PropertyInterpolationAdapter.NoInterpolationAdapter(this);
        case "numeric":
        case "number":
        case "angle":
            return "combo" === this._propertyTrack.GetPropertyType() ? new NS.PropertyInterpolationAdapter.NoInterpolationAdapter(this) : new NS.PropertyInterpolationAdapter.NumericInterpolationAdapter(this);
        case "color":
        case "offsetColor":
            return new NS.PropertyInterpolationAdapter.ColorInterpolationAdapter(this);
        default:
            return new NS.PropertyInterpolationAdapter.NumericInterpolationAdapter(this)
        }
    }
    _SaveToJson() {
        return {
            propertyAdapterJson: this.GetPropertyAdapter()._SaveToJson()
        }
    }
    _LoadFromJson(a) {
        a && this.GetPropertyAdapter()._LoadFromJson(a.propertyAdapterJson)
    }
}
;
"use strict";
const C3$jscomp$112 = self.C3;
class InstanceVariableSourceAdapter extends C3$jscomp$112.PropertyTrackState.PropertySourceAdapter {
    constructor(a) {
        super(a);
        this._updatedIndex = NaN
    }
    GetEditorIndex() {
        return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[0]
    }
    GetIndex() {
        return this._updatedIndex ? this._updatedIndex : super.GetIndex()
    }
    GetTarget() {
        return this._propertyTrack.GetTrack().GetInstance()
    }
    UpdateInstanceVariableIndex(a) {
        this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[0] !== a && (this._updatedIndex = a)
    }
    Interpolate(a, b, c, d, e, f, h) {
        this.GetPropertyAdapter().CanChange(b.GetValue()) && super.Interpolate(a, b, c, d, e, f, h)
    }
    GetInterpolatedValue(a, b, c) {
        if (this.GetPropertyAdapter().CanChange(b.GetValue()))
            return super.GetInterpolatedValue(a, b, c)
    }
    _SaveToJson() {
        return Object.assign(super._SaveToJson(), {
            index: this._updatedIndex
        })
    }
    _LoadFromJson(a) {
        a && (super._LoadFromJson(a),
        this._updatedIndex = a.index)
    }
}
C3$jscomp$112.PropertyTrackState.InstanceVariableSourceAdapter = InstanceVariableSourceAdapter;
"use strict";
const C3$jscomp$113 = self.C3;
class BehaviorSourceAdapter extends C3$jscomp$113.PropertyTrackState.PropertySourceAdapter {
    constructor(a) {
        super(a);
        this._sid = NaN
    }
    GetEditorIndex() {
        return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[1]
    }
    GetTarget() {
        var a = this._propertyTrack.GetPropertyTrackDataItem()
          , b = this._propertyTrack.GetTrack();
        a = this._sid ? this._sid : a.GetSourceAdapterArguments()[0];
        b = b.GetInstance();
        a = b.GetBehaviorIndexBySID(a);
        return b.GetBehaviorInstances()[a].GetSdkInstance()
    }
    GetBehaviorType(a) {
        const b = this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[2];
        return a.GetBehaviorTypeByName(b)
    }
    UpdateBehaviorTypeSid(a) {
        this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[0] !== a && (this._sid = a)
    }
    Interpolate(a, b, c, d, e, f, h) {
        const l = this._propertyTrack.GetTrack().GetInstance();
        this.GetBehaviorType(l.GetObjectClass()) && super.Interpolate(a, b, c, d, e, f, h)
    }
    GetInterpolatedValue(a, b, c) {
        const d = this._propertyTrack.GetTrack().GetInstance();
        if (this.GetBehaviorType(d.GetObjectClass()))
            return super.GetInterpolatedValue(a, b, c)
    }
    _SaveToJson() {
        return Object.assign(super._SaveToJson(), {
            sid: this._sid
        })
    }
    _LoadFromJson(a) {
        a && (super._LoadFromJson(a),
        this._sid = a.sid)
    }
}
C3$jscomp$113.PropertyTrackState.BehaviorSourceAdapter = BehaviorSourceAdapter;
"use strict";
const C3$jscomp$114 = self.C3;
class EffectSourceAdapter extends C3$jscomp$114.PropertyTrackState.PropertySourceAdapter {
    constructor(a) {
        super(a)
    }
    GetEditorIndex() {
        return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[1]
    }
    GetTarget() {
        const a = this._propertyTrack.GetTrack().GetWorldInfo().GetInstanceEffectList();
        var b = a.GetEffectList();
        b = this.GetEffectType(b).GetIndex();
        return a.IsEffectIndexActive(b) ? a.GetEffectParametersForIndex(b) : null
    }
    GetEffectType(a) {
        const b = this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[0];
        return a.GetEffectTypeByName(b)
    }
    Interpolate(a, b, c, d, e, f, h) {
        this._IsEffectActive() && super.Interpolate(a, b, c, d, e, f, h)
    }
    GetInterpolatedValue(a, b, c) {
        if (this._IsEffectActive())
            return super.GetInterpolatedValue(a, b, c)
    }
    _IsEffectActive() {
        const a = this._propertyTrack.GetTrack().GetWorldInfo().GetInstanceEffectList();
        var b = a.GetEffectList();
        if (b = this.GetEffectType(b))
            return b = b.GetIndex(),
            a.IsEffectIndexActive(b)
    }
}
C3$jscomp$114.PropertyTrackState.EffectSourceAdapter = EffectSourceAdapter;
"use strict";
const C3$jscomp$115 = self.C3;
class PluginSourceAdapter extends C3$jscomp$115.PropertyTrackState.PropertySourceAdapter {
    constructor(a) {
        super(a)
    }
    GetEditorIndex() {
        return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[0]
    }
    GetTarget() {
        return this._propertyTrack.GetTrack().GetInstance().GetSdkInstance()
    }
    Interpolate(a, b, c, d, e, f, h) {
        var l = this._propertyTrack.GetTrack();
        const m = l.GetObjectClass().GetPlugin();
        l = l.GetInstance().GetObjectClass().GetPlugin();
        m === l && super.Interpolate(a, b, c, d, e, f, h)
    }
    GetInterpolatedValue(a, b, c) {
        var d = this._propertyTrack.GetTrack();
        const e = d.GetObjectClass().GetPlugin();
        d = d.GetInstance().GetObjectClass().GetPlugin();
        if (e === d)
            return super.GetInterpolatedValue(a, b, c)
    }
    GetOptionalCallbacks() {
        const a = this._propertyTrack.GetTrack().GetObjectClass().GetPlugin();
        if (C3$jscomp$115.Plugins.Sprite && a instanceof C3$jscomp$115.Plugins.Sprite && ("initial-frame" === this._propertyTrack.GetPropertyName() || "initial-animation" === this._propertyTrack.GetPropertyName()))
            switch (this._propertyTrack.GetResultMode()) {
            case "relative":
                return null;
            case "absolute":
                return null
            }
    }
}
C3$jscomp$115.PropertyTrackState.PluginSourceAdapter = PluginSourceAdapter;
"use strict";
const C3$jscomp$116 = self.C3;
class ValueSourceAdapter extends C3$jscomp$116.PropertyTrackState.PropertySourceAdapter {
    constructor(a) {
        super(a);
        this._value = 0;
        this._init = !1
    }
    MayNeedBeforeAndAfterInterpolate() {
        return !1
    }
    SetInitialState() {
        const a = this._propertyTrack.GetPropertyTrackData();
        let b = this._propertyTrack.GetPropertyTrackDataItem();
        b = a.GetFirstPropertyKeyframeDataItem(b);
        this._value = b.GetValueWithResultMode()
    }
    SetResumeState() {}
    GetValue() {
        this._init || this._propertyTrack.Interpolate(0);
        return this._value
    }
    Interpolate(a, b, c, d, e, f, h) {
        this._value = C3$jscomp$116.PropertyTrackState.NumericTypeAdapter.Interpolate(a, b, c, this._propertyTrack);
        this._init = !0
    }
    SaveState() {}
    ClearSaveState() {}
    GetCurrentState() {
        return this._value
    }
    CompareInitialStateWithCurrent() {
        return !1
    }
    CompareSaveStateWithCurrent() {
        return !1
    }
    _SaveToJson() {
        return {
            value: this._value,
            init: this._init
        }
    }
    _LoadFromJson(a) {
        a && (this._value = a.value,
        this._init = a.hasOwnProperty("init") ? a.init : !0)
    }
}
C3$jscomp$116.PropertyTrackState.ValueSourceAdapter = ValueSourceAdapter;
"use strict";
const C3$jscomp$117 = self.C3;
class AudioSourceAdapter extends C3$jscomp$117.PropertyTrackState.PropertySourceAdapter {
    constructor(a) {
        super(a);
        this._audioPlaybackStarted = !1;
        this._expressions = this._actions = this._sdkInstance = null;
        this._timeline = this._propertyTrack.GetTimeline();
        this._track = this._propertyTrack.GetTrack();
        this._sourceAdapterArgs = this._propertyTrack.GetSourceAdapterArgs();
        this._fileArgs = this._sourceAdapterArgs[0];
        this._startOffsetTime = this._sourceAdapterArgs[1];
        this._audioTag = this._sourceAdapterArgs[3] ? this._sourceAdapterArgs[3] : Math.random().toString(36).slice(2);
        this._volume = this._pauseVolume = this._pauseTime = NaN;
        this._audioSource = null;
        this._Initialize()
    }
    Release() {
        super.Release();
        this._audioSource = this._fileArgs = this._sourceAdapterArgs = this._track = this._timeline = this._expressions = this._actions = this._sdkInstance = null
    }
    _Initialize() {
        if (self.C3.Plugins.Audio) {
            var a = this._propertyTrack.GetRuntime().GetSingleGlobalObjectClassByCtor(self.C3.Plugins.Audio);
            a && (this._sdkInstance = a.GetSingleGlobalInstance().GetSdkInstance());
            this._actions = self.C3.Plugins.Audio.Acts;
            this._expressions = self.C3.Plugins.Audio.Exps
        }
    }
    _MaybeSetAudioSource() {
        if (!this._audioSource) {
            var a = this._propertyTrack.GetTrack().GetPropertyTrack("audioSource");
            a && (this._audioSource = a.GetSourceAdapter())
        }
    }
    _GetPauseVolume() {
        const a = this._propertyTrack.GetTrack().GetPropertyTrack("volume");
        return a ? a.GetSourceAdapter()._pauseVolume : this._pauseVolume
    }
    TimelineRemoved() {
        super.TimelineRemoved();
        this._audioPlaybackStarted = !1;
        this._sdkInstance && (this._expressions && (this._pauseTime = this._expressions.PlaybackTime.call(this._sdkInstance, this._audioTag),
        this._pauseVolume = this._expressions.Volume.call(this._sdkInstance, this._audioTag)),
        this._actions && this._actions.Stop.call(this._sdkInstance, this._audioTag))
    }
    GetAudioTag() {
        return this._audioTag
    }
    GetVolume() {
        return this._volume
    }
    SetVolume(a) {
        this._volume = a
    }
    SetInitialState() {
        super.SetInitialState();
        this._pauseTime = NaN;
        this._audioPlaybackStarted = !1
    }
    SetResumeState() {
        super.SetResumeState();
        const a = this._propertyTrack.GetTimeline().GetTime();
        this._pauseTime = a - this._startOffsetTime;
        switch (this._propertyTrack.GetPropertyName()) {
        case "volume":
            this._pauseVolume = this._propertyTrack.GetInterpolatedValue(a)
        }
        this._audioPlaybackStarted = !1
    }
    Interpolate(a, b, c, d, e, f, h) {
        if (this._sdkInstance)
            switch (this._propertyTrack.GetPropertyName()) {
            case "audioSource":
                if (!this._timeline.IsForwardPlayBack())
                    break;
                if (d) {
                    this._actions && this._actions.Stop.call(this._sdkInstance, this._audioTag);
                    break
                }
                if (a < this._startOffsetTime) {
                    this._audioPlaybackStarted = !1;
                    break
                }
                b = this._expressions.PlaybackRate.call(this._sdkInstance, this._audioTag);
                c = this._timeline.GetPlaybackRate();
                c !== b && this._actions.SetPlaybackRate.call(this._sdkInstance, this._audioTag, c);
                if (this._audioPlaybackStarted)
                    break;
                if (!this._propertyTrack.GetTimeline().IsPlaying())
                    break;
                this._audioPlaybackStarted = !0;
                isNaN(this._pauseTime) ? (b = self.performance.now(),
                c = a - this._startOffsetTime,
                "suspended" === this._sdkInstance.GetAudioContextState() ? this._audioPlaybackStarted = !1 : (a = self.performance.now(),
                a = c + (a - b) / 1E3,
                this._actions && (b = this.GetVolume(),
                isNaN(b) ? (this.SetVolume(0),
                b = 0) : this.SetVolume(b),
                this._actions.PlayFromTimeline.call(this._sdkInstance, this._fileArgs, b, this._audioTag, a)))) : (a = this._pauseTime,
                this._pauseTime = NaN,
                b = this._GetPauseVolume(),
                this._pauseVolume = NaN,
                "suspended" === this._sdkInstance.GetAudioContextState() ? this._audioPlaybackStarted = !1 : this._actions && (this.SetVolume(b),
                this._actions.PlayFromTimeline.call(this._sdkInstance, this._fileArgs, b, this._audioTag, a)));
                break;
            case "volume":
                this._MaybeSetAudioSource(),
                super.Interpolate(a, b, c, d, e, f, h)
            }
    }
    GetInterpolatedValue(a, b, c) {
        if (this._sdkInstance)
            switch (this._propertyTrack.GetPropertyName()) {
            case "volume":
                return this._MaybeSetAudioSource(),
                super.GetInterpolatedValue(a, b, c)
            }
    }
    Getter(a, b) {
        return this._audioSource ? this._audioSource.GetVolume() : 0
    }
    Setter(a, b, c, d) {
        this._audioSource && this._audioSource.SetVolume(this.Getter() + b);
        this._actions && this._audioSource && this._actions.SetVolume.call(this._sdkInstance, this._audioSource.GetAudioTag(), this._audioSource.GetVolume())
    }
    AbsoluteSetter(a, b, c) {
        this._audioSource && this._audioSource.SetVolume(b);
        this._actions && this._audioSource && this._actions.SetVolume.call(this._sdkInstance, this._audioSource.GetAudioTag(), this._audioSource.GetVolume())
    }
    DoesRounding() {
        return !0
    }
    _SaveToJson() {
        return {
            audioPlaybackStarted: this._audioPlaybackStarted,
            audioTag: this._audioTag,
            pauseTime: this._pauseTime,
            pauseVolume: this._pauseVolume,
            volume: this._volume
        }
    }
    _LoadFromJson(a) {
        a && (this._audioPlaybackStarted = a.audioPlaybackStarted,
        this._audioTag = a.audioTag,
        this._pauseTime = a.pauseTime,
        this._pauseVolume = a.pauseVolume,
        this._volume = a.volume,
        this._Initialize())
    }
}
C3$jscomp$117.PropertyTrackState.AudioSourceAdapter = AudioSourceAdapter;
"use strict";
self.C3.PropertyTrackState.PropertyInterpolationAdapter = class {
    constructor(a) {
        this._sourceAdapter = a;
        this._propertyTrack = a.GetPropertyTrack();
        this._worldInfo = this._propertyTrack.GetTrack().GetWorldInfo();
        this._property = this._propertyTrack.GetPropertyName();
        this._firstAbsoluteUpdate = !1;
        this._target = this._saveState = null
    }
    Release() {
        this._target = this._saveState = this._worldInfo = this._propertyTrack = this._sourceAdapter = null
    }
    MayNeedBeforeAndAfterInterpolate() {
        return !1
    }
    TimelineRemoved() {}
    CleanCaches() {
        this._target = this._saveState = this._worldInfo = null
    }
    GetSourceAdapter() {
        return this._sourceAdapter
    }
    GetPropertyTrack() {
        return this._propertyTrack
    }
    GetWorldInfo() {
        return this._worldInfo ? this._worldInfo : this._worldInfo = this._propertyTrack.GetTrack().GetWorldInfo()
    }
    SetFirstAbsoluteUpdate(a) {
        this._firstAbsoluteUpdate = !!a
    }
    GetFirstAbsoluteUpdate() {
        return this._firstAbsoluteUpdate
    }
    SetResetState() {}
    SetInitialState() {}
    SetResumeState() {}
    SetSaveState() {
        this._saveState = this.GetCurrentState()
    }
    ClearSaveState() {
        this._saveState = null
    }
    GetCurrentState() {}
    CompareInitialStateWithCurrent() {}
    CompareSaveStateWithCurrent() {}
    CanChange(a) {
        return typeof this._Getter() === typeof a
    }
    BeforeChangeProperty() {}
    ChangeProperty(a, b, c, d, e, f, h, l) {}
    AfterChangeProperty() {}
    _FirstKeyframeGetter() {
        return this._PickTimelinePlaybackMode( () => {
            const a = this._propertyTrack.GetPropertyTrackDataItem();
            return this._propertyTrack.GetPropertyTrackData().GetFirstPropertyKeyframeDataItem(a)
        }
        , () => {
            const a = this._propertyTrack.GetPropertyTrackDataItem();
            return this._propertyTrack.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(a)
        }
        ).GetAbsoluteValue()
    }
    _CurrentKeyframeGetter() {
        const a = this._propertyTrack.GetTimeline().GetTime() - this._propertyTrack.GetTrack().GetStartOffset();
        return this._PickTimelinePlaybackMode( () => {
            const b = this._propertyTrack.GetPropertyTrackDataItem();
            return this._propertyTrack.GetPropertyTrackData().GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a, b)
        }
        , () => {
            const b = this._propertyTrack.GetPropertyTrackDataItem()
              , c = this._propertyTrack.GetPropertyTrackData()
              , d = c.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(a, b);
            return d ? d : c.GetLastPropertyKeyframeDataItem(b)
        }
        ).GetAbsoluteValue()
    }
    _PickTimelinePlaybackMode(a, b) {
        return this._propertyTrack.GetTimeline().IsForwardPlayBack() ? a() : b()
    }
    _PickResultMode(a, b) {
        return "relative" === this._propertyTrack.GetResultMode() ? a() : b()
    }
    _PickFirstAbsoluteUpdate(a, b) {
        return this.GetFirstAbsoluteUpdate() ? (this.SetFirstAbsoluteUpdate(!1),
        a()) : b()
    }
    _GetAbsoluteInitialValue(a) {}
    _GetIndex() {
        return this._sourceAdapter.GetIndex()
    }
    _GetTarget() {
        return this._target ? this._target : this._target = this._sourceAdapter.GetTarget()
    }
    _PickSource(a, b, c, d, e, f) {
        switch (this._propertyTrack.GetSourceAdapterId()) {
        case "behavior":
            return a();
        case "effect":
            return b();
        case "instance-variable":
            return c();
        case "plugin":
            return d();
        case "world-instance":
            return e();
        case "audio":
            return f()
        }
    }
    _SaveToJson() {
        return {
            firstAbsoluteUpdate: this._firstAbsoluteUpdate,
            saveState: this._saveState
        }
    }
    _LoadFromJson(a) {
        a && (this._firstAbsoluteUpdate = a.firstAbsoluteUpdate,
        this._saveState = a.saveState)
    }
    _GetPropertyKeyframeStubs(a, b=!1) {
        const c = [];
        for (const d of a) {
            a = d.GetTrack().GetStartOffset();
            for (const e of d.GetPropertyKeyframeDataItems())
                b && 0 === e.GetTime() ? c.push({
                    time: a + e.GetTime(),
                    value: e.GetAbsoluteValue()
                }) : b || c.push({
                    time: a + e.GetTime(),
                    value: e.GetAbsoluteValue()
                })
        }
        return c.sort( (d, e) => d.time - e.time)
    }
    _GetLastPropertyKeyframeStub(a, b, c) {
        return this._GetPropertyKeyframeStubLowerThanPlayhead(b, c)
    }
    _GetPropertyKeyframeStubLowerThanPlayhead(a, b) {
        for (let c = b.length - 1; 0 <= c; c--)
            if (b[c].time <= a)
                return b[c];
        return null
    }
}
;
"use strict";
const C3$jscomp$119 = self.C3
  , TMP_COLORS_MAP = new Map
  , TMP_COLOR = [0, 0, 0];
class ColorInterpolationAdapter extends C3$jscomp$119.PropertyTrackState.PropertyInterpolationAdapter {
    constructor(a) {
        super(a)
    }
    SetResetState() {}
    SetInitialState() {}
    SetResumeState() {}
    GetCurrentState() {
        const a = this._propertyTrack.GetSourceAdapterId()
          , b = this._GetTarget()
          , c = this._GetIndex();
        switch (a) {
        case "behavior":
            return this._ToColorArray(b.GetPropertyValueByIndex(c));
        case "effect":
            return this._ToColorArray(b[c]);
        case "plugin":
            return this._ToColorArray(b.GetPropertyValueByIndex(c));
        case "world-instance":
            return this._ToColorArray(this._Getter())
        }
    }
    CompareInitialStateWithCurrent() {
        const a = this._FirstKeyframeGetter();
        return !this._CompareColors(a, this._Getter())
    }
    CompareSaveStateWithCurrent() {
        return C3$jscomp$119.IsNullOrUndefined(this._saveState) ? !1 : !this._CompareColors(this._saveState, this._Getter())
    }
    _CompareColors(a, b) {
        a = this._GetColorFromArray(a);
        b = this._GetColorFromArray(b);
        return a.equalsIgnoringAlpha(b)
    }
    _FirstKeyframeGetter() {
        const a = super._FirstKeyframeGetter();
        return this._GetColorFromArray(a)
    }
    _CurrentKeyframeGetter() {
        const a = super._CurrentKeyframeGetter();
        return this._GetColorFromArray(a)
    }
    _GetAbsoluteInitialValue(a) {}
    _ToColorArray(a) {
        return C3$jscomp$119.IsInstanceOf(a, C3$jscomp$119.Color) ? a.toArray().slice(0, 3) : a.slice(0, 3)
    }
    _GetColorFromArray(a) {
        return C3$jscomp$119.IsInstanceOf(a, C3$jscomp$119.Color) ? a : new C3$jscomp$119.Color(a[0],a[1],a[2],1)
    }
    CanChange(a) {
        return !0
    }
    MayNeedBeforeAndAfterInterpolate() {
        return !0
    }
    BeforeChangeProperty() {
        var a = this._propertyTrack.GetTimeline()
          , b = this._propertyTrack.GetInstance();
        const c = this._propertyTrack.GetSourceAdapter();
        (a = a.GetSimilarPropertyTracks(b, c, this._property, this._propertyTrack)) && 1 < a.length && (TMP_COLORS_MAP.has(b) || TMP_COLORS_MAP.set(b, new Map),
        b = TMP_COLORS_MAP.get(b),
        a = this._propertyTrack.GetSourceAdapterId(),
        b.has(a) || b.set(a, new Map),
        b = b.get(a),
        b.has(this._property) || b.set(this._property, {
            used: !1,
            color: new C3$jscomp$119.Color(0,0,0,1)
        }))
    }
    _GetTmpColor(a, b, c) {
        a = TMP_COLORS_MAP.get(a).get(b).get(c);
        a.used = !0;
        return a.color
    }
    ChangeProperty(a, b, c, d, e, f, h, l) {
        e = this._propertyTrack.GetTimeline();
        d = this._propertyTrack.GetTrack();
        a = this._propertyTrack.GetInstance();
        f = this._propertyTrack.GetSourceAdapter();
        c = this._propertyTrack.GetSourceAdapterId();
        if ((f = e.GetSimilarPropertyTracks(a, f, this._property, this._propertyTrack)) && 1 < f.length) {
            if (f = this._GetPropertyKeyframeStubs(f, !0),
            e = this._GetLastPropertyKeyframeStub(e, e.GetTime(), f))
                d = d.GetStartOffset(),
                f = e.time - d,
                0 === f ? this._GetTmpColor(a, c, this._property).addRgb(b[0], b[1], b[2]) : 0 > f || (e = b[0],
                d = b[1],
                b = b[2],
                f = this._propertyTrack.Interpolate(f, !1, !0),
                e = C3$jscomp$119.Color.DiffChannel(e, f[0]),
                d = C3$jscomp$119.Color.DiffChannel(d, f[1]),
                b = C3$jscomp$119.Color.DiffChannel(b, f[2]),
                this._GetTmpColor(a, c, this._property).addRgb(e, d, b))
        } else
            this._Setter(b[0], b[1], b[2])
    }
    AfterChangeProperty() {
        const a = this._propertyTrack.GetInstance();
        if (TMP_COLORS_MAP.has(a)) {
            var b = TMP_COLORS_MAP.get(a)
              , c = this._propertyTrack.GetSourceAdapterId();
            if (b.has(c)) {
                var d = b.get(c);
                if (d.has(this._property)) {
                    var e = d.get(this._property)
                      , f = e.color;
                    e.used && this._Setter(f.getR(), f.getG(), f.getB());
                    0 === d.size && b.delete(c);
                    0 === b.size && TMP_COLORS_MAP.delete(a)
                }
            }
        }
    }
    _Getter() {
        const a = this._propertyTrack.GetSourceAdapterId()
          , b = this._GetTarget()
          , c = this._GetIndex();
        switch (a) {
        case "behavior":
            return this._GetColorFromArray(b.GetPropertyValueByIndex(c));
        case "effect":
            return b[c].clone();
        case "plugin":
            return this._GetColorFromArray(b.GetPropertyValueByIndex(c));
        case "world-instance":
            return this.GetWorldInfo().GetUnpremultipliedColor().clone()
        }
    }
    _Setter(a, b, c) {
        const d = this._propertyTrack.GetSourceAdapterId()
          , e = this._GetTarget()
          , f = this._GetIndex();
        switch (d) {
        case "behavior":
            TMP_COLOR[0] = a;
            TMP_COLOR[1] = b;
            TMP_COLOR[2] = c;
            e.SetPropertyValueByIndex(f, TMP_COLOR);
            break;
        case "effect":
            e[f].setRgb(a, b, c);
            break;
        case "plugin":
            TMP_COLOR[0] = a;
            TMP_COLOR[1] = b;
            TMP_COLOR[2] = c;
            e.SetPropertyValueByIndex(f, TMP_COLOR);
            break;
        case "world-instance":
            this.GetWorldInfo().SetUnpremultipliedColorRGB(a, b, c)
        }
    }
    _SaveToJson() {}
    _LoadFromJson(a) {}
}
C3$jscomp$119.PropertyTrackState.PropertyInterpolationAdapter.ColorInterpolationAdapter = ColorInterpolationAdapter;
"use strict";
const C3$jscomp$120 = self.C3
  , NS$jscomp$1 = C3$jscomp$120.PropertyTrackState;
class NoInterpolationAdapter extends C3$jscomp$120.PropertyTrackState.PropertyInterpolationAdapter {
    constructor(a) {
        super(a)
    }
    SetResetState() {}
    SetInitialState() {}
    SetResumeState() {}
    GetCurrentState() {
        return this._Getter()
    }
    CompareInitialStateWithCurrent() {
        return this._FirstKeyframeGetter() !== this.GetCurrentState()
    }
    CompareSaveStateWithCurrent() {
        return C3$jscomp$120.IsNullOrUndefined(this._saveState) ? !1 : this._saveState !== this.GetCurrentState()
    }
    MayNeedBeforeAndAfterInterpolate() {
        return !1
    }
    ChangeProperty(a, b, c, d, e, f, h, l) {
        c = this._propertyTrack;
        f = c.GetTrack();
        d = c.GetSourceAdapterId();
        e = c.GetTimeline();
        h = f.GetInstance();
        l = c.GetSourceAdapter();
        (h = e.GetSimilarPropertyTracks(h, l, this._property, c)) && 1 < h.length && (h = this._GetPropertyKeyframeStubs(h),
        a += f.GetStartOffset(),
        a = this._GetLastPropertyKeyframeStub(e, a, h)) && (b = a.value);
        switch (c.GetPropertyKeyframeType()) {
        case "numeric":
            if (!NS$jscomp$1.NumericTypeAdapter.WillChange(this._GetIndex(), this._GetTarget(), b, d))
                return;
            break;
        case "angle":
            if (!NS$jscomp$1.AngleTypeAdapter.WillChange(this._GetIndex(), this._GetTarget(), b, d))
                return;
            break;
        case "boolean":
            if (!NS$jscomp$1.BooleanTypeAdapter.WillChange(this._GetIndex(), this._GetTarget(), b, d))
                return;
            break;
        case "color":
            if (!NS$jscomp$1.ColorTypeAdapter.WillChange(this._GetIndex(), this._GetTarget(), b, d))
                return;
            break;
        case "text":
            if (!NS$jscomp$1.TextTypeAdapter.WillChange(this._GetIndex(), this._GetTarget(), b, d))
                return
        }
        this._Setter(b)
    }
    _Getter() {
        const a = this._propertyTrack.GetSourceAdapterId()
          , b = this._GetTarget()
          , c = this._GetIndex();
        switch (a) {
        case "behavior":
            return b.GetPropertyValueByIndex(c);
        case "effect":
            return b[c];
        case "instance-variable":
            return b.GetInstanceVariableValue(c);
        case "plugin":
            return b.GetPropertyValueByIndex(c)
        }
    }
    _Setter(a) {
        const b = this._propertyTrack.GetSourceAdapterId()
          , c = this._GetTarget()
          , d = this._GetIndex();
        switch (b) {
        case "behavior":
            c.SetPropertyValueByIndex(d, a);
            break;
        case "effect":
            c[d] = a;
            break;
        case "instance-variable":
            c.SetInstanceVariableValue(d, a);
            break;
        case "plugin":
            c.SetPropertyValueByIndex(d, a)
        }
    }
}
C3$jscomp$120.PropertyTrackState.PropertyInterpolationAdapter.NoInterpolationAdapter = NoInterpolationAdapter;
"use strict";
const C3$jscomp$121 = self.C3
  , INSTANCE_FUNC_MAP = new Map
  , add$jscomp$1 = (a, b, c, d, e, f=!1, h=null, l=null) => {
    INSTANCE_FUNC_MAP.set(a, {
        setter: b,
        absolute_setter: c,
        getter: d,
        round: e,
        fRound: f,
        init: h,
        reset: l
    })
}
;
add$jscomp$1("offsetX", (a, b, c, d) => {
    "relative" === d._propertyTrack.GetResultMode() ? a.OffsetX(b, c.GetTimeline().GetTransformWithSceneGraph()) : a.OffsetX(b)
}
, (a, b) => a.SetX(b), a => a.GetX(), !0);
add$jscomp$1("offsetY", (a, b, c, d) => {
    "relative" === d._propertyTrack.GetResultMode() ? a.OffsetY(b, c.GetTimeline().GetTransformWithSceneGraph()) : a.OffsetY(b)
}
, (a, b) => a.SetY(b), a => a.GetY(), !0);
add$jscomp$1("offsetWidth", (a, b, c, d, e) => {
    if (0 !== b) {
        var f = "relative" === d._propertyTrack.GetResultMode()
          , h = 1 === d._typeAdapter.GetType();
        if ((f || h) && a.HasParent() && a.GetTransformWithParentWidth()) {
            if (isNaN(d._absoluteToFactor)) {
                f = [];
                for (var l = a.GetParent(); l; )
                    f.push(l),
                    l = l.GetParent();
                f.reverse();
                l = (v, x) => {
                    if (x = x.GetTimeline().GetTrackFromInstance(v.GetInstance()))
                        return x.GetOriginalWidth();
                    x = v.GetInstance().GetSdkInstance();
                    return x.IsOriginalSizeKnown() ? x.GetOriginalWidth() : v._GetSceneGraphInfo()._GetStartWidth()
                }
                ;
                const r = (v, x, B, A=0) => {
                    v = x.GetTimeline().GetTrackFromInstance(v.GetInstance());
                    if (!v)
                        return A;
                    B = v.GetPropertyTrack(B);
                    if (!B)
                        return A;
                    B = B.GetPropertyTrackDataItem().GetPropertyKeyframeData();
                    return B ? (B = B.GetLastPropertyKeyframeDataItem()) ? B.GetValue() : A : A
                }
                ;
                if (h)
                    var m = f[f.length - 1].GetWidth();
                else {
                    h = f[0];
                    m = h._GetSceneGraphInfo()._GetStartWidth();
                    var p = h._GetSceneGraphInfo().GetStartScaleX();
                    m *= p;
                    m += r(h, c, "offsetWidth");
                    m += l(h, c) * r(h, c, "offsetScaleX");
                    for (p = 1; p < f.length; p++) {
                        h = f[p];
                        const v = h._GetSceneGraphInfo().GetStartScaleX();
                        m *= v;
                        m += r(h, c, "offsetWidth");
                        m += l(h, c) * r(h, c, "offsetScaleX")
                    }
                }
                d._absoluteToFactor = 0 === m ? Number.EPSILON : m
            }
            e || a.OffsetWidth(b / d._absoluteToFactor, !0)
        } else
            a.OffsetWidth(b)
    }
}
, (a, b) => a.SetWidth(b), a => a.GetWidth(), !0);
add$jscomp$1("offsetHeight", (a, b, c, d, e) => {
    if (0 !== b) {
        var f = "relative" === d._propertyTrack.GetResultMode()
          , h = 1 === d._typeAdapter.GetType();
        if ((f || h) && a.HasParent() && a.GetTransformWithParentHeight()) {
            if (isNaN(d._absoluteToFactor)) {
                f = [];
                for (var l = a.GetParent(); l; )
                    f.push(l),
                    l = l.GetParent();
                f.reverse();
                l = (v, x) => {
                    if (x = x.GetTimeline().GetTrackFromInstance(v.GetInstance()))
                        return x.GetOriginalHeight();
                    x = v.GetInstance().GetSdkInstance();
                    return x.IsOriginalSizeKnown() ? x.GetOriginalHeight() : v._GetSceneGraphInfo()._GetStartHeight()
                }
                ;
                const r = (v, x, B, A=0) => {
                    v = x.GetTimeline().GetTrackFromInstance(v.GetInstance());
                    if (!v)
                        return A;
                    B = v.GetPropertyTrack(B);
                    if (!B)
                        return A;
                    B = B.GetPropertyTrackDataItem().GetPropertyKeyframeData();
                    return B ? (B = B.GetLastPropertyKeyframeDataItem()) ? B.GetValue() : A : A
                }
                ;
                if (h)
                    var m = f[f.length - 1].GetHeight();
                else {
                    h = f[0];
                    m = h._GetSceneGraphInfo()._GetStartHeight();
                    var p = h._GetSceneGraphInfo().GetStartScaleY();
                    m *= p;
                    m += r(h, c, "offsetHeight");
                    m += l(h, c) * r(h, c, "offsetScaleY");
                    for (p = 1; p < f.length; p++) {
                        h = f[p];
                        const v = h._GetSceneGraphInfo().GetStartScaleY();
                        m *= v;
                        m += r(h, c);
                        m += l(h, c) * r(h, c, "offsetScaleY")
                    }
                }
                d._absoluteToFactor = 0 === m ? Number.EPSILON : m
            }
            e || a.OffsetHeight(b / d._absoluteToFactor, !0)
        } else
            a.OffsetHeight(b)
    }
}
, (a, b) => a.SetHeight(b), a => a.GetHeight(), !0);
add$jscomp$1("offsetAngle", (a, b, c, d, e) => {
    a.OffsetAngle(b)
}
, (a, b) => a.SetAngle(b), a => a.GetAngle(), !1, !0);
add$jscomp$1("offsetOpacity", (a, b, c, d, e) => {
    b /= d._opacityFactor ? d._opacityFactor : 1;
    c = a.GetOpacity() + b;
    0 === d._clampAccumulator ? (1 < c ? d._clampAccumulator += c - 1 : 0 > c && (d._clampAccumulator += c),
    a.OffsetOpacity(b)) : (a = a.GetOpacity() + b,
    0 < b && 0 < d._clampAccumulator ? 1 < a && (d._clampAccumulator += a - 1) : 0 < b && 0 > d._clampAccumulator ? (d._clampAccumulator += b,
    0 < d._clampAccumulator && (d._clampAccumulator = 0)) : 0 > b && 0 < d._clampAccumulator ? (d._clampAccumulator += b,
    0 > d._clampAccumulator && (d._clampAccumulator = 0)) : 0 > b && 0 > d._clampAccumulator && 0 > a && (d._clampAccumulator += a))
}
, (a, b) => {
    a.SetOpacity(b)
}
, a => a.GetOpacity(), !1, !0, (a, b, c) => {
    a._clampAccumulator = 0;
    switch (a._propertyTrack.GetResultMode()) {
    case "relative":
        a._propertyTrack.GetPropertyTrackData();
        var d = a._propertyTrack.GetPropertyTrackDataItem().GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray()
          , e = a.GetWorldInfo().GetOpacity()
          , f = e;
        for (var h of d)
            f = h.GetTime(),
            f = a._propertyTrack.GetInterpolatedValue(f),
            f = e + f,
            f = C3$jscomp$121.clamp(f, 0, 1);
        a._totalForewardOpacityDelta = e - f;
        a._totalForewardOpacityDelta = Math.round(100 * (a._totalForewardOpacityDelta + Number.EPSILON)) / 100;
        f = e;
        for (e = d.length - 1; 0 <= e; e--)
            h = d[e].GetTime(),
            h = a._propertyTrack.GetInterpolatedValue(h),
            f -= h,
            f = C3$jscomp$121.clamp(f, 0, 1);
        a._totalBackwardOpacityDelta = f;
        a._totalBackwardOpacityDelta = Math.round(100 * (a._totalBackwardOpacityDelta + Number.EPSILON)) / 100
    }
    d = "relative" === a._propertyTrack.GetResultMode();
    f = 1 === a._typeAdapter.GetType();
    if ((d || f) && b.HasParent() && b.GetTransformWithParentOpacity()) {
        d = [];
        for (b = b.GetParent(); b; )
            d.push(b),
            b = b.GetParent();
        d.reverse();
        b = (l, m, p) => {
            l = m.GetTimeline().GetTrackFromInstance(l.GetInstance());
            if (!l)
                return 0;
            p = l.GetPropertyTrack(p);
            if (!p)
                return 0;
            p = p.GetPropertyTrackDataItem().GetPropertyKeyframeData();
            return p ? (p = p.GetLastPropertyKeyframeDataItem()) ? p.GetValue() : 0 : 0
        }
        ;
        f = d[0]._GetSceneGraphInfo().GetStartOpacity();
        f += b(d[0], c, "offsetOpacity");
        for (e = 1; e < d.length; e++)
            f += b(d[e], c, "offsetOpacity");
        a._opacityFactor = 0 === f ? 1 : f
    }
}
, a => {
    switch (a._propertyTrack.GetResultMode()) {
    case "relative":
        a._clampAccumulator = 0;
        const b = a.GetWorldInfo();
        let c = b.GetOpacity();
        c = Math.round(100 * (c + Number.EPSILON)) / 100;
        a._propertyTrack.GetTimeline().IsForwardPlayBack() ? (b.SetOpacity(c + a._totalForewardOpacityDelta),
        a._lastValue = 0) : (b.SetOpacity(c - a._totalBackwardOpacityDelta),
        a._lastValue = a.GetSourceAdapter().GetValueAtTime())
    }
}
);
add$jscomp$1("offsetOriginX", (a, b) => a.OffsetOriginX(b), (a, b) => a.SetOriginX(b), a => a.GetOriginX(), !1);
add$jscomp$1("offsetOriginY", (a, b) => a.OffsetOriginY(b), (a, b) => a.SetOriginY(b), a => a.GetOriginY(), !1);
add$jscomp$1("offsetZElevation", (a, b) => a.OffsetZElevation(b), (a, b) => a.SetZElevation(b), a => a.GetZElevation(), !0);
add$jscomp$1("offsetScaleX", (a, b, c, d) => {
    if (0 !== b) {
        var e = 0 > a.GetWidth() ? -1 : 1;
        "relative" === d._propertyTrack.GetResultMode() && a.HasParent() && a.GetTransformWithParentWidth() ? (b *= c.GetOriginalWidth() * e,
        isNaN(d._absoluteToFactor) && INSTANCE_FUNC_MAP.get("offsetWidth").setter(a, 1, c, d, !0),
        a.OffsetWidth(b / d._absoluteToFactor, !0)) : a.OffsetWidth(c.GetOriginalWidth() * e * b)
    }
}
, (a, b, c) => {
    a.SetWidth(c.GetOriginalWidth() * b)
}
, (a, b) => {
    const c = 0 > a.GetWidth() ? -1 : 1;
    if (a.GetTransformWithParentWidth()) {
        var d = a.GetParent()
          , e = b.GetTimeline().GetTrackFromInstance(d.GetInstance());
        e ? d = d.GetWidth() / e.GetOriginalWidth() : (e = d.GetInstance().GetSdkInstance(),
        d = e.IsOriginalSizeKnown() ? d.GetWidth() / e.GetOriginalWidth() : 1);
        return a.GetWidth() * c / (b.GetOriginalWidth() * d)
    }
    return a.GetWidth() * c / b.GetOriginalWidth()
}
, !1);
add$jscomp$1("offsetScaleY", (a, b, c, d) => {
    if (0 !== b) {
        var e = 0 > a.GetHeight() ? -1 : 1;
        "relative" === d._propertyTrack.GetResultMode() && a.HasParent() && a.GetTransformWithParentHeight() ? (b *= c.GetOriginalHeight() * e,
        isNaN(d._absoluteToFactor) && INSTANCE_FUNC_MAP.get("offsetHeight").setter(a, 1, c, d, !0),
        a.OffsetHeight(b / d._absoluteToFactor, !0)) : a.OffsetHeight(c.GetOriginalHeight() * e * b)
    }
}
, (a, b, c) => {
    a.SetHeight(c.GetOriginalHeight() * b)
}
, (a, b) => {
    const c = 0 > a.GetHeight() ? -1 : 1;
    if (a.GetTransformWithParentHeight()) {
        var d = a.GetParent()
          , e = b.GetTimeline().GetTrackFromInstance(d.GetInstance());
        e ? d = d.GetHeight() / e.GetOriginalHeight() : (e = d.GetInstance().GetSdkInstance(),
        d = e.IsOriginalSizeKnown() ? d.GetHeight() / e.GetOriginalHeight() : 1);
        return a.GetHeight() * c / (b.GetOriginalHeight() * d)
    }
    return a.GetHeight() * c / b.GetOriginalHeight()
}
, !1);
class NumericInterpolationAdapter extends C3$jscomp$121.PropertyTrackState.PropertyInterpolationAdapter {
    constructor(a) {
        super(a);
        this._totalBackwardOpacityDelta = this._totalForewardOpacityDelta = this._clampAccumulator = this._lastValue = 0;
        this._absoluteToFactor = this._opacityFactor = NaN;
        this._angleReflectMirrorAndFlip = this._angleReflectMirrorOrFlip = void 0;
        this._source_adapter_absolute_setter = this._source_adapter_setter = this._source_adapter_getter = this._init_action = this._reset_action = this._instance_absolute_setter = this._instance_setter = this._instance_getter = null;
        this._fRound = this._round = !1;
        C3$jscomp$121.IsInstanceOf(this._propertyTrack.GetTimeline(), C3$jscomp$121.TweenState) ? this._typeAdapter = new C3$jscomp$121.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTween(this) : this._typeAdapter = new C3$jscomp$121.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTimeline(this);
        const b = this._propertyTrack.GetPropertyName();
        switch (this._propertyTrack.GetSourceAdapterId()) {
        case "world-instance":
            a = INSTANCE_FUNC_MAP.get(b);
            this._instance_getter = a.getter;
            this._instance_setter = a.setter;
            this._instance_absolute_setter = a.absolute_setter;
            this._round = a.round;
            this._fRound = a.fRound;
            this._init_action = a.init;
            this._reset_action = a.reset;
            break;
        case "audio":
            this._source_adapter_getter = a.Getter,
            this._source_adapter_setter = a.Setter,
            this._source_adapter_absolute_setter = a.AbsoluteSetter,
            this._round = !!a.DoesRounding(),
            this._fRound = !1
        }
    }
    Release() {
        this._source_adapter_absolute_setter = this._source_adapter_setter = this._source_adapter_getter = this._init_action = this._reset_action = this._instance_absolute_setter = this._instance_setter = this._instance_getter = this._typeAdapter = null;
        super.Release()
    }
    MayNeedBeforeAndAfterInterpolate() {
        return this._typeAdapter.MayNeedBeforeAndAfterInterpolate()
    }
    GetLastValue() {
        return this._lastValue
    }
    SetLastValue(a) {
        this._lastValue = a
    }
    SetResetState() {
        this._reset_action && this._reset_action(this)
    }
    SetInitialState() {
        var a = this._typeAdapter.SetInitialState();
        "number" === typeof a && (this._lastValue = a);
        if (this._init_action) {
            a = this.GetWorldInfo();
            const b = this._propertyTrack.GetTrack();
            this._init_action(this, a, b)
        }
    }
    SetResumeState() {
        const a = this._typeAdapter.SetResumeState();
        "number" === typeof a && (this._lastValue = a)
    }
    GetCurrentState() {
        return this._Getter()
    }
    CompareInitialStateWithCurrent() {
        return this._FirstKeyframeGetter() !== this.GetCurrentState()
    }
    CompareSaveStateWithCurrent() {
        return C3$jscomp$121.IsNullOrUndefined(this._saveState) ? !1 : this._saveState !== this.GetCurrentState()
    }
    BeforeChangeProperty() {
        this._typeAdapter.BeforeChangeProperty()
    }
    ChangeProperty(a, b, c, d, e, f, h, l) {
        return this._typeAdapter.ChangeProperty(a, b, c, d, e, f, h, l)
    }
    AfterChangeProperty() {
        this._typeAdapter.AfterChangeProperty()
    }
    _Getter() {
        const a = this._GetTarget()
          , b = this._GetIndex()
          , c = this.GetWorldInfo()
          , d = this._propertyTrack.GetTrack();
        switch (this._propertyTrack.GetSourceAdapterId()) {
        case "behavior":
            return a.GetPropertyValueByIndex(b);
        case "effect":
            return a[b];
        case "instance-variable":
            return a.GetInstanceVariableValue(b);
        case "plugin":
            return a.GetPropertyValueByIndex(b);
        case "world-instance":
            return this._instance_getter(c, d);
        case "audio":
            return this._source_adapter_getter.call(this.GetSourceAdapter(), c, d)
        }
    }
    _Setter(a, b, c) {
        b = this._GetTarget();
        c = this._GetIndex();
        const d = this.GetWorldInfo()
          , e = this._propertyTrack.GetTrack();
        switch (this._propertyTrack.GetSourceAdapterId()) {
        case "behavior":
            b.OffsetPropertyValueByIndex(c, a);
            break;
        case "effect":
            b[c] += a;
            break;
        case "instance-variable":
            b.SetInstanceVariableOffset(c, a);
            break;
        case "plugin":
            b.OffsetPropertyValueByIndex(c, a, this.GetSourceAdapter().GetOptionalCallbacks());
            break;
        case "world-instance":
            this._instance_setter(d, a, e, this);
            break;
        case "audio":
            this._source_adapter_setter.call(this.GetSourceAdapter(), d, a, e, this)
        }
    }
    _SetterAbsolute(a, b, c) {
        var d = this._propertyTrack.GetInterpolationMode();
        d = "default" === d ? "continuous" : d;
        if ("discrete" !== d || b) {
            if ("discrete" === d && c && (b = this._propertyTrack.GetTimeline().GetTime(),
            !this._propertyTrack.GetPropertyKeyFrameDataItemAtTime(b)))
                return;
            b = this._GetTarget();
            c = this._GetIndex();
            d = this.GetWorldInfo();
            var e = this._propertyTrack.GetTrack();
            switch (this._propertyTrack.GetSourceAdapterId()) {
            case "behavior":
                b.SetPropertyValueByIndex(c, a);
                break;
            case "effect":
                b[c] = a;
                break;
            case "instance-variable":
                b.SetInstanceVariableValue(c, a);
                break;
            case "plugin":
                b.SetPropertyValueByIndex(c, a, this.GetSourceAdapter().GetOptionalCallbacks());
                break;
            case "world-instance":
                this._instance_absolute_setter(d, a, e);
                break;
            case "audio":
                this._source_adapter_absolute_setter.call(this.GetSourceAdapter(), d, a, e)
            }
        }
    }
    _MaybeEnsureValue(a, b, c, d, e, f, h, l) {
        this._typeAdapter._MaybeEnsureValue(a, b, c, d, e, f, h, l)
    }
    _AddDelta(a, b, c, d, e) {
        switch (this._propertyTrack.GetPropertyType()) {
        case "angle":
            a = C3$jscomp$121.toDegrees(a)
        }
        d = (a.toString().split(".")[1] || "").length;
        a = this._Getter();
        if (0 === d)
            if (this._round)
                d = Math.round(a);
            else if (this._fRound)
                switch (this._propertyTrack.GetPropertyType()) {
                case "angle":
                    d = C3$jscomp$121.toRadians(Math.round(C3$jscomp$121.toDegrees(a)));
                    break;
                default:
                    d = Number(C3$jscomp$121.toFixed(a, 2))
                }
            else
                d = a;
        else
            d = this._round ? Number(C3$jscomp$121.toFixed(a, d)) : a;
        this._Setter(d - a, b, c);
        switch (this._propertyTrack.GetPropertyName()) {
        case "offsetWidth":
        case "offsetScaleX":
            b = this.GetWorldInfo();
            c = b.GetWidth();
            a = Number(C3$jscomp$121.toFixed(c, 2));
            b.OffsetWidth(a - c);
            break;
        case "offsetHeight":
        case "offsetScaleY":
            b = this.GetWorldInfo(),
            c = b.GetHeight(),
            a = Number(C3$jscomp$121.toFixed(c, 2)),
            b.OffsetHeight(a - c)
        }
    }
    _SaveToJson() {
        return Object.assign(super._SaveToJson(), {
            v: this._lastValue,
            a: this._clampAccumulator,
            fod: this._totalForewardOpacityDelta,
            bod: this._totalBackwardOpacityDelta,
            of: this._opacityFactor,
            sf: this._absoluteToFactor,
            armorf: this._angleReflectMirrorOrFlip,
            armandf: this._angleReflectMirrorAndFlip
        })
    }
    _LoadFromJson(a) {
        a && (super._LoadFromJson(a),
        this._lastValue = a.v,
        this._clampAccumulator = a.a,
        this._totalForewardOpacityDelta = C3$jscomp$121.IsFiniteNumber(a.fod) ? a.fod : 0,
        this._totalBackwardOpacityDelta = C3$jscomp$121.IsFiniteNumber(a.bod) ? a.bod : 0,
        this._opacityFactor = C3$jscomp$121.IsFiniteNumber(a.of) ? a.of : NaN,
        this._absoluteToFactor = C3$jscomp$121.IsFiniteNumber(a.sf) ? a.sf : NaN,
        this._angleReflectMirrorOrFlip = C3$jscomp$121.IsFiniteNumber(a.armorf) ? a.armorf : void 0,
        this._angleReflectMirrorAndFlip = C3$jscomp$121.IsFiniteNumber(a.armandf) ? a.armandf : void 0)
    }
}
C3$jscomp$121.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapter = NumericInterpolationAdapter;
"use strict";
class AbsoluteValueObject {
    constructor(a) {
        this._used = !1;
        this._value = 0;
        this._endState = this._propertyKeyframeReached = !1;
        this._propertyTracks = a;
        for (let b = 0, c = this._propertyTracks.length; b < c; b++)
            this._propertyTracks[b].SetAbsoluteValueObject(this)
    }
    GetPropertyTracks() {
        return this._propertyTracks
    }
    SetUsed() {
        this._used = !0
    }
    GetUsed() {
        return this._used
    }
    SetValue(a) {
        this._value = a
    }
    GetValue() {
        return this._value
    }
    SetPropertyKeyframeReached(a) {
        this._propertyKeyframeReached = a
    }
    GetPropertyKeyframeReached() {
        return this._propertyKeyframeReached
    }
    SetEndState(a) {
        this._endState = a
    }
    GetEndState() {
        return this._endState
    }
    Reset() {
        this._used = !1;
        this._value = 0;
        this._endState = this._propertyKeyframeReached = !1
    }
}
class NumericInterpolationAdapterForTimeline {
    constructor(a) {
        this._numericInterpolationAdapter = a
    }
    Release() {
        this._numericInterpolationAdapter = null
    }
    GetType() {
        return 0
    }
    SetInitialState() {
        const a = this._numericInterpolationAdapter;
        this._numericInterpolationAdapter.GetPropertyTrack();
        return a._PickResultMode( () => a._PickTimelinePlaybackMode( () => 0, () => a.GetSourceAdapter().GetValueAtTime()), () => {}
        )
    }
    SetResumeState() {}
    MayNeedBeforeAndAfterInterpolate() {
        switch (this._numericInterpolationAdapter.GetPropertyTrack().GetResultMode()) {
        case "relative":
            return !1;
        case "absolute":
            return !0
        }
    }
    BeforeChangeProperty() {
        var a = this._numericInterpolationAdapter.GetPropertyTrack();
        const b = a.GetPropertyName();
        switch (a.GetResultMode()) {
        case "absolute":
            if (a.HasAbsoluteValueObject())
                a.GetAbsoluteValueObject().Reset();
            else {
                const c = a.GetTimeline()
                  , d = a.GetInstance()
                  , e = a.GetSourceAdapter();
                (a = c.GetSimilarPropertyTracks(d, e, b, a)) && 1 < a.length && new AbsoluteValueObject(a)
            }
        }
    }
    ChangeProperty(a, b, c, d, e, f, h, l) {
        var m = this._numericInterpolationAdapter
          , p = this._numericInterpolationAdapter.GetPropertyTrack();
        switch (p.GetResultMode()) {
        case "relative":
            h = m.GetLastValue();
            m._Setter(b - h, c, d);
            f && this._MaybeEnsureValue(a, c, d, e, h, b);
            m.SetLastValue(b);
            break;
        case "absolute":
            if (d = p.GetTimeline(),
            c = p.GetTrack(),
            p.GetInstance(),
            p.GetSourceAdapter(),
            p.HasAbsoluteValueObject()) {
                if (a = p.GetAbsoluteValueObject(),
                e = a.GetPropertyTracks(),
                e = m._GetPropertyKeyframeStubs(e, !0),
                m = m._GetLastPropertyKeyframeStub(d, d.GetTime(), e))
                    c = c.GetStartOffset(),
                    m = m.time - c,
                    0 === m ? (a.SetEndState(h),
                    a.SetPropertyKeyframeReached(l),
                    a.SetUsed(),
                    a.SetValue(a.GetValue() + b)) : 0 > m || (p = p.GetInterpolatedValue(m),
                    a.SetEndState(h),
                    a.SetPropertyKeyframeReached(l),
                    a.SetUsed(),
                    a.SetValue(a.GetValue() + (b - p)))
            } else
                m._SetterAbsolute(b, l, h)
        }
    }
    AfterChangeProperty() {
        const a = this._numericInterpolationAdapter;
        var b = this._numericInterpolationAdapter.GetPropertyTrack();
        switch (b.GetResultMode()) {
        case "absolute":
            b.HasAbsoluteValueObject() && (b = b.GetAbsoluteValueObject(),
            b.GetUsed() && a._SetterAbsolute(b.GetValue(), b.GetPropertyKeyframeReached(), b.GetEndState()))
        }
    }
    _MaybeEnsureValue(a, b, c, d, e, f) {
        const h = this._numericInterpolationAdapter;
        d || (b && a === b.GetTime() ? h._AddDelta(b.GetValueWithResultMode(), b, c) : c && a === c.GetTime() ? h._AddDelta(c.GetValueWithResultMode(), b, c) : 0 === f - e && h._AddDelta(b.GetValueWithResultMode(), b, c))
    }
}
self.C3.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTimeline = NumericInterpolationAdapterForTimeline;
"use strict";
class NumericInterpolationAdapterForTween {
    constructor(a) {
        this._numericInterpolationAdapter = a
    }
    Release() {
        this._numericInterpolationAdapter = null
    }
    GetType() {
        return 1
    }
    SetInitialState() {
        const a = this._numericInterpolationAdapter;
        a.SetFirstAbsoluteUpdate(!0);
        return this._GetAbsoluteInitialValue(a._FirstKeyframeGetter())
    }
    SetResumeState() {
        const a = this._numericInterpolationAdapter;
        if (a._FirstKeyframeGetter() !== a._CurrentKeyframeGetter())
            return a.SetFirstAbsoluteUpdate(!0),
            this._GetAbsoluteInitialValue(a._CurrentKeyframeGetter())
    }
    MayNeedBeforeAndAfterInterpolate() {
        return !1
    }
    BeforeChangeProperty() {}
    ChangeProperty(a, b, c, d, e, f, h, l) {
        l = this._numericInterpolationAdapter;
        const m = l.GetLastValue();
        switch (l.GetPropertyTrack().GetResultMode()) {
        case "relative":
            l._Setter(b - m, c, d);
            f && this._MaybeEnsureValue(a, c, d, e, m, b, !1, h);
            break;
        case "absolute":
            l.GetFirstAbsoluteUpdate() ? (l.SetFirstAbsoluteUpdate(!1),
            l._Setter(m, c, d)) : 0 === a && 0 === l.GetPropertyTrack().GetTimeline().GetTotalTime() ? l._SetterAbsolute(b, !0, !1) : (l._Setter(b - m, c, d),
            f && this._MaybeEnsureValue(a, c, d, e, m, b, this._ForceEndValue(), h))
        }
        l.SetLastValue(b)
    }
    AfterChangeProperty() {}
    _GetAbsoluteInitialValue(a) {
        return a - this._numericInterpolationAdapter.GetCurrentState()
    }
    _ForceEndValue() {
        var a = this._numericInterpolationAdapter;
        const b = a.GetWorldInfo().GetInstance();
        a = a.GetPropertyTrack().GetRuntime().GetTimelineManager();
        let c = 0;
        for (const d of a.GetPlayingTimelines())
            0 === d.GetType() ? d.HasTrackInstance(b) && c++ : 1 === d.GetType() && d.GetInstance() === b && c++;
        return 1 >= c
    }
    _MaybeEnsureValue(a, b, c, d, e, f, h, l) {
        const m = this._numericInterpolationAdapter;
        d ? b && a === b.GetTime() ? m._AddDelta(b.GetValueWithResultMode(), b, c, h, l) : c && a === c.GetTime() ? m._AddDelta(c.GetValueWithResultMode(), b, c, h, l) : c || m._AddDelta(b.GetValueWithResultMode(), b, c, h, l) : b && a === b.GetTime() ? m._AddDelta(b.GetValueWithResultMode(), b, c, h, l) : c && a === c.GetTime() ? m._AddDelta(c.GetValueWithResultMode(), b, c, h, l) : 0 === f - e && m._AddDelta(b.GetValueWithResultMode(), b, c, h, l)
    }
}
self.C3.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTween = NumericInterpolationAdapterForTween;
"use strict";
const C3$jscomp$124 = self.C3
  , Ease$jscomp$1 = self.Ease;
C3$jscomp$124.PropertyTrackState.NumericTypeAdapter = class {
    constructor() {}
    static WillChange(a, b, c, d) {
        let e;
        switch (d) {
        case "behavior":
            e = b.GetPropertyValueByIndex(a);
            break;
        case "effect":
            e = b[a];
            break;
        case "instance-variable":
            e = b.GetInstanceVariableValue(a);
            break;
        case "plugin":
            e = b.GetPropertyValueByIndex(a)
        }
        return e === c ? !1 : !0
    }
    static Interpolate(a, b, c, d) {
        if (!c) {
            var e = d.GetPropertyTrackDataItem();
            e = d.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(e);
            return e.GetValueWithResultMode()
        }
        let f = d.GetInterpolationMode();
        "default" === f && (f = "continuous");
        "combo" === d.GetPropertyType() && (f = "discrete");
        if ("discrete" === f)
            return b.GetValueWithResultMode();
        if ("continuous" === f || "step" === f) {
            const l = d.GetTimeline().GetStep();
            "step" === f && 0 !== l && (e = 1 / l,
            a = Math.floor(a * e) / e);
            e = b.GetValueWithResultMode();
            const m = c.GetValueWithResultMode()
              , p = b.GetAddOn("cubic-bezier")
              , r = c.GetAddOn("cubic-bezier");
            var h = p && p.GetStartEnable() && r && r.GetEndEnable();
            if (!h && e === m)
                return e;
            const v = b.GetTime();
            c = c.GetTime();
            "step" === f && 0 !== l && (a = C3$jscomp$124.clamp(a, v, c));
            a = C3$jscomp$124.normalize(a, v, c);
            b = b.GetEase();
            h ? (h = c - v,
            b = Ease$jscomp$1.GetRuntimeEase(b)(h * a, 0, 1, h),
            b = Ease$jscomp$1.GetRuntimeEase("cubicbezier")(b, e, e + p.GetStartAnchor(), m + r.GetEndAnchor(), m)) : b = Ease$jscomp$1.GetRuntimeEase(b)((c - v) * a, e, m - e, c - v);
            return "integer" === d.GetPropertyType() ? Math.floor(b) : b
        }
    }
}
;
"use strict";
const C3$jscomp$125 = self.C3;
C3$jscomp$125.PropertyTrackState.AngleTypeAdapter = class {
    constructor() {}
    static WillChange(a, b, c, d) {
        let e;
        switch (d) {
        case "behavior":
            e = b.GetPropertyValueByIndex(a);
            break;
        case "effect":
            e = b[a];
            break;
        case "instance-variable":
            e = b.GetInstanceVariableValue(a);
            break;
        case "plugin":
            e = b.GetPropertyValueByIndex(a)
        }
        return e === c ? !1 : !0
    }
    static Interpolate(a, b, c, d) {
        if (!c)
            return b = d.GetPropertyTrackDataItem(),
            b = d.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(b),
            b.GetValueWithResultMode();
        var e = d.GetInterpolationMode();
        "default" === e && (e = "continuous");
        "combo" === d.GetPropertyType() && (e = "discrete");
        if ("discrete" === e)
            return b.GetValueWithResultMode();
        if ("continuous" === e || "step" === e) {
            var f = d.GetTimeline().GetStep();
            "step" === e && 0 !== f && (d = 1 / f,
            a = Math.floor(a * d) / d);
            const h = b.GetTime()
              , l = c.GetTime();
            d = b.GetValueWithResultMode();
            c = c.GetValueWithResultMode();
            "step" === e && 0 !== f && (a = C3$jscomp$125.clamp(a, h, l));
            if (e = b.GetAddOn("angle")) {
                f = e.GetRevolutions();
                if (d === c && 0 === f)
                    return d;
                a = C3$jscomp$125.normalize(a, h, l);
                b = self.Ease.GetRuntimeEase(b.GetEase())(a, 0, 1, 1);
                switch (e.GetDirection()) {
                case "closest":
                    return C3$jscomp$125.angleLerp(d, c, b, f);
                case "clockwise":
                    return C3$jscomp$125.angleLerpClockwise(d, c, b, f);
                case "anti-clockwise":
                    return C3$jscomp$125.angleLerpAntiClockwise(d, c, b, f)
                }
            } else {
                if (d === c)
                    return d;
                a = C3$jscomp$125.normalize(a, h, l);
                b = self.Ease.GetRuntimeEase(b.GetEase());
                return C3$jscomp$125.angleLerp(d, c, b(a, 0, 1, 1))
            }
        }
    }
}
;
"use strict";
self.C3.PropertyTrackState.BooleanTypeAdapter = class {
    constructor() {}
    static WillChange(a, b, c, d) {
        let e;
        switch (d) {
        case "behavior":
            e = b.GetPropertyValueByIndex(a);
            break;
        case "effect":
            e = b[a];
            break;
        case "instance-variable":
            e = b.GetInstanceVariableValue(a);
            break;
        case "plugin":
            e = b.GetPropertyValueByIndex(a)
        }
        return !!e === !!c ? !1 : !0
    }
    static Interpolate(a, b, c, d) {
        return c ? b.GetValueWithResultMode() ? 1 : 0 : (a = d.GetPropertyTrackDataItem(),
        a = d.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(a),
        a.GetValueWithResultMode() ? 1 : 0)
    }
}
;
"use strict";
const C3$jscomp$127 = self.C3
  , TEMP_COLOR_ARRAY = [0, 0, 0]
  , TEMP_COLOR_ARRAY_2 = [0, 0, 0]
  , TEMP_COLOR_ARRAY_3 = [0, 0, 0];
C3$jscomp$127.PropertyTrackState.ColorTypeAdapter = class {
    constructor() {}
    static WillChange(a, b, c, d) {
        let e;
        switch (d) {
        case "behavior":
            e = b.GetPropertyValueByIndex(a);
            break;
        case "effect":
            e = b[a];
            break;
        case "instance-variable":
            e = b.GetInstanceVariableValue(a);
            break;
        case "plugin":
            e = b.GetPropertyValueByIndex(a)
        }
        Array.isArray(c) ? (TEMP_COLOR_ARRAY[0] = c[0],
        TEMP_COLOR_ARRAY[1] = c[1],
        TEMP_COLOR_ARRAY[2] = c[2]) : (TEMP_COLOR_ARRAY_3.parseCommaSeparatedRgb(c),
        TEMP_COLOR_ARRAY[0] = Math.floor(255 * TEMP_COLOR_ARRAY_3.getR()),
        TEMP_COLOR_ARRAY[1] = Math.floor(255 * TEMP_COLOR_ARRAY_3.getG()),
        TEMP_COLOR_ARRAY[2] = Math.floor(255 * TEMP_COLOR_ARRAY_3.getB()));
        Array.isArray(e) ? (TEMP_COLOR_ARRAY_2[0] = e[0],
        TEMP_COLOR_ARRAY_2[1] = e[1],
        TEMP_COLOR_ARRAY_2[2] = e[2]) : (TEMP_COLOR_ARRAY_3.parseCommaSeparatedRgb(e),
        TEMP_COLOR_ARRAY_2[0] = Math.floor(255 * TEMP_COLOR_ARRAY_3.getR()),
        TEMP_COLOR_ARRAY_2[1] = Math.floor(255 * TEMP_COLOR_ARRAY_3.getG()),
        TEMP_COLOR_ARRAY_2[2] = Math.floor(255 * TEMP_COLOR_ARRAY_3.getB()));
        return TEMP_COLOR_ARRAY[0] !== TEMP_COLOR_ARRAY_2[0] || TEMP_COLOR_ARRAY[1] !== TEMP_COLOR_ARRAY_2[1] || TEMP_COLOR_ARRAY[2] !== TEMP_COLOR_ARRAY_2[2] ? !0 : !1
    }
    static Interpolate(a, b, c, d) {
        if (!c) {
            var e = d.GetPropertyTrackDataItem();
            e = d.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(e);
            d = e.GetValueWithResultMode();
            TEMP_COLOR_ARRAY[0] = d[0];
            TEMP_COLOR_ARRAY[1] = d[1];
            TEMP_COLOR_ARRAY[2] = d[2];
            return TEMP_COLOR_ARRAY
        }
        var f = d.GetInterpolationMode();
        "default" === f && (f = "continuous");
        if ("discrete" === f)
            return d = b.GetValueWithResultMode(),
            TEMP_COLOR_ARRAY[0] = d[0],
            TEMP_COLOR_ARRAY[1] = d[1],
            TEMP_COLOR_ARRAY[2] = d[2],
            TEMP_COLOR_ARRAY;
        if ("continuous" === f || "step" === f) {
            var h = d.GetTimeline().GetStep();
            "step" === f && 0 !== h && (d = 1 / h,
            a = Math.floor(a * d) / d);
            d = b.GetTime();
            e = c.GetTime();
            var l = b.GetValueWithResultMode();
            c = c.GetValueWithResultMode();
            "step" === f && 0 !== h && (a = C3$jscomp$127.clamp(a, d, e));
            a = C3$jscomp$127.normalize(a, d, e);
            var m = b.GetEase();
            b = l[0];
            f = l[1];
            l = l[2];
            h = c[0];
            const p = c[1];
            c = c[2];
            m = self.Ease.GetRuntimeEase(m);
            d = e - d;
            e = d * a;
            TEMP_COLOR_ARRAY[0] = b === h ? b : m(e, b, h - b, d);
            TEMP_COLOR_ARRAY[1] = f === p ? f : m(e, f, p - f, d);
            TEMP_COLOR_ARRAY[2] = l === c ? l : m(e, l, c - l, d);
            return TEMP_COLOR_ARRAY
        }
    }
}
;
"use strict";
self.C3.PropertyTrackState.TextTypeAdapter = class {
    constructor() {}
    static WillChange(a, b, c, d) {
        let e;
        switch (d) {
        case "behavior":
            e = b.GetPropertyValueByIndex(a);
            break;
        case "effect":
            e = b[a];
            break;
        case "instance-variable":
            e = b.GetInstanceVariableValue(a);
            break;
        case "plugin":
            e = b.GetPropertyValueByIndex(a)
        }
        return e === c ? !1 : !0
    }
    static Interpolate(a, b, c, d) {
        return c ? b.GetValueWithResultMode() : (a = d.GetPropertyTrackDataItem(),
        a = d.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(a),
        a.GetValueWithResultMode())
    }
}
;
"use strict";
const C3$jscomp$129 = self.C3;
C3$jscomp$129.TimelineDataManager = class {
    constructor() {
        this._timelineDataItems = new Map
    }
    Release() {
        for (const a of this._timelineDataItems.values())
            a.Release();
        this._timelineDataItems.clear();
        this._timelineDataItems = null
    }
    Add(a) {
        a = new C3$jscomp$129.TimelineDataItem(a);
        const b = a.GetName();
        this._timelineDataItems.set(b, a)
    }
    Get(a) {
        return this._timelineDataItems.get(a)
    }
    GetNameId() {
        return 0
    }
    static _CreateDataItems(a, b, c, d) {
        if (b)
            for (const e of b)
                C3$jscomp$129.TimelineDataManager._CreateDataItem("create", e, a, c, d)
    }
    static _CreateDataItemsIncludingDisabled(a, b, c, d) {
        if (b)
            for (const e of b)
                C3$jscomp$129.TimelineDataManager._CreateDataItem("create-including-disabled", e, a, c, d)
    }
    static _LoadDataItemsFromJson(a, b, c, d) {
        a.length ? b.forEach( (e, f) => {
            a[f]._LoadFromJson(e)
        }
        ) : b.forEach(e => {
            C3$jscomp$129.TimelineDataManager._CreateDataItem("load", e, a, c, d)
        }
        )
    }
    static _CreateDataItem(a, b, c, d, e) {
        let f;
        if ("function" === typeof d)
            switch (a) {
            case "load":
                f = new d(null,e);
                break;
            case "create":
                f = new d(b,e);
                break;
            case "create-including-disabled":
                f = new d(b,e)
            }
        else if ("object" === typeof d)
            switch (d = d.map.get(b[d.prop]),
            a) {
            case "load":
                f = new d(null,e);
                break;
            case "create":
                f = new d(b,e);
                break;
            case "create-including-disabled":
                f = new d(b,e)
            }
        switch (a) {
        case "load":
            f._LoadFromJson(b);
            c.push(f);
            break;
        case "create":
            if ("function" === typeof f.GetEnable && !f.GetEnable())
                return f.Release();
            c.push(f);
            break;
        case "create-including-disabled":
            c.push(f)
        }
    }
}
;
"use strict";
const C3$jscomp$130 = self.C3;
C3$jscomp$130.TimelineDataItem = class {
    constructor(a) {
        this._name = "";
        this._totalTime = NaN;
        this._step = 0;
        this._resultMode = this._interpolationMode = "default";
        this._pingPong = this._loop = !1;
        this._repeatCount = 1;
        this._trackData = null;
        this._startOnLayout = "";
        this._transformWithSceneGraph = !1;
        this._useSystemTimescale = !0;
        a && (this._name = a[0],
        this._totalTime = a[1],
        this._step = a[2],
        this._interpolationMode = a[3],
        this._resultMode = a[4],
        this._loop = !!a[6],
        this._pingPong = !!a[7],
        this._repeatCount = a[8],
        this._startOnLayout = a[9],
        this._transformWithSceneGraph = !!a[10],
        this._useSystemTimescale = !!a[11],
        this._trackData = new C3$jscomp$130.TrackData(a[5],this))
    }
    Release() {
        this._trackData.Release();
        this._trackData = null
    }
    GetTrackData() {
        this._trackData || (this._trackData = new C3$jscomp$130.TrackData(null,this));
        return this._trackData
    }
    GetName() {
        return this._name
    }
    SetName(a) {
        this._name = a
    }
    GetTotalTime() {
        return this._totalTime
    }
    SetTotalTime(a) {
        this._totalTime = a
    }
    GetStep() {
        return this._step
    }
    SetStep(a) {
        this._step = a
    }
    GetInterpolationMode() {
        return this._interpolationMode
    }
    SetInterpolationMode(a) {
        this._interpolationMode = a
    }
    GetResultMode() {
        return this._resultMode
    }
    SetResultMode(a) {
        this._resultMode = a
    }
    GetLoop() {
        return this._loop
    }
    SetLoop(a) {
        this._loop = a
    }
    GetPingPong() {
        return this._pingPong
    }
    SetPingPong(a) {
        this._pingPong = a
    }
    GetRepeatCount() {
        return this._repeatCount
    }
    SetRepeatCount(a) {
        this._repeatCount = a
    }
    GetStartOnLayout() {
        return this._startOnLayout
    }
    GetTransformWithSceneGraph() {
        return this._transformWithSceneGraph
    }
    GetUseSystemTimescale() {
        return this._useSystemTimescale
    }
    _SaveToJson() {
        return {
            trackDataJson: this._trackData._SaveToJson(),
            name: this._name,
            totalTime: this._totalTime,
            step: this._step,
            interpolationMode: this._interpolationMode,
            resultMode: this._resultMode,
            loop: this._loop,
            pingPong: this._pingPong,
            repeatCount: this._repeatCount,
            startOnLayout: this._startOnLayout,
            transformWithSceneGraph: !!this._transformWithSceneGraph,
            useSystemTimescale: this._useSystemTimescale
        }
    }
    _LoadFromJson(a) {
        a && (this.GetTrackData()._LoadFromJson(a.trackDataJson),
        this._name = a.name,
        this._totalTime = a.totalTime,
        this._step = a.step,
        this._interpolationMode = a.interpolationMode,
        this._resultMode = a.resultMode,
        this._loop = a.loop,
        this._pingPong = a.pingPong,
        this._repeatCount = a.repeatCount,
        this._startOnLayout = a.startOnLayout,
        this._transformWithSceneGraph = !!a.transformWithSceneGraph,
        this._useSystemTimescale = !!a.useSystemTimescale)
    }
}
;
"use strict";
const C3$jscomp$131 = self.C3;
class TrackDataItem {
    constructor(a, b) {
        this._trackData = b;
        this._additionalInstanceData = this._instanceData = null;
        this._objectClassIndex = this._instanceUid = NaN;
        this._resultMode = this._interpolationMode = "default";
        this._enabled = !1;
        this._propertyTrackData = this._keyframeData = null;
        this._id = "";
        this._nestedData = null;
        this._startOffset = 0;
        this._localTotalTime = this._trackData.GetTimelineDataItem().GetTotalTime();
        this._type = 0;
        this._name = "";
        a && (a[0] && (this._instanceData = a[0],
        this._instanceUid = a[0][2],
        this._objectClassIndex = a[0][1]),
        this._interpolationMode = a[1],
        this._resultMode = a[2],
        this._enabled = !!a[3],
        a[6] && (this._id = a[6]),
        a[7] && (this._nestedData = a[7],
        this._startOffset = a[7][0],
        this._localTotalTime = a[7][1]),
        a[8] && (this._additionalInstanceData = a[8]),
        a[8] && (this._additionalInstanceData = a[8]),
        a[9] && (this._type = a[9]),
        a[10] && (this._name = a[10]),
        this._keyframeData = new C3$jscomp$131.KeyframeData(a[4],this),
        this._propertyTrackData = new C3$jscomp$131.PropertyTrackData(a[5],this))
    }
    Release() {
        this._trackData = this._instanceData = null;
        this._keyframeData && (this._keyframeData.Release(),
        this._keyframeData = null);
        this._propertyTrackData && (this._propertyTrackData.Release(),
        this._propertyTrackData = null);
        this._nestedData = null
    }
    GetTrackData() {
        return this._trackData
    }
    GetKeyframeData() {
        this._keyframeData || (this._keyframeData = new C3$jscomp$131.KeyframeData(null,this));
        return this._keyframeData
    }
    GetPropertyTrackData() {
        this._propertyTrackData || (this._propertyTrackData = new C3$jscomp$131.PropertyTrackData(null,this));
        return this._propertyTrackData
    }
    GetInstanceData() {
        return this._instanceData
    }
    GetObjectClassIndex() {
        return this._objectClassIndex
    }
    SetObjectClassIndex(a) {
        this._objectClassIndex = a
    }
    GetInstanceUID() {
        return this._instanceUid
    }
    SetInstanceUID(a) {
        this._instanceUid = a
    }
    GetInterpolationMode() {
        return this._interpolationMode
    }
    SetInterpolationMode(a) {
        this._interpolationMode = a
    }
    GetResultMode() {
        return this._resultMode
    }
    SetResultMode(a) {
        this._resultMode = a
    }
    GetEnable() {
        return this._enabled
    }
    SetEnable(a) {
        this._enabled = !!a
    }
    GetId() {
        return this._id
    }
    GetStartOffset() {
        return this._startOffset
    }
    GetLocalTotalTime() {
        return this._localTotalTime
    }
    SetLocalTotalTime(a) {
        this._localTotalTime = a
    }
    GetOriginalWidth() {
        return this._additionalInstanceData[0]
    }
    SetOriginalWidth(a) {
        this._additionalInstanceData || (this._additionalInstanceData = []);
        this._additionalInstanceData[0] = a
    }
    GetOriginalHeight() {
        this._additionalInstanceData || (this._additionalInstanceData = []);
        return this._additionalInstanceData[1]
    }
    SetOriginalHeight(a) {
        this._additionalInstanceData || (this._additionalInstanceData = []);
        this._additionalInstanceData[1] = a
    }
    GetType() {
        return this._type
    }
    GetName() {
        return this._name
    }
    _SaveToJson() {
        return {
            keyframeDataJson: this._keyframeData._SaveToJson(),
            propertyTrackDataJson: this._propertyTrackData._SaveToJson(),
            instanceData: this._instanceData,
            additionalInstanceData: this._additionalInstanceData,
            instanceUid: this._instanceUid,
            objectClassIndex: this._objectClassIndex,
            interpolationMode: this._interpolationMode,
            resultMode: this._resultMode,
            enabled: this._enabled,
            id: this._id,
            nestedData: this._nestedData,
            type: this._type,
            name: this._name
        }
    }
    _LoadFromJson(a) {
        a && (this._instanceData = a.instanceData,
        this._instanceUid = a.instanceUid,
        this._objectClassIndex = a.objectClassIndex,
        this._interpolationMode = a.interpolationMode,
        this._resultMode = a.resultMode,
        this._enabled = a.enabled,
        this._id = a.id,
        this._type = a.type ? a.type : 0,
        this._name = a.name ? a.name : "",
        this._localTotalTime = this._trackData.GetTimelineDataItem().GetTotalTime(),
        a.nestedData && (this._nestedData = a.nestedData,
        this._startOffset = this._nestedData[0],
        this._localTotalTime = this._nestedData[1]),
        a.additionalInstanceData && (this._additionalInstanceData = a.additionalInstanceData),
        this.GetKeyframeData()._LoadFromJson(a.keyframeDataJson),
        this.GetPropertyTrackData()._LoadFromJson(a.propertyTrackDataJson))
    }
}
C3$jscomp$131.TrackData = class {
    constructor(a, b) {
        this._timelineDataItem = b;
        this._trackDataItems = [];
        C3$jscomp$131.TimelineDataManager._CreateDataItems(this._trackDataItems, a, TrackDataItem, this)
    }
    Release() {
        this._timelineDataItem = null;
        for (const a of this._trackDataItems)
            a.Release();
        C3$jscomp$131.clearArray(this._trackDataItems);
        this._trackDataItems = null
    }
    GetTimelineDataItem() {
        return this._timelineDataItem
    }
    AddEmptyTrackDataItem() {
        const a = new TrackDataItem(null,this);
        this._trackDataItems.push(a);
        return a
    }
    GetFirstKeyframeDataItem(a) {
        return a.GetKeyframeData().GetKeyframeDataItemArray()[0]
    }
    GetLastKeyframeDataItem(a) {
        return a.GetKeyframeData().GetKeyframeDataItemArray().at(-1)
    }
    GetKeyFrameDataItemAtTime(a, b) {
        b = b.GetKeyframeData().GetKeyframeDataItemArray();
        const c = b.length;
        for (let d = 0; d < c; d++) {
            const e = b[d];
            if (e.GetTime() === a)
                return e
        }
    }
    GetFirstKeyFrameDataItemHigherThan(a, b) {
        b = b.GetKeyframeData().GetKeyframeDataItemArray();
        const c = b.length;
        for (let d = 0; d < c; d++) {
            const e = b[d];
            if (e.GetTime() > a)
                return e
        }
    }
    GetFirstKeyFrameDataItemHigherOrEqualThan(a, b) {
        b = b.GetKeyframeData().GetKeyframeDataItemArray();
        const c = b.length;
        for (let d = 0; d < c; d++) {
            const e = b[d];
            if (e.GetTime() >= a)
                return e
        }
    }
    GetFirstKeyFrameDataItemLowerOrEqualThan(a, b) {
        b = b.GetKeyframeData().GetKeyframeDataItemArray();
        for (let c = b.length - 1; 0 <= c; c--) {
            const d = b[c];
            if (d.GetTime() <= a)
                return d
        }
    }
    *trackDataItems() {
        for (const a of this._trackDataItems)
            yield a
    }
    _SaveToJson() {
        return {
            trackDataItemsJson: this._trackDataItems.map(a => a._SaveToJson())
        }
    }
    _LoadFromJson(a) {
        a && C3$jscomp$131.TimelineDataManager._LoadDataItemsFromJson(this._trackDataItems, a.trackDataItemsJson, TrackDataItem, this)
    }
}
;
"use strict";
const C3$jscomp$132 = self.C3;
class PropertyTrackDataItem {
    constructor(a, b) {
        this._propertyTrackData = b;
        this._sourceAdapterId = "";
        this._type = this._property = this._sourceAdapterArguments = null;
        this._max = this._min = NaN;
        this._resultMode = this._interpolationMode = "default";
        this._enabled = !1;
        this._propertyKeyframeData = null;
        this._canHavePropertyKeyframes = !0;
        a && (this._sourceAdapterId = a[0][0],
        this._sourceAdapterArguments = a[0].slice(1),
        this._property = a[1],
        this._type = a[2],
        this._min = a[3],
        this._max = a[4],
        this._interpolationMode = a[5],
        this._resultMode = a[6],
        this._enabled = !!a[7],
        this._propertyKeyframeData = new C3$jscomp$132.PropertyKeyframeData(a[8],this),
        this._canHavePropertyKeyframes = a[9])
    }
    Release() {
        this._propertyKeyframeData.Release();
        this._sourceAdapterArguments = this._propertyTrackData = this._propertyKeyframeData = null
    }
    GetPropertyTrackData() {
        return this._propertyTrackData
    }
    GetPropertyKeyframeData() {
        this._propertyKeyframeData || (this._propertyKeyframeData = new C3$jscomp$132.PropertyKeyframeData(null,this));
        return this._propertyKeyframeData
    }
    GetSourceAdapterId() {
        return this._sourceAdapterId
    }
    SetSourceAdapterId(a) {
        this._sourceAdapterId = a
    }
    GetSourceAdapterArguments() {
        return this._sourceAdapterArguments
    }
    SetSourceAdapterArguments(a) {
        this._sourceAdapterArguments = a
    }
    GetProperty() {
        return this._property
    }
    SetProperty(a) {
        this._property = a
    }
    GetType() {
        return this._type
    }
    SetType(a) {
        this._type = a
    }
    GetMin() {
        return this._min
    }
    SetMin(a) {
        this._min = a
    }
    GetMax() {
        return this._max
    }
    SetMax(a) {
        this._max = a
    }
    GetInterpolationMode() {
        return this._interpolationMode
    }
    SetInterpolationMode(a) {
        this._interpolationMode = a
    }
    GetResultMode() {
        return this._resultMode
    }
    SetResultMode(a) {
        this._resultMode = a
    }
    GetEnable() {
        return this._enabled
    }
    SetEnable(a) {
        this._enabled = !!a
    }
    CanHavePropertyKeyframes() {
        return !!this._canHavePropertyKeyframes
    }
    _SaveToJson() {
        return {
            propertyKeyframeDataJson: this._propertyKeyframeData._SaveToJson(),
            sourceAdapterId: this._sourceAdapterId,
            sourceAdapterArguments: this._sourceAdapterArguments,
            property: this._property,
            type: this._type,
            min: this._min,
            max: this._max,
            interpolationMode: this._interpolationMode,
            resultMode: this._resultMode,
            enabled: this._enabled,
            canHavePropertyKeyframes: this._canHavePropertyKeyframes
        }
    }
    _LoadFromJson(a) {
        a && (this._sourceAdapterId = a.sourceAdapterId,
        this._sourceAdapterArguments = a.sourceAdapterArguments,
        this._property = a.property,
        this._type = a.type,
        this._min = a.min,
        this._max = a.max,
        this._interpolationMode = a.interpolationMode,
        this._resultMode = a.resultMode,
        this._enabled = a.enabled,
        this._canHavePropertyKeyframes = a.canHavePropertyKeyframes,
        this.GetPropertyKeyframeData()._LoadFromJson(a.propertyKeyframeDataJson))
    }
}
C3$jscomp$132.PropertyTrackData = class {
    constructor(a, b) {
        this._trackDataItem = b;
        this._propertyTrackDataItems = [];
        C3$jscomp$132.TimelineDataManager._CreateDataItems(this._propertyTrackDataItems, a, PropertyTrackDataItem, this)
    }
    Release() {
        this._trackDataItem = null;
        for (const a of this._propertyTrackDataItems)
            a.Release();
        C3$jscomp$132.clearArray(this._propertyTrackDataItems);
        this._propertyTrackDataItems = null
    }
    GetTrackDataItem() {
        return this._trackDataItem
    }
    AddEmptyPropertyTrackDataItem() {
        const a = new PropertyTrackDataItem(null,this);
        this._propertyTrackDataItems.push(a);
        return a
    }
    GetFirstPropertyKeyframeDataItem(a) {
        return a.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray()[0]
    }
    GetLastPropertyKeyframeDataItem(a) {
        return a.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray().at(-1)
    }
    GetPropertyKeyFrameDataItemAtTime(a, b) {
        b = b.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray();
        const c = b.length;
        for (let d = 0; d < c; d++) {
            const e = b[d];
            if (e.GetTime() === a)
                return e
        }
    }
    GetFirstPropertyKeyFrameDataItemHigherThan(a, b) {
        b = b.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray();
        const c = b.length;
        for (let d = 0; d < c; d++) {
            const e = b[d];
            if (e.GetTime() > a)
                return e
        }
    }
    GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(a, b) {
        b = b.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray();
        const c = b.length;
        for (let d = 0; d < c; d++) {
            const e = b[d];
            if (e.GetTime() >= a)
                return e
        }
    }
    GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a, b) {
        b = b.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray();
        for (let c = b.length - 1; 0 <= c; c--) {
            const d = b[c];
            if (d.GetTime() <= a)
                return d
        }
    }
    *propertyTrackDataItems() {
        for (const a of this._propertyTrackDataItems)
            yield a
    }
    _SaveToJson() {
        return {
            propertyTrackDataItemsJson: this._propertyTrackDataItems.map(a => a._SaveToJson())
        }
    }
    _LoadFromJson(a) {
        a && C3$jscomp$132.TimelineDataManager._LoadDataItemsFromJson(this._propertyTrackDataItems, a.propertyTrackDataItemsJson, PropertyTrackDataItem, this)
    }
}
;
"use strict";
const C3$jscomp$133 = self.C3;
class KeyframeDataItem {
    constructor(a, b) {
        this._keyframeData = b;
        this._time = -1;
        this._ease = "noease";
        this._enable = !1;
        this._lowerTags = this._tags = null;
        a && (this._time = a[0],
        this._ease = a[1],
        this._enable = !!a[2],
        this._tags = (a = a[3]) ? a.split(" ") : [],
        this._lowerTags = new Set(this._tags.map(c => c.toLowerCase())),
        this._next = null)
    }
    Release() {
        this._keyframeData = null;
        C3$jscomp$133.clearArray(this._tags);
        this._tags = null;
        this._lowerTags.clear();
        this._next = this._lowerTags = null
    }
    GetKeyframeData() {
        return this._keyframeData
    }
    GetNext() {
        return this._next
    }
    SetNext(a) {
        this._next = a
    }
    GetTime() {
        return this._time
    }
    SetTime(a) {
        this._time = a;
        this._keyframeData._LinkKeyframeDataItems()
    }
    GetEase() {
        return this._ease
    }
    SetEase(a) {
        this._ease = a
    }
    GetEnable() {
        return this._enable
    }
    SetEnable(a) {
        this._enable = !!a
    }
    GetTags() {
        return this._tags
    }
    SetTags(a) {
        this._tags = a ? a.split(" ") : [];
        this._lowerTags = new Set(this._tags.map(b => b.toLowerCase()))
    }
    GetLowerTags() {
        return this._lowerTags
    }
    HasTag(a) {
        return this._lowerTags.has(a.toLowerCase())
    }
    _SaveToJson() {
        return {
            time: this._time,
            ease: this._ease,
            enable: this._enable,
            tags: this._tags
        }
    }
    _LoadFromJson(a) {
        a && (this._time = a.time,
        this._ease = a.ease,
        this._enable = a.enable,
        this._tags = a.tags,
        this._lowerTags = new Set(this._tags.map(b => b.toLowerCase())))
    }
}
C3$jscomp$133.KeyframeData = class {
    constructor(a, b) {
        this._trackDataItem = b;
        this._keyframeDataItems = [];
        C3$jscomp$133.TimelineDataManager._CreateDataItems(this._keyframeDataItems, a, KeyframeDataItem, this);
        this._LinkKeyframeDataItems()
    }
    Release() {
        this._trackDataItem = null;
        for (const a of this._keyframeDataItems)
            a.Release();
        C3$jscomp$133.clearArray(this._keyframeDataItems);
        this._keyframeDataItems = null
    }
    _LinkKeyframeDataItems() {
        this._keyframeDataItems.sort( (a, b) => a.GetTime() - b.GetTime());
        for (let a = 0; a < this._keyframeDataItems.length; a++)
            this._keyframeDataItems[a].SetNext(this._keyframeDataItems[a + 1])
    }
    GetTrackDataItem() {
        return this._trackDataItem
    }
    GetKeyframeDataItemCount() {
        return this._keyframeDataItems.length
    }
    GetKeyframeDataItemArray() {
        return this._keyframeDataItems
    }
    AddEmptyKeyframeDataItem() {
        const a = new KeyframeDataItem(null,this);
        this._keyframeDataItems.push(a);
        this._LinkKeyframeDataItems();
        return a
    }
    DeleteKeyframeDataItems(a) {
        for (const b of this._keyframeDataItems) {
            if (!a(b))
                continue;
            const c = this._keyframeDataItems.indexOf(b);
            -1 !== c && (b.Release(),
            this._keyframeDataItems.splice(c, 1))
        }
        this.SortKeyframeDataItems();
        this._LinkKeyframeDataItems()
    }
    SortKeyframeDataItems() {
        this._keyframeDataItems.sort( (a, b) => a.GetTime() - b.GetTime())
    }
    GetKeyframeDataItemIndex(a) {
        return this._keyframeDataItems.indexOf(a)
    }
    GetKeyframeDataItemFromIndex(a) {
        return this._keyframeDataItems[a]
    }
    *keyframeDataItems() {
        for (const a of this._keyframeDataItems)
            yield a
    }
    *keyframeDataItemsReverse() {
        for (let a = this._keyframeDataItems.length - 1; 0 <= a; a--)
            yield this._keyframeDataItems[a]
    }
    _SaveToJson() {
        return {
            keyframeDataItemsJson: this._keyframeDataItems.map(a => a._SaveToJson())
        }
    }
    _LoadFromJson(a) {
        a && (C3$jscomp$133.TimelineDataManager._LoadDataItemsFromJson(this._keyframeDataItems, a.keyframeDataItemsJson, KeyframeDataItem, this),
        this._LinkKeyframeDataItems())
    }
}
;
"use strict";
const C3$jscomp$134 = self.C3;
class PropertyKeyframeDataItem {
    constructor(a, b) {
        this._propertyKeyframeData = b;
        this._aValue = this._value = null;
        this._type = "";
        this._time = NaN;
        this._ease = "noease";
        this._enable = !1;
        this._addonData = null;
        this._addonInstance = void 0;
        this._pathMode = "line";
        a && (this._value = a[0][0],
        this._aValue = a[0][1],
        this._type = a[0][2],
        this._time = a[1],
        this._ease = a[2],
        this._enable = !!a[3],
        this._pathMode = a[5],
        this._addonData = null,
        a[4] && (this._addonData = new C3$jscomp$134.AddonData(a[4],this)),
        this._prev = this._next = null)
    }
    Release() {
        this._propertyKeyframeData = null;
        this._addonData && (this._addonData.Release(),
        this._addonData = null);
        this._prev = this._next = null
    }
    GetAddonData() {
        return this._addonData
    }
    SetNext(a) {
        this._next = a
    }
    GetNext() {
        return this._next
    }
    SetPrevious(a) {
        this._prev = a
    }
    GetPrevious() {
        return this._prev
    }
    GetValue() {
        return this._value
    }
    SetValue(a) {
        "color" === this._type && C3$jscomp$134.IsFiniteNumber(a) ? (this._value[0] = C3$jscomp$134.GetRValue(a),
        this._value[1] = C3$jscomp$134.GetGValue(a),
        this._value[2] = C3$jscomp$134.GetBValue(a)) : this._value = a
    }
    GetAbsoluteValue() {
        return this._aValue
    }
    SetAbsoluteValue(a) {
        "color" === this._type && C3$jscomp$134.IsFiniteNumber(a) ? (this._aValue[0] = C3$jscomp$134.GetRValue(a),
        this._aValue[1] = C3$jscomp$134.GetGValue(a),
        this._aValue[2] = C3$jscomp$134.GetBValue(a)) : this._aValue = a
    }
    GetValueWithResultMode() {
        const a = this._propertyKeyframeData.GetPropertyTrackDataItem().GetResultMode();
        if ("relative" === a)
            return this.GetValue();
        if ("absolute" === a)
            return this.GetAbsoluteValue()
    }
    GetType() {
        return this._type
    }
    SetType(a) {
        this._type = a
    }
    GetTime() {
        return this._time
    }
    SetTime(a) {
        this._time = a;
        this._propertyKeyframeData._LinkPropertyKeyframeDataItems()
    }
    GetEase() {
        return this._ease
    }
    SetEase(a) {
        this._ease = a
    }
    GetEnable() {
        return this._enable
    }
    SetEnable(a) {
        this._enable = !!a
    }
    GetPathMode() {
        return this._pathMode
    }
    GetAddOn(a) {
        if (this._addonData) {
            if (this._addonInstance || null === this._addonInstance)
                return this._addonInstance;
            var b = this._addonData.GetAddDataItemArray();
            if (!b)
                return this._addonInstance = null;
            var c = b.length;
            for (let d = 0; d < c; d++) {
                const e = b[d];
                if (e.GetId() === a)
                    return this._addonInstance = e
            }
            return this._addonInstance = null
        }
    }
    _SaveToJson() {
        const a = this._addonData;
        return {
            addonDataJson: a ? a._SaveToJson() : a,
            value: this._value,
            aValue: this._aValue,
            type: this._type,
            time: this._time,
            ease: this._ease,
            enable: this._enable
        }
    }
    _LoadFromJson(a) {
        a && (a.addonDataJson && this._addonData._SetFromJson(a.addonDataJson),
        this._value = a.value,
        this._aValue = a.aValue,
        this._type = a.type,
        this._time = a.time,
        this._ease = a.ease,
        this._enable = a.enable)
    }
}
C3$jscomp$134.PropertyKeyframeData = class {
    constructor(a, b) {
        this._propertyTrackDataItem = b;
        this._propertyKeyframeDataItems = [];
        this._propertyKeyframeDataItemsIncludingDisabled = [];
        C3$jscomp$134.TimelineDataManager._CreateDataItems(this._propertyKeyframeDataItems, a, PropertyKeyframeDataItem, this);
        C3$jscomp$134.TimelineDataManager._CreateDataItemsIncludingDisabled(this._propertyKeyframeDataItemsIncludingDisabled, a, PropertyKeyframeDataItem, this);
        this._LinkPropertyKeyframeDataItems()
    }
    Release() {
        this._propertyTrackDataItem = null;
        for (const a of this._propertyKeyframeDataItems)
            a.Release();
        C3$jscomp$134.clearArray(this._propertyKeyframeDataItems);
        this._propertyKeyframeDataItems = null;
        for (const a of this._propertyKeyframeDataItemsIncludingDisabled)
            a.Release();
        C3$jscomp$134.clearArray(this._propertyKeyframeDataItemsIncludingDisabled);
        this._propertyKeyframeDataItemsIncludingDisabled = null
    }
    _LinkPropertyKeyframeDataItems() {
        let a = this._propertyKeyframeDataItems;
        a.sort( (d, e) => d.GetTime() - e.GetTime());
        for (var b = 0; b < a.length; b++) {
            var c = a[b];
            b + 1 < a.length && c.SetNext(a[b + 1]);
            0 <= b - 1 && c.SetPrevious(a[b - 1])
        }
        a = this._propertyKeyframeDataItemsIncludingDisabled;
        a.sort( (d, e) => d.GetTime() - e.GetTime());
        for (b = 0; b < a.length; b++)
            c = a[b],
            b + 1 < a.length && c.SetNext(a[b + 1]),
            0 <= b - 1 && c.SetPrevious(a[b - 1])
    }
    AddEmptyPropertyKeyframeDataItem() {
        const a = new PropertyKeyframeDataItem(null,this);
        this._propertyKeyframeDataItems.push(a);
        this._LinkPropertyKeyframeDataItems();
        return a
    }
    DeletePropertyKeyframeDataItems(a) {
        for (const b of this._propertyKeyframeDataItems) {
            if (!a(b))
                continue;
            const c = this._propertyKeyframeDataItems.indexOf(b);
            -1 !== c && (b.Release(),
            this._propertyKeyframeDataItems.splice(c, 1))
        }
        this.SortPropertyKeyFrameDataItems();
        this._LinkPropertyKeyframeDataItems()
    }
    SortPropertyKeyFrameDataItems() {
        this._propertyKeyframeDataItems.sort( (a, b) => a.GetTime() - b.GetTime())
    }
    GetPropertyTrackDataItem() {
        return this._propertyTrackDataItem
    }
    GetPropertyKeyframeDataItemCount() {
        return this._propertyKeyframeDataItems.length
    }
    GetLastPropertyKeyframeDataItem() {
        return this._propertyKeyframeDataItems[this._propertyKeyframeDataItems.length - 1]
    }
    GetPropertyKeyframeDataItemArray() {
        return this._propertyKeyframeDataItems
    }
    GetPropertyKeyframeDataItemArrayIncludingDisabled() {
        return this._propertyKeyframeDataItemsIncludingDisabled
    }
    *propertyKeyframeDataItems() {
        for (const a of this._propertyKeyframeDataItems)
            yield a
    }
    *propertyKeyframeDataItemsReverse() {
        for (let a = this._propertyKeyframeDataItems.length - 1; 0 <= a; a--)
            yield this._propertyKeyframeDataItems[a]
    }
    _SaveToJson() {
        const a = this._propertyKeyframeDataItemsIncludingDisabled;
        return {
            propertyKeyframeDataItemsJson: this._propertyKeyframeDataItems.map(b => b._SaveToJson()),
            propertyKeyframeDataItemsIncludingDisabledJson: a.map(b => b._SaveToJson())
        }
    }
    _LoadFromJson(a) {
        a && (C3$jscomp$134.TimelineDataManager._LoadDataItemsFromJson(this._propertyKeyframeDataItems, a.propertyKeyframeDataItemsJson, PropertyKeyframeDataItem, this),
        C3$jscomp$134.TimelineDataManager._LoadDataItemsFromJson(this._propertyKeyframeDataItemsIncludingDisabled, a.propertyKeyframeDataItemsIncludingDisabledJson, PropertyKeyframeDataItem, this),
        this._LinkPropertyKeyframeDataItems())
    }
}
;
"use strict";
const C3$jscomp$135 = self.C3;
class AddonDataItem {
    constructor(a, b) {
        this._addonData = b;
        this._id = a[0];
        this._data = a[1]
    }
    Release() {
        this._data = this._addonData = null
    }
    GetAddonData() {
        return this._addonData
    }
    GetId() {
        return this._id
    }
    _SaveToJson() {
        return {
            id: this._id,
            data: this._data
        }
    }
    _LoadFromJson(a) {
        a && (this._id = a.id,
        this._data = a.data)
    }
}
class AddonDataCubicBezierItem extends AddonDataItem {
    constructor(a, b) {
        super(a, b);
        this._startAnchor = this._data[0];
        this._startEnable = !!this._data[1];
        this._endAnchor = this._data[2];
        this._endEnable = !!this._data[3]
    }
    Release() {
        super.Release()
    }
    GetStartAnchor() {
        return this._startAnchor
    }
    GetStartEnable() {
        return this._startEnable
    }
    GetEndAnchor() {
        return this._endAnchor
    }
    GetEndEnable() {
        return this._endEnable
    }
    _SaveToJson() {
        return Object.assign(super._SaveToJson(), {
            startAnchor: this._startAnchor,
            startEnable: !!this._startEnable,
            endAnchor: this._endAnchor,
            endEnable: !!this._endEnable
        })
    }
    _LoadFromJson(a) {
        a && (super._LoadFromJson(a),
        this._startAnchor = a.startAnchor,
        this._startEnable = !!a.startEnable,
        this._endAnchor = a.endAnchor,
        this._endEnable = !!a.endEnable)
    }
}
class AddonDataAngleItem extends AddonDataItem {
    constructor(a, b) {
        super(a, b);
        this._direction = this._data[0];
        this._revolutions = this._data[1]
    }
    Release() {
        super.Release()
    }
    GetDirection() {
        return this._direction
    }
    GetRevolutions() {
        return this._revolutions
    }
    _SaveToJson() {
        return Object.assign(super._SaveToJson(), {
            direction: this._direction,
            revolutions: this._revolutions
        })
    }
    _LoadFromJson(a) {
        a && (super._LoadFromJson(a),
        this._direction = a.direction,
        this._revolutions = a.revolutions)
    }
}
C3$jscomp$135.AddonData = class {
    constructor(a, b) {
        this._propertyKeyframeDataItem = b;
        this._addonDataItems = [];
        C3$jscomp$135.TimelineDataManager._CreateDataItems(this._addonDataItems, a, {
            prop: 0,
            map: new Map([["cubic-bezier", AddonDataCubicBezierItem], ["angle", AddonDataAngleItem]])
        }, this)
    }
    Release() {
        this._propertyKeyframeDataItem = null;
        for (const a of this._addonDataItems)
            a.Release();
        C3$jscomp$135.clearArray(this._addonDataItems);
        this._addonDataItems = null
    }
    GetPropertyKeyframeDataItem() {
        return this._propertyKeyframeDataItem
    }
    GetAddDataItemArray() {
        return this._addonDataItems
    }
    *addonDataItems() {
        for (const a of this._addonDataItems)
            yield a
    }
    _SaveToJson() {
        return {
            addonDataItemsJson: this._addonDataItems.map(a => a._SaveToJson())
        }
    }
    _LoadFromJson(a) {
        a && C3$jscomp$135.TimelineDataManager._LoadDataItemsFromJson(this._addonDataItems, a.addonDataItemsJson, {
            prop: "id",
            map: new Map([["cubic-bezier", AddonDataCubicBezierItem], ["angle", AddonDataAngleItem]])
        }, this)
    }
}
;
"use strict";
const C3$jscomp$136 = self.C3;
let createdTweens = 0;
C3$jscomp$136.TweenState = class extends C3$jscomp$136.TimelineState {
    constructor(a, b) {
        super(`tween-${createdTweens++}`, a, b);
        this._id = "";
        this._destroyInstanceOnComplete = !1;
        this._initialValueMode = "start-value";
        this._iTweenState = this._track = this._on_started_callbacks = this._on_completed_callbacks = this._instance = null
    }
    FireReleaseEvent(a) {
        const b = C3$jscomp$136.New(C3$jscomp$136.Event, "tweenstatereleased");
        b.tweenState = this;
        a.dispatchEvent(b)
    }
    GetType() {
        return 1
    }
    CreateTrackStates() {
        for (const a of this._timelineDataItem.GetTrackData().trackDataItems())
            this._tracks.push(C3$jscomp$136.TweenTrackState.Create(this, a));
        this._track = this._tracks[0]
    }
    AddTrack() {
        var a = this._timelineDataItem.GetTrackData().AddEmptyTrackDataItem();
        a = C3$jscomp$136.TweenTrackState.Create(this, a);
        this._tracks.push(a);
        this._CacheTrack();
        return a
    }
    _CacheTrack() {
        this._track = this._tracks[0]
    }
    GetPropertyTrack(a) {
        return this._track.GetPropertyTracks()[0]
    }
    SetPropertyType(a) {
        this._propertyType = a
    }
    GetInstance() {
        var a = this.GetTracks();
        if (a && a.length && (this._track = a = a[0])) {
            var b = a.GetInstance();
            return a.IsInstanceValid() ? b : void 0
        }
    }
    AddStartedCallback(a) {
        this._on_started_callbacks || (this._on_started_callbacks = []);
        this._on_started_callbacks.push(a)
    }
    AddCompletedCallback(a) {
        this._on_completed_callbacks || (this._on_completed_callbacks = []);
        this._on_completed_callbacks.push(a)
    }
    RemoveStartedCallback(a) {
        this._on_started_callbacks && (a = this._on_started_callbacks.indexOf(a),
        -1 !== a && this._on_started_callbacks.splice(a, 1))
    }
    RemoveCompletedCallback(a) {
        this._on_completed_callbacks && (a = this._on_completed_callbacks.indexOf(a),
        -1 !== a && this._on_completed_callbacks.splice(a, 1))
    }
    SetStartValue(a, b) {
        for (const d of this._tracks)
            for (const e of d._propertyTracks) {
                if (e.GetPropertyName() !== b)
                    continue;
                var c = e.GetPropertyTrackData();
                const f = e.GetPropertyTrackDataItem();
                c = c.GetFirstPropertyKeyframeDataItem(f);
                c.SetValue(a);
                c.SetAbsoluteValue(a)
            }
    }
    _GetPropertyTrackState(a) {
        for (const b of this._tracks)
            for (const c of b._propertyTracks)
                if (c.GetPropertyName() === a)
                    return c
    }
    BeforeSetEndValues(a) {
        for (const d of a)
            a = this._GetPropertyTrackState(d),
            this.SetStartValue(a.GetCurrentState(), d);
        if (this.IsForwardPlayBack()) {
            var b = this.GetTotalTime() - this.GetTime();
            this.SetTotalTime(b);
            for (var c of this._tracks)
                c.SetLocalTotalTime(b);
            this._SetTime(0)
        } else {
            c = this.GetTime();
            this.SetTotalTime(c);
            for (b of this._tracks)
                b.SetLocalTotalTime(c);
            this._SetTime(c)
        }
        this.SetInitialStateFromSetTime()
    }
    SetEndValue(a, b) {
        var c = this._GetPropertyTrackState(b);
        b = c.GetPropertyTrackData();
        c = c.GetPropertyTrackDataItem();
        b = b.GetLastPropertyKeyframeDataItem(c);
        b.SetTime(this.GetTotalTime());
        b.SetValue(a);
        b.SetAbsoluteValue(a)
    }
    SetId(a) {
        this._id = a
    }
    GetId() {
        return this._id
    }
    SetInitialValueMode(a) {
        this._initialValueMode = a
    }
    GetInitialValueMode() {
        return this._initialValueMode
    }
    SetDestroyInstanceOnComplete(a) {
        this._destroyInstanceOnComplete = a
    }
    GetDestroyInstanceOnComplete() {
        return this._destroyInstanceOnComplete
    }
    OnStarted() {
        if (this._on_started_callbacks)
            for (const a of this._on_started_callbacks)
                a(this);
        if (!this.IsComplete())
            for (const a of this._tracks)
                a.CompareSaveStateWithCurrent()
    }
    OnCompleted() {
        this._completedTick = this._runtime.GetTickCount()
    }
    FinishTriggers() {
        if (!this._finishedTriggers && (this._finishedTriggers = !0,
        this._on_completed_callbacks))
            for (const a of this._on_completed_callbacks)
                a(this)
    }
    SetTime(a) {
        this._DeleteIntermediateKeyframes();
        super.SetTime(a)
    }
    _SetTimeAndReset(a) {
        C3$jscomp$136.IsFiniteNumber(a) || (a = this.GetTotalTime());
        0 > a ? this._playheadTime = 0 : a >= this.GetTotalTime() ? this._playheadTime = this.GetTotalTime() : this._playheadTime = a;
        this._track.SetResetState()
    }
    SetInitialState(a) {
        if (!this.InitialStateSet() && "current-state" === this.GetInitialValueMode())
            for (const b of this._tracks)
                b.CompareInitialStateWithCurrent();
        super.SetInitialState(a)
    }
    Stop(a=!1) {
        super.Stop(a);
        if (!this.IsComplete())
            for (const b of this._tracks)
                b.SaveState()
    }
    Reset(a=!0, b=!1) {
        this._DeleteIntermediateKeyframes();
        super.Reset(a, b)
    }
    _DeleteIntermediateKeyframes() {
        for (const a of this._tracks) {
            const b = c => {
                c = c.GetTime();
                const d = this.GetTotalTime();
                return 0 !== c && c !== d
            }
            ;
            a.DeleteKeyframes(b);
            a.DeletePropertyKeyframes(b)
        }
    }
    _OnBeforeChangeLayout() {
        if (this.IsReleased())
            return !0;
        const a = this.GetInstance();
        if (a && a.GetObjectClass().IsGlobal())
            return !1;
        this._timelineManager.CompleteTimelineBeforeChangeOfLayout(this);
        this.ResetBeforeChangeLayout();
        return !0
    }
    Tick(a, b, c) {
        this._instance || (this._instance = this.GetInstance());
        if (!this._instance || this._instance.IsDestroyed())
            this.Stop(!0),
            this.OnCompleted();
        else if (b = this._instance.GetTimeScale(),
        -1 !== b && (a = c * b),
        0 !== a || 0 !== this._lastDelta) {
            this._lastDelta = a;
            c = this._playheadTime + this._overshoot + a * this._playbackRate;
            a = this._timelineDataItem._totalTime;
            0 > c ? (this._playheadTime = 0,
            this._overshoot = -c) : c >= a ? (this._playheadTime = a,
            this._overshoot = this._playheadTime - c) : (this._playheadTime = c,
            this._overshoot = 0);
            b = c = !1;
            var d = this.GetLoop()
              , e = this.GetPingPong();
            d || e ? d && !e ? 0 < this._playbackRate ? this._playheadTime >= a && (this._SetTimeAndReset(0),
            this._TweenTrigger(C3$jscomp$136.Behaviors.Tween.Cnds.OnAnyTweenLoop),
            this._TweenTrigger(C3$jscomp$136.Behaviors.Tween.Cnds.OnTweensLoop),
            b = !0) : 0 >= this._playheadTime && (this._SetTimeAndReset(a),
            this._TweenTrigger(C3$jscomp$136.Behaviors.Tween.Cnds.OnAnyTweenLoop),
            this._TweenTrigger(C3$jscomp$136.Behaviors.Tween.Cnds.OnTweensLoop),
            b = !0) : !d && e ? 0 < this._playbackRate ? this._playheadTime >= a && (this._SetTime(a),
            this.SetPlaybackRate(-1 * this.GetPlaybackRate()),
            b = !0,
            1 === this._pingPongState ? this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++,
            this._TweenTrigger(C3$jscomp$136.Behaviors.Tween.Cnds.OnAnyTweenLoop),
            this._TweenTrigger(C3$jscomp$136.Behaviors.Tween.Cnds.OnTweensLoop),
            this._TweenTrigger(C3$jscomp$136.Behaviors.Tween.Cnds.OnAnyTweenPingPong),
            this._TweenTrigger(C3$jscomp$136.Behaviors.Tween.Cnds.OnTweensPingPong),
            this._pingPongState = 0) : (this._TweenTrigger(C3$jscomp$136.Behaviors.Tween.Cnds.OnAnyTweenPingPong),
            this._TweenTrigger(C3$jscomp$136.Behaviors.Tween.Cnds.OnTweensPingPong),
            c = !0) : 0 === this._pingPongState && (this._TweenTrigger(C3$jscomp$136.Behaviors.Tween.Cnds.OnAnyTweenPingPong),
            this._TweenTrigger(C3$jscomp$136.Behaviors.Tween.Cnds.OnTweensPingPong),
            this._pingPongState = 1)) : 0 >= this._playheadTime && (this._SetTime(0),
            this.SetPlaybackRate(-1 * this.GetPlaybackRate()),
            b = !0,
            1 === this._pingPongState ? this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++,
            this._TweenTrigger(C3$jscomp$136.Behaviors.Tween.Cnds.OnAnyTweenLoop),
            this._TweenTrigger(C3$jscomp$136.Behaviors.Tween.Cnds.OnTweensLoop),
            this._TweenTrigger(C3$jscomp$136.Behaviors.Tween.Cnds.OnAnyTweenPingPong),
            this._TweenTrigger(C3$jscomp$136.Behaviors.Tween.Cnds.OnTweensPingPong),
            this._pingPongState = 0) : (c = !0,
            this._TweenTrigger(C3$jscomp$136.Behaviors.Tween.Cnds.OnAnyTweenPingPong),
            this._TweenTrigger(C3$jscomp$136.Behaviors.Tween.Cnds.OnTweensPingPong)) : 0 === this._pingPongState && (this._TweenTrigger(C3$jscomp$136.Behaviors.Tween.Cnds.OnAnyTweenPingPong),
            this._TweenTrigger(C3$jscomp$136.Behaviors.Tween.Cnds.OnTweensPingPong),
            this._pingPongState = 1)) : d && e && (0 < this._playbackRate ? this._playheadTime >= a && (this._SetTime(a),
            this.SetPlaybackRate(-1 * this.GetPlaybackRate()),
            b = !0,
            0 === this._pingPongState && (this._TweenTrigger(C3$jscomp$136.Behaviors.Tween.Cnds.OnAnyTweenPingPong),
            this._TweenTrigger(C3$jscomp$136.Behaviors.Tween.Cnds.OnTweensPingPong)),
            1 === this._pingPongState && (this._TweenTrigger(C3$jscomp$136.Behaviors.Tween.Cnds.OnAnyTweenLoop),
            this._TweenTrigger(C3$jscomp$136.Behaviors.Tween.Cnds.OnTweensLoop),
            this._TweenTrigger(C3$jscomp$136.Behaviors.Tween.Cnds.OnAnyTweenPingPong),
            this._TweenTrigger(C3$jscomp$136.Behaviors.Tween.Cnds.OnTweensPingPong)),
            this._pingPongState++,
            this._pingPongState = C3$jscomp$136.wrap(this._pingPongState, 0, 2)) : 0 >= this._playheadTime && (this._SetTime(0),
            this.SetPlaybackRate(-1 * this.GetPlaybackRate()),
            b = !0,
            0 === this._pingPongState && (this._TweenTrigger(C3$jscomp$136.Behaviors.Tween.Cnds.OnAnyTweenPingPong),
            this._TweenTrigger(C3$jscomp$136.Behaviors.Tween.Cnds.OnTweensPingPong)),
            1 === this._pingPongState && (this._TweenTrigger(C3$jscomp$136.Behaviors.Tween.Cnds.OnAnyTweenLoop),
            this._TweenTrigger(C3$jscomp$136.Behaviors.Tween.Cnds.OnTweensLoop),
            this._TweenTrigger(C3$jscomp$136.Behaviors.Tween.Cnds.OnAnyTweenPingPong),
            this._TweenTrigger(C3$jscomp$136.Behaviors.Tween.Cnds.OnTweensPingPong)),
            this._pingPongState++,
            this._pingPongState = C3$jscomp$136.wrap(this._pingPongState, 0, 2))) : 0 < this._playbackRate ? this._playheadTime >= a && (this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++,
            this._SetTimeAndReset(0),
            this._TweenTrigger(C3$jscomp$136.Behaviors.Tween.Cnds.OnAnyTweenLoop),
            this._TweenTrigger(C3$jscomp$136.Behaviors.Tween.Cnds.OnTweensLoop),
            b = !0) : (this._SetTime(a),
            c = !0)) : 0 >= this._playheadTime && (this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++,
            this._SetTimeAndReset(a),
            this._TweenTrigger(C3$jscomp$136.Behaviors.Tween.Cnds.OnAnyTweenLoop),
            this._TweenTrigger(C3$jscomp$136.Behaviors.Tween.Cnds.OnTweensLoop),
            b = !0) : (this._SetTime(0),
            c = !0));
            c ? (this._track.SetEndState(),
            this.Stop(!0),
            this.OnCompleted()) : (this._track.Interpolate(this._playheadTime, !0, !1, b, this._firstTick, !1),
            this._firstTick && (this._firstTick = !1))
        }
    }
    _TweenTrigger(a) {
        const b = this.GetInstance()
          , c = b.GetBehaviorSdkInstanceFromCtor(C3$jscomp$136.Behaviors.Tween);
        c.PushTriggerTween(this);
        this._runtime.Trigger(a, b, c.GetBehaviorType());
        c.PopTriggerTween()
    }
    _SaveToJson() {
        const a = super._SaveToJson()
          , b = this.GetTimelineDataItem();
        return Object.assign(a, {
            tweenDataItemJson: b._SaveToJson(),
            id: this._id,
            destroyInstanceOnComplete: this._destroyInstanceOnComplete,
            initialValueMode: this._initialValueMode
        })
    }
    _LoadFromJson(a) {
        a && (this.GetTimelineDataItem()._LoadFromJson(a.tweenDataItemJson),
        super._LoadFromJson(a),
        this._id = a.id,
        this._destroyInstanceOnComplete = a.destroyInstanceOnComplete,
        this._initialValueMode = a.initialValueMode,
        this._CacheTrack())
    }
    static IsPlaying(a) {
        return a.IsPlaying()
    }
    static IsPaused(a) {
        return a.IsPaused()
    }
    static IsPing(a) {
        return a.GetPingPong() ? 0 === a.GetPingPongState() : !1
    }
    static IsPong(a) {
        return a.GetPingPong() ? 1 === a.GetPingPongState() : !1
    }
    static Build(a) {
        var b = a.runtime.GetTimelineManager()
          , c = new C3$jscomp$136.TimelineDataItem;
        if (a.json) {
            c._LoadFromJson(a.json.tweenDataItemJson);
            var d = new C3$jscomp$136.TweenState(c,b);
            d._LoadFromJson(a.json);
            return d
        }
        b = new C3$jscomp$136.TweenState(c,b);
        C3$jscomp$136.IsArray(a.propertyTracksConfig) || (a.propertyTracksConfig = [a.propertyTracksConfig]);
        b.SetId(a.id);
        b.SetTags(a.tags);
        b.SetInitialValueMode(a.initialValueMode);
        b.SetDestroyInstanceOnComplete(a.releaseOnComplete);
        b.SetLoop(a.loop);
        b.SetPingPong(a.pingPong);
        b.SetTotalTime(a.time);
        b.SetStep(0);
        b.SetInterpolationMode("default");
        b.SetResultMode(a.propertyTracksConfig[0].resultMode);
        b.SetRepeatCount(a.repeatCount);
        c = b.AddTrack();
        c.SetInstanceUID(a.instance.GetUID());
        c.SetInterpolationMode("default");
        c.SetResultMode(a.propertyTracksConfig[0].resultMode);
        c.SetEnable(!0);
        c.SetObjectClassIndex(a.instance.GetObjectClass().GetIndex());
        var e = a.instance.GetSdkInstance()
          , f = e.IsOriginalSizeKnown() ? e.GetOriginalWidth() : a.instance.GetWorldInfo().GetWidth();
        e = e.IsOriginalSizeKnown() ? e.GetOriginalHeight() : a.instance.GetWorldInfo().GetHeight();
        c.SetOriginalWidth(f);
        c.SetOriginalHeight(e);
        f = c.AddKeyframe();
        f.SetTime(0);
        f.SetEase("noease");
        f.SetEnable(!0);
        f.SetTags("");
        f = c.AddKeyframe();
        f.SetTime(a.time);
        f.SetEase("noease");
        f.SetEnable(!0);
        f.SetTags("");
        for (d of a.propertyTracksConfig)
            f = c.AddPropertyTrack(),
            f.SetSourceAdapterId(d.sourceId),
            f.SetSourceAdapterArgs(d.sourceArgs),
            f.SetPropertyName(d.property),
            f.SetPropertyType(d.type),
            f.SetMin(NaN),
            f.SetMax(NaN),
            f.SetInterpolationMode("default"),
            f.SetResultMode(d.resultMode),
            f.SetEnable(!0),
            e = f.AddPropertyKeyframe(),
            e.SetType(d.valueType),
            e.SetTime(0),
            e.SetEase(d.ease),
            e.SetEnable(!0),
            e.SetValue(d.startValue),
            e.SetAbsoluteValue(d.startValue),
            e = f.AddPropertyKeyframe(),
            e.SetType(d.valueType),
            e.SetTime(a.time),
            e.SetEase(d.ease),
            e.SetEnable(!0),
            e.SetValue(d.endValue),
            e.SetAbsoluteValue(d.endValue),
            f.GetSourceAdapter();
        return b
    }
    static SetInstanceUID(a, b) {
        if (!isNaN(b))
            for (const c of a.GetTracks())
                c.SetInstanceUID(b)
    }
    GetITweenState(a, b) {
        this._iTweenState || (this._iTweenState = C3$jscomp$136.New(self.ITweenState, this, a, b));
        return this._iTweenState
    }
}
;
"use strict";
const C3$jscomp$137 = self.C3;
C3$jscomp$137.TweenTrackState = class extends C3$jscomp$137.TrackState {
    constructor(a, b) {
        super(a, b);
        this._secondPropertyTrack = this._firstPropertyTrack = null
    }
    static Create(a, b) {
        return C3$jscomp$137.New(C3$jscomp$137.TweenTrackState, a, b)
    }
    _CachePropertyTracks() {
        1 === this._propertyTracks.length ? this._firstPropertyTrack = this._propertyTracks[0] : (this._firstPropertyTrack = this._propertyTracks[0],
        this._secondPropertyTrack = this._propertyTracks[1])
    }
    CreatePropertyTrackStates() {
        for (const a of this._trackDataItem.GetPropertyTrackData().propertyTrackDataItems())
            this._propertyTracks.push(C3$jscomp$137.TweenPropertyTrackState.Create(this, a));
        this._CachePropertyTracks()
    }
    AddPropertyTrack() {
        var a = this._trackDataItem.GetPropertyTrackData().AddEmptyPropertyTrackDataItem();
        a = C3$jscomp$137.TweenPropertyTrackState.Create(this, a);
        this._propertyTracks.push(a);
        this._CachePropertyTracks();
        return a
    }
    SetInitialState() {
        this.MaybeGetInstance();
        if (this.IsInstanceValid() || !this.IsInstanceTrack()) {
            var a = this.GetTimeline().IsForwardPlayBack() ? 0 : this.GetLocalTotalTime();
            for (const b of this._propertyTracks)
                b.SetInitialState(a),
                0 === this._worldInfoChange && 1 === b.GetWorldInfoChange() && (this._worldInfoChange = 1),
                0 === this._renderChange && 1 === b.GetRenderChange() && (this._renderChange = 1);
            this._needsBeforeAndAfter = 0;
            this._propertyTracks.some(b => b.GetNeedsBeforeAndAfter()) && (this._needsBeforeAndAfter = 1);
            this._lastKeyframeDataItem = this._GetLastKeyFrameBeforeTime(a);
            this._endStateOfNestedSet = this._initialStateOfNestedSet = !1;
            this.Interpolate(a)
        }
    }
    BeforeInterpolate() {}
    Interpolate(a, b, c=!1, d=!1, e, f=!1, h=!1) {
        this._instance || this.GetInstance();
        if (this._instance) {
            if (this._instance.IsDestroyed() || f && this.GetObjectClass().IsGlobal())
                return !1;
            this._secondPropertyTrack ? (this._firstPropertyTrack.Interpolate(a, c, d, h),
            this._secondPropertyTrack.Interpolate(a, c, d, h)) : this._firstPropertyTrack.Interpolate(a, c, d, h);
            0 !== this._firstPropertyTrack.GetWorldInfoChange() && (this._worldInfo || (this._worldInfo = this._instance.GetWorldInfo()),
            this._worldInfo && this._worldInfo.SetBboxChanged())
        }
    }
    AfterInterpolate() {}
    _LoadFromJson(a) {
        super._LoadFromJson(a);
        this._CachePropertyTracks()
    }
}
;
"use strict";
const C3$jscomp$138 = self.C3;
C3$jscomp$138.TweenPropertyTrackState = class extends C3$jscomp$138.PropertyTrackState {
    constructor(a, b) {
        super(a, b);
        this._basic = !1
    }
    static Create(a, b) {
        return C3$jscomp$138.New(C3$jscomp$138.TweenPropertyTrackState, a, b)
    }
    Interpolate(a, b=!1, c=!1, d=!1) {
        if (this._basic) {
            var e = this._propertyKeyframeDataItems[0];
            var f = this._propertyKeyframeDataItems[1]
        } else {
            if (b)
                e = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a, this._propertyTrackDataItem);
            else {
                if (this._lastPropertyKeyframeDataItem) {
                    f = this.GetTimeline();
                    const h = this._lastPropertyKeyframeDataItem.GetNext();
                    e = this._lastPropertyKeyframeDataItem.GetTime();
                    f = h ? h.GetTime() : f.GetTotalTime();
                    if (a <= e || a >= f)
                        this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a, this._propertyTrackDataItem)
                } else
                    this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a, this._propertyTrackDataItem);
                e = this._lastPropertyKeyframeDataItem
            }
            f = e.GetNext()
        }
        this._sourceAdapter.Interpolate(a, e, f, b, c, d)
    }
    AddPropertyKeyframe() {
        const a = this._propertyTrackDataItem.GetPropertyKeyframeData().AddEmptyPropertyKeyframeDataItem();
        this._lastPropertyKeyframeDataItem = null;
        this._basic = 2 >= this.GetPropertyKeyframeDataItems().length;
        return a
    }
    DeletePropertyKeyframes(a) {
        this._lastPropertyKeyframeDataItem = null;
        this._propertyTrackDataItem.GetPropertyKeyframeData().DeletePropertyKeyframeDataItems(a);
        this._basic = 2 >= this.GetPropertyKeyframeDataItems().length
    }
    _SaveToJson() {
        return {
            sourceAdapterJson: this.GetSourceAdapter()._SaveToJson(),
            basic: this._basic
        }
    }
    _LoadFromJson(a) {
        a && (this.GetSourceAdapter()._LoadFromJson(a.sourceAdapterJson),
        this._basic = a.basic)
    }
}
;
"use strict";
const C3$jscomp$139 = self.C3
  , Ease$jscomp$2 = self.Ease;
C3$jscomp$139.Transition = class extends C3$jscomp$139.DefendedBase {
    constructor(a, b=!0) {
        super();
        this._name = a[0];
        this._linear = a[2];
        this._transitionKeyframes = [];
        for (var c of a[1])
            a = C3$jscomp$139.TransitionKeyframe.Create(this, c),
            this._transitionKeyframes.push(a);
        for (c = 0; c < this._transitionKeyframes.length; c++) {
            a = this._transitionKeyframes[c];
            const d = this._transitionKeyframes[c - 1];
            a.SetNext(this._transitionKeyframes[c + 1]);
            a.SetPrevious(d)
        }
        this._precalculatedSamples = new Map;
        this._transitionKeyframeCache = new Map;
        this._PreCalcSamples();
        b && Ease$jscomp$2.AddCustomEase(this._name, (d, e, f, h) => this.Interpolate(d, e, f, h), null, {
            transition: this
        })
    }
    static Create(a) {
        return C3$jscomp$139.New(C3$jscomp$139.Transition, a)
    }
    Release() {
        for (const a of this._transitionKeyframes)
            a.Release();
        C3$jscomp$139.clearArray(this._transitionKeyframes);
        this._transitionKeyframes = null;
        this._precalculatedSamples.clear();
        this._precalculatedSamples = null;
        this._transitionKeyframeCache.clear();
        this._transitionKeyframeCache = null
    }
    MakeLinear(a) {
        this._linear = !!a
    }
    GetTransitionKeyFrameAt(a) {
        const b = this._transitionKeyframeCache.get(a);
        if (b)
            return b;
        for (const c of this._transitionKeyframes)
            if (c.GetValueX() === a)
                return this._transitionKeyframeCache.set(a, c),
                c
    }
    GetFirstTransitionKeyFrameLowerOrEqualThan(a) {
        for (let c = this._transitionKeyframes.length - 1; 0 <= c; c--) {
            var b = this._transitionKeyframes[c];
            const d = b.GetValueX();
            if (d <= a) {
                if (d < a)
                    return b;
                if (d === a) {
                    for (; b; ) {
                        a = b.GetPrevious();
                        if (!a)
                            break;
                        if (a.GetValueX() !== b.GetValueX())
                            break;
                        b = a
                    }
                    return b
                }
            }
        }
    }
    Interpolate(a, b, c, d) {
        var e = a / d;
        if (this._linear) {
            var f = this.GetTransitionKeyFrameAt(0);
            e = this.GetTransitionKeyFrameAt(1);
            f = b + (b + c) * f.GetValueY();
            b = (b + c) * e.GetValueY() - f;
            return 0 === d ? f + b : Ease$jscomp$2.NoEase(a, f, b, d)
        }
        0 === d && (e = 1);
        a = this.GetFirstTransitionKeyFrameLowerOrEqualThan(e);
        d = a.GetNext();
        d || (d = a.GetPrevious(),
        f = a,
        a = d,
        d = f);
        f = d.GetValueX() - a.GetValueX();
        e = C3$jscomp$139.mapToRange(e, a.GetValueX(), d.GetValueX(), 0, f);
        if (a.IsSegmentLinear() || 0 === f)
            return a = b + (b + c) * a.GetValueY(),
            b = (b + c) * d.GetValueY() - a,
            0 === f ? 1 === e ? a + b : a : Ease$jscomp$2.NoEase(e, a, b, f);
        f = a.GetValueX();
        const h = a.GetValueY()
          , l = a.GetValueX() + a.GetStartAnchorX()
          , m = a.GetValueY() + a.GetStartAnchorY()
          , p = d.GetValueX() + d.GetEndAnchorX()
          , r = d.GetValueY() + d.GetEndAnchorY()
          , v = d.GetValueX();
        d = d.GetValueY();
        e = Ease$jscomp$2.GetRuntimeEase("spline")(e, f, h, l, m, p, r, v, d, this._precalculatedSamples.get(a));
        e += a.GetValueY();
        return (1 - e) * b + e * (b + c)
    }
    _PreCalcSamples() {
        this._precalculatedSamples.clear();
        for (let c = 0; c < this._transitionKeyframes.length - 1; c++) {
            var a = this._transitionKeyframes[c];
            if (!a.GetStartEnable())
                continue;
            var b = this._transitionKeyframes[c + 1];
            if (!b.GetEndEnable())
                continue;
            const d = a.GetValueX()
              , e = a.GetValueX() + a.GetStartAnchorX()
              , f = b.GetValueX() + b.GetEndAnchorX();
            b = b.GetValueX();
            this._precalculatedSamples.set(a, Ease$jscomp$2.GetBezierSamples(d, e, f, b))
        }
    }
}
;
"use strict";
const C3$jscomp$140 = self.C3;
C3$jscomp$140.TransitionKeyframe = class extends C3$jscomp$140.DefendedBase {
    constructor(a, b) {
        super();
        this._transition = a;
        this._valueX = b[0];
        this._valueY = b[1];
        this._startAnchorX = b[2];
        this._startAnchorY = b[3];
        this._endAnchorX = b[4];
        this._endAnchorY = b[5];
        this._startEnable = b[6];
        this._endEnable = b[7];
        this._segmentMode = b[8];
        this._prev = this._next = null
    }
    Release() {
        this._transition = null
    }
    static Create(a, b) {
        return C3$jscomp$140.New(C3$jscomp$140.TransitionKeyframe, a, b)
    }
    SetNext(a) {
        this._next = a
    }
    GetNext() {
        return this._next
    }
    SetPrevious(a) {
        this._prev = a
    }
    GetPrevious() {
        return this._prev
    }
    GetValueX() {
        return this._valueX
    }
    GetValueY() {
        return this._valueY
    }
    GetStartAnchorX() {
        return this._startAnchorX
    }
    GetStartAnchorY() {
        return this._startAnchorY
    }
    GetEndAnchorX() {
        return this._endAnchorX
    }
    GetEndAnchorY() {
        return this._endAnchorY
    }
    GetStartEnable() {
        return this._startEnable
    }
    GetEndEnable() {
        return this._endEnable
    }
    IsSegmentLinear() {
        return "linear" === this._segmentMode
    }
    IsSegmentCubic() {
        return "cubic" === this._segmentMode
    }
}
;
"use strict";
const C3$jscomp$141 = self.C3;
C3$jscomp$141.TransitionManager = class extends C3$jscomp$141.DefendedBase {
    constructor(a) {
        super();
        this._runtime = a;
        this._transitions = []
    }
    Release() {
        for (const a of this._transitions)
            a.Release();
        C3$jscomp$141.clearArray(this._transitions);
        this._transitions = null
    }
    Create(a) {
        this._transitions.push(C3$jscomp$141.Transition.Create(a))
    }
}
;
"use strict";
const C3$jscomp$142 = self.C3;
C3$jscomp$142.TemplateManager = class extends C3$jscomp$142.DefendedBase {
    constructor(a) {
        super();
        this._runtime = a;
        this._instanceToTemplateNameMap = this._templateDataMap = null;
        this._instanceDestroy = b => this._OnInstanceDestroy(b.instance)
    }
    Release() {
        this.RemoveRuntimeListeners();
        if (this._templateDataMap) {
            for (const a of this._templateDataMap.values())
                a.clear();
            this._templateDataMap.clear()
        }
        this._runtime = this._templateDataMap = null
    }
    Create(a) {
        this._templateDataMap || (this._templateDataMap = new Map);
        if (a) {
            var b = a[0][16][0]
              , c = a[1];
            this._templateDataMap.has(c) || this._templateDataMap.set(c, new Map);
            this._templateDataMap.get(c).set(b, a)
        }
    }
    AddRuntimeListeners() {
        const a = this._runtime.Dispatcher();
        a && a.addEventListener("instancedestroy", this._instanceDestroy)
    }
    RemoveRuntimeListeners() {
        const a = this._runtime.Dispatcher();
        a && a.removeEventListener("instancedestroy", this._instanceDestroy)
    }
    HasTemplates() {
        return this._templateDataMap ? 0 !== this._templateDataMap.size : !1
    }
    GetTemplateData(a, b) {
        a = a instanceof C3$jscomp$142.ObjectClass ? a.GetIndex() : a;
        if (this._templateDataMap.has(a) && (b = this._templateDataMap.get(a).get(b)))
            return JSON.parse(JSON.stringify(b))
    }
    MapInstanceToTemplateName(a, b) {
        this._instanceToTemplateNameMap || (this._instanceToTemplateNameMap = new WeakMap);
        this._instanceToTemplateNameMap.has(a) || this._instanceToTemplateNameMap.set(a, b)
    }
    GetInstanceTemplateName(a) {
        return this._instanceToTemplateNameMap ? (a = this._instanceToTemplateNameMap.get(a)) ? a : "" : ""
    }
    _OnInstanceDestroy(a) {
        this._instanceToTemplateNameMap && this._instanceToTemplateNameMap.has(a) && this._instanceToTemplateNameMap.delete(a)
    }
}
;
"use strict";
const C3$jscomp$143 = self.C3;
C3$jscomp$143.FlowchartManager = class {
    constructor(a) {
        this._runtime = a;
        this._flowchartDataManager = new C3$jscomp$143.FlowchartDataManager
    }
    Release() {
        this._flowchartDataManager.Release();
        this._runtime = this._flowchartDataManager = null
    }
    GetRuntime() {
        return this._runtime
    }
    Create(a) {
        this._flowchartDataManager.Add(a)
    }
    GetFlowchartDataItemByName(a) {
        return this._flowchartDataManager.Get(a)
    }
    HasFlowcharts() {
        return this._flowchartDataManager.HasFlowcharts()
    }
}
;
"use strict";
const C3$jscomp$144 = self.C3;
C3$jscomp$144.FlowchartState = class {
    constructor(a, b, c, d, e, f, h) {
        this._runtime = e.GetRuntime();
        this._flowchartManager = e;
        this._flowchartName = a;
        this._startNodeTag = c;
        this._flowchartDataItem = d;
        this._tag = b;
        this._pluginInstance = f;
        this._pluginUID = h ? h : f.GetInstance().GetUID();
        this._SetStartFlowchartNode();
        this._currentFlowchartNodeId = this._startFlowchartNode.GetFlowchartId();
        this._previousFlowchartNodeIds = [];
        this._previousFlowchartState = null;
        this._previousFlowchartStateStartNodeId = NaN;
        this._rootFlowchartState = this._currentReferenceFlowchartState = this._referenceFlowchartStates = null;
        this._previousFlowchartStateTag = "";
        this._referenceFlowchartStatesJson = null;
        this._rootFlowchartStateTag = this._currentReferenceFlowchartStateTag = "";
        this._triggerCount = 0;
        this._released = this._markForRelease = !1
    }
    Release() {
        this._released || (C3$jscomp$144.clearArray(this._previousFlowchartNodeIds),
        this._previousFlowchartState = this._pluginInstance = this._flowchartDataItem = this._flowchartManager = this._runtime = this._previousFlowchartNodeIds = null,
        this._previousFlowchartStateStartNodeId = NaN,
        this._referenceFlowchartStates && this._referenceFlowchartStates.clear(),
        this._rootFlowchartState = this._currentReferenceFlowchartState = this._referenceFlowchartStates = null,
        this._previousFlowchartStateTag = "",
        this._referenceFlowchartStatesJson = null,
        this._rootFlowchartStateTag = this._currentReferenceFlowchartStateTag = "",
        this._released = !0)
    }
    WasReleased() {
        return this._released
    }
    GetFlowchartManager() {
        return this._flowchartManager
    }
    GetRuntime() {
        return this._runtime
    }
    GetName() {
        return this._flowchartName
    }
    GetFlowchartDataItem() {
        return this._flowchartDataItem
    }
    GetTag() {
        return this._tag
    }
    GetPluginInstance() {
        this._pluginInstance || (this._pluginInstance = this._runtime.GetInstanceByUID(this._pluginUID).GetSdkInstance());
        return this._pluginInstance
    }
    GetCurrentNode() {
        return this.GetFlowchartElementById(this._currentFlowchartNodeId)
    }
    GetCurrentNodeTag() {
        const a = this.GetCurrentNode();
        return a ? a.GetTag() : ""
    }
    GetCurrentNodeParent(a) {
        var b = this.GetCurrentNode();
        if (C3$jscomp$144.IsFiniteNumber(a)) {
            var c = b.GetParentFlowchartIds();
            c = c ? c[a] : void 0;
            if (C3$jscomp$144.IsFiniteNumber(c))
                return this.GetFlowchartElementById(c)
        }
        if ("string" === typeof a)
            for (const d of b.GetParentFlowchartIds())
                if (b = this.GetFlowchartElementById(d),
                b.GetTag() === a)
                    return this.GetFlowchartElementById(b.GetFlowchartId())
    }
    GetCurrentNodeParentTag(a) {
        return (a = this.GetCurrentNodeParent(a)) ? a.GetTag() : ""
    }
    GetCurrentNodeParentIndex(a) {
        a = this.GetCurrentNodeParent(a);
        if (!a)
            return -1;
        const b = a.GetParentFlowchartIds();
        return b ? b.indexOf(a.GetFlowchartId()) : -1
    }
    GetFlowchartElementById(a) {
        return this._flowchartDataItem.GetFlowchartElementById(a)
    }
    Reset() {
        this._GetRootFlowchartState()._Reset(!0)
    }
    _Reset(a) {
        if (this._GetReferenceFlowchartStates()) {
            for (const [,b] of this._GetReferenceFlowchartStates().entries())
                b._Reset(!1);
            this._GetReferenceFlowchartStates().clear()
        }
        this._currentReferenceFlowchartState = this._previousFlowchartStateStartNode = this._previousFlowchartState = this._referenceFlowchartStates = null;
        this._previousFlowchartStateTag = "";
        this._referenceFlowchartStatesJson = null;
        this._rootFlowchartStateTag = this._currentReferenceFlowchartStateTag = "";
        this._previousFlowchartNodeIds = [];
        a ? (this._flowchartManager.SetCurrentFlowchartState(this),
        a = this._startFlowchartNode.GetFlowchartId(),
        a !== this._currentFlowchartNodeId && this._GotoFlowchartNode(a)) : this._currentFlowchartNodeId = this._startFlowchartNode.GetFlowchartId()
    }
    GetCurrentNodeOutputCount() {
        return this._flowchartDataItem.GetFlowchartElementById(this._currentFlowchartNodeId).GetFlowchartNodeOutputData().GetFlowchartNodeOutputDataItemCount()
    }
    GetCurrentNodeOutputNameAt(a) {
        return (a = this._GetFlowchartNodeOutputAt(a)) ? a.GetName() : ""
    }
    GetCurrentNodeOutputValueAt(a) {
        let b;
        C3$jscomp$144.IsFiniteNumber(a) && (b = this._GetFlowchartNodeOutputAt(a));
        "string" === typeof a && (b = this._GetFlowchartNodeOutputByName(a));
        "number" !== typeof a && "string" !== typeof a && console.warn("[Flowcharts] unexpected argument type in GetCurrentNodeOutputValueAt expression");
        return b ? b.GetValue() : ""
    }
    GotoNextFlowchartNode(a) {
        let b;
        C3$jscomp$144.IsFiniteNumber(a) && (b = this._GetFlowchartNodeOutputAt(a));
        "string" === typeof a && (b = this._GetFlowchartNodeOutputByName(a));
        a = b.GetConnectedFlowchartNodeFlowchartId();
        C3$jscomp$144.IsFiniteNumber(a) && (this._previousFlowchartNodeIds.push(this._currentFlowchartNodeId),
        this._GotoFlowchartNode(a))
    }
    GotoAnyFlowchartNode(a) {
        if (a = this._flowchartDataItem.GetFlowchartNodeByTag(a))
            if (a = this._flowchartDataItem.GetFlowchartElementById(a.GetFlowchartId()))
                this._previousFlowchartNodeIds.push(this._currentFlowchartNodeId),
                this._GotoFlowchartNode(a.GetFlowchartId())
    }
    GotoPreviousFlowchartNode() {
        const a = this._previousFlowchartNodeIds.pop();
        C3$jscomp$144.IsFiniteNumber(a) ? this._GotoFlowchartNode(a) : this._GetPreviousFlowchartState() && (this._flowchartManager.SetCurrentFlowchartState(this._GetPreviousFlowchartState(), !0, !1, !1),
        this._GetPreviousFlowchartState()._GotoFlowchartNode(this._GetPreviousFlowchartStateStartNodeId()),
        this._GetRootFlowchartState()._SetCurrentReferenceFlowchart(this._GetPreviousFlowchartState()))
    }
    GotoParentFlowchartNode(a) {
        this.GetCurrentNode().GetFlowchartId();
        if (a = this.GetCurrentNodeParent(a))
            this._previousFlowchartNodeIds.push(this._currentFlowchartNodeId),
            this._GotoFlowchartNode(a.GetFlowchartId())
    }
    HasOutput(a) {
        if (C3$jscomp$144.IsFiniteNumber(a))
            return !!this._flowchartDataItem.GetFlowchartElementById(this._currentFlowchartNodeId).GetFlowchartNodeOutputData().GetFlowchartNodeOutputDataItems()[a];
        if ("string" === typeof a) {
            const b = this._flowchartDataItem.GetFlowchartElementById(this._currentFlowchartNodeId).GetFlowchartNodeOutputData().GetFlowchartNodeOutputDataItems();
            for (let c = 0; c < b.length; c++)
                if (b[c].GetName() === a)
                    return !0
        }
        return !1
    }
    MarkForRelease() {
        this._markForRelease = !0
    }
    IsInTriggerState() {
        return 0 < this._triggerCount
    }
    PushIsTriggerState() {
        this._triggerCount++
    }
    PopIsTriggerState() {
        this._triggerCount--;
        0 === this._triggerCount && this._markForRelease && this._flowchartManager.RemoveFlowchartState(this)
    }
    _GotoFlowchartNode(a) {
        var b = this._currentFlowchartNodeId
          , c = this.GetPluginInstance().GetInstance();
        this.PushIsTriggerState();
        this._flowchartManager.PushFlowchartState(this);
        this._runtime.Trigger(C3$jscomp$144.Plugins.Flowchart.Cnds.OnBeforeAnyNodeChange, c);
        this._runtime.Trigger(C3$jscomp$144.Plugins.Flowchart.Cnds.OnBeforeTaggedNodeChange, c);
        this._runtime.Trigger(C3$jscomp$144.Plugins.Flowchart.Cnds.OnBeforeAnyNodeChangeInFlowchart, c);
        this._runtime.Trigger(C3$jscomp$144.Plugins.Flowchart.Cnds.OnBeforeTaggedNodeChangeInFlowchart, c);
        this._currentFlowchartNodeId = a;
        this._runtime.Trigger(C3$jscomp$144.Plugins.Flowchart.Cnds.OnAnyNodeChange, c);
        this._runtime.Trigger(C3$jscomp$144.Plugins.Flowchart.Cnds.OnTaggedNodeChange, c);
        this._runtime.Trigger(C3$jscomp$144.Plugins.Flowchart.Cnds.OnAnyNodeChangeInFlowchart, c);
        this._runtime.Trigger(C3$jscomp$144.Plugins.Flowchart.Cnds.OnTaggedNodeChangeInFlowchart, c);
        this._flowchartManager.PopFlowchartState();
        this.PopIsTriggerState();
        a = this.GetFlowchartElementById(this._currentFlowchartNodeId);
        if ("reference" === a.GetType())
            if (c = a.GetReferenceFlowchartName(),
            this._HasReferenceFlowchartState(a))
                this._previousFlowchartNodeIds.pop(),
                a = this._GetReferenceFlowchartState(a),
                this._flowchartManager.SetCurrentFlowchartState(a, !0, !0, !1),
                a._SetPreviousFlowchart(this, b),
                this._GetRootFlowchartState()._SetCurrentReferenceFlowchart(a);
            else {
                const e = a.GetReferenceFlowchartStartNodeTag();
                if (c) {
                    this._previousFlowchartNodeIds.pop();
                    let f = a.GetReferenceFlowchartTag();
                    if (f)
                        for (var d = this._flowchartManager.GetFlowchartState(f); d; )
                            f = C3$jscomp$144.IncrementNumberAtEndOf(f),
                            d = this._flowchartManager.GetFlowchartState(f);
                    else
                        for (f = `${c}-ref`,
                        d = this._flowchartManager.GetFlowchartState(f); d; )
                            f = C3$jscomp$144.IncrementNumberAtEndOf(f),
                            d = this._flowchartManager.GetFlowchartState(f);
                    c = this._flowchartManager.AddFlowchartState(c, e, f, this._pluginInstance, !0);
                    c._SetPreviousFlowchart(this, b);
                    this._SetReferenceFlowchartState(a, c);
                    b = this._GetRootFlowchartState();
                    c._SetRootFlowchartState(b);
                    b._SetCurrentReferenceFlowchart(c)
                }
            }
    }
    _GetFlowchartNodeOutputAt(a) {
        var b = this._flowchartDataItem.GetFlowchartElementById(this._currentFlowchartNodeId);
        if (!b)
            return null;
        b = b.GetFlowchartNodeOutputData().GetFlowchartNodeOutputDataItems();
        return b ? (a = b[a]) ? a : null : null
    }
    _GetFlowchartNodeOutputByName(a) {
        const b = this._flowchartDataItem.GetFlowchartElementById(this._currentFlowchartNodeId);
        return b ? (a = b.GetFlowchartNodeOutputData().GetFlowchartNodeOutputDataItemByName(a)) ? a : null : null
    }
    _SetStartFlowchartNode(a) {
        "number" === typeof a ? ((a = this.GetFlowchartElementById(a)) || (a = this._flowchartDataItem.GetFlowchartStartNode()),
        this._startFlowchartNode = a) : ((a = this._flowchartDataItem.GetFlowchartNodeByTag(this._startNodeTag)) || (a = this._flowchartDataItem.GetFlowchartStartNode()),
        this._startFlowchartNode = a)
    }
    _SaveToJson() {
        return this._markForRelease ? null : {
            flowchartName: this._flowchartName,
            flowchartTag: this._tag,
            startNodeTag: this._startNodeTag,
            currentNodeId: this._currentFlowchartNodeId,
            previousNodeIds: this._previousFlowchartNodeIds,
            pluginUID: this._pluginInstance.GetInstance().GetUID(),
            reference: {
                previousFlowchartTag: this._GetPreviousFlowchartState() ? this._GetPreviousFlowchartState().GetTag() : "",
                previousStartNodeId: C3$jscomp$144.IsFiniteNumber(this._GetPreviousFlowchartStateStartNodeId()) ? this._GetPreviousFlowchartStateStartNodeId() : NaN,
                referencesJson: this._GetFlowchartReferencesJson(),
                currentReferenceFlowchartTag: this.GetCurrentReferenceFlowchart() ? this.GetCurrentReferenceFlowchart().GetTag() : "",
                rootFlowchartTag: this._GetRootFlowchartState() ? this._GetRootFlowchartState().GetTag() : ""
            }
        }
    }
    _GetFlowchartReferencesJson() {
        if (!this._HasReferenceFlowchartStates())
            return null;
        const a = [];
        for (const [b,c] of this._GetReferenceFlowchartStates().entries())
            a.push({
                flowchartElementId: b.GetFlowchartId(),
                flowchartStateTag: c.GetTag()
            });
        return a.length ? a : null
    }
    _LoadFromJson(a) {
        a && (this._flowchartName = a.flowchartName,
        this._tag = a.flowchartTag,
        this._startNodeTag = a.startNodeTag,
        this._currentFlowchartNodeId = a.currentNodeId,
        this._previousFlowchartNodeIds = a.previousNodeIds,
        this._pluginUID = a.pluginUID,
        a.hasOwnProperty("reference") && (a = a.reference,
        this._previousFlowchartStateTag = a.previousFlowchartTag,
        this._previousFlowchartStateStartNodeId = a.previousStartNodeId,
        this._referenceFlowchartStatesJson = a.referencesJson,
        this._currentReferenceFlowchartStateTag = a.currentReferenceFlowchartTag,
        this._rootFlowchartStateTag = a.rootFlowchartTag),
        this._SetStartFlowchartNode())
    }
    _GetPreviousFlowchartState() {
        "string" === typeof this._previousFlowchartStateTag && this._previousFlowchartStateTag && (this._previousFlowchartState = this._flowchartManager.GetFlowchartState(this._previousFlowchartStateTag),
        this._previousFlowchartStateTag = "");
        return this._previousFlowchartState
    }
    _GetPreviousFlowchartStateStartNodeId() {
        return this._previousFlowchartStateStartNodeId
    }
    _SetPreviousFlowchart(a, b) {
        this._previousFlowchartState = a;
        this._previousFlowchartStateStartNodeId = b
    }
    GetCurrentReferenceFlowchart() {
        "string" === typeof this._currentReferenceFlowchartStateTag && this._currentReferenceFlowchartStateTag && (this._currentReferenceFlowchartState = this._flowchartManager.GetFlowchartState(this._currentReferenceFlowchartStateTag),
        this._currentReferenceFlowchartStateTag = "");
        return this._currentReferenceFlowchartState
    }
    _SetCurrentReferenceFlowchart(a) {
        this._currentReferenceFlowchartState = a;
        this._currentReferenceFlowchartState === this && (this._currentReferenceFlowchartState = null)
    }
    _GetRootFlowchartState() {
        "string" === typeof this._rootFlowchartStateTag && this._rootFlowchartStateTag && (this._rootFlowchartState = this._flowchartManager.GetFlowchartState(this._rootFlowchartStateTag),
        this._rootFlowchartStateTag = "");
        return this._rootFlowchartState ? this._rootFlowchartState : this
    }
    _SetRootFlowchartState(a) {
        this._rootFlowchartState = a
    }
    _HasReferenceFlowchartStates() {
        this._RebuildReferenceFlowchartStates();
        return !!this._referenceFlowchartStates
    }
    _HasReferenceFlowchartState(a) {
        this._RebuildReferenceFlowchartStates();
        return this._referenceFlowchartStates && this._referenceFlowchartStates.has(a)
    }
    _RebuildReferenceFlowchartStates() {
        if (this._referenceFlowchartStatesJson) {
            this._referenceFlowchartStates && this._referenceFlowchartStates.clear();
            this._referenceFlowchartStates || (this._referenceFlowchartStates = new Map);
            for (const a of this._referenceFlowchartStatesJson) {
                const b = this._flowchartManager.GetFlowchartState(a.flowchartStateTag)
                  , c = b.GetFlowchartElementById(a.flowchartElementId);
                this._referenceFlowchartStates.set(c, b)
            }
            this._referenceFlowchartStatesJson = null
        }
    }
    _GetReferenceFlowchartStates() {
        this._RebuildReferenceFlowchartStates();
        return this._referenceFlowchartStates
    }
    _GetReferenceFlowchartState(a) {
        this._RebuildReferenceFlowchartStates();
        return this._referenceFlowchartStates.get(a)
    }
    _SetReferenceFlowchartState(a, b) {
        this._referenceFlowchartStates || (this._referenceFlowchartStates = new Map);
        this._referenceFlowchartStates.set(a, b)
    }
}
;
"use strict";
const C3$jscomp$145 = self.C3;
C3$jscomp$145.FlowchartStateManager = class {
    constructor(a) {
        this._runtime = a;
        this._flowchartStates = new Map;
        this._currentFlowchartState = null;
        this._flowchartStateStack = []
    }
    Release() {
        C3$jscomp$145.clearArray(this._flowchartStateStack);
        this._flowchartStateStack = null;
        this._flowchartStates.clear();
        this._runtime = this._currentFlowchartState = this._flowchartStates = null
    }
    GetRuntime() {
        return this._runtime
    }
    AddFlowchartState(a, b, c, d, e, f) {
        const h = this._runtime.GetFlowchartManager().GetFlowchartDataItemByName(a);
        if (h)
            if (this._flowchartStates.has(c))
                console.warn(`[Flowcharts] there already is a flowchart with the tag '${c}'`);
            else
                return a = new C3$jscomp$145.FlowchartState(a,c,b,h,this,d,f),
                this._flowchartStates.set(c, a),
                e && this.SetCurrentFlowchartState(a, !0),
                a;
        else
            console.warn(`[Flowcharts] no flowchart found with name '${a}'`)
    }
    RemoveFlowchartState(a) {
        a.MarkForRelease();
        if (!a.IsInTriggerState()) {
            var b = a.GetTag();
            this._flowchartStates.delete(b);
            a.Release();
            this._currentFlowchartState === a && (this._currentFlowchartState = null)
        }
    }
    ResetFlowchartState(a) {
        a.Reset()
    }
    GetFlowchartState(a) {
        return this._flowchartStates.get(a)
    }
    PushFlowchartState(a) {
        this._flowchartStateStack.push(a)
    }
    PopFlowchartState() {
        this._flowchartStateStack.pop()
    }
    SetCurrentFlowchartState(a, b=!1, c=!1, d=!0) {
        d && (a = (d = a.GetCurrentReferenceFlowchart()) ? d : a);
        a !== this._currentFlowchartState && (this._TriggerBeforeFlowchartChange(),
        this._TriggerAfterFlowchartChange(a, b, c))
    }
    GetCurrentFlowchartState(a) {
        return "string" === typeof a ? this.GetFlowchartState(a) : this._flowchartStateStack.length ? this._flowchartStateStack[this._flowchartStateStack.length - 1] : this._currentFlowchartState
    }
    _TriggerBeforeFlowchartChange() {
        if (this._currentFlowchartState && !this._currentFlowchartState.WasReleased()) {
            var a = this._currentFlowchartState.GetPluginInstance().GetInstance();
            this._currentFlowchartState.PushIsTriggerState();
            this.PushFlowchartState(this._currentFlowchartState);
            this._runtime.Trigger(C3$jscomp$145.Plugins.Flowchart.Cnds.OnBeforeFlowchartChange, a);
            this.PopFlowchartState();
            this._currentFlowchartState.PopIsTriggerState()
        }
    }
    _TriggerAfterFlowchartChange(a, b=!1, c=!1) {
        (this._currentFlowchartState = a) && !this._currentFlowchartState.WasReleased() && (a = this._currentFlowchartState.GetPluginInstance().GetInstance(),
        this._currentFlowchartState.PushIsTriggerState(),
        this.PushFlowchartState(this._currentFlowchartState),
        this._runtime.Trigger(C3$jscomp$145.Plugins.Flowchart.Cnds.OnFlowchartChange, a),
        !0 !== c && "number" !== typeof c || this._currentFlowchartState._SetStartFlowchartNode(c),
        b && (this._runtime.Trigger(C3$jscomp$145.Plugins.Flowchart.Cnds.OnAnyNodeChange, a),
        this._runtime.Trigger(C3$jscomp$145.Plugins.Flowchart.Cnds.OnTaggedNodeChange, a)),
        this.PopFlowchartState(),
        this._currentFlowchartState.PopIsTriggerState())
    }
    _SaveToJson() {
        return {
            flowchartJsonObjects: [...this._flowchartStates.values()].map(a => a._SaveToJson()),
            currentFlowchartTag: this._currentFlowchartState ? this._currentFlowchartState.GetTag() : null
        }
    }
    _LoadFromJson(a) {
        if (a) {
            var b = new Map;
            for (const d of a.flowchartJsonObjects) {
                var c = d.flowchartTag;
                if (this._flowchartStates.has(c)) {
                    const e = this._flowchartStates.get(c);
                    e._LoadFromJson(d);
                    b.set(c, e)
                } else
                    c = this.AddFlowchartState(d.flowchartName, d.startNodeTag, d.flowchartTag, null, !1, d.pluginUID),
                    c._LoadFromJson(d),
                    b.set(d.flowchartTag, c)
            }
            for (const [d,e] of this._flowchartStates.entries())
                b.has(d) || e.Release();
            this._flowchartStates.clear();
            this._flowchartStates = b;
            (a = this._flowchartStates.get(a.currentFlowchartTag)) && this.SetCurrentFlowchartState(a, !0)
        }
    }
}
;
"use strict";
const C3$jscomp$146 = self.C3;
C3$jscomp$146.FlowchartDataManager = class {
    constructor() {
        this._flowchartDataItems = new Map
    }
    Release() {
        for (const a of this._flowchartDataItems.values())
            a.Release();
        this._flowchartDataItems.clear();
        this._flowchartDataItems = null
    }
    Add(a) {
        a = new C3$jscomp$146.FlowchartDataItem(a);
        const b = a.GetName();
        this._flowchartDataItems.set(b, a)
    }
    Get(a) {
        return this._flowchartDataItems.get(a)
    }
    HasFlowcharts() {
        return !!this._flowchartDataItems.size
    }
    static CreateDataItems(a, b, c, d) {
        if (b)
            for (const e of b)
                b = new c(e,d),
                a.push(b)
    }
}
;
"use strict";
const C3$jscomp$147 = self.C3;
C3$jscomp$147.FlowchartDataItem = class {
    constructor(a) {
        this._name = a[0];
        this._flowchartNodeData = new C3$jscomp$147.FlowchartNodeData(a[1],this)
    }
    Release() {
        this._flowchartNodeData.Release();
        this._flowchartNodeData = null
    }
    GetFlowchartNodeData() {
        return this._flowchartNodeData
    }
    GetFlowchartElementById(a) {
        return this._flowchartNodeData.GetFlowchartElementById(a)
    }
    GetFlowchartNodeByTag(a) {
        return this._flowchartNodeData.GetFlowchartNodeByTag(a)
    }
    GetFlowchartStartNode() {
        return this._flowchartNodeData.GetFlowchartStartNode()
    }
    GetName() {
        return this._name
    }
}
;
"use strict";
const C3$jscomp$148 = self.C3;
class FlowchartNodeDataItem {
    constructor(a, b) {
        this._flowchartNodeData = b;
        this._type = a[7];
        this._flowchartId = a[0];
        this._tag = a[1];
        this._parentFlowchartIds = a[2];
        this._childrenFlowchartIds = this._parentOutputFlowchartIds = null;
        "dictionary" === this._type && (this._parentOutputFlowchartIds = a[3],
        this._childrenFlowchartIds = a[4]);
        this._isStart = a[6];
        this._referenceFlowchartTag = this._referenceFlowchartStartNodeTag = this._referenceFlowchartName = null;
        "reference" === this._type && (this._referenceFlowchartName = a[8],
        this._referenceFlowchartStartNodeTag = a[9],
        this._referenceFlowchartTag = a[10]);
        this._flowchartNodeOutputData = new C3$jscomp$148.FlowchartNodeOutputData(a[5],this)
    }
    Release() {
        this._flowchartNodeData = null
    }
    GetFlowchartNodeData() {
        return this._flowchartNodeData
    }
    GetFlowchartNodeOutputData() {
        return this._flowchartNodeOutputData
    }
    GetFlowchartId() {
        return this._flowchartId
    }
    GetTag() {
        return this._tag
    }
    GetIsStart() {
        return this._isStart
    }
    GetParentFlowchartIds() {
        return this._parentFlowchartIds
    }
    GetParentOutputFlowchartIds() {
        return this._parentOutputFlowchartIds
    }
    GetChildrenFlowchartIds() {
        return this._childrenFlowchartIds
    }
    GetType() {
        return this._type
    }
    GetReferenceFlowchartName() {
        return this._referenceFlowchartName
    }
    GetReferenceFlowchartStartNodeTag() {
        return this._referenceFlowchartStartNodeTag
    }
    GetReferenceFlowchartTag() {
        return this._referenceFlowchartTag
    }
}
C3$jscomp$148.FlowchartNodeData = class {
    constructor(a, b) {
        this._flowchartDataItem = b;
        this._flowchartNodeItems = [];
        this._flowchartNodeItemsIdMap = new Map;
        this._flowchartNodeItemsTagMap = new Map;
        this._flowchartNodeStartItem = null;
        C3$jscomp$148.FlowchartDataManager.CreateDataItems(this._flowchartNodeItems, a, FlowchartNodeDataItem, this);
        for (const c of this._flowchartNodeItems) {
            a = c.GetFlowchartId();
            b = c.GetTag();
            const d = c.GetIsStart();
            this._flowchartNodeItemsIdMap.set(a, c);
            b && this._flowchartNodeItemsTagMap.set(b, c);
            d && (this._flowchartNodeStartItem = c);
            a = c.GetFlowchartNodeOutputData();
            for (const e of a.flowchartNodeOutputDataItems())
                a = e.GetFlowchartId(),
                this._flowchartNodeItemsIdMap.set(a, e)
        }
    }
    Release() {
        this._flowchartDataItem = null;
        for (const a of this._flowchartNodeItems)
            a.Release();
        C3$jscomp$148.clearArray(this._flowchartNodeItems);
        this._flowchartNodeItems = null
    }
    GetFlowchartDataItem() {
        return this._flowchartDataItem
    }
    GetFlowchartElementById(a) {
        return this._flowchartNodeItemsIdMap.get(a)
    }
    GetFlowchartNodeByTag(a) {
        return this._flowchartNodeItemsTagMap.get(a)
    }
    GetFlowchartStartNode() {
        return this._flowchartNodeStartItem
    }
    *flowchartNodeDataItems() {
        for (const a of this._flowchartNodeItems)
            yield a
    }
}
;
"use strict";
const C3$jscomp$149 = self.C3;
class FlowchartNodeDataOutputItem {
    constructor(a, b) {
        this._flowchartNodeOutputData = b;
        this._flowchartId = a[0];
        this._name = a[1];
        this._value = a[2];
        this._connectedFlowchartNodeFlowchartId = a[3]
    }
    Release() {
        this._flowchartNodeOutputData = null
    }
    GetFlowchartNodeOutputData() {
        return this._flowchartNodeOutputData
    }
    GetFlowchartId() {
        return this._flowchartId
    }
    GetName() {
        return this._name
    }
    GetValue() {
        return this._value
    }
    GetConnectedFlowchartNodeFlowchartId() {
        return this._connectedFlowchartNodeFlowchartId
    }
}
C3$jscomp$149.FlowchartNodeOutputData = class {
    constructor(a, b) {
        this._flowchartDataNodeItem = b;
        this._flowchartNodeOutputItems = [];
        this._flowchartNodeOutputItemsNameMap = new Map;
        C3$jscomp$149.FlowchartDataManager.CreateDataItems(this._flowchartNodeOutputItems, a, FlowchartNodeDataOutputItem, this);
        for (const c of this._flowchartNodeOutputItems)
            this._flowchartNodeOutputItemsNameMap.set(c.GetName(), c)
    }
    Release() {
        this._flowchartDataNodeItem = null;
        for (const a of this._flowchartNodeOutputItems)
            a.Release();
        C3$jscomp$149.clearArray(this._flowchartNodeOutputItems);
        this._flowchartNodeOutputItems = null
    }
    GetFlowchartNodeDataItem() {
        return this._flowchartDataNodeItem
    }
    GetFlowchartNodeOutputDataItemCount() {
        return this._flowchartNodeOutputItems.length
    }
    GetFlowchartNodeOutputDataItems() {
        return this._flowchartNodeOutputItems
    }
    GetFlowchartNodeOutputDataItemByName(a) {
        return this._flowchartNodeOutputItemsNameMap.get(a)
    }
    *flowchartNodeOutputDataItems() {
        for (const a of this._flowchartNodeOutputItems)
            yield a
    }
}
;
"use strict";
const C3$jscomp$150 = self.C3;
C3$jscomp$150.SolStack = class extends C3$jscomp$150.DefendedBase {
    constructor(a) {
        super();
        this._objectClass = a;
        this._stack = [];
        this._stack.push(C3$jscomp$150.New(C3$jscomp$150.Sol, this));
        this._index = 0;
        this._current = this._stack[0]
    }
    Release() {
        for (const a of this._stack)
            a.Release();
        C3$jscomp$150.clearArray(this._stack);
        this._objectClass = this._current = null
    }
    GetObjectClass() {
        return this._objectClass
    }
    GetCurrentSol() {
        return this._current
    }
    GetOneBelowCurrentSol() {
        return this._stack[this._index - 1]
    }
    Clear() {
        this.GetCurrentSol().Clear()
    }
    PushClean() {
        var a = this._stack
          , b = ++this._index;
        b === a.length ? (b = C3$jscomp$150.New(C3$jscomp$150.Sol, this),
        a.push(b),
        this._current = b) : (a = a[b],
        a.Reset(),
        this._current = a)
    }
    PushCopy() {
        const a = this._stack
          , b = ++this._index;
        b === a.length && a.push(C3$jscomp$150.New(C3$jscomp$150.Sol, this));
        const c = a[b];
        c.Copy(a[b - 1]);
        this._current = c
    }
    Pop() {
        this._current = this._stack[--this._index]
    }
    RemoveInstances(a) {
        const b = this._stack;
        for (let c = 0, d = b.length; c < d; ++c)
            b[c].RemoveInstances(a)
    }
}
;
"use strict";
const C3$jscomp$151 = self.C3;
C3$jscomp$151.Sol = class extends C3$jscomp$151.DefendedBase {
    constructor(a) {
        super();
        this._stack = a;
        this._objectClass = this._stack.GetObjectClass();
        this._eventStack = this._objectClass.GetRuntime().GetEventStack();
        this._selectAll = !0;
        this._instances = [];
        this._elseInstances = []
    }
    Release() {
        this.ClearArrays();
        this._eventStack = this._objectClass = this._stack = null
    }
    ClearArrays() {
        C3$jscomp$151.clearArray(this._instances);
        C3$jscomp$151.clearArray(this._elseInstances)
    }
    GetObjectClass() {
        return this._objectClass
    }
    IsSelectAll() {
        return this._selectAll
    }
    HasAnyInstances() {
        return this._selectAll ? !!this._objectClass.GetInstanceCount() : !!this._instances.length
    }
    GetInstances() {
        return this._selectAll ? this._objectClass.GetInstances() : this._instances
    }
    HasAnyElseInstances() {
        return !!this._elseInstances.length
    }
    GetElseInstances() {
        return this._elseInstances
    }
    GetExpressionInstances() {
        const a = this.GetInstances();
        return a.length ? a : this._elseInstances
    }
    Reset() {
        this._selectAll = !0;
        C3$jscomp$151.clearArray(this._elseInstances)
    }
    Clear() {
        this._selectAll = !0
    }
    Copy(a) {
        a.IsSelectAll() ? this.Reset() : (this._selectAll = !1,
        C3$jscomp$151.shallowAssignArray(this._instances, a._instances),
        C3$jscomp$151.clearArray(this._elseInstances))
    }
    _PushInstance(a) {
        this._instances.push(a)
    }
    _PushElseInstance(a) {
        this._elseInstances.push(a)
    }
    _SetSelectAll(a) {
        this._selectAll = !!a
    }
    _GetOwnInstances() {
        return this._instances
    }
    _GetOwnElseInstances() {
        return this._elseInstances
    }
    SetSinglePicked(a) {
        this._selectAll = !1;
        C3$jscomp$151.clearArray(this._instances);
        this._instances.push(a)
    }
    SetArrayPicked(a) {
        this._selectAll = !1;
        C3$jscomp$151.shallowAssignArray(this._instances, a)
    }
    SetSetPicked(a) {
        this._selectAll = !1;
        C3$jscomp$151.clearArray(this._instances);
        for (const b of a)
            this._instances.push(b)
    }
    AddElseInstances(a, b) {
        for (const c of b)
            a.has(c) || this._elseInstances.push(c)
    }
    TransferElseInstancesToOwn(a) {
        for (const b of a)
            this._instances.push(b);
        C3$jscomp$151.arrayRemoveAllInSet(this._elseInstances, a)
    }
    ClearElseInstances() {
        C3$jscomp$151.clearArray(this._elseInstances)
    }
    PickOne(a) {
        a && (this._eventStack.GetCurrentStackFrame().GetCurrentEvent().IsOrBlock() ? (this.IsSelectAll() && (C3$jscomp$151.clearArray(this._instances),
        C3$jscomp$151.shallowAssignArray(this._elseInstances, a.GetObjectClass().GetInstances()),
        this._selectAll = !1),
        a = this._elseInstances.indexOf(a),
        -1 !== a && (this._instances.push(this._elseInstances[a]),
        this._elseInstances.splice(a, 1))) : this.SetSinglePicked(a))
    }
    RemoveInstances(a) {
        C3$jscomp$151.arrayRemoveAllInSet(this._instances, a);
        C3$jscomp$151.arrayRemoveAllInSet(this._elseInstances, a)
    }
}
;
"use strict";
const C3$jscomp$152 = self.C3;
C3$jscomp$152.EventStack = class extends C3$jscomp$152.DefendedBase {
    constructor(a) {
        super();
        this._eventSheetManager = a;
        this._runtime = this._eventSheetManager.GetRuntime();
        this._stack = [];
        this._stack.push(C3$jscomp$152.New(C3$jscomp$152.EventStackFrame, this, null));
        this._index = 0;
        this._expFuncStack = []
    }
    Release() {
        for (const a of this._stack)
            a.Release();
        C3$jscomp$152.clearArray(this._stack);
        C3$jscomp$152.clearArray(this._expFuncStack);
        this._runtime = this._eventSheetManager = null
    }
    GetEventSheetManager() {
        return this._eventSheetManager
    }
    GetRuntime() {
        return this._runtime
    }
    GetCurrentStackFrame() {
        return this._stack[this._index]
    }
    GetAllStackFrames() {
        return this._stack
    }
    GetCurrentStackFrameIndex() {
        return this._index
    }
    Push(a) {
        var b = this._stack;
        const c = ++this._index;
        if (c === b.length)
            return a = C3$jscomp$152.New(C3$jscomp$152.EventStackFrame, this, a),
            b.push(a),
            a;
        b = b[c];
        b.Reset(a);
        return b
    }
    Pop() {
        --this._index
    }
    PushExpFunc(a) {
        this._expFuncStack.push(a)
    }
    PopExpFunc() {
        this._expFuncStack.pop()
    }
    GetCurrentExpFuncStackFrame() {
        const a = this._expFuncStack;
        return 0 === a.length ? null : a.at(-1)
    }
}
;
"use strict";
const C3$jscomp$153 = self.C3;
C3$jscomp$153.EventStackFrame = class extends C3$jscomp$153.DefendedBase {
    constructor(a, b) {
        super();
        this._stack = a;
        this._runtime = this._stack.GetRuntime();
        this._currentEvent = b;
        this._actIndex = this._cndIndex = 0;
        this._elseBranchRan = this._lastEventTrue = !1;
        this._expressionObjectClass = null;
        this._functionReturnValue = this._functionReturnType = 0;
        this._dynamicSolModifiers = null
    }
    Release() {
        this.Reset(null);
        this._runtime = this._stack = null
    }
    Reset(a) {
        this._currentEvent = a;
        this._actIndex = this._cndIndex = 0;
        this._elseBranchRan = this._lastEventTrue = !1;
        this._dynamicSolModifiers = null
    }
    _Restore(a, b) {
        this._currentEvent = a;
        this._cndIndex = 0;
        this._actIndex = b
    }
    ResetQuick() {
        this._actIndex = this._cndIndex = 0
    }
    GetCurrentEvent() {
        return this._currentEvent
    }
    SetCurrentEvent(a) {
        this._currentEvent = a
    }
    GetConditionIndex() {
        return this._cndIndex
    }
    SetConditionIndex(a) {
        this._cndIndex = a
    }
    GetActionIndex() {
        return this._actIndex
    }
    SetActionIndex(a) {
        this._actIndex = a
    }
    SetLastEventTrue(a) {
        this._lastEventTrue = !!a
    }
    GetLastEventTrue() {
        return this._lastEventTrue
    }
    SetElseBranchRan(a) {
        this._elseBranchRan = !!a
    }
    GetElseBranchRan() {
        return this._elseBranchRan
    }
    SetExpressionObjectClass(a) {
        this._expressionObjectClass = a
    }
    GetExpressionObjectClass() {
        return this._expressionObjectClass
    }
    InitCallFunctionExpression(a, b) {
        this._functionReturnType = a;
        this._functionReturnValue = b
    }
    GetFunctionReturnType() {
        return this._functionReturnType
    }
    SetFunctionReturnValue(a) {
        this._functionReturnValue = a
    }
    GetFunctionReturnValue() {
        return this._functionReturnValue
    }
    IsSolModifierAfterCnds() {
        const a = this._currentEvent;
        return a.IsSolWriterAfterCnds() ? !0 : this._cndIndex < a.GetConditionCount() - 1 ? !!a.GetSolModifiers().length : !1
    }
    SetDynamicSolModifiers(a) {
        this._dynamicSolModifiers = a
    }
    GetDynamicSolModifiers() {
        return this._dynamicSolModifiers
    }
}
;
"use strict";
const C3$jscomp$154 = self.C3;
C3$jscomp$154.LocalVarStack = class extends C3$jscomp$154.DefendedBase {
    constructor(a) {
        super();
        this._eventSheetManager = a;
        this._runtime = this._eventSheetManager.GetRuntime();
        this._stack = [];
        this._index = -1;
        this._current = null;
        this._initialValues = []
    }
    Release() {
        C3$jscomp$154.clearArray(this._stack);
        this._runtime = this._eventSheetManager = null
    }
    _SetInitialValues(a) {
        this._initialValues = a;
        a = this._initialValues.slice(0);
        this._stack.push(a);
        this._index = 0;
        this._current = a
    }
    GetEventSheetManager() {
        return this._eventSheetManager
    }
    GetRuntime() {
        return this._runtime
    }
    GetCurrent() {
        return this._current
    }
    Push() {
        const a = ++this._index
          , b = this._stack;
        a === b.length ? b.push(this._initialValues.slice(0)) : C3$jscomp$154.shallowAssignArray(b[a], this._initialValues);
        this._current = b[a]
    }
    Pop() {
        this._current = this._stack[--this._index]
    }
}
;
"use strict";
const C3$jscomp$155 = self.C3;
C3$jscomp$155.LoopStack = class extends C3$jscomp$155.DefendedBase {
    constructor(a) {
        super();
        this._eventSheetManager = a;
        this._runtime = this._eventSheetManager.GetRuntime();
        this._stack = [];
        this._index = -1
    }
    Release() {
        C3$jscomp$155.clearArray(this._stack);
        this._runtime = this._eventSheetManager = null
    }
    GetEventSheetManager() {
        return this._eventSheetManager
    }
    GetRuntime() {
        return this._runtime
    }
    IsInLoop() {
        return 0 <= this._index
    }
    GetCurrent() {
        return this._stack[this._index]
    }
    Push() {
        ++this._index;
        if (this._index === this._stack.length) {
            var a = C3$jscomp$155.New(C3$jscomp$155.Loop, this);
            this._stack.push(a);
            return a
        }
        a = this._stack[this._index];
        a.Reset();
        return a
    }
    Pop() {
        --this._index
    }
    FindByName(a) {
        const b = this._stack;
        for (let c = this._index; 0 <= c; --c) {
            const d = b[c];
            if (d.GetName() === a)
                return d
        }
        return null
    }
    _GetStack() {
        return this._stack.slice(0, this._index + 1)
    }
}
;
"use strict";
const C3$jscomp$156 = self.C3;
C3$jscomp$156.Loop = class extends C3$jscomp$156.DefendedBase {
    constructor(a) {
        super();
        this._loopStack = a;
        this._name = "";
        this._index = 0;
        this._isStopped = !1;
        this._end = NaN
    }
    Reset() {
        this._name = "";
        this._index = 0;
        this._isStopped = !1;
        this._end = NaN
    }
    SetName(a) {
        this._name = a
    }
    GetName() {
        return this._name
    }
    SetIndex(a) {
        this._index = a
    }
    GetIndex() {
        return this._index
    }
    Stop() {
        this._isStopped = !0
    }
    IsStopped() {
        return this._isStopped
    }
    SetEnd(a) {
        this._end = a
    }
    GetEnd() {
        return this._end
    }
}
;
"use strict";
const C3$jscomp$157 = self.C3;
C3$jscomp$157.ArrayStack = class extends C3$jscomp$157.DefendedBase {
    constructor() {
        super();
        this._stack = [];
        this._index = -1
    }
    Release() {
        C3$jscomp$157.clearArray(this._stack)
    }
    GetCurrent() {
        return this._stack[this._index]
    }
    Push() {
        ++this._index;
        if (this._index === this._stack.length) {
            const a = [];
            this._stack.push(a);
            return a
        }
        return this._stack[this._index]
    }
    Pop() {
        --this._index
    }
}
;
"use strict";
const C3$jscomp$158 = self.C3;
function SortSolArray(a, b) {
    return a.GetIndex() - b.GetIndex()
}
function IsSolArrayIdentical(a, b) {
    for (let c = 0, d = a.length; c < d; ++c)
        if (a[c] !== b[c])
            return !1;
    return !0
}
C3$jscomp$158.EventSheetManager = class extends C3$jscomp$158.DefendedBase {
    constructor(a) {
        super();
        this._runtime = a;
        this._allSheets = [];
        this._sheetsByName = new Map;
        this._allGroups = [];
        this._groupsByName = new Map;
        this._blocksBySid = new Map;
        this._cndsBySid = new Map;
        this._actsBySid = new Map;
        this._allUniqueSolModifiers = new Map;
        this._eventVarsBySid = new Map;
        this._nextLocalVarIndex = 0;
        this._allGlobalVars = [];
        this._allLocalVars = [];
        this._localVarInitialValues = [];
        this._functionBlocksByName = new Map;
        this._customActionBlocksMap = new Map;
        this._eventStack = C3$jscomp$158.New(C3$jscomp$158.EventStack, this);
        this._localVarStack = C3$jscomp$158.New(C3$jscomp$158.LocalVarStack, this);
        this._loopStack = C3$jscomp$158.New(C3$jscomp$158.LoopStack, this);
        this._triggersToPostInit = [];
        this._queuedTriggers = [];
        this._queuedDebugTriggers = [];
        this._blockFlushingDepth = this._executingTriggerDepth = this._runningEventsDepth = 0;
        this._scheduledWaits = [];
        this._asyncActionPromises = [];
        self.c3_callFunction = (b, c) => this._InvokeFunctionFromJS(b, c)
    }
    Release() {
        this.ClearAllScheduledWaits();
        this._eventStack.Release();
        this._eventStack = null;
        this._localVarStack.Release();
        this._localVarStack = null;
        C3$jscomp$158.clearArray(this._queuedTriggers);
        C3$jscomp$158.clearArray(this._queuedDebugTriggers);
        this._runtime = null;
        C3$jscomp$158.clearArray(this._allSheets);
        this._sheetsByName.clear()
    }
    Create(a) {
        a = C3$jscomp$158.New(C3$jscomp$158.EventSheet, this, a);
        this._allSheets.push(a);
        this._sheetsByName.set(a.GetName().toLowerCase(), a)
    }
    _AddTriggerToPostInit(a) {
        this._triggersToPostInit.push(a)
    }
    _PostInit() {
        for (const a of this._customActionBlocksMap.values())
            a._CheckOverrideState();
        for (const a of this._functionBlocksByName.values())
            a._PostInit();
        for (const a of this._customActionBlocksMap.values())
            a._PostInit();
        for (const a of this._allSheets)
            a._PostInit();
        for (const a of this._allSheets)
            a._UpdateDeepIncludes();
        for (const a of this._triggersToPostInit)
            a._PostInit(!1);
        C3$jscomp$158.clearArray(this._triggersToPostInit);
        this._localVarStack._SetInitialValues(this._localVarInitialValues)
    }
    GetRuntime() {
        return this._runtime
    }
    GetEventSheetByName(a) {
        return this._sheetsByName.get(a.toLowerCase()) || null
    }
    _RegisterGroup(a) {
        this._allGroups.push(a);
        this._groupsByName.set(a.GetGroupName(), a)
    }
    _RegisterEventBlock(a) {
        this._blocksBySid.set(a.GetSID(), a)
    }
    _RegisterCondition(a) {
        this._cndsBySid.set(a.GetSID(), a)
    }
    _RegisterAction(a) {
        this._actsBySid.set(a.GetSID(), a)
    }
    _RegisterFunctionBlock(a) {
        switch (a.GetFunctionType()) {
        case 0:
            this._functionBlocksByName.set(a.GetFunctionName().toLowerCase(), a);
            break;
        case 1:
            this._customActionBlocksMap.set(a.GetFunctionName().toLowerCase(), a)
        }
    }
    _RegisterEventVariable(a) {
        this._eventVarsBySid.set(a.GetSID(), a);
        a.IsGlobal() ? this._allGlobalVars.push(a) : this._allLocalVars.push(a)
    }
    _DeduplicateSolModifierList(a) {
        2 <= a.length && a.sort(SortSolArray);
        let b = this._allUniqueSolModifiers.get(a.length);
        b || (b = [],
        this._allUniqueSolModifiers.set(a.length, b));
        for (let c = 0, d = b.length; c < d; ++c) {
            const e = b[c];
            if (IsSolArrayIdentical(a, e))
                return e
        }
        b.push(a);
        return a
    }
    _GetNextLocalVarIndex(a) {
        this._localVarInitialValues.push(a.GetInitialValue());
        return this._nextLocalVarIndex++
    }
    GetEventStack() {
        return this._eventStack
    }
    GetCurrentEventStackFrame() {
        return this.GetEventStack().GetCurrentStackFrame()
    }
    GetCurrentEvent() {
        return this.GetCurrentEventStackFrame().GetCurrentEvent()
    }
    GetCurrentCondition() {
        const a = this.GetCurrentEventStackFrame();
        return a.GetCurrentEvent().GetConditionAt(a.GetConditionIndex())
    }
    GetCurrentAction() {
        const a = this.GetCurrentEventStackFrame();
        return a.GetCurrentEvent().GetActionAt(a.GetActionIndex())
    }
    GetLocalVarStack() {
        return this._localVarStack
    }
    GetLoopStack() {
        return this._loopStack
    }
    GetAllLocalVariablesInScope(a) {
        const b = [];
        for (a = a.GetScopeParent(); a; )
            C3$jscomp$158.appendArray(b, a._GetAllLocalVariablesInScope()),
            a = a.GetScopeParent();
        return b
    }
    _GetLocalVariablesScriptInterface(a) {
        const b = {};
        for (const c of this.GetAllLocalVariablesInScope(a))
            b[c.GetJsPropName()] = c._GetScriptInterfaceDescriptor();
        return Object.create(Object.prototype, b)
    }
    GetEventVariableBySID(a) {
        return this._eventVarsBySid.get(a) || null
    }
    GetEventBlockBySID(a) {
        return this._blocksBySid.get(a) || null
    }
    GetConditionBySID(a) {
        return this._cndsBySid.get(a) || null
    }
    GetActionBySID(a) {
        return this._actsBySid.get(a) || null
    }
    GetFunctionBlockByName(a) {
        return this._functionBlocksByName.get(a.toLowerCase()) || null
    }
    GetCustomActionBlockByName(a, b) {
        let c = this._customActionBlocksMap.get((a.GetName() + "." + b).toLowerCase());
        if (c)
            return c;
        if (!a.IsFamily())
            for (const d of a.GetFamilies())
                if (c = this._customActionBlocksMap.get((d.GetName() + "." + b).toLowerCase()))
                    return c;
        return null
    }
    GetAllGlobalVariables() {
        return this._allGlobalVars
    }
    GetAllLocalVariables() {
        return this._allLocalVars
    }
    ResetAllGlobalsToInitialValue(a) {
        for (const b of this._allGlobalVars)
            b.ResetToInitialValue();
        if (a)
            for (const b of this._allLocalVars)
                b.IsStatic() && b.ResetToInitialValue()
    }
    GetEventGroupByName(a) {
        return this._groupsByName.get(a.toLowerCase()) || null
    }
    GetEventGroupBySID(a) {
        return (a = this._blocksBySid.get(a)) && a.IsGroup() ? a : null
    }
    GetAllGroups() {
        return this._allGroups
    }
    ResetAllGroupsInitialActivation() {
        for (const a of this._allGroups)
            a.ResetInitialActivation()
    }
    _ResetAllHasRunFlags() {
        for (const a of this._allSheets)
            a._ResetHasRunFlag()
    }
    RunEvents(a) {
        this._ResetAllHasRunFlags();
        this._runningEventsDepth++;
        for (const b of a.runningLayouts())
            if (a = b.GetEventSheet())
                this._runtime.PushCurrentLayout(b),
                a.Run(),
                this._runtime.PopCurrentLayout();
        this._runningEventsDepth--
    }
    async DebugRunEvents(a) {
        this._ResetAllHasRunFlags();
        this._runningEventsDepth++;
        for (const b of this._DebugRunEventsGen(a))
            await this._runtime.DebugBreak(b);
        this._runningEventsDepth--
    }
    *_DebugRunEventsGen(a) {
        for (const b of a.runningLayouts())
            if (a = b.GetEventSheet())
                this._runtime.PushCurrentLayout(b),
                yield*a.DebugRun(),
                this._runtime.PopCurrentLayout()
    }
    _Trigger(a, b, c, d) {
        let e = !1;
        if (!a.GetMainRunningLayout())
            return this.QueueTrigger(b, c, d);
        this._executingTriggerDepth++;
        for (const f of a.runningLayouts())
            if (a = f.GetEventSheet()) {
                this._runtime.PushCurrentLayout(f);
                for (const h of a.deepIncludes()) {
                    const l = h._Trigger(b, c, d);
                    e = e || l
                }
                a = a._Trigger(b, c, d);
                e = e || a;
                this._runtime.PopCurrentLayout()
            }
        this._executingTriggerDepth--;
        return e
    }
    *_DebugTrigger(a, b, c, d) {
        let e = !1;
        if (!a.GetMainRunningLayout())
            return this.QueueTrigger(b, c, d);
        this._executingTriggerDepth++;
        for (const f of a.runningLayouts())
            if (a = f.GetEventSheet()) {
                this._runtime.PushCurrentLayout(f);
                for (const h of a.deepIncludes()) {
                    const l = yield*h._DebugTrigger(b, c, d);
                    e = e || l
                }
                a = yield*a._DebugTrigger(b, c, d);
                e = e || a;
                this._runtime.PopCurrentLayout()
            }
        this._executingTriggerDepth--;
        return e
    }
    QueueTrigger(a, b, c) {
        this._queuedTriggers.push([a, b, c]);
        return !1
    }
    QueueDebugTrigger(a, b, c) {
        let d = null;
        const e = new Promise(f => d = f);
        this._queuedDebugTriggers.push([a, b, c, d]);
        return e
    }
    *_RunQueuedDebugTriggersGen() {
        if (this._runtime.HitBreakpoint())
            throw Error("should not be in breakpoint");
        const a = this._runtime.GetLayoutManager();
        for (; this._queuedDebugTriggers.length; ) {
            const [b,c,d,e] = this._queuedDebugTriggers.shift()
              , f = yield*this._DebugTrigger(a, b, c, d);
            e(f)
        }
    }
    async RunQueuedDebugTriggersAsync() {
        for (const a of this._RunQueuedDebugTriggersGen())
            await this._runtime.DebugBreak(a)
    }
    _FastTrigger(a, b, c, d) {
        let e = !1;
        var f = a.GetMainRunningLayout();
        if (a = f.GetEventSheet()) {
            this._executingTriggerDepth++;
            this._runtime.PushCurrentLayout(f);
            f = a.deepIncludes();
            for (let h = 0, l = f.length; h < l; ++h) {
                const m = f[h]._FastTrigger(b, c, d);
                e = e || m
            }
            b = a._FastTrigger(b, c, d);
            e = e || b;
            this._runtime.PopCurrentLayout();
            this._executingTriggerDepth--;
            return e
        }
    }
    *_DebugFastTrigger(a, b, c, d) {
        let e = !1;
        var f = a.GetMainRunningLayout();
        if (a = f.GetEventSheet()) {
            this._executingTriggerDepth++;
            this._runtime.PushCurrentLayout(f);
            f = a.deepIncludes();
            for (let h = 0, l = f.length; h < l; ++h) {
                const m = yield*f[h]._DebugFastTrigger(b, c, d);
                e = e || m
            }
            b = yield*a._DebugFastTrigger(b, c, d);
            e = e || b;
            this._runtime.PopCurrentLayout();
            this._executingTriggerDepth--;
            return e
        }
    }
    GetTriggerDepth() {
        return this._executingTriggerDepth
    }
    IsInTrigger() {
        return 0 < this.GetTriggerDepth()
    }
    _IncTriggerDepth() {
        return ++this._executingTriggerDepth
    }
    _DecTriggerDepth() {
        --this._executingTriggerDepth
    }
    IsRunningEvents() {
        return 0 < this._runningEventsDepth
    }
    IsInEventEngine() {
        return this.IsRunningEvents() || this.IsInTrigger()
    }
    _RunQueuedTriggers(a) {
        for (const [b,c,d] of this._queuedTriggers)
            this._Trigger(a, b, c, d);
        C3$jscomp$158.clearArray(this._queuedTriggers)
    }
    BlockFlushingInstances(a) {
        a ? this._blockFlushingDepth++ : this._blockFlushingDepth--
    }
    IsFlushingBlocked() {
        return 0 < this._blockFlushingDepth
    }
    ClearSol(a) {
        for (let b = 0, c = a.length; b < c; ++b)
            a[b].GetSolStack().Clear()
    }
    PushCleanSol(a) {
        for (let b = 0, c = a.length; b < c; ++b)
            a[b].GetSolStack().PushClean()
    }
    PushCopySol(a) {
        for (let b = 0, c = a.length; b < c; ++b)
            a[b].GetSolStack().PushCopy()
    }
    PopSol(a) {
        for (let b = 0, c = a.length; b < c; ++b)
            a[b].GetSolStack().Pop()
    }
    GetDynamicSolModifiersSet(a) {
        const b = new Set
          , c = this._eventStack.GetAllStackFrames()
          , d = this._eventStack.GetCurrentStackFrameIndex();
        for (let e = 0; e <= d; ++e) {
            const f = c[e].GetDynamicSolModifiers();
            if (f)
                for (const h of f)
                    a && a.has(h) || b.add(h)
        }
        return b
    }
    PushCleanSolDynamic(a) {
        a = new Set([...a]);
        a = this.GetDynamicSolModifiersSet(a);
        if (0 < a.size) {
            for (const b of a)
                b.GetSolStack().PushClean();
            return [...a]
        }
        return null
    }
    AddScheduledWait() {
        const a = C3$jscomp$158.New(C3$jscomp$158.ScheduledWait, this);
        this._scheduledWaits.push(a);
        return a
    }
    scheduledWaits() {
        return this._scheduledWaits
    }
    RunScheduledWaits() {
        if (this._scheduledWaits.length) {
            var a = this.GetCurrentEventStackFrame()
              , b = !1;
            this._runningEventsDepth++;
            for (let c = 0, d = this._scheduledWaits.length; c < d; ++c) {
                const e = this._scheduledWaits[c];
                e._ShouldRun() && e._Run(a);
                e.ShouldRelease() && (b = !0)
            }
            b && (this._FilterScheduledWaitsToRelease(),
            a.Reset(null));
            this._runningEventsDepth--
        }
    }
    async DebugRunScheduledWaits() {
        if (this._scheduledWaits.length) {
            var a = this.GetCurrentEventStackFrame()
              , b = !1;
            this._runningEventsDepth++;
            for (let c = 0, d = this._scheduledWaits.length; c < d; ++c) {
                const e = this._scheduledWaits[c];
                e._ShouldRun() && await e._DebugRun(a);
                e.ShouldRelease() && (b = !0)
            }
            b && (this._FilterScheduledWaitsToRelease(),
            a.Reset(null));
            this._runningEventsDepth--
        }
    }
    _FilterScheduledWaitsToRelease() {
        const a = C3$jscomp$158.arrayFilterOut(this._scheduledWaits, b => b.ShouldRelease());
        for (const b of a)
            b.Release()
    }
    ClearAllScheduledWaits() {
        for (const a of this._scheduledWaits)
            a.Release();
        C3$jscomp$158.clearArray(this._scheduledWaits)
    }
    RemoveInstancesFromScheduledWaits(a) {
        for (const b of this._scheduledWaits)
            b.RemoveInstances(a)
    }
    AddAsyncActionPromise(a) {
        this._asyncActionPromises.push(a)
    }
    ClearAsyncActionPromises() {
        C3$jscomp$158.clearArray(this._asyncActionPromises)
    }
    GetPromiseForAllAsyncActions() {
        const a = Promise.all(this._asyncActionPromises);
        this._asyncActionPromises = [];
        return a
    }
    _SaveToJson() {
        return {
            groups: this._SaveGroupsToJson(),
            cnds: this._SaveCndsToJson(),
            acts: this._SaveActsToJson(),
            vars: this._SaveVarsToJson(),
            waits: this._SaveScheduledWaitsToJson()
        }
    }
    _LoadFromJson(a) {
        this._LoadGroupsFromJson(a.groups);
        this._LoadCndsFromJson(a.cnds);
        this._LoadActsFromJson(a.acts);
        this._LoadVarsFromJson(a.vars);
        this._LoadScheduledWaitsFromJson(a.waits)
    }
    _SaveGroupsToJson() {
        const a = {};
        for (const b of this.GetAllGroups())
            a[b.GetSID().toString()] = b.IsGroupActive();
        return a
    }
    _LoadGroupsFromJson(a) {
        for (const [b,c] of Object.entries(a))
            a = parseInt(b, 10),
            (a = this.GetEventGroupBySID(a)) && a.SetGroupActive(c)
    }
    _SaveCndsToJson() {
        const a = {};
        for (const [b,c] of this._cndsBySid) {
            const d = c._SaveToJson();
            d && (a[b.toString()] = d)
        }
        return a
    }
    _LoadCndsFromJson(a) {
        const b = new Map;
        for (const [c,d] of Object.entries(a))
            b.set(parseInt(c, 10), d);
        for (const [c,d] of this._cndsBySid)
            d._LoadFromJson(b.get(c) || null)
    }
    _SaveActsToJson() {
        const a = {};
        for (const [b,c] of this._actsBySid) {
            const d = c._SaveToJson();
            d && (a[b.toString()] = d)
        }
        return a
    }
    _LoadActsFromJson(a) {
        const b = new Map;
        for (const [c,d] of Object.entries(a))
            b.set(parseInt(c, 10), d);
        for (const [c,d] of this._actsBySid)
            d._LoadFromJson(b.get(c) || null)
    }
    _SaveVarsToJson() {
        const a = {};
        for (const [b,c] of this._eventVarsBySid)
            c.IsConstant() || !c.IsGlobal() && !c.IsStatic() || (a[b.toString()] = c.GetValue());
        return a
    }
    _LoadVarsFromJson(a) {
        for (const [b,c] of Object.entries(a))
            a = parseInt(b, 10),
            (a = this.GetEventVariableBySID(a)) && a.SetValue(c)
    }
    _SaveScheduledWaitsToJson() {
        return this._scheduledWaits.filter(a => !a.IsPromise()).map(a => a._SaveToJson())
    }
    _LoadScheduledWaitsFromJson(a) {
        this.ClearAllScheduledWaits();
        for (const b of a)
            (a = C3$jscomp$158.ScheduledWait._CreateFromJson(this, b)) && this._scheduledWaits.push(a)
    }
    _GetPerfRecords() {
        return [...this._runtime.GetLayoutManager().runningLayouts()].map(a => a.GetEventSheet()).filter(a => a).map(a => a._GetPerfRecord())
    }
    FindFirstFunctionBlockParent(a) {
        for (; a; )
            if (a = a.GetScopeParent(),
            a instanceof C3$jscomp$158.FunctionBlock)
                return a;
        return null
    }
    _InvokeFunctionFromJS(a, b) {
        Array.isArray(b) || (b = []);
        a = this.GetFunctionBlockByName(a.toLowerCase());
        if (!a)
            return null;
        if (!a.IsEnabled())
            return a.GetDefaultReturnValue();
        var c = a.GetFunctionParameters();
        if (b.length < c.length) {
            b = b.slice(0);
            do
                b.push(c[b.length].GetInitialValue());
            while (b.length < c.length)
        }
        c = a.GetEventBlock();
        return c.RunAsExpressionFunctionCall(c.GetSolModifiersIncludingParents(), !1, a.GetReturnType(), a.GetDefaultReturnValue(), ...b)
    }
}
;
"use strict";
const C3$jscomp$159 = self.C3;
C3$jscomp$159.EventSheet = class extends C3$jscomp$159.DefendedBase {
    constructor(a, b) {
        super();
        this._eventSheetManager = a;
        this._runtime = a.GetRuntime();
        this._name = b[0];
        this._events = [];
        this._triggers = new Map;
        this._fastTriggers = new Map;
        this._eventsByDisplayNumber = new Map;
        this._hasRun = !1;
        this._shallowIncludes = [];
        this._deepIncludes = [];
        this._alreadyIncludedSheets = new Set;
        for (const c of b[1])
            this._CreateEvent(c, null, this._events);
        this._perfRecord = this._runtime.IsDebug() ? {
            type: "sheet",
            name: this._name,
            totalTimeCounter: 0,
            children: []
        } : null
    }
    Release() {
        this._runtime = this._eventSheetManager = null
    }
    _CreateEvent(a, b, c) {
        switch (a[0]) {
        case 0:
        case 3:
            this._CreateEventBlock(a, b, c);
            break;
        case 1:
            this._CreateEventVariable(a, b, c);
            break;
        case 2:
            this._CreateInclude(a, b, c);
            break;
        case 4:
            this._CreateFunctionBlock(a, b);
            break;
        case 5:
            this._CreateScriptBlock(a, b, c);
            break;
        case 6:
            this._CreateCustomACEBlock(a, b);
            break;
        default:
            throw Error("invalid event type");
        }
    }
    _CreateEventBlock(a, b, c) {
        a = C3$jscomp$159.EventBlock.Create(this, b, a);
        if (a.IsOrBlock()) {
            c.push(a);
            c = a.GetConditions();
            for (let d = 0, e = c.length; d < e; ++d)
                c[d].IsTrigger() && this._InitTrigger(a, d)
        } else
            a.IsTrigger() ? this._InitTrigger(a, 0) : c.push(a)
    }
    _CreateFunctionBlock(a, b) {
        a = C3$jscomp$159.FunctionBlock.CreateFunctionBlock(this, b, a);
        this._eventSheetManager._RegisterFunctionBlock(a)
    }
    _CreateCustomACEBlock(a, b) {
        a = C3$jscomp$159.FunctionBlock.CreateCustomACEBlock(this, b, a);
        this._eventSheetManager._RegisterFunctionBlock(a)
    }
    _CreateEventVariable(a, b, c) {
        a = C3$jscomp$159.EventVariable.Create(this, b, a);
        c.push(a)
    }
    _CreateInclude(a, b, c) {
        a = C3$jscomp$159.EventInclude.Create(this, b, a);
        c.push(a)
    }
    _CreateScriptBlock(a, b, c) {
        a = C3$jscomp$159.EventScript.Create(this, b, a);
        c.push(a)
    }
    _InitTrigger(a, b) {
        a.IsOrBlock() || this._eventSheetManager._AddTriggerToPostInit(a);
        var c = a.GetConditionAt(b)
          , d = c._GetFunc()
          , e = c.GetObjectClass();
        if (c.IsFastTrigger()) {
            var f = this._fastTriggers.get(e);
            f || (f = new Map,
            this._fastTriggers.set(e, f));
            c = c.GetFastTriggerValue().toLowerCase();
            e = f.get(d);
            e || (e = new Map,
            f.set(d, e));
            d = e.get(c);
            d || (d = [],
            e.set(c, d));
            d.push([a, b])
        } else
            f = this._triggers.get(e),
            f || (f = {
                methodMap: new Map,
                behaviors: new Map
            },
            this._triggers.set(e, f)),
            (e = c.GetBehaviorType()) ? (c = f.behaviors.get(e),
            c || (c = new Map,
            f.behaviors.set(e, c))) : c = f.methodMap,
            f = c.get(d),
            f || (f = [],
            c.set(d, f)),
            f.push([a, b])
    }
    _PostInit() {
        const a = this._events;
        for (let b = 0, c = a.length; b < c; ++b) {
            const d = b < c - 1 && a[b + 1]instanceof C3$jscomp$159.EventBlock && a[b + 1].IsElseBlock();
            a[b]._PostInit(d)
        }
    }
    _AddShallowInclude(a) {
        this._shallowIncludes.push(a)
    }
    _UpdateDeepIncludes() {
        C3$jscomp$159.clearArray(this._deepIncludes);
        this._AddDeepIncludes(this);
        this._alreadyIncludedSheets.clear()
    }
    _AddDeepIncludes(a) {
        const b = a._deepIncludes
          , c = a._alreadyIncludedSheets;
        for (const d of this._shallowIncludes) {
            const e = d.GetIncludeSheet();
            d.IsActive() && a !== e && !c.has(e) && (c.add(e),
            e._AddDeepIncludes(a),
            b.push(e))
        }
    }
    deepIncludes() {
        return this._deepIncludes
    }
    GetEventSheetManager() {
        return this._eventSheetManager
    }
    GetRuntime() {
        return this._runtime
    }
    GetName() {
        return this._name
    }
    _RegisterEventByDisplayNumber(a, b) {
        this._eventsByDisplayNumber.set(b, a)
    }
    _GetEventByDisplayNumber(a) {
        return this._eventsByDisplayNumber.get(a) || null
    }
    _ResetHasRunFlag() {
        this._hasRun = !1
    }
    Run() {
        if (!this._hasRun) {
            var a = this._runtime
              , b = a.IsCPUProfiling()
              , c = b ? performance.now() : 0;
            this._hasRun = !0;
            var d = this.GetEventSheetManager()
              , e = d.GetCurrentEventStackFrame();
            for (const f of this._events)
                f.Run(e),
                d.ClearSol(f.GetSolModifiers()),
                d.ClearAsyncActionPromises(),
                a.FlushPendingInstances();
            e.Reset(null);
            b && (this._perfRecord.totalTimeCounter += performance.now() - c)
        }
    }
    *DebugRun() {
        if (!this._hasRun) {
            this._hasRun = !0;
            var a = this._runtime
              , b = this.GetEventSheetManager()
              , c = b.GetCurrentEventStackFrame();
            for (const d of this._events)
                yield*d.DebugRun(c),
                b.ClearSol(d.GetSolModifiers()),
                b.ClearAsyncActionPromises(),
                a.FlushPendingInstances();
            c.Reset(null)
        }
    }
    _Trigger(a, b, c) {
        if (b) {
            const d = b.GetObjectClass();
            this._TriggerForClass(a, b, d, c);
            for (const e of d.GetFamilies())
                this._TriggerForClass(a, b, e, c)
        } else
            return this._TriggerForClass(a, b, null, null)
    }
    _TriggerForClass(a, b, c, d) {
        c = this._triggers.get(c);
        if (!c)
            return !1;
        d = d ? c.behaviors.get(d) : c.methodMap;
        if (!d)
            return !1;
        d = d.get(a);
        if (!d)
            return !1;
        a = !1;
        for (const [e,f] of d)
            d = this._ExecuteTrigger(b, e, f),
            a = a || d;
        return a
    }
    *_DebugTrigger(a, b, c) {
        if (b) {
            const d = b.GetObjectClass();
            yield*this._DebugTriggerForClass(a, b, d, c);
            for (const e of d.GetFamilies())
                yield*this._DebugTriggerForClass(a, b, e, c)
        } else
            return yield*this._DebugTriggerForClass(a, b, null, null)
    }
    *_DebugTriggerForClass(a, b, c, d) {
        c = this._triggers.get(c);
        if (!c)
            return !1;
        d = d ? c.behaviors.get(d) : c.methodMap;
        if (!d)
            return !1;
        d = d.get(a);
        if (!d)
            return !1;
        a = !1;
        for (const [e,f] of d)
            d = e.DebugCanRunFast() ? this._ExecuteTrigger(b, e, f) : yield*this._DebugExecuteTrigger(b, e, f),
            a = a || d;
        return a
    }
    _FastTrigger(a, b, c) {
        b = b.GetObjectClass();
        b = this._fastTriggers.get(b);
        if (!b)
            return !1;
        a = b.get(a);
        if (!a)
            return !1;
        c = a.get(c);
        if (!c)
            return !1;
        a = !1;
        for (let d = 0, e = c.length; d < e; ++d)
            b = c[d],
            b = this._ExecuteTrigger(null, b[0], b[1]),
            a = a || b;
        return a
    }
    *_DebugFastTrigger(a, b, c) {
        b = b.GetObjectClass();
        b = this._fastTriggers.get(b);
        if (!b)
            return !1;
        a = b.get(a);
        if (!a)
            return !1;
        c = a.get(c);
        if (!c)
            return !1;
        a = !1;
        for (let e = 0, f = c.length; e < f; ++e) {
            var d = c[e];
            b = d[0];
            d = d[1];
            b = b.DebugCanRunFast() ? this._ExecuteTrigger(null, b, d) : yield*this._DebugExecuteTrigger(null, b, d);
            a = a || b
        }
        return a
    }
    _ExecuteTrigger(a, b, c) {
        const d = this._runtime
          , e = this._eventSheetManager
          , f = e.GetCurrentEvent()
          , h = e.GetEventStack()
          , l = e.GetTriggerDepth();
        let m = !1;
        f && e.PushCleanSol(f.GetSolModifiersIncludingParents());
        e.PushCleanSol(b.GetSolModifiersIncludingParents());
        const p = 1 < l;
        p && e.GetLocalVarStack().Push();
        const r = h.Push(b);
        a && (b.GetConditions()[c].GetObjectClass().GetCurrentSol().SetSinglePicked(a),
        a.IsInContainer() && a.SetSiblingsSinglePicked());
        a = !0;
        if (b.GetParent()) {
            const v = b.GetTriggerParents();
            for (let x = 0, B = v.length; x < B; ++x)
                if (!v[x].RunPreTrigger(r)) {
                    a = !1;
                    break
                }
        }
        a && (b.IsOrBlock() ? b.RunOrBlockTrigger(r, c) : b.Run(r),
        m = r.GetLastEventTrue());
        h.Pop();
        p && e.GetLocalVarStack().Pop();
        e.PopSol(b.GetSolModifiersIncludingParents());
        f && e.PopSol(f.GetSolModifiersIncludingParents());
        f || 1 !== l || (e.ClearAsyncActionPromises(),
        e.IsFlushingBlocked() || d.FlushPendingInstances());
        return m
    }
    *_DebugExecuteTrigger(a, b, c) {
        const d = this._runtime
          , e = this._eventSheetManager
          , f = e.GetCurrentEvent()
          , h = e.GetEventStack()
          , l = e.GetTriggerDepth();
        let m = !1;
        f && e.PushCleanSol(f.GetSolModifiersIncludingParents());
        e.PushCleanSol(b.GetSolModifiersIncludingParents());
        const p = 1 < l;
        p && e.GetLocalVarStack().Push();
        const r = h.Push(b);
        a && (b.GetConditions()[c].GetObjectClass().GetCurrentSol().SetSinglePicked(a),
        a.IsInContainer() && a.SetSiblingsSinglePicked());
        a = !0;
        if (b.GetParent()) {
            const v = b.GetTriggerParents();
            for (let x = 0, B = v.length; x < B; ++x)
                if (!(yield*v[x].DebugRunPreTrigger(r))) {
                    a = !1;
                    break
                }
        }
        a && (b.IsOrBlock() ? yield*b.DebugRunOrBlockTrigger(r, c) : yield*b.DebugRun(r),
        m = r.GetLastEventTrue());
        h.Pop();
        p && e.GetLocalVarStack().Pop();
        e.PopSol(b.GetSolModifiersIncludingParents());
        f && e.PopSol(f.GetSolModifiersIncludingParents());
        f || 1 !== l || (e.ClearAsyncActionPromises(),
        e.IsFlushingBlocked() || d.FlushPendingInstances());
        return m
    }
    _GetPerfRecord() {
        return this._perfRecord
    }
}
;
"use strict";
const C3$jscomp$160 = self.C3
  , EMPTY_ARRAY = [];
function NoActions(a, b) {
    return !0
}
function *DebugNoActions(a, b) {
    return !0
}
C3$jscomp$160.EventBlock = class extends C3$jscomp$160.DefendedBase {
    constructor(a, b, c) {
        super();
        this._eventSheet = a;
        this._runtime = a.GetRuntime();
        this._parent = b;
        this._scopeParent = null;
        this._eventStack = this._runtime.GetEventSheetManager().GetEventStack();
        this._solModifiers = [];
        this._solModifiersIncludingParents = [];
        this._hasElseBlock = this._isTopLevelGroup = this._isSolWriterAfterCnds = this._hasGotSolModifiersIncludingParents = !1;
        this._isOrBlock = !!c[2];
        this._isElseBlock = !1;
        this._triggerParents = null;
        this._conditions = [];
        this._actions = [];
        this._subEvents = [];
        this._RunActions = NoActions;
        this._DebugRunActions = DebugNoActions;
        this._isInitiallyActive = this._isGroup = !1;
        this._groupName = "";
        this._isGroupActive = !1;
        this._perfRecord = this._containedIncludes = null;
        this._sid = c[4];
        this._displayNumber = c[5];
        this._eventSheet._RegisterEventByDisplayNumber(this, this._displayNumber);
        this._debugData = this._runtime.IsDebug() ? {
            isBreakpoint: c[3][0],
            isBreakable: c[3][1],
            canRunAllConditionsFast: !1,
            canRunAllActionsFast: !1,
            canRunAllSubEventsFast: !1,
            canRunSelfFast: !1
        } : null;
        this.GetEventSheetManager()._RegisterEventBlock(this);
        3 === c[0] && this._InitGroup(c[1]);
        a = 0;
        for (var d of c[6])
            b = C3$jscomp$160.Condition.Create(this, d, a++),
            this._conditions.push(b),
            this._AddSolModifier(b.GetObjectClass());
        a = 0;
        for (const e of c[7])
            d = C3$jscomp$160.Action.Create(this, e, a++),
            this._actions.push(d);
        if (9 === c.length) {
            c = c[8];
            for (const e of c)
                this._eventSheet._CreateEvent(e, this, this._subEvents)
        }
        this._conditions.length && (this._isElseBlock = null === this._conditions[0].GetObjectClass() && this._conditions[0]._GetFunc() === C3$jscomp$160.Plugins.System.Cnds.Else);
        0 === this._conditions.length && (this._conditions = EMPTY_ARRAY);
        0 === this._actions.length && (this._actions = EMPTY_ARRAY);
        0 === this._subEvents.length && (this._subEvents = EMPTY_ARRAY)
    }
    static Create(a, b, c) {
        return C3$jscomp$160.New(C3$jscomp$160.EventBlock, a, b, c)
    }
    _InitGroup(a) {
        this._isGroup = !0;
        this._isGroupActive = this._isInitiallyActive = !!a[0];
        this._groupName = a[1].toLowerCase();
        this._containedIncludes = [];
        this.GetEventSheetManager()._RegisterGroup(this);
        this._runtime.IsDebug() && (this._perfRecord = {
            type: "group",
            name: a[1],
            totalTimeCounter: 0,
            children: []
        })
    }
    _AddContainedInclude(a) {
        this._containedIncludes.push(a)
    }
    _AddContainerSolModifierToList(a, b) {
        for (const c of a.GetContainer().objectTypes())
            b.includes(c) || b.push(c)
    }
    _AddSolModifierToList(a, b) {
        if (a)
            if (b.includes(a) || b.push(a),
            a.IsFamily())
                for (const c of a.GetFamilyMembers())
                    c.IsInContainer() && this._AddContainerSolModifierToList(c, b);
            else
                a.IsInContainer() && this._AddContainerSolModifierToList(a, b)
    }
    _AddSolModifier(a) {
        this._AddSolModifierToList(a, this._solModifiers)
    }
    _AddParentSolModifier(a) {
        this._AddSolModifierToList(a, this._solModifiersIncludingParents)
    }
    SetAllSolModifiers() {
        this._solModifiers = this._runtime.GetAllObjectClasses()
    }
    _PostInit(a) {
        this._hasElseBlock = !!a;
        this._IdentifyTopLevelGroup();
        this._IdentifyTriggerParents();
        for (const c of this._conditions)
            c._PostInit();
        if (0 < this._actions.length) {
            a = !1;
            for (var b of this._actions)
                b._PostInit(),
                b.HasReturnType() && (a = !0);
            a ? (this._RunActions = this._RunActions_ReturnValue,
            this._DebugRunActions = this._DebugRunActions_ReturnValue) : (this._RunActions = this._RunActions_Fast,
            this._DebugRunActions = this._DebugRunActions_Fast)
        }
        b = this._subEvents;
        for (let c = 0, d = b.length; c < d; ++c)
            a = c < d - 1 && b[c + 1]instanceof C3$jscomp$160.EventBlock && b[c + 1].IsElseBlock(),
            b[c]._PostInit(a);
        this._debugData && this._UpdateCanRunFast();
        this._perfRecord && this._GetPerfRecordParent()._GetPerfRecord().children.push(this._perfRecord)
    }
    _GetPerfRecord() {
        return this._perfRecord
    }
    _GetPerfRecordParent() {
        let a = this.GetParent();
        for (; a; ) {
            if (a.IsGroup())
                return a;
            a = a.GetParent()
        }
        return this._eventSheet
    }
    _UpdateCanRunFast() {
        const a = this._debugData;
        a.canRunAllConditionsFast = this._conditions.every(b => b.DebugCanRunFast());
        a.canRunAllActionsFast = this._actions.every(b => b.DebugCanRunFast());
        a.canRunAllSubEventsFast = this._subEvents.every(b => b.DebugCanRunFast());
        a.canRunSelfFast = a.canRunAllConditionsFast && a.canRunAllActionsFast && a.canRunAllSubEventsFast
    }
    _UpdateCanRunFastRecursive() {
        let a = this;
        do
            a._UpdateCanRunFast(),
            a = a.GetParent();
        while (a)
    }
    _IdentifyTopLevelGroup() {
        if (this.IsGroup()) {
            var a = this.GetParent();
            for (this._isTopLevelGroup = !0; a; ) {
                if (!a.IsGroup()) {
                    this._isTopLevelGroup = !1;
                    break
                }
                a = a.GetParent()
            }
        }
    }
    _IdentifySolModifiersIncludingParents() {
        var a = this._runtime.GetAllObjectClasses();
        if (this._solModifiers === a)
            this._solModifiersIncludingParents = a;
        else {
            this._solModifiersIncludingParents = C3$jscomp$160.cloneArray(this._solModifiers);
            for (a = this.GetParent(); a; ) {
                for (var b of a._solModifiers)
                    this._AddParentSolModifier(b);
                a = a.GetParent()
            }
            b = this.GetEventSheetManager();
            this._solModifiers = b._DeduplicateSolModifierList(this._solModifiers);
            this._solModifiersIncludingParents = b._DeduplicateSolModifierList(this._solModifiersIncludingParents)
        }
    }
    _IdentifyTriggerParents() {
        if (this.HasAnyTriggeredCondition()) {
            this._triggerParents = [];
            for (var a = this.GetParent(); a; )
                this._triggerParents.push(a),
                a = a.GetParent();
            this._triggerParents.reverse()
        }
    }
    SetSolWriterAfterCnds() {
        this._isSolWriterAfterCnds = !0;
        this._parent && this._parent.SetSolWriterAfterCnds()
    }
    IsSolWriterAfterCnds() {
        return this._isSolWriterAfterCnds
    }
    GetSolModifiers() {
        return this._solModifiers
    }
    GetSolModifiersIncludingParents() {
        this._hasGotSolModifiersIncludingParents || (this._hasGotSolModifiersIncludingParents = !0,
        this._IdentifySolModifiersIncludingParents());
        return this._solModifiersIncludingParents
    }
    HasSolModifier(a) {
        return this._solModifiers.includes(a)
    }
    GetTriggerParents() {
        return this._triggerParents
    }
    GetEventSheet() {
        return this._eventSheet
    }
    GetEventSheetManager() {
        return this._eventSheet.GetEventSheetManager()
    }
    GetRuntime() {
        return this._runtime
    }
    GetParent() {
        return this._parent
    }
    _SetScopeParent(a) {
        this._scopeParent = a
    }
    GetScopeParent() {
        return this._scopeParent || this._parent
    }
    GetDisplayNumber() {
        return this._displayNumber
    }
    IsDebugBreakable() {
        return this._debugData && this._debugData.isBreakable
    }
    IsDebugBreakpoint() {
        return this.IsDebugBreakable() && this._debugData.isBreakpoint
    }
    _SetDebugBreakpoint(a) {
        this._debugData.isBreakpoint = !!a;
        this._UpdateCanRunFastRecursive()
    }
    IsGroup() {
        return this._isGroup
    }
    IsTopLevelGroup() {
        return this._isTopLevelGroup
    }
    IsElseBlock() {
        return this._isElseBlock
    }
    HasElseBlock() {
        return this._hasElseBlock
    }
    GetGroupName() {
        return this._groupName
    }
    IsGroupActive() {
        return this._isGroupActive
    }
    ResetInitialActivation() {
        this.SetGroupActive(this._isInitiallyActive)
    }
    SetGroupActive(a) {
        a = !!a;
        if (!this._isGroup)
            throw Error("not a group");
        if (this._isGroupActive !== a) {
            this._isGroupActive = a;
            for (const b of this._containedIncludes)
                b.UpdateActive();
            this._containedIncludes.length && (a = this._runtime.GetCurrentLayout().GetEventSheet()) && a._UpdateDeepIncludes()
        }
    }
    GetSID() {
        return this._sid
    }
    IsOrBlock() {
        return this._isOrBlock
    }
    IsTrigger() {
        return this._conditions.length && this._conditions[0].IsTrigger()
    }
    IsForFunctionBlock() {
        return this._scopeParent && this._scopeParent instanceof C3$jscomp$160.FunctionBlock
    }
    HasAnyTriggeredCondition() {
        return this.IsForFunctionBlock() || this._conditions.some(a => a.IsTrigger())
    }
    GetConditions() {
        return this._conditions
    }
    GetConditionCount() {
        return this._conditions.length
    }
    GetConditionAt(a) {
        a = Math.floor(a);
        if (0 > a || a >= this._conditions.length)
            throw new RangeError("invalid condition index");
        return this._conditions[a]
    }
    GetConditionByDebugIndex(a) {
        return this.GetConditionAt(a)
    }
    IsFirstConditionOfType(a) {
        let b = a.GetIndex();
        if (0 === b)
            return !0;
        --b;
        for (a = a.IsSystemOrSingleGlobalCondition() ? a.GetFirstObjectParameterObjectClass() : a.GetObjectClass(); 0 <= b; --b) {
            const c = this._conditions[b];
            if (a === c.GetObjectClass() || c.IsSystemOrSingleGlobalCondition() && c.GetFirstObjectParameterObjectClass() === a)
                return !1
        }
        return !0
    }
    GetActions() {
        return this._actions
    }
    GetActionCount() {
        return this._actions.length
    }
    GetActionAt(a) {
        a = Math.floor(a);
        if (0 > a || a >= this._actions.length)
            throw new RangeError("invalid action index");
        return this._actions[a]
    }
    GetActionByDebugIndex(a) {
        a = Math.floor(a);
        const b = this._actions.find(c => c.GetDebugIndex() === a);
        if (!b)
            throw new RangeError("invalid action debug index");
        return b
    }
    _HasActionIndex(a) {
        a = Math.floor(a);
        return 0 <= a && a < this._actions.length
    }
    GetSubEvents() {
        return this._subEvents
    }
    _GetAllLocalVariablesInScope() {
        return this._subEvents.filter(a => a instanceof C3$jscomp$160.EventVariable)
    }
    RunPreTrigger(a) {
        a.SetCurrentEvent(this);
        const b = this._conditions;
        let c = 0 === b.length;
        for (let d = 0, e = b.length; d < e; ++d) {
            const f = b[d];
            a.SetConditionIndex(d);
            if (f.IsLooping())
                throw Error("trigger cannot be used as sub-event to a loop");
            if (f.Run())
                c = !0;
            else if (!this._isOrBlock)
                return !1
        }
        return this._isOrBlock ? c : !0
    }
    RunOrBlockTrigger(a, b) {
        a.SetCurrentEvent(this);
        a.SetConditionIndex(b);
        this._conditions[b].Run() && (this._RunActions(a, 0) && this._RunSubEvents(a),
        a.SetLastEventTrue(!0))
    }
    *DebugRunPreTrigger(a) {
        a.SetCurrentEvent(this);
        const b = this._conditions;
        let c = 0 === b.length;
        for (let d = 0, e = b.length; d < e; ++d) {
            const f = b[d];
            a.SetConditionIndex(d);
            if (f.IsLooping())
                throw Error("trigger cannot be used as sub-event to a loop");
            if (f.DebugCanRunFast() ? f.Run() : yield*f.DebugRun())
                c = !0;
            else if (!this._isOrBlock)
                return !1
        }
        return this._isOrBlock ? c : !0
    }
    *DebugRunOrBlockTrigger(a, b) {
        a.SetCurrentEvent(this);
        a.SetConditionIndex(b);
        b = this._conditions[b];
        if (b.DebugCanRunFast() ? b.Run() : yield*b.DebugRun())
            (this.DebugCanRunActionsFast() ? this._RunActions(a, 0) : yield*this._DebugRunActions(a, 0)) && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() : yield*this._DebugRunSubEvents()),
            a.SetLastEventTrue(!0)
    }
    Run(a) {
        a.SetCurrentEvent(this);
        this._isElseBlock || a.SetElseBranchRan(!1);
        this._isOrBlock ? this._RunOrBlock(a) : this._RunAndBlock(a)
    }
    *DebugRun(a) {
        if (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        a.SetCurrentEvent(this);
        this._isElseBlock || a.SetElseBranchRan(!1);
        this._isOrBlock ? yield*this._DebugRunOrBlock(a) : yield*this._DebugRunAndBlock(a)
    }
    _RunOrBlock(a) {
        const b = this._conditions;
        let c = 0 === b.length;
        for (let e = 0, f = b.length; e < f; ++e) {
            var d = b[e];
            d.IsTrigger() || (a.SetConditionIndex(e),
            d = d.Run(),
            c = c || d)
        }
        a.SetLastEventTrue(c);
        c && (this._RunActions(a, 0) && this._RunSubEvents(a),
        this._hasElseBlock && a.SetElseBranchRan(!0))
    }
    *_DebugRunOrBlock(a) {
        const b = this._conditions;
        let c = 0 === b.length;
        for (let e = 0, f = b.length; e < f; ++e) {
            var d = b[e];
            d.IsTrigger() || (a.SetConditionIndex(e),
            d = d.DebugCanRunFast() ? d.Run() : yield*d.DebugRun(),
            c = c || d)
        }
        a.SetLastEventTrue(c);
        c && ((this.DebugCanRunActionsFast() ? this._RunActions(a, 0) : yield*this._DebugRunActions(a, 0)) && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() : yield*this._DebugRunSubEvents()),
        this._hasElseBlock && a.SetElseBranchRan(!0))
    }
    _RunAndBlock(a) {
        const b = this._conditions;
        for (let c = 0, d = b.length; c < d; ++c) {
            const e = b[c];
            a.SetConditionIndex(c);
            if (!e.Run()) {
                a.SetLastEventTrue(!1);
                return
            }
        }
        a.SetLastEventTrue(!0);
        this._RunActions(a, 0) && this._RunSubEvents(a);
        a.GetLastEventTrue() && this._hasElseBlock && a.SetElseBranchRan(!0)
    }
    *_DebugRunAndBlock(a) {
        const b = this._conditions;
        for (let c = 0, d = b.length; c < d; ++c) {
            const e = b[c];
            a.SetConditionIndex(c);
            if (e.DebugCanRunFast() ? !e.Run() : !(yield*e.DebugRun())) {
                a.SetLastEventTrue(!1);
                return
            }
        }
        a.SetLastEventTrue(!0);
        (this.DebugCanRunActionsFast() ? this._RunActions(a, 0) : yield*this._DebugRunActions(a, 0)) && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() : yield*this._DebugRunSubEvents());
        a.GetLastEventTrue() && this._hasElseBlock && a.SetElseBranchRan(!0)
    }
    _RunActions_Fast(a, b) {
        const c = this._actions;
        for (let d = b, e = c.length; d < e; ++d)
            b = c[d],
            a.SetActionIndex(d),
            b.Run();
        return !0
    }
    *_DebugRunActions_Fast(a, b) {
        const c = this._actions;
        for (let d = b, e = c.length; d < e; ++d)
            b = c[d],
            a.SetActionIndex(d),
            b.DebugCanRunFast() ? b.Run() : yield*b.DebugRun();
        return !0
    }
    _RunActions_ReturnValue(a, b) {
        const c = this.GetEventSheetManager()
          , d = this._actions;
        for (let e = b, f = d.length; e < f; ++e) {
            b = d[e];
            a.SetActionIndex(e);
            const h = b.Run();
            if (b.CanBailOut() && !0 === h)
                return !1;
            b.IsAsync() && h instanceof Promise && c.AddAsyncActionPromise(h)
        }
        return !0
    }
    *_DebugRunActions_ReturnValue(a, b) {
        const c = this.GetEventSheetManager()
          , d = this._actions;
        for (let e = b, f = d.length; e < f; ++e) {
            b = d[e];
            a.SetActionIndex(e);
            let h;
            h = b.DebugCanRunFast() ? b.Run() : yield*b.DebugRun();
            if (b.CanBailOut() && !0 === h)
                return !1;
            b.IsAsync() && h instanceof Promise && c.AddAsyncActionPromise(h)
        }
        return !0
    }
    _ResumeActionsAndSubEvents(a) {
        this._RunActions(a, a.GetActionIndex()) && this._RunSubEvents()
    }
    *_DebugResumeActionsAndSubEvents(a) {
        if (yield*this._DebugRunActions(a, a.GetActionIndex()))
            yield*this._DebugRunSubEvents()
    }
    _RunSubEvents() {
        if (this._subEvents.length) {
            var a = this.IsGroup() && this._runtime.IsCPUProfiling()
              , b = a ? performance.now() : 0
              , c = this._eventStack
              , d = c.Push(this);
            this._isSolWriterAfterCnds ? this._RunSubEvents_SolWriterAfterCnds(d) : this._RunSubEvents_Fast(d);
            c.Pop();
            a && (this._perfRecord.totalTimeCounter += performance.now() - b)
        }
    }
    _RunSubEvents_SolWriterAfterCnds(a) {
        const b = this._isGroup
          , c = this._isTopLevelGroup
          , d = this.GetEventSheetManager()
          , e = this._subEvents;
        for (let f = 0, h = e.length, l = h - 1; f < h; ++f) {
            const m = e[f]
              , p = m.GetSolModifiers()
              , r = !c || !b && f < l;
            r && d.PushCopySol(p);
            m.Run(a);
            r ? d.PopSol(p) : d.ClearSol(p)
        }
    }
    _RunSubEvents_Fast(a) {
        const b = this._subEvents;
        for (let c = 0, d = b.length; c < d; ++c)
            b[c].Run(a)
    }
    *_DebugRunSubEvents() {
        if (this._subEvents.length) {
            var a = this._eventStack
              , b = a.Push(this);
            this._isSolWriterAfterCnds ? yield*this._DebugRunSubEvents_SolWriterAfterCnds(b) : yield*this._DebugRunSubEvents_Fast(b);
            a.Pop()
        }
    }
    *_DebugRunSubEvents_SolWriterAfterCnds(a) {
        const b = this._isGroup
          , c = this._isTopLevelGroup
          , d = this.GetEventSheetManager()
          , e = this._subEvents;
        for (let f = 0, h = e.length, l = h - 1; f < h; ++f) {
            const m = e[f]
              , p = m.GetSolModifiers()
              , r = !c || !b && f < l;
            r && d.PushCopySol(p);
            yield*m.DebugRun(a);
            r ? d.PopSol(p) : d.ClearSol(p)
        }
    }
    *_DebugRunSubEvents_Fast(a) {
        const b = this._subEvents;
        for (let c = 0, d = b.length; c < d; ++c)
            yield*b[c].DebugRun(a)
    }
    Retrigger(a, b) {
        b.ResetQuick();
        const c = this._conditions;
        if (!this.IsOrBlock())
            for (let d = a.GetConditionIndex() + 1, e = c.length; d < e; ++d)
                if (a = c[d],
                b.SetConditionIndex(d),
                !a.Run())
                    return !1;
        this._RunActions(b, 0) && this._RunSubEvents(b);
        return !0
    }
    *DebugRetrigger(a, b) {
        b.ResetQuick();
        const c = this._conditions;
        if (!this.IsOrBlock())
            for (let d = a.GetConditionIndex() + 1, e = c.length; d < e; ++d)
                if (a = c[d],
                b.SetConditionIndex(d),
                a.DebugCanRunFast() ? !a.Run() : !(yield*a.DebugRun()))
                    return !1;
        (this.DebugCanRunActionsFast() ? this._RunActions(b, 0) : yield*this._DebugRunActions(b, 0)) && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() : yield*this._DebugRunSubEvents());
        return !0
    }
    DebugCanRunFast() {
        return !this.IsDebugBreakpoint() && !this._runtime.DebugBreakNext() && this._debugData.canRunSelfFast
    }
    DebugCanRunActionsFast() {
        return !this._runtime.DebugBreakNext() && this._debugData.canRunAllActionsFast
    }
    DebugCanRunSubEventsFast() {
        return !this._runtime.DebugBreakNext() && this._debugData.canRunAllSubEventsFast
    }
    _CheckParentsOKToRun(a) {
        if (this.GetParent()) {
            const b = this.GetTriggerParents();
            for (let c = 0, d = b.length; c < d; ++c)
                if (!b[c].RunPreTrigger(a))
                    return !1
        }
        return !0
    }
    *_DebugCheckParentsOKToRun(a) {
        if (this.GetParent()) {
            const b = this.GetTriggerParents();
            for (let c = 0, d = b.length; c < d; ++c)
                if (!(yield*b[c].DebugRunPreTrigger(a)))
                    return !1
        }
        return !0
    }
    _EvaluateFunctionCallParameters(a, b, c) {
        0 < b.length ? c ? (b = b.map(d => d.Get(0)),
        a.GetLocalVarStack().Push(),
        this._scopeParent.SetFunctionParameters(b)) : this._scopeParent.EvaluateFunctionParameters(b) : c && a.GetLocalVarStack().Push()
    }
    RunAsFunctionCall(a, b, c, d) {
        let e, f;
        const h = 0 < a.length;
        let l = null;
        const m = this._eventStack
          , p = this._runtime.GetEventSheetManager()
          , r = 1 < p._IncTriggerDepth();
        this._EvaluateFunctionCallParameters(p, b, r);
        h && (c ? p.PushCopySol(a) : p.PushCleanSol(a));
        if (null !== d) {
            if (d.copyFromObjectClass) {
                b = c ? d.copyFromObjectClass.GetCurrentSol() : d.copyFromObjectClass.GetSolStack().GetOneBelowCurrentSol();
                const v = d.copyToObjectClass.GetCurrentSol();
                v.SetArrayPicked(b.GetInstances());
                v.ClearElseInstances();
                c || d.copyToObjectClass.ApplySolToContainer()
            } else
                d.pickObjectClass && (b = d.pickObjectClass.GetCurrentSol(),
                b.SetArrayPicked(d.pickInstances),
                b.ClearElseInstances());
            d.pushCleanSolDynamic && (l = p.PushCleanSolDynamic(a))
        }
        d = m.Push(this);
        c && d.SetDynamicSolModifiers(a);
        this._CheckParentsOKToRun(d) && (d.SetCurrentEvent(this),
        (c = this._scopeParent.IsAsync()) && ([f,e] = this._scopeParent.StartAsyncFunctionCall()),
        this._RunAndBlock(d),
        c && this._scopeParent.MaybeFinishAsyncFunctionCall(f));
        m.Pop();
        r && p.GetLocalVarStack().Pop();
        null !== l && p.PopSol(l);
        h && p.PopSol(a);
        p._DecTriggerDepth();
        return e
    }
    *DebugRunAsFunctionCall(a, b, c, d) {
        let e, f;
        if (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        const h = 0 < a.length;
        let l = null;
        const m = this._eventStack
          , p = this._runtime.GetEventSheetManager()
          , r = 1 < p._IncTriggerDepth();
        this._EvaluateFunctionCallParameters(p, b, r);
        h && (c ? p.PushCopySol(a) : p.PushCleanSol(a));
        if (null !== d) {
            if (d.copyFromObjectClass) {
                b = c ? d.copyFromObjectClass.GetCurrentSol() : d.copyFromObjectClass.GetSolStack().GetOneBelowCurrentSol();
                const v = d.copyToObjectClass.GetCurrentSol();
                v.SetArrayPicked(b.GetInstances());
                v.ClearElseInstances();
                c || d.copyToObjectClass.ApplySolToContainer()
            } else
                d.pickObjectClass && (b = d.pickObjectClass.GetCurrentSol(),
                b.SetArrayPicked(d.pickInstances),
                b.ClearElseInstances());
            d.pushCleanSolDynamic && (l = p.PushCleanSolDynamic(a))
        }
        d = m.Push(this);
        c && d.SetDynamicSolModifiers(a);
        if (yield*this._DebugCheckParentsOKToRun(d))
            d.SetCurrentEvent(this),
            (c = this._scopeParent.IsAsync()) && ([f,e] = this._scopeParent.StartAsyncFunctionCall()),
            yield*this._DebugRunAndBlock(d),
            c && this._scopeParent.MaybeFinishAsyncFunctionCall(f);
        m.Pop();
        r && p.GetLocalVarStack().Pop();
        null !== l && p.PopSol(l);
        h && p.PopSol(a);
        p._DecTriggerDepth();
        return e
    }
    RunAsMappedFunctionCall(a, b) {
        const c = this.GetSolModifiersIncludingParents()
          , d = 0 < c.length
          , e = this._eventStack
          , f = this._runtime.GetEventSheetManager()
          , h = 1 < f._IncTriggerDepth();
        h && f.GetLocalVarStack().Push();
        this._scopeParent.SetFunctionParameters(a);
        d && (b ? f.PushCopySol(c) : f.PushCleanSol(c));
        a = e.Push(this);
        this._CheckParentsOKToRun(a) && (a.SetCurrentEvent(this),
        this._RunAndBlock(a));
        e.Pop();
        h && f.GetLocalVarStack().Pop();
        d && f.PopSol(c);
        f._DecTriggerDepth()
    }
    *DebugRunAsMappedFunctionCall(a, b) {
        if (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        const c = this.GetSolModifiersIncludingParents()
          , d = 0 < c.length
          , e = this._eventStack
          , f = this._runtime.GetEventSheetManager()
          , h = 1 < f._IncTriggerDepth();
        h && f.GetLocalVarStack().Push();
        this._scopeParent.SetFunctionParameters(a);
        d && (b ? f.PushCopySol(c) : f.PushCleanSol(c));
        a = e.Push(this);
        if (yield*this._DebugCheckParentsOKToRun(a))
            a.SetCurrentEvent(this),
            yield*this._DebugRunAndBlock(a);
        e.Pop();
        h && f.GetLocalVarStack().Pop();
        d && f.PopSol(c);
        f._DecTriggerDepth()
    }
    RunAsExpressionFunctionCall(a, b, c, d, ...e) {
        let f, h;
        const l = 0 < a.length
          , m = this._runtime
          , p = this._eventStack
          , r = m.GetEventSheetManager()
          , v = 1 < r._IncTriggerDepth();
        v && r.GetLocalVarStack().Push();
        0 < e.length && this._scopeParent.SetFunctionParameters(e);
        l && (b ? r.PushCopySol(a) : r.PushCleanSol(a));
        b = p.Push(this);
        b.InitCallFunctionExpression(c, d);
        p.PushExpFunc(b);
        m.SetDebuggingEnabled(!1);
        this._CheckParentsOKToRun(b) && (b.SetCurrentEvent(this),
        (c = this._scopeParent.IsAsync()) && ([h,f] = this._scopeParent.StartAsyncFunctionCall()),
        this._RunAndBlock(b),
        c && this._scopeParent.MaybeFinishAsyncFunctionCall(h));
        m.SetDebuggingEnabled(!0);
        p.Pop();
        p.PopExpFunc();
        v && r.GetLocalVarStack().Pop();
        l && r.PopSol(a);
        r._DecTriggerDepth();
        return f || b.GetFunctionReturnValue()
    }
}
;
"use strict";
const C3$jscomp$161 = self.C3
  , EMPTY_SOL_MODIFIERS = [];
let hadUserScriptException = !1;
C3$jscomp$161.EventScript = class extends C3$jscomp$161.DefendedBase {
    constructor(a, b, c) {
        super();
        const d = a.GetRuntime()
          , e = a.GetEventSheetManager();
        this._eventSheet = a;
        this._eventSheetManager = e;
        this._runtime = a.GetRuntime();
        this._parent = b;
        this._func = d.GetObjectReference(c[1]);
        this._displayNumber = c[2];
        this._eventSheet._RegisterEventByDisplayNumber(this, this._displayNumber);
        this._debugData = d.IsDebug() ? {
            isBreakpoint: c[3][0],
            isBreakable: c[3][1]
        } : null
    }
    static Create(a, b, c) {
        return C3$jscomp$161.New(C3$jscomp$161.EventScript, a, b, c)
    }
    _PostInit() {
        const a = this._func
          , b = this._runtime.GetEventSheetManager()._GetLocalVariablesScriptInterface(this);
        this._func = a.bind(null, this._runtime.GetIRuntime(), b)
    }
    GetParent() {
        return this._parent
    }
    GetScopeParent() {
        return this._parent
    }
    GetEventSheet() {
        return this._eventSheet
    }
    GetDisplayNumber() {
        return this._displayNumber
    }
    IsDebugBreakable() {
        return this._debugData && this._debugData.isBreakable
    }
    IsDebugBreakpoint() {
        return this.IsDebugBreakable() && this._debugData.isBreakpoint
    }
    _SetDebugBreakpoint(a) {
        this._debugData.isBreakpoint = !!a
    }
    IsElseBlock() {
        return !1
    }
    GetSolModifiers() {
        return EMPTY_SOL_MODIFIERS
    }
    GetSolModifiersIncludingParents() {
        return this._parent ? this._parent.GetSolModifiersIncludingParents() : EMPTY_SOL_MODIFIERS
    }
    Run(a) {
        a.SetCurrentEvent(this);
        this._eventSheetManager.AddAsyncActionPromise(this._RunUserScript())
    }
    async _RunUserScript() {
        try {
            await this._func()
        } catch (a) {
            console.error(`Unhandled exception running script %c${this.GetEventSheet().GetName()}, event ${this.GetDisplayNumber()}:`, "font-size: 1.2em; font-weight: bold;", a),
            self.C3Debugger && self.C3Debugger._SetLastErrorScript(this),
            hadUserScriptException || (console.info("%cTip:%c run this to highlight in Construct the last script that had an error: %cgoToLastErrorScript()", "font-weight: bold; text-decoration: underline", "", "font-weight: bold"),
            hadUserScriptException = !0)
        }
    }
    *DebugRun(a) {
        a.SetCurrentEvent(this);
        if (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        this.Run(a)
    }
    DebugCanRunFast() {
        return !this.IsDebugBreakpoint() && !this._runtime.DebugBreakNext()
    }
    static HadUserScriptException() {
        return hadUserScriptException
    }
    static SetHadUserScriptException() {
        hadUserScriptException = !0
    }
}
;
"use strict";
const C3$jscomp$162 = self.C3;
C3$jscomp$162.FunctionBlock = class extends C3$jscomp$162.DefendedBase {
    constructor(a, b, c) {
        super();
        this._eventSheet = a;
        this._runtime = a.GetRuntime();
        this._parent = b;
        this._functionType = 0;
        this._functionName = "";
        this._returnType = 0;
        this._functionParameters = [];
        this._isEnabled = !0;
        this._aceName = "";
        this._objectClass = null;
        this._hasOverrides = !1;
        this._innerLocalVariables = [];
        this._isAsync = this._isCopyPicked = !1;
        this._nextAsyncId = 0;
        this._currentAsyncId = -1;
        this._asyncMap = new Map;
        this._eventBlock = C3$jscomp$162.EventBlock.Create(a, b, c);
        this._eventBlock._SetScopeParent(this)
    }
    InitFunctionBlock(a) {
        this._functionType = 0;
        this._functionName = a[0];
        this._returnType = a[1];
        this._functionParameters = a[2].map(b => C3$jscomp$162.EventVariable.Create(this._eventSheet, this, b));
        this._isEnabled = a[3];
        this._isAsync = a[4];
        this._isCopyPicked = a[5]
    }
    InitCustomACEBlock(a) {
        this._functionType = 1;
        this._aceName = a[1];
        this._objectClass = this._runtime.GetObjectClassByIndex(a[2]);
        this._eventBlock._AddSolModifier(this._objectClass);
        this._functionName = this._objectClass.GetName() + "." + this._aceName;
        this._returnType = a[3];
        this._functionParameters = a[4].map(b => C3$jscomp$162.EventVariable.Create(this._eventSheet, this, b));
        this._isEnabled = a[5];
        this._isAsync = a[6];
        this._isCopyPicked = a[7];
        this._objectClass.AddCustomAction(this)
    }
    static CreateFunctionBlock(a, b, c) {
        a = C3$jscomp$162.New(C3$jscomp$162.FunctionBlock, a, b, c);
        a.InitFunctionBlock(c[1]);
        return a
    }
    static CreateCustomACEBlock(a, b, c) {
        a = C3$jscomp$162.New(C3$jscomp$162.FunctionBlock, a, b, c);
        a.InitCustomACEBlock(c[1]);
        return a
    }
    _CheckOverrideState() {
        if (this._objectClass && this._objectClass.IsFamily())
            for (const a of this._objectClass.GetFamilyMembers())
                if (a.HasOwnCustomActionByName(this._aceName)) {
                    this._hasOverrides = !0;
                    break
                }
    }
    _PostInit() {
        for (const a of this._functionParameters)
            a._PostInit();
        this._eventBlock._PostInit(!1)
    }
    GetFunctionType() {
        return this._functionType
    }
    _GetAllLocalVariablesInScope() {
        return this._functionParameters
    }
    GetFunctionParameters() {
        return this._functionParameters
    }
    GetFunctionParameterCount() {
        return this._functionParameters.length
    }
    _RegisterLocalVariable(a) {
        this._innerLocalVariables.push(a)
    }
    _GetAllInnerLocalVariables() {
        return this._innerLocalVariables
    }
    EvaluateFunctionParameters(a) {
        const b = this._functionParameters;
        for (let c = 0, d = b.length; c < d; ++c)
            b[c].SetValue(a[c].Get(0))
    }
    SetFunctionParameters(a) {
        const b = this._functionParameters;
        for (let c = 0, d = b.length; c < d; ++c)
            b[c].SetValue(a[c])
    }
    CaptureFunctionParameters() {
        return this._functionParameters.map(a => a.GetValue())
    }
    GetParent() {
        return this._parent
    }
    GetScopeParent() {
        return this._parent
    }
    GetFunctionName() {
        return this._functionName
    }
    GetACEName() {
        return this._aceName
    }
    HasCustomACEOverrides() {
        return this._hasOverrides
    }
    GetReturnType() {
        return this._returnType
    }
    GetObjectClass() {
        return this._objectClass
    }
    IsEnabled() {
        return this._isEnabled
    }
    GetDefaultReturnValue() {
        switch (this._returnType) {
        case 0:
            return null;
        case 2:
            return "";
        default:
            return 0
        }
    }
    GetEventBlock() {
        return this._eventBlock
    }
    IsCopyPicked() {
        return this._isCopyPicked
    }
    IsAsync() {
        return this._isAsync
    }
    StartAsyncFunctionCall() {
        const a = this._nextAsyncId++;
        this._currentAsyncId = a;
        let b;
        const c = new Promise(d => b = d);
        this._asyncMap.set(a, {
            resolve: b,
            pauseCount: 0
        });
        return [a, c]
    }
    MaybeFinishAsyncFunctionCall(a) {
        const b = this._asyncMap.get(a);
        0 === b.pauseCount && (b.resolve(),
        this._asyncMap.delete(a));
        this._currentAsyncId = -1
    }
    PauseCurrentAsyncFunction() {
        this._asyncMap.get(this._currentAsyncId).pauseCount++;
        return this._currentAsyncId
    }
    ResumeAsyncFunction(a) {
        this._currentAsyncId = a;
        this._asyncMap.get(a).pauseCount--
    }
    RunAsFamilyCustomActionWithOverrides(a, b) {
        var c = new Map
          , d = [];
        for (const e of this._objectClass.GetCurrentSol().GetInstances()) {
            const f = e.GetObjectClass();
            if (f.HasOwnCustomActionByName(this._aceName)) {
                const h = c.get(f);
                Array.isArray(h) ? h.push(e) : c.set(f, [e])
            } else
                d.push(e)
        }
        0 < d.length && this._eventBlock.RunAsFunctionCall(a, b, this._isCopyPicked, {
            pickObjectClass: this._objectClass,
            pickInstances: d
        });
        if (0 < c.size)
            for (const [e,f] of c)
                c = e.GetOwnCustomActionByName(this._aceName).GetEventBlock(),
                d = [...(new Set([...a, ...c.GetSolModifiers()]))],
                c.RunAsFunctionCall(d, b, this._isCopyPicked, {
                    pickObjectClass: e,
                    pickInstances: f
                })
    }
    *DebugRunAsFamilyCustomActionWithOverrides(a, b) {
        var c = new Map
          , d = [];
        for (const e of this._objectClass.GetCurrentSol().GetInstances()) {
            const f = e.GetObjectClass();
            if (f.HasOwnCustomActionByName(this._aceName)) {
                const h = c.get(f);
                Array.isArray(h) ? h.push(e) : c.set(f, [e])
            } else
                d.push(e)
        }
        0 < d.length && (yield*this._eventBlock.DebugRunAsFunctionCall(a, b, this._isCopyPicked, {
            pickObjectClass: this._objectClass,
            pickInstances: d
        }));
        if (0 < c.size)
            for (const [e,f] of c)
                c = e.GetOwnCustomActionByName(this._aceName).GetEventBlock(),
                d = [...(new Set([...a, ...c.GetSolModifiers()]))],
                yield*c.DebugRunAsFunctionCall(d, b, this._isCopyPicked, {
                    pickObjectClass: e,
                    pickInstances: f
                })
    }
}
;
"use strict";
const C3$jscomp$163 = self.C3
  , EMPTY_SOL_MODIFIERS$jscomp$1 = [];
C3$jscomp$163.EventVariable = class extends C3$jscomp$163.DefendedBase {
    constructor(a, b, c) {
        super();
        const d = a.GetEventSheetManager();
        this._eventSheet = a;
        this._eventSheetManager = d;
        this._runtime = a.GetRuntime();
        this._parent = b;
        this._localVarStack = d.GetLocalVarStack();
        this._name = c[1];
        this._type = c[2];
        this._initialValue = c[3];
        this._isStatic = !!c[4];
        this._isConstant = !!c[5];
        this._isFunctionParameter = b instanceof C3$jscomp$163.FunctionBlock;
        this._sid = c[6];
        this._jsPropName = this._runtime.GetJsPropName(c[8]);
        this._scriptSetter = e => this.SetValue(e);
        this._scriptGetter = () => this.GetValue();
        this._hasSingleValue = !this._parent || this._isStatic || this._isConstant;
        this._value = this._initialValue;
        this._localIndex = -1;
        this.IsBoolean() && (this._value = this._value ? 1 : 0);
        !this.IsLocal() || this.IsStatic() || this.IsConstant() || (this._localIndex = d._GetNextLocalVarIndex(this));
        d._RegisterEventVariable(this)
    }
    static Create(a, b, c) {
        return C3$jscomp$163.New(C3$jscomp$163.EventVariable, a, b, c)
    }
    _PostInit() {
        if (this.IsLocal() && !this.IsStatic() && !this.IsConstant() && !this.IsFunctionParameter()) {
            const a = this._eventSheetManager.FindFirstFunctionBlockParent(this);
            a && a._RegisterLocalVariable(this)
        }
    }
    GetName() {
        return this._name
    }
    GetJsPropName() {
        return this._jsPropName
    }
    GetParent() {
        return this._parent
    }
    GetScopeParent() {
        return this.GetParent()
    }
    IsGlobal() {
        return !this.GetParent()
    }
    IsLocal() {
        return !this.IsGlobal()
    }
    IsFunctionParameter() {
        return this._isFunctionParameter
    }
    IsStatic() {
        return this._isStatic
    }
    IsConstant() {
        return this._isConstant
    }
    IsNumber() {
        return 0 === this._type
    }
    IsString() {
        return 1 === this._type
    }
    IsBoolean() {
        return 2 === this._type
    }
    IsElseBlock() {
        return !1
    }
    GetSID() {
        return this._sid
    }
    GetInitialValue() {
        return this._initialValue
    }
    GetSolModifiers() {
        return EMPTY_SOL_MODIFIERS$jscomp$1
    }
    Run(a) {
        !this.IsLocal() || this.IsStatic() || this.IsConstant() || this.SetValue(this.GetInitialValue())
    }
    DebugCanRunFast() {
        return !0
    }
    *DebugRun(a) {
        this.Run(a)
    }
    SetValue(a) {
        this.IsNumber() ? "number" !== typeof a && (a = parseFloat(a)) : this.IsString() ? "string" !== typeof a && (a = a.toString()) : this.IsBoolean() && (a = a ? 1 : 0);
        this._hasSingleValue ? this._value = a : this._localVarStack.GetCurrent()[this._localIndex] = a
    }
    GetValue() {
        return this._hasSingleValue ? this._value : this._localVarStack.GetCurrent()[this._localIndex]
    }
    GetTypedValue() {
        let a = this.GetValue();
        this.IsBoolean() && (a = !!a);
        return a
    }
    ResetToInitialValue() {
        this._value = this._initialValue
    }
    _GetScriptInterfaceDescriptor() {
        return {
            configurable: !1,
            enumerable: !0,
            get: this._scriptGetter,
            set: this._scriptSetter
        }
    }
}
;
"use strict";
const C3$jscomp$164 = self.C3
  , EMPTY_SOL_MODIFIERS$jscomp$2 = [];
C3$jscomp$164.EventInclude = class extends C3$jscomp$164.DefendedBase {
    constructor(a, b, c) {
        super();
        const d = a.GetEventSheetManager();
        this._eventSheet = a;
        this._eventSheetManager = d;
        this._runtime = a.GetRuntime();
        this._parent = b;
        this._includeSheet = null;
        this._includeSheetName = c[1];
        this._isActive = !0
    }
    static Create(a, b, c) {
        return C3$jscomp$164.New(C3$jscomp$164.EventInclude, a, b, c)
    }
    _PostInit() {
        this._includeSheet = this._eventSheetManager.GetEventSheetByName(this._includeSheetName);
        this._eventSheet._AddShallowInclude(this);
        let a = this.GetParent();
        for (; a; )
            a instanceof C3$jscomp$164.EventBlock && a.IsGroup() && a._AddContainedInclude(this),
            a = a.GetParent();
        this.UpdateActive();
        this._runtime.IsDebug() && this._eventSheet._GetPerfRecord().children.push(this._includeSheet._GetPerfRecord())
    }
    GetParent() {
        return this._parent
    }
    GetSolModifiers() {
        return EMPTY_SOL_MODIFIERS$jscomp$2
    }
    GetIncludeSheet() {
        return this._includeSheet
    }
    Run(a) {
        a = !!this.GetParent();
        const b = this._runtime.GetAllObjectClasses();
        a && this._eventSheetManager.PushCleanSol(b);
        this._includeSheet.Run();
        a && this._eventSheetManager.PopSol(b)
    }
    *DebugRun(a) {
        a = !!this.GetParent();
        const b = this._runtime.GetAllObjectClasses();
        a && this._eventSheetManager.PushCleanSol(b);
        yield*this._includeSheet.DebugRun();
        a && this._eventSheetManager.PopSol(b)
    }
    DebugCanRunFast() {
        return !1
    }
    IsActive() {
        return this._isActive
    }
    UpdateActive() {
        let a = this.GetParent();
        for (; a; ) {
            if (a instanceof C3$jscomp$164.EventBlock && a.IsGroup() && !a.IsGroupActive()) {
                this._isActive = !1;
                return
            }
            a = a.GetParent()
        }
        this._isActive = !0
    }
}
;
"use strict";
const C3$jscomp$165 = self.C3;
C3$jscomp$165.ExpNode = class extends C3$jscomp$165.DefendedBase {
    constructor(a) {
        super();
        this._owner = a;
        this._runtime = a.GetRuntime()
    }
    _PostInit() {}
    static CreateNode(a, b) {
        return C3$jscomp$165.New([BehaviorExpressionNode, ObjectExpressionNode, InstVarExpressionNode, EventVarExpNode, SystemExpressionExpNode, CallFunctionExpressionExpNode][b[0]], a, b)
    }
}
;
class SystemExpressionExpNode extends C3$jscomp$165.ExpNode {
    constructor(a, b) {
        super(a);
        this._systemPlugin = this._runtime.GetSystemPlugin();
        this._func = this._runtime.GetObjectReference(b[1]);
        this._func !== C3$jscomp$165.Plugins.System.Exps.random && this._func !== C3$jscomp$165.Plugins.System.Exps.choose || this._owner.SetVariesPerInstance()
    }
    GetBoundMethod() {
        return this._systemPlugin._GetBoundACEMethod(this._func, this._systemPlugin)
    }
}
class CallFunctionExpressionExpNode extends C3$jscomp$165.ExpNode {
    constructor(a, b) {
        super(a);
        this._functionBlock = null;
        this._functionName = b[1];
        this._owner.SetVariesPerInstance()
    }
    _PostInit() {
        const a = this._runtime.GetEventSheetManager();
        this._functionBlock = a.GetFunctionBlockByName(this._functionName);
        this._functionName = null;
        const b = this._owner.GetEventBlock()
          , c = this._functionBlock.GetEventBlock();
        this._combinedSolModifiers = [...(new Set([...b.GetSolModifiersIncludingParents(), ...c.GetSolModifiersIncludingParents()]))];
        this._combinedSolModifiers = a._DeduplicateSolModifierList(this._combinedSolModifiers)
    }
    GetBoundMethod() {
        const a = this._functionBlock;
        if (a.IsEnabled()) {
            const c = a.GetEventBlock();
            return C3$jscomp$165.EventBlock.prototype.RunAsExpressionFunctionCall.bind(c, this._combinedSolModifiers, a.IsCopyPicked(), a.GetReturnType(), a.GetDefaultReturnValue())
        }
        const b = a.GetDefaultReturnValue();
        return () => b
    }
}
function WrapIndex(a, b) {
    if (a >= b)
        return a % b;
    0 > a && (a <= -b && (a %= b),
    0 > a && (a += b));
    return a
}
class ObjectExpressionNode extends C3$jscomp$165.ExpNode {
    constructor(a, b) {
        super(a);
        this._objectClass = this._runtime.GetObjectClassByIndex(b[1]);
        this._func = this._runtime.GetObjectReference(b[2]);
        this._returnsString = !!b[3];
        this._eventStack = this._runtime.GetEventSheetManager().GetEventStack();
        this._owner._MaybeVaryFor(this._objectClass)
    }
    GetBoundMethod() {
        return this._objectClass.GetPlugin()._GetBoundACEMethod(this._func, this._objectClass.GetSingleGlobalInstance().GetSdkInstance())
    }
    ExpObject(...a) {
        const b = this._objectClass
          , c = b.GetCurrentSol().GetExpressionInstances();
        var d = c.length;
        if (0 === d)
            return this._returnsString ? "" : 0;
        d = WrapIndex(this._owner.GetSolIndex(), d);
        this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(b);
        return this._func.apply(c[d].GetSdkInstance(), a)
    }
    ExpObject_InstExpr(a, ...b) {
        const c = this._objectClass
          , d = c.GetInstances()
          , e = d.length;
        if (0 === e)
            return this._returnsString ? "" : 0;
        a = WrapIndex(a, e);
        this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(c);
        return this._func.apply(d[a].GetSdkInstance(), b)
    }
}
class InstVarExpressionNode extends C3$jscomp$165.ExpNode {
    constructor(a, b) {
        super(a);
        this._objectClass = this._runtime.GetObjectClassByIndex(b[1]);
        this._varIndex = b[3];
        this._returnsString = !!b[2];
        this._owner._MaybeVaryFor(this._objectClass)
    }
    ExpInstVar() {
        const a = this._objectClass.GetCurrentSol().GetExpressionInstances();
        var b = a.length;
        if (0 === b)
            return this._returnsString ? "" : 0;
        b = WrapIndex(this._owner.GetSolIndex(), b);
        return a[b]._GetInstanceVariableValueUnchecked(this._varIndex)
    }
    ExpInstVar_Family() {
        var a = this._objectClass
          , b = a.GetCurrentSol().GetExpressionInstances()
          , c = b.length;
        if (0 === c)
            return this._returnsString ? "" : 0;
        c = WrapIndex(this._owner.GetSolIndex(), c);
        b = b[c];
        a = b.GetObjectClass().GetFamilyInstanceVariableOffset(a.GetFamilyIndex());
        return b._GetInstanceVariableValueUnchecked(this._varIndex + a)
    }
    ExpInstVar_InstExpr(a) {
        const b = this._objectClass;
        var c = b.GetInstances();
        const d = c.length;
        if (0 === d)
            return this._returnsString ? "" : 0;
        a = WrapIndex(a, d);
        c = c[a];
        a = 0;
        b.IsFamily() && (a = c.GetObjectClass().GetFamilyInstanceVariableOffset(b.GetFamilyIndex()));
        return c._GetInstanceVariableValueUnchecked(this._varIndex + a)
    }
}
class BehaviorExpressionNode extends C3$jscomp$165.ExpNode {
    constructor(a, b) {
        super(a);
        this._objectClass = this._runtime.GetObjectClassByIndex(b[1]);
        this._behaviorType = this._objectClass.GetBehaviorTypeByName(b[2]);
        this._behaviorIndex = this._objectClass.GetBehaviorIndexByName(b[2]);
        this._func = this._runtime.GetObjectReference(b[3]);
        this._returnsString = !!b[4];
        this._eventStack = this._runtime.GetEventSheetManager().GetEventStack();
        this._owner._MaybeVaryFor(this._objectClass)
    }
    ExpBehavior(...a) {
        const b = this._objectClass;
        var c = b.GetCurrentSol().GetExpressionInstances()
          , d = c.length;
        if (0 === d)
            return this._returnsString ? "" : 0;
        d = WrapIndex(this._owner.GetSolIndex(), d);
        this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(b);
        c = c[d];
        d = 0;
        b.IsFamily() && (d = c.GetObjectClass().GetFamilyBehaviorOffset(b.GetFamilyIndex()));
        return this._func.apply(c.GetBehaviorInstances()[this._behaviorIndex + d].GetSdkInstance(), a)
    }
    ExpBehavior_InstExpr(a, ...b) {
        const c = this._objectClass;
        var d = c.GetInstances();
        const e = d.length;
        if (0 === e)
            return this._returnsString ? "" : 0;
        a = WrapIndex(a, e);
        this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(c);
        d = d[a];
        a = 0;
        c.IsFamily() && (a = d.GetObjectClass().GetFamilyBehaviorOffset(c.GetFamilyIndex()));
        return this._func.apply(d.GetBehaviorInstances()[this._behaviorIndex + a].GetSdkInstance(), b)
    }
}
class EventVarExpNode extends C3$jscomp$165.ExpNode {
    constructor(a, b) {
        super(a);
        this._eventVar = null;
        this._eventVarSid = b[1]
    }
    _PostInit() {
        this._eventVar = this._runtime.GetEventSheetManager().GetEventVariableBySID(this._eventVarSid)
    }
    GetVar() {
        return this._eventVar
    }
}
"use strict";
const C3$jscomp$166 = self.C3;
C3$jscomp$166.Parameter = class extends C3$jscomp$166.DefendedBase {
    constructor(a, b, c) {
        super();
        this._owner = a;
        this._index = c;
        this._type = b;
        this.Get = null;
        this._isConstant = this._variesPerInstance = !1
    }
    static Create(a, b, c) {
        const d = b[0];
        return C3$jscomp$166.New([ExpressionParameter, StringExpressionParameter, FileParameter, ComboParameter, ObjectParameter, LayerExpressionParameter, LayoutParameter, ExpressionParameter, ComboParameter, ComboParameter, InstVarParameter, EventVarParameter, FileParameter, VariadicParameter, StringExpressionParameter, TimelineParameter, BooleanParameter, FunctionParameter, EaseParameter, TilemapBrushParameter, TemplateExpressionParameter, FlowchartParameter][d], a, d, c, b)
    }
    _PostInit() {}
    SetVariesPerInstance() {
        this._variesPerInstance = !0
    }
    _MaybeVaryFor(a) {
        this._variesPerInstance || !a || a.GetPlugin().IsSingleGlobal() || (this._variesPerInstance = !0)
    }
    VariesPerInstance() {
        return this._variesPerInstance
    }
    GetIndex() {
        return this._index
    }
    GetRuntime() {
        return this._owner.GetRuntime()
    }
    GetEventBlock() {
        return this._owner.GetEventBlock()
    }
    IsConstant() {
        return this._isConstant
    }
    IsObjectParameter() {
        return 4 === this._type
    }
}
;
function GetExpressionFunc(a) {
    a = self.C3_ExpressionFuncs[a];
    if (!a)
        throw Error("invalid expression number");
    return a
}
class ExpressionParameter extends C3$jscomp$166.Parameter {
    constructor(a, b, c, d) {
        super(a, b, c);
        this._solIndex = 0;
        a = d[1];
        this._expressionNumber = a[0];
        this._numberedNodes = [];
        this._expressionFunc = null;
        for (let e = 1, f = a.length; e < f; ++e)
            this._numberedNodes.push(C3$jscomp$166.ExpNode.CreateNode(this, a[e]));
        this._numberedNodes.length ? this.Get = this.GetExpression : (this.Get = GetExpressionFunc(this._expressionNumber),
        this._isConstant = !0)
    }
    _GetNode(a) {
        if (0 > a || a >= this._numberedNodes.length)
            throw new RangeError("invalid numbered node");
        return this._numberedNodes[a]
    }
    _PostInit() {
        for (var a of this._numberedNodes)
            a._PostInit();
        a = GetExpressionFunc(this._expressionNumber);
        this._expressionFunc = this._numberedNodes.length ? a(this) : a
    }
    GetSolIndex() {
        return this._solIndex
    }
    GetExpression(a) {
        this._solIndex = a;
        return this._expressionFunc()
    }
}
class StringExpressionParameter extends ExpressionParameter {
    constructor(a, b, c, d) {
        super(a, b, c, d);
        this.Get = this.GetStringExpression;
        14 === b && (this.GetEventBlock().SetAllSolModifiers(),
        this._owner instanceof C3$jscomp$166.Action && this.GetEventBlock().SetSolWriterAfterCnds())
    }
    GetStringExpression(a) {
        this._solIndex = a;
        a = this._expressionFunc();
        return "string" === typeof a ? a : ""
    }
    _GetFastTriggerValue() {
        return GetExpressionFunc(this._expressionNumber)()
    }
}
class LayerExpressionParameter extends ExpressionParameter {
    constructor(a, b, c, d) {
        super(a, b, c, d);
        2 <= a.GetImplementationSdkVersion() ? this.Get = this.GetILayer : this.Get = this.GetLayer;
        this._isConstant = !1
    }
    GetLayer(a) {
        this._solIndex = a;
        a = this._expressionFunc();
        return this.GetRuntime().GetCurrentLayout().GetLayer(a)
    }
    GetILayer(a) {
        return (a = this.GetLayer()) ? a.GetILayer() : null
    }
}
class ComboParameter extends C3$jscomp$166.Parameter {
    constructor(a, b, c, d) {
        super(a, b, c);
        this._combo = d[1];
        this.Get = this.GetCombo;
        this._isConstant = !0
    }
    GetCombo() {
        return this._combo
    }
}
class BooleanParameter extends C3$jscomp$166.Parameter {
    constructor(a, b, c, d) {
        super(a, b, c);
        this._bool = d[1];
        this.Get = this.GetBoolean;
        this._isConstant = !0
    }
    GetBoolean() {
        return this._bool
    }
}
class ObjectParameter extends C3$jscomp$166.Parameter {
    constructor(a, b, c, d) {
        super(a, b, c);
        this._objectClass = this.GetRuntime().GetObjectClassByIndex(d[1]);
        2 <= a.GetImplementationSdkVersion() ? this.Get = this.GetIObjectClass : this.Get = this.GetObjectClass;
        a = this.GetEventBlock();
        a._AddSolModifier(this._objectClass);
        this._owner instanceof C3$jscomp$166.Action ? a.SetSolWriterAfterCnds() : a.GetParent() && a.GetParent().SetSolWriterAfterCnds();
        this._isConstant = !0
    }
    GetObjectClass() {
        return this._objectClass
    }
    GetIObjectClass() {
        return this._objectClass ? this._objectClass.GetIObjectClass() : null
    }
}
class LayoutParameter extends C3$jscomp$166.Parameter {
    constructor(a, b, c, d) {
        super(a, b, c);
        this._layout = this.GetRuntime().GetLayoutManager().GetLayoutByName(d[1]);
        2 <= a.GetImplementationSdkVersion() ? this.Get = this.GetILayout : this.Get = this.GetLayout;
        this._isConstant = !0
    }
    GetLayout() {
        return this._layout
    }
    GetILayout() {
        return this._layout ? this._layout.GetILayout() : null
    }
}
class TimelineParameter extends C3$jscomp$166.Parameter {
    constructor(a, b, c, d) {
        super(a, b, c);
        this._timeline = this.GetRuntime().GetTimelineManager().GetTimelineByName(d[1]);
        2 <= a.GetImplementationSdkVersion() ? this.Get = this.GetITimelineState : this.Get = this.GetTimeline;
        this._isConstant = !0
    }
    GetTimeline() {
        return this._timeline
    }
    GetITimelineState() {
        return this._timeline ? this._timeline.GetITimelineState() : null
    }
}
class FileParameter extends C3$jscomp$166.Parameter {
    constructor(a, b, c, d) {
        super(a, b, c);
        this._fileInfo = d[1];
        this.Get = this.GetFile;
        this._isConstant = !0
    }
    GetFile() {
        return this._fileInfo
    }
}
class InstVarParameter extends C3$jscomp$166.Parameter {
    constructor(a, b, c, d) {
        super(a, b, c);
        this._instVarIndex = d[1];
        a = this._owner.GetObjectClass();
        this._owner instanceof C3$jscomp$166.Condition && this._owner.IsStatic() ? (this.Get = this.GetInstanceVariable,
        this._isConstant = !0) : a && a.IsFamily() ? (this.Get = this.GetFamilyInstanceVariable,
        this.SetVariesPerInstance()) : (this.Get = this.GetInstanceVariable,
        this._isConstant = !0)
    }
    GetInstanceVariable() {
        return this._instVarIndex
    }
    GetFamilyInstanceVariable(a) {
        a = a || 0;
        const b = this._owner.GetObjectClass();
        var c = b.GetCurrentSol();
        const d = c.GetInstances();
        if (d.length)
            a = d[a % d.length].GetObjectClass();
        else if (c.HasAnyElseInstances())
            c = c.GetElseInstances(),
            a = c[a % c.length].GetObjectClass();
        else if (0 < b.GetInstanceCount())
            c = b.GetInstances(),
            a = c[a % c.length].GetObjectClass();
        else
            return 0;
        return this._instVarIndex + a.GetFamilyInstanceVariableOffset(b.GetFamilyIndex())
    }
}
class EventVarParameter extends C3$jscomp$166.Parameter {
    constructor(a, b, c, d) {
        super(a, b, c);
        this._eventVarSid = d[1];
        this._eventVar = null;
        2 <= a.GetImplementationSdkVersion() ? this.Get = this.GetIEventVariable : this.Get = this.GetEventVariable;
        this._isConstant = !0
    }
    _PostInit() {
        this._eventVar = this.GetRuntime().GetEventSheetManager().GetEventVariableBySID(this._eventVarSid)
    }
    GetEventVariable() {
        return this._eventVar
    }
    GetIEventVariable() {
        return null
    }
}
class FunctionParameter extends C3$jscomp$166.Parameter {
    constructor(a, b, c, d) {
        super(a, b, c);
        this._functionBlockName = d[1];
        this._functionBlock = null;
        2 <= a.GetImplementationSdkVersion() ? this.Get = this.GetIFunction : this.Get = this.GetFunction;
        this._isConstant = !0
    }
    _PostInit() {
        this._functionBlock = this.GetRuntime().GetEventSheetManager().GetFunctionBlockByName(this._functionBlockName);
        this._functionBlockName = null
    }
    GetFunction() {
        return this._functionBlock
    }
    GetIFunction() {
        return null
    }
}
class VariadicParameter extends C3$jscomp$166.Parameter {
    constructor(a, b, c, d) {
        super(a, b, c);
        this._subParams = [];
        this._variadicRet = [];
        this._isConstant = !0;
        for (let e = 1, f = d.length; e < f; ++e)
            a = C3$jscomp$166.Parameter.Create(this._owner, d[e], 0),
            this._subParams.push(a),
            this._variadicRet.push(0),
            a.IsConstant() || (this._isConstant = !1);
        this.Get = this.GetVariadic
    }
    _PostInit() {
        for (const a of this._subParams)
            a._PostInit()
    }
    GetVariadic() {
        const a = this._subParams
          , b = this._variadicRet;
        for (let c = 0, d = a.length; c < d; ++c)
            b[c] = a[c].Get(0);
        return b
    }
}
class EaseParameter extends C3$jscomp$166.Parameter {
    constructor(a, b, c, d) {
        super(a, b, c);
        this._easeIndex = d[1];
        this.Get = this.GetEase;
        this._isConstant = !0
    }
    GetEase() {
        return this._easeIndex
    }
}
class TilemapBrushParameter extends C3$jscomp$166.Parameter {
    constructor(a, b, c, d) {
        super(a, b, c);
        this._brushIndex = d[1];
        this.Get = this.GetTilemapBrush;
        this._isConstant = !0
    }
    GetTilemapBrush() {
        return this._brushIndex
    }
}
class TemplateExpressionParameter extends ExpressionParameter {
    constructor(a, b, c, d) {
        super(a, b, c, d);
        this.Get = this.GetTemplateName;
        this._isConstant = !1
    }
    GetTemplateName() {
        return this._expressionFunc()
    }
}
class FlowchartParameter extends C3$jscomp$166.Parameter {
    constructor(a, b, c, d) {
        super(a, b, c);
        this._flowchartDataItem = this.GetRuntime().GetFlowchartManager().GetFlowchartDataItemByName(d[1]);
        this.Get = this.GetFlowchartName;
        this._isConstant = !0
    }
    GetFlowchartName() {
        return this._flowchartDataItem.GetName()
    }
}
"use strict";
const C3$jscomp$167 = self.C3;
function EvalParams(a, b) {
    for (let c = 0, d = a.length; c < d; ++c)
        b[c] = a[c].Get(0)
}
const EMPTY_PARAMS_ARRAY = []
  , noop$jscomp$1 = function() {};
C3$jscomp$167.Condition = class extends C3$jscomp$167.DefendedBase {
    constructor(a, b, c) {
        super();
        this._eventBlock = a;
        this._runtime = a.GetRuntime();
        this._index = c;
        this._func = this._runtime.GetObjectReference(b[1]);
        this._isTrigger = 0 < b[3];
        this._isFastTrigger = 2 === b[3];
        this._isLooping = !!b[4];
        this._isInverted = !!b[5];
        this._isStatic = !!b[6];
        this._sid = b[7];
        this._isInOrBlock = this._eventBlock.IsOrBlock();
        this._behaviorType = this._objectClass = null;
        this._behaviorIndex = -1;
        this._systemPlugin = null;
        this.DebugRun = this.Run = noop$jscomp$1;
        this._parameters = [];
        this._results = [];
        this._anyParamVariesPerInstance = !1;
        this._unsavedData = this._savedData = null;
        this._debugData = this._runtime.IsDebug() ? {
            isBreakpoint: b[8][0],
            canDebug: b[8][1]
        } : null;
        -1 === b[0] ? this._systemPlugin = this._runtime.GetSystemPlugin() : (this._objectClass = this._runtime.GetObjectClassByIndex(b[0]),
        b[2] && (this._behaviorType = this._objectClass.GetBehaviorTypeByName(b[2]),
        this._behaviorIndex = this._objectClass.GetBehaviorIndexByName(b[2])),
        this._eventBlock.GetParent() && this._eventBlock.GetParent().SetSolWriterAfterCnds());
        if (10 === b.length) {
            a = b[9];
            for (let d of a)
                this._parameters.push(C3$jscomp$167.Parameter.Create(this, d, this._parameters.length)),
                this._results.push(0)
        }
        0 === this._parameters.length && (this._results = this._parameters = EMPTY_PARAMS_ARRAY);
        this._eventBlock.GetEventSheetManager()._RegisterCondition(this)
    }
    static Create(a, b, c) {
        return C3$jscomp$167.New(C3$jscomp$167.Condition, a, b, c)
    }
    _PostInit() {
        for (const a of this._parameters)
            a._PostInit(),
            a.VariesPerInstance() && (this._anyParamVariesPerInstance = !0);
        this._isFastTrigger ? (this.Run = this._RunFastTrigger,
        this.DebugRun = this._DebugRunFastTrigger) : this._systemPlugin ? (this._SetSystemRunMethod(),
        this.DebugRun = this._DebugRunSystem) : this._objectClass.GetPlugin().IsSingleGlobal() ? (this._SetSingleGlobalRunMethod(),
        this.DebugRun = this._DebugRunSingleGlobal) : this._isStatic ? (this.Run = this._RunStatic,
        this.DebugRun = this._DebugRunStatic) : (this.Run = this._RunObject,
        this.DebugRun = this._DebugRunObject)
    }
    _SetSystemRunMethod() {
        this._SetRunMethodForBoundFunc(this._systemPlugin, this._systemPlugin, this._RunSystem)
    }
    _SetSingleGlobalRunMethod() {
        const a = this._objectClass.GetPlugin()
          , b = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();
        this._SetRunMethodForBoundFunc(a, b, this._RunSingleGlobal)
    }
    _SetRunMethodForBoundFunc(a, b, c) {
        const d = this._func
          , e = this._isInverted
          , f = this._parameters;
        if (0 === f.length) {
            const h = a._GetBoundACEMethod(d, b);
            this.Run = e ? function() {
                return C3$jscomp$167.xor(h(), e)
            }
            : h
        } else if (1 === f.length) {
            const h = f[0];
            if (!e && h.IsConstant())
                this.Run = a._GetBoundACEMethod_1param(d, b, h.Get(0));
            else {
                const l = a._GetBoundACEMethod(d, b);
                this.Run = function() {
                    return C3$jscomp$167.xor(l(h.Get(0)), e)
                }
            }
        } else if (2 === f.length) {
            const h = f[0]
              , l = f[1];
            if (!e && h.IsConstant() && l.IsConstant())
                this.Run = a._GetBoundACEMethod_2params(d, b, h.Get(0), l.Get(0));
            else {
                const m = a._GetBoundACEMethod(d, b);
                this.Run = function() {
                    return C3$jscomp$167.xor(m(h.Get(0), l.Get(0)), e)
                }
            }
        } else if (3 === f.length) {
            const h = f[0]
              , l = f[1]
              , m = f[2];
            if (!e && h.IsConstant() && l.IsConstant() && m.IsConstant())
                this.Run = a._GetBoundACEMethod_3params(d, b, h.Get(0), l.Get(0), m.Get(0));
            else {
                const p = a._GetBoundACEMethod(d, b);
                this.Run = function() {
                    return C3$jscomp$167.xor(p(h.Get(0), l.Get(0), m.Get(0)), e)
                }
            }
        } else
            this.Run = c
    }
    GetSID() {
        return this._sid
    }
    _GetFunc() {
        return this._func
    }
    GetObjectClass() {
        return this._objectClass
    }
    GetBehaviorType() {
        return this._behaviorType
    }
    GetImplementationAddon() {
        return this._behaviorType ? this._behaviorType.GetBehavior() : this._objectClass ? this._objectClass.GetPlugin() : null
    }
    GetImplementationSdkVersion() {
        const a = this.GetImplementationAddon();
        return a ? a.GetSdkVersion() : 1
    }
    GetEventBlock() {
        return this._eventBlock
    }
    GetRuntime() {
        return this._runtime
    }
    GetIndex() {
        return this._index
    }
    GetDebugIndex() {
        return this.GetIndex()
    }
    IsTrigger() {
        return this._isTrigger
    }
    IsFastTrigger() {
        return this._isFastTrigger
    }
    IsInverted() {
        return this._isInverted
    }
    IsLooping() {
        return this._isLooping
    }
    IsStatic() {
        return this._isStatic
    }
    IsBreakpoint() {
        return this._debugData.isBreakpoint
    }
    IsSystemCondition() {
        return !!this._systemPlugin
    }
    IsSystemOrSingleGlobalCondition() {
        return this.IsSystemCondition() || this._objectClass.GetPlugin().IsSingleGlobal()
    }
    GetFirstObjectParameterObjectClass() {
        for (const a of this._parameters)
            if (a.IsObjectParameter())
                return a.GetObjectClass();
        return null
    }
    _SetBreakpoint(a) {
        this._debugData.isBreakpoint = !!a;
        this._eventBlock._UpdateCanRunFastRecursive()
    }
    _DebugReturnsGenerator() {
        return this._debugData.canDebug
    }
    DebugCanRunFast() {
        return !this.IsBreakpoint() && !this._runtime.DebugBreakNext() && !this._DebugReturnsGenerator()
    }
    GetSavedDataMap() {
        this._savedData || (this._savedData = new Map);
        return this._savedData
    }
    GetUnsavedDataMap() {
        this._unsavedData || (this._unsavedData = new Map);
        return this._unsavedData
    }
    _RunSystem() {
        const a = this._results;
        EvalParams(this._parameters, a);
        return C3$jscomp$167.xor(this._func.apply(this._systemPlugin, a), this._isInverted)
    }
    *_DebugRunSystem() {
        if (this.IsBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        if (this._DebugReturnsGenerator()) {
            var a = this._results;
            EvalParams(this._parameters, a);
            a = this._func.apply(this._systemPlugin, a);
            C3$jscomp$167.IsIterator(a) && (a = yield*a);
            return C3$jscomp$167.xor(a, this._isInverted)
        }
        return this.Run()
    }
    _RunSingleGlobal() {
        const a = this._results;
        EvalParams(this._parameters, a);
        const b = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();
        return C3$jscomp$167.xor(this._func.apply(b, a), this._isInverted)
    }
    *_DebugRunSingleGlobal() {
        if (this.IsBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        if (this._DebugReturnsGenerator()) {
            var a = this._results;
            EvalParams(this._parameters, a);
            const b = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();
            a = this._func.apply(b, a);
            C3$jscomp$167.IsIterator(a) && (a = yield*a);
            return C3$jscomp$167.xor(a, this._isInverted)
        }
        return this.Run()
    }
    _RunFastTrigger() {
        return !0
    }
    *_DebugRunFastTrigger() {
        if (this.IsBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        return !0
    }
    _GetStaticConditionThis() {
        if (this._behaviorType) {
            if (2 <= this._behaviorType.GetBehavior().GetSdkVersion())
                throw Error("not yet implemented");
            return this._behaviorType
        }
        return 2 <= this._objectClass.GetPlugin().GetSdkVersion() ? this._objectClass.GetIObjectClass() : this._objectClass
    }
    _RunStatic() {
        var a = this._results;
        EvalParams(this._parameters, a);
        a = this._func.apply(this._GetStaticConditionThis(), a);
        this._objectClass.ApplySolToContainer();
        return a
    }
    *_DebugRunStatic() {
        if (this.IsBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        if (this._DebugReturnsGenerator()) {
            var a = this._results;
            EvalParams(this._parameters, a);
            a = this._func.apply(this._GetStaticConditionThis(), a);
            C3$jscomp$167.IsIterator(a) && (a = yield*a);
            this._objectClass.ApplySolToContainer();
            return a
        }
        return this.Run()
    }
    _RunObject() {
        const a = this._parameters
          , b = this._results
          , c = this._objectClass.GetCurrentSol();
        for (let d = 0, e = a.length; d < e; ++d) {
            const f = a[d];
            f.VariesPerInstance() || (b[d] = f.Get(0))
        }
        return c.IsSelectAll() ? this._RunObject_FirstFilter(c) : this._RunObject_NextFilter(c)
    }
    *_DebugRunObject() {
        if (this.IsBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        return this._RunObject()
    }
    _EvaluateVaryingParameters(a) {
        const b = this._parameters
          , c = this._results;
        for (let d = 0, e = b.length; d < e; ++d) {
            const f = b[d];
            f.VariesPerInstance() && (c[d] = f.Get(a))
        }
    }
    _RunObject_FirstFilter(a) {
        const b = this._objectClass
          , c = b.IsFamily()
          , d = b.GetFamilyIndex()
          , e = this._behaviorIndex
          , f = 0 <= e
          , h = b.GetInstances()
          , l = this._anyParamVariesPerInstance
          , m = this._results
          , p = this._func
          , r = this._isInverted
          , v = this._isInOrBlock && !this._isTrigger;
        a.ClearArrays();
        for (let B = 0, A = h.length; B < A; ++B) {
            const D = h[B];
            l && this._EvaluateVaryingParameters(B);
            var x = void 0;
            f ? (x = c ? D.GetObjectClass().GetFamilyBehaviorOffset(d) : 0,
            x = p.apply(D.GetBehaviorInstances()[e + x].GetSdkInstance(), m)) : x = p.apply(D.GetSdkInstance(), m);
            C3$jscomp$167.xor(x, r) ? a._PushInstance(D) : v && a._PushElseInstance(D)
        }
        b.FinishCondition(!0);
        a._SetSelectAll(!1);
        b.ApplySolToContainer();
        return a.HasAnyInstances()
    }
    _RunObject_NextFilter(a) {
        const b = this._objectClass;
        var c = b.IsFamily();
        const d = b.GetFamilyIndex()
          , e = b.IsInContainer()
          , f = this._behaviorIndex
          , h = 0 <= f
          , l = this._anyParamVariesPerInstance
          , m = this._results
          , p = this._func
          , r = this._isInverted
          , v = this._isInOrBlock && !this._isTrigger
          , x = a._GetOwnInstances()
          , B = a._GetOwnElseInstances()
          , A = v && !this._eventBlock.IsFirstConditionOfType(this)
          , D = A ? B : x;
        let F = 0
          , I = !1;
        for (let M = 0, Q = D.length; M < Q; ++M) {
            const W = D[M];
            l && this._EvaluateVaryingParameters(M);
            var K = void 0;
            h ? (K = c ? W.GetObjectClass().GetFamilyBehaviorOffset(d) : 0,
            K = p.apply(W.GetBehaviorInstances()[f + K].GetSdkInstance(), m)) : K = p.apply(W.GetSdkInstance(), m);
            C3$jscomp$167.xor(K, r) ? (I = !0,
            A ? (x.push(W),
            e && W._PushSiblingsToSolInstances()) : (D[F] = W,
            e && W._SetSiblingsToSolInstancesIndex(F),
            ++F)) : A ? (D[F] = W,
            e && W._SetSiblingsToSolElseInstancesIndex(F),
            ++F) : v && (B.push(W),
            e && W._PushSiblingsToSolElseInstances())
        }
        C3$jscomp$167.truncateArray(D, F);
        e && b._TruncateContainerSols(A, F);
        c = I;
        A && !I && (I = this._OrBlockCheckInstances(x));
        b.FinishCondition(c || v);
        return v ? I : a.HasAnyInstances()
    }
    _OrBlockCheckInstances(a) {
        var b = this._objectClass;
        const c = b.IsFamily();
        b = b.GetFamilyIndex();
        const d = this._anyParamVariesPerInstance
          , e = this._behaviorIndex
          , f = 0 <= e
          , h = this._results
          , l = this._func
          , m = this._isInverted;
        for (let r = 0, v = a.length; r < v; ++r) {
            var p = a[r];
            d && this._EvaluateVaryingParameters(r);
            if (f) {
                const x = c ? p.GetObjectClass().GetFamilyBehaviorOffset(b) : 0;
                p = l.apply(p.GetBehaviorInstances()[e + x].GetSdkInstance(), h)
            } else
                p = l.apply(p.GetSdkInstance(), h);
            if (C3$jscomp$167.xor(p, m))
                return !0
        }
        return !1
    }
    ReevaluateParameter(a, b) {
        return this._parameters[a].Get(b)
    }
    GetFastTriggerValue() {
        const a = this._parameters;
        if (!a.length)
            throw Error("no parameters");
        return a[0]._GetFastTriggerValue()
    }
    _SaveToJson() {
        if (!this._savedData || !this._savedData.size)
            return null;
        const a = {};
        for (const [b,c] of this._savedData.entries()) {
            let d = c;
            "collmemory" === b && (d = [...c.entries()].map(e => [e[0].GetUID(), e[1].GetUID(), e[2]]));
            a[b] = d
        }
        return {
            ex: a
        }
    }
    _LoadFromJson(a) {
        this._savedData && (this._savedData.clear(),
        this._savedData = null);
        if (a) {
            var b = this._runtime
              , c = a.ex;
            if (c) {
                a = this.GetSavedDataMap();
                a.clear();
                for (const [d,e] of Object.entries(c))
                    c = e,
                    "collmemory" === d && (c = C3$jscomp$167.New(C3$jscomp$167.PairMap, e.map(f => [b.GetInstanceByUID(f[0]), b.GetInstanceByUID(f[1]), f[2]]).filter(f => f[0] && f[1]))),
                    a.set(d, c)
            }
        }
    }
}
;
"use strict";
const C3$jscomp$168 = self.C3;
function EvalParams$jscomp$1(a, b) {
    for (let c = 0, d = a.length; c < d; ++c)
        b[c] = a[c].Get(0)
}
const EMPTY_PARAMS_ARRAY$jscomp$1 = []
  , noop$jscomp$2 = function() {}
  , noopGenerator = function*() {};
C3$jscomp$168.Action = class extends C3$jscomp$168.DefendedBase {
    constructor(a, b, c) {
        super();
        this._eventBlock = a;
        this._runtime = a = a.GetRuntime();
        this._index = c;
        this._sid = 4 <= b.length ? b[3] : -1;
        this._actionType = 5 <= b.length ? b[4] & 255 : 0;
        this._flags = 5 <= b.length ? b[4] >> 8 : 0;
        this._behaviorType = this._objectClass = this._func = null;
        this._behaviorIndex = -1;
        this._systemPlugin = null;
        this._callFunctionName = "";
        this._callEventBlock = this._callCustomAceObjectClass = null;
        this.DebugRun = this.Run = noop$jscomp$2;
        this._parameters = [];
        this._results = [];
        this._anyParamVariesPerInstance = !1;
        this._unsavedData = this._savedData = null;
        const d = (c = -3 === b[0]) ? b[2] : b[5];
        this._debugData = a.IsDebug() || c ? {
            isBreakpoint: d[0],
            canDebug: d[1],
            index: d[2]
        } : null;
        -1 === b[0] ? (this._systemPlugin = a.GetSystemPlugin(),
        this._func = a.GetObjectReference(b[1])) : -2 === b[0] ? this._callFunctionName = b[1] : c ? (this._func = a.GetObjectReference(b[1]),
        this.Run = this.RunUserScript,
        this.DebugRun = this.DebugRunUserScript,
        this._flags |= 8) : (this._objectClass = a.GetObjectClassByIndex(b[0]),
        this._flags & 4 ? (this._callFunctionName = b[1],
        this._callCustomAceObjectClass = a.GetObjectClassByIndex(b[2])) : (b[2] && (this._behaviorType = this._objectClass.GetBehaviorTypeByName(b[2]),
        this._behaviorIndex = this._objectClass.GetBehaviorIndexByName(b[2])),
        this._func = a.GetObjectReference(b[1])));
        if (7 === b.length) {
            b = b[6];
            for (const e of b)
                this._parameters.push(C3$jscomp$168.Parameter.Create(this, e, this._parameters.length)),
                this._results.push(0)
        }
        0 === this._parameters.length && (this._results = this._parameters = EMPTY_PARAMS_ARRAY$jscomp$1);
        this.CanPickAnyObjectClass() && (this._eventBlock.SetAllSolModifiers(),
        this._eventBlock.SetSolWriterAfterCnds());
        this._eventBlock.GetEventSheetManager()._RegisterAction(this)
    }
    static Create(a, b, c) {
        return C3$jscomp$168.New(C3$jscomp$168.Action, a, b, c)
    }
    _PostInit() {
        for (var a of this._parameters)
            a._PostInit(),
            a.VariesPerInstance() && (this._anyParamVariesPerInstance = !0);
        if (this._systemPlugin)
            this._SetSystemRunMethod(),
            this.DebugRun = this._DebugRunSystem;
        else if (this._callFunctionName)
            this._flags & 4 ? this._SetCallCustomActionRunMethod() : this._SetCallFunctionRunMethod(),
            this._callFunctionName = "",
            this._callCustomAceObjectClass = null;
        else if (this.Run === this.RunUserScript) {
            a = this._func;
            const b = this._runtime.GetEventSheetManager()._GetLocalVariablesScriptInterface(this._eventBlock);
            this._func = a.bind(null, this._runtime.GetIRuntime(), b)
        } else
            this._behaviorType ? this.IsAsync() ? (this.Run = this._RunBehavior_Async,
            this.DebugRun = this._DebugRunBehavior_Async) : (this.Run = this._RunBehavior,
            this.DebugRun = this._DebugRunBehavior) : this._objectClass.GetPlugin().IsSingleGlobal() ? (this._SetSingleGlobalRunMethod(),
            this.DebugRun = this._DebugRunSingleGlobal) : this.IsStatic() ? (this.Run = this._RunObject_Static,
            this.DebugRun = this._DebugRunObject_Static) : this.IsAsync() ? (this.Run = this._RunObject_Async,
            this.DebugRun = this._DebugRunObject_Async) : this.CallBeforeAfterHooks() ? (this.Run = this._RunObject_BeforeAfterHooks,
            this.DebugRun = this._DebugRunObject_BeforeAfterHooks) : this._parameters.length ? this._parameters.every(b => b.VariesPerInstance()) ? (this.Run = this._RunObject_AllParamsVary,
            this.DebugRun = this._DebugRunObject_AllParamsVary) : this._anyParamVariesPerInstance ? (this.Run = this._RunObject_SomeParamsVary,
            this.DebugRun = this._DebugRunObject_SomeParamsVary) : this._parameters.every(b => b.IsConstant()) ? (EvalParams$jscomp$1(this._parameters, this._results),
            this.Run = this._RunObject_ParamsConst,
            this.DebugRun = this._DebugRunObject_ParamsConst) : (this.Run = this._RunObject_ParamsDontVary,
            this.DebugRun = this._DebugRunObject_ParamsDontVary) : (this.Run = this._RunObject_ParamsConst,
            this.DebugRun = this._DebugRunObject_ParamsConst)
    }
    _SetSystemRunMethod() {
        this._SetRunMethodForBoundFunc(this._systemPlugin, this._systemPlugin, this._RunSystem)
    }
    _SetSingleGlobalRunMethod() {
        const a = this._objectClass.GetPlugin()
          , b = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();
        this._SetRunMethodForBoundFunc(a, b, this._RunSingleGlobal)
    }
    _SetCallFunctionRunMethod() {
        const a = this._eventBlock.GetEventSheetManager()
          , b = a.GetFunctionBlockByName(this._callFunctionName);
        if (b.IsEnabled()) {
            const c = 0 !== (this._flags & 2);
            this._callEventBlock = b.GetEventBlock();
            let d = [...(new Set([...this._eventBlock.GetSolModifiersIncludingParents(), ...this._callEventBlock.GetSolModifiersIncludingParents()]))];
            d = a._DeduplicateSolModifierList(d);
            const e = !b.IsCopyPicked() && this._HasCopyPickedParent() ? {
                pushCleanSolDynamic: !0
            } : null;
            this.Run = C3$jscomp$168.EventBlock.prototype.RunAsFunctionCall.bind(this._callEventBlock, d, this._parameters, c, e);
            if (this._runtime.IsDebug()) {
                const f = this;
                this.DebugRun = function*() {
                    if (f.IsBreakpoint() || f._runtime.DebugBreakNext())
                        yield f;
                    return yield*f._callEventBlock.DebugRunAsFunctionCall(d, f._parameters, c, e)
                }
            } else
                this.DebugRun = noopGenerator
        } else
            this.Run = noop$jscomp$2,
            this.DebugRun = noopGenerator
    }
    _SetCallCustomActionRunMethod() {
        var a = this._eventBlock.GetEventSheetManager();
        const b = a.GetCustomActionBlockByName(this._callCustomAceObjectClass, this._callFunctionName);
        if (b.IsEnabled()) {
            const c = 0 !== (this._flags & 2);
            this._callEventBlock = b.GetEventBlock();
            let d = [...(new Set([...this._eventBlock.GetSolModifiersIncludingParents(), ...this._callEventBlock.GetSolModifiersIncludingParents(), this._objectClass, b.GetObjectClass()]))];
            d = a._DeduplicateSolModifierList(d);
            a = !this._objectClass.IsFamily() && !b.GetObjectClass().IsFamily();
            const e = !this._objectClass.IsFamily() && b.GetObjectClass().IsFamily()
              , f = this._objectClass.IsFamily();
            let h = null;
            !b.IsCopyPicked() && this._HasCopyPickedParent() && (h = h || {},
            h.pushCleanSolDynamic = !0);
            if (e || !c)
                h = h || {},
                h.copyFromObjectClass = this._objectClass,
                h.copyToObjectClass = b.GetObjectClass();
            a || e || f && !b.HasCustomACEOverrides() ? this.Run = C3$jscomp$168.EventBlock.prototype.RunAsFunctionCall.bind(this._callEventBlock, d, this._parameters, c, h) : f && (this.Run = C3$jscomp$168.FunctionBlock.prototype.RunAsFamilyCustomActionWithOverrides.bind(b, d, this._parameters));
            if (this._runtime.IsDebug()) {
                const l = this;
                a || e || f && !b.HasCustomACEOverrides() ? this.DebugRun = function*() {
                    if (l.IsBreakpoint() || l._runtime.DebugBreakNext())
                        yield l;
                    return yield*l._callEventBlock.DebugRunAsFunctionCall(d, l._parameters, c, h)
                }
                : f && (this.DebugRun = function*() {
                    if (l.IsBreakpoint() || l._runtime.DebugBreakNext())
                        yield l;
                    return yield*b.DebugRunAsFamilyCustomActionWithOverrides(d, l._parameters)
                }
                )
            } else
                this.DebugRun = noopGenerator
        } else
            this.Run = noop$jscomp$2,
            this.DebugRun = noopGenerator
    }
    _SetRunMethodForBoundFunc(a, b, c) {
        const d = this._func
          , e = this._parameters;
        if (0 === e.length)
            this.Run = a._GetBoundACEMethod(d, b);
        else if (1 === e.length) {
            const f = e[0];
            if (f.IsConstant())
                this.Run = a._GetBoundACEMethod_1param(d, b, f.Get(0));
            else {
                const h = a._GetBoundACEMethod(d, b);
                this.Run = function() {
                    return h(f.Get(0))
                }
            }
        } else if (2 === e.length) {
            const f = e[0]
              , h = e[1];
            if (f.IsConstant() && h.IsConstant())
                this.Run = a._GetBoundACEMethod_2params(d, b, f.Get(0), h.Get(0));
            else {
                const l = a._GetBoundACEMethod(d, b);
                this.Run = function() {
                    return l(f.Get(0), h.Get(0))
                }
            }
        } else if (3 === e.length) {
            const f = e[0]
              , h = e[1]
              , l = e[2];
            if (f.IsConstant() && h.IsConstant() && l.IsConstant())
                this.Run = a._GetBoundACEMethod_3params(d, b, f.Get(0), h.Get(0), l.Get(0));
            else {
                const m = a._GetBoundACEMethod(d, b);
                this.Run = function() {
                    return m(f.Get(0), h.Get(0), l.Get(0))
                }
            }
        } else
            this.Run = c
    }
    GetSID() {
        return this._sid
    }
    IsAsync() {
        return 0 !== (this._flags & 8)
    }
    CanBailOut() {
        return 1 === this._actionType
    }
    CallBeforeAfterHooks() {
        return 2 === this._actionType
    }
    IsStatic() {
        return 3 === this._actionType
    }
    CanPickAnyObjectClass() {
        return 0 !== (this._flags & 1)
    }
    HasReturnType() {
        return this.IsAsync() || this.CanBailOut()
    }
    GetObjectClass() {
        return this._objectClass
    }
    GetImplementationAddon() {
        return this._behaviorType ? this._behaviorType.GetBehavior() : this._objectClass ? this._objectClass.GetPlugin() : null
    }
    GetImplementationSdkVersion() {
        const a = this.GetImplementationAddon();
        return a ? a.GetSdkVersion() : 1
    }
    GetEventBlock() {
        return this._eventBlock
    }
    _HasCopyPickedParent() {
        let a = this._eventBlock;
        do {
            if (a instanceof C3$jscomp$168.FunctionBlock && a.IsCopyPicked())
                return !0;
            a = a.GetScopeParent()
        } while (a);
        return !1
    }
    GetRuntime() {
        return this._runtime
    }
    GetIndex() {
        return this._index
    }
    GetDebugIndex() {
        return this._debugData.index
    }
    IsBreakpoint() {
        return this._debugData.isBreakpoint
    }
    _SetBreakpoint(a) {
        this._debugData.isBreakpoint = !!a;
        this._eventBlock._UpdateCanRunFastRecursive()
    }
    _DebugReturnsGenerator() {
        return this._debugData.canDebug
    }
    DebugCanRunFast() {
        return !this.IsBreakpoint() && !this._runtime.DebugBreakNext() && !this._DebugReturnsGenerator()
    }
    GetSavedDataMap() {
        this._savedData || (this._savedData = new Map);
        return this._savedData
    }
    GetUnsavedDataMap() {
        this._unsavedData || (this._unsavedData = new Map);
        return this._unsavedData
    }
    _RunSystem() {
        const a = this._results;
        EvalParams$jscomp$1(this._parameters, a);
        return this._func.apply(this._systemPlugin, a)
    }
    *_DebugRunSystem() {
        if (this.IsBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        if (this._DebugReturnsGenerator()) {
            const a = this._results;
            EvalParams$jscomp$1(this._parameters, a);
            return yield*this._func.apply(this._systemPlugin, a)
        }
        return this.Run()
    }
    _RunSingleGlobal() {
        const a = this._results;
        EvalParams$jscomp$1(this._parameters, a);
        return this._func.apply(this._objectClass.GetSingleGlobalInstance().GetSdkInstance(), a)
    }
    *_DebugRunSingleGlobal() {
        if (this.IsBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        if (this._DebugReturnsGenerator()) {
            const a = this._results;
            EvalParams$jscomp$1(this._parameters, a);
            return yield*this._func.apply(this._objectClass.GetSingleGlobalInstance().GetSdkInstance(), a)
        }
        return this.Run()
    }
    _RunObject_ParamsConst() {
        const a = this._results
          , b = this._objectClass.GetCurrentSol().GetInstances();
        for (let c = 0, d = b.length; c < d; ++c)
            this._func.apply(b[c].GetSdkInstance(), a)
    }
    *_DebugRunObject_ParamsConst() {
        if (this.IsBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        if (this._DebugReturnsGenerator()) {
            const a = this._results
              , b = this._objectClass.GetCurrentSol().GetInstances();
            for (let c = 0, d = b.length; c < d; ++c)
                yield*this._func.apply(b[c].GetSdkInstance(), a)
        } else
            this._RunObject_ParamsConst()
    }
    _RunObject_ParamsDontVary() {
        const a = this._results;
        EvalParams$jscomp$1(this._parameters, a);
        const b = this._objectClass.GetCurrentSol().GetInstances();
        for (let c = 0, d = b.length; c < d; ++c)
            this._func.apply(b[c].GetSdkInstance(), a)
    }
    *_DebugRunObject_ParamsDontVary() {
        if (this.IsBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        if (this._DebugReturnsGenerator()) {
            const a = this._results;
            EvalParams$jscomp$1(this._parameters, a);
            const b = this._objectClass.GetCurrentSol().GetInstances();
            for (let c = 0, d = b.length; c < d; ++c)
                yield*this._func.apply(b[c].GetSdkInstance(), a)
        } else
            this._RunObject_ParamsDontVary()
    }
    _RunObject_AllParamsVary() {
        const a = this._parameters
          , b = this._results
          , c = this._func
          , d = this._objectClass.GetCurrentSol().GetInstances();
        for (let e = 0, f = d.length; e < f; ++e) {
            const h = d[e];
            for (let l = 0, m = a.length; l < m; ++l)
                b[l] = a[l].Get(e);
            c.apply(h.GetSdkInstance(), b)
        }
    }
    *_DebugRunObject_AllParamsVary() {
        if (this.IsBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        if (this._DebugReturnsGenerator()) {
            const a = this._parameters
              , b = this._results
              , c = this._func
              , d = this._objectClass.GetCurrentSol().GetInstances();
            for (let e = 0, f = d.length; e < f; ++e) {
                const h = d[e];
                for (let l = 0, m = a.length; l < m; ++l)
                    b[l] = a[l].Get(e);
                yield*c.apply(h.GetSdkInstance(), b)
            }
        } else
            this._RunObject_AllParamsVary()
    }
    _RunObject_SomeParamsVary() {
        const a = this._parameters
          , b = this._results
          , c = this._func
          , d = this._objectClass.GetCurrentSol().GetInstances();
        for (let f = 0, h = a.length; f < h; ++f) {
            var e = a[f];
            e.VariesPerInstance() || (b[f] = e.Get(0))
        }
        for (let f = 0, h = d.length; f < h; ++f) {
            e = d[f];
            for (let l = 0, m = a.length; l < m; ++l) {
                const p = a[l];
                p.VariesPerInstance() && (b[l] = p.Get(f))
            }
            c.apply(e.GetSdkInstance(), b)
        }
    }
    *_DebugRunObject_SomeParamsVary() {
        if (this.IsBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        if (this._DebugReturnsGenerator()) {
            const b = this._parameters
              , c = this._results
              , d = this._func
              , e = this._objectClass.GetCurrentSol().GetInstances();
            for (let f = 0, h = b.length; f < h; ++f) {
                var a = b[f];
                a.VariesPerInstance() || (c[f] = a.Get(0))
            }
            for (let f = 0, h = e.length; f < h; ++f) {
                a = e[f];
                for (let l = 0, m = b.length; l < m; ++l) {
                    const p = b[l];
                    p.VariesPerInstance() && (c[l] = p.Get(f))
                }
                yield*d.apply(a.GetSdkInstance(), c)
            }
        } else
            this._RunObject_SomeParamsVary()
    }
    _RunObject_BeforeAfterHooks() {
        const a = this._parameters
          , b = this._results
          , c = this._func;
        var d = this._objectClass;
        const e = d.GetSdkType();
        d = d.GetCurrentSol().GetInstances();
        e.BeforeRunAction(c);
        for (let f = 0, h = d.length; f < h; ++f) {
            const l = d[f];
            for (let m = 0, p = a.length; m < p; ++m)
                b[m] = a[m].Get(f);
            c.apply(l.GetSdkInstance(), b)
        }
        e.AfterRunAction(c)
    }
    *_DebugRunObject_BeforeAfterHooks() {
        if (this.IsBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        if (this._DebugReturnsGenerator()) {
            const b = this._parameters
              , c = this._results
              , d = this._func;
            var a = this._objectClass;
            const e = a.GetSdkType();
            a = a.GetCurrentSol().GetInstances();
            e.BeforeRunAction(d);
            for (let f = 0, h = a.length; f < h; ++f) {
                const l = a[f];
                for (let m = 0, p = b.length; m < p; ++m)
                    c[m] = b[m].Get(f);
                yield*d.apply(l.GetSdkInstance(), c)
            }
            e.AfterRunAction(d)
        } else
            this._RunObject_BeforeAfterHooks()
    }
    _RunObject_Static() {
        const a = this._results;
        EvalParams$jscomp$1(this._parameters, a);
        return this._func.apply(this._behaviorType || this._objectClass, a)
    }
    *_DebugRunObject_Static() {
        if (this.IsBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        if (this._DebugReturnsGenerator()) {
            var a = this._results;
            EvalParams$jscomp$1(this._parameters, a);
            a = this._func.apply(this._behaviorType || this._objectClass, a);
            C3$jscomp$168.IsIterator(a) && (a = yield*a);
            return a
        }
        return this._RunObject_Static()
    }
    _RunBehavior() {
        var a = this._objectClass;
        const b = a.IsFamily()
          , c = a.GetFamilyIndex()
          , d = this._parameters
          , e = this._anyParamVariesPerInstance
          , f = this._results
          , h = this._func
          , l = this._behaviorIndex;
        a = a.GetCurrentSol().GetInstances();
        for (let r = 0, v = d.length; r < v; ++r) {
            var m = d[r];
            m.VariesPerInstance() || (f[r] = m.Get(0))
        }
        for (let r = 0, v = a.length; r < v; ++r) {
            m = a[r];
            if (e)
                for (let x = 0, B = d.length; x < B; ++x) {
                    var p = d[x];
                    p.VariesPerInstance() && (f[x] = p.Get(r))
                }
            p = b ? m.GetObjectClass().GetFamilyBehaviorOffset(c) : 0;
            h.apply(m.GetBehaviorInstances()[l + p].GetSdkInstance(), f)
        }
    }
    *_DebugRunBehavior() {
        if (this.IsBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        if (this._DebugReturnsGenerator()) {
            var a = this._objectClass;
            const d = a.IsFamily()
              , e = a.GetFamilyIndex()
              , f = this._parameters
              , h = this._anyParamVariesPerInstance
              , l = this._results
              , m = this._func
              , p = this._behaviorIndex;
            a = a.GetCurrentSol().GetInstances();
            for (let r = 0, v = f.length; r < v; ++r) {
                var b = f[r];
                b.VariesPerInstance() || (l[r] = b.Get(0))
            }
            for (let r = 0, v = a.length; r < v; ++r) {
                b = a[r];
                if (h)
                    for (let x = 0, B = f.length; x < B; ++x) {
                        var c = f[x];
                        c.VariesPerInstance() && (l[x] = c.Get(r))
                    }
                c = d ? b.GetObjectClass().GetFamilyBehaviorOffset(e) : 0;
                yield*m.apply(b.GetBehaviorInstances()[p + c].GetSdkInstance(), l)
            }
        } else
            this._RunBehavior()
    }
    _RunObject_Async() {
        const a = this._parameters
          , b = this._results
          , c = this._func
          , d = this._objectClass.GetCurrentSol().GetInstances()
          , e = [];
        for (let f = 0, h = d.length; f < h; ++f) {
            const l = d[f];
            for (let m = 0, p = a.length; m < p; ++m)
                b[m] = a[m].Get(f);
            e.push(c.apply(l.GetSdkInstance(), b))
        }
        return Promise.all(e)
    }
    *_DebugRunObject_Async() {
        if (this.IsBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        if (this._DebugReturnsGenerator()) {
            const a = this._parameters
              , b = this._results
              , c = this._func
              , d = this._objectClass.GetCurrentSol().GetInstances()
              , e = [];
            for (let f = 0, h = d.length; f < h; ++f) {
                const l = d[f];
                for (let m = 0, p = a.length; m < p; ++m)
                    b[m] = a[m].Get(f);
                e.push(yield*c.apply(l.GetSdkInstance(), b))
            }
            return Promise.all(e)
        }
        return this._RunObject_Async()
    }
    _RunBehavior_Async() {
        var a = this._objectClass;
        const b = a.IsFamily()
          , c = a.GetFamilyIndex()
          , d = this._parameters
          , e = this._results
          , f = this._func
          , h = this._behaviorIndex;
        a = a.GetCurrentSol().GetInstances();
        const l = [];
        for (let m = 0, p = a.length; m < p; ++m) {
            const r = a[m];
            for (let x = 0, B = d.length; x < B; ++x)
                e[x] = d[x].Get(m);
            const v = b ? r.GetObjectClass().GetFamilyBehaviorOffset(c) : 0;
            l.push(f.apply(r.GetBehaviorInstances()[h + v].GetSdkInstance(), e))
        }
        return Promise.all(l)
    }
    *_DebugRunBehavior_Async() {
        if (this.IsBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        if (this._DebugReturnsGenerator()) {
            var a = this._objectClass;
            const b = a.IsFamily()
              , c = a.GetFamilyIndex()
              , d = this._parameters
              , e = this._results
              , f = this._func
              , h = this._behaviorIndex;
            a = a.GetCurrentSol().GetInstances();
            const l = [];
            for (let m = 0, p = a.length; m < p; ++m) {
                const r = a[m];
                for (let x = 0, B = d.length; x < B; ++x)
                    e[x] = d[x].Get(m);
                const v = b ? r.GetObjectClass().GetFamilyBehaviorOffset(c) : 0;
                l.push(yield*f.apply(r.GetBehaviorInstances()[h + v].GetSdkInstance(), e))
            }
            return Promise.all(l)
        }
        return this._RunBehavior_Async()
    }
    async RunUserScript() {
        try {
            await this._func()
        } catch (a) {
            console.error(`Unhandled exception running script %c${this._eventBlock.GetEventSheet().GetName()}, event ${this._eventBlock.GetDisplayNumber()}, action ${this.GetDebugIndex() + 1}:`, "font-size: 1.2em; font-weight: bold;", a),
            self.C3Debugger && self.C3Debugger._SetLastErrorScript(this),
            C3$jscomp$168.EventScript.HadUserScriptException() || (console.info("%cTip:%c run this to highlight in Construct the last script that had an error: %cgoToLastErrorScript()", "font-weight: bold; text-decoration: underline", "", "font-weight: bold"),
            C3$jscomp$168.EventScript.SetHadUserScriptException())
        }
    }
    *DebugRunUserScript() {
        if (this.IsBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        return this.RunUserScript()
    }
    _SaveToJson() {
        return this._savedData && this._savedData.size ? {
            ex: C3$jscomp$168.ToSuperJSON(this._savedData)
        } : null
    }
    _LoadFromJson(a) {
        this._savedData && (this._savedData.clear(),
        this._savedData = null);
        a && (a = a.ex) && (this._savedData = C3$jscomp$168.FromSuperJSON(a))
    }
}
;
"use strict";
const C3$jscomp$169 = self.C3
  , tempColor$jscomp$5 = new C3$jscomp$169.Color;
let runtime$jscomp$66 = null;
C3$jscomp$169.CommonACES_SetRuntime = function(a) {
    runtime$jscomp$66 = a
}
;
const IInstance$jscomp$2 = self.IInstance;
function GetInst(a) {
    return a instanceof IInstance$jscomp$2 ? runtime$jscomp$66._UnwrapScriptInterface(a) : a.GetInstance()
}
function GetWorldInfo(a) {
    return GetInst(a).GetWorldInfo()
}
function CompareX(a, b) {
    return C3$jscomp$169.compare(GetWorldInfo(this).GetX(), a, b)
}
function CompareY(a, b) {
    return C3$jscomp$169.compare(GetWorldInfo(this).GetY(), a, b)
}
function IsOnScreen() {
    return GetWorldInfo(this).IsInViewport2()
}
function IsOutsideLayout() {
    var a = GetWorldInfo(this);
    const b = a.GetLayout();
    a = a.GetBoundingBox();
    return 0 > a.getRight() || 0 > a.getBottom() || a.getLeft() > b.GetWidth() || a.getTop() > b.GetHeight()
}
function PickDistance(a, b, c) {
    const d = this.GetCurrentSol()
      , e = d.GetInstances();
    if (!e.length)
        return !1;
    let f = e[0];
    var h = f.GetWorldInfo();
    let l = f
      , m = C3$jscomp$169.distanceSquared(h.GetX(), h.GetY(), b, c);
    for (let p = 1, r = e.length; p < r; ++p)
        if (f = e[p],
        h = f.GetWorldInfo(),
        h = C3$jscomp$169.distanceSquared(h.GetX(), h.GetY(), b, c),
        0 === a && h < m || 1 === a && h > m)
            m = h,
            l = f;
    d.PickOne(l);
    return !0
}
function SetX(a) {
    const b = GetWorldInfo(this);
    b.GetX() !== a && (b.SetX(a),
    b.SetBboxChanged())
}
function SetY(a) {
    const b = GetWorldInfo(this);
    b.GetY() !== a && (b.SetY(a),
    b.SetBboxChanged())
}
function SetPos(a, b) {
    const c = GetWorldInfo(this);
    c.EqualsXY(a, b) || (c.SetXY(a, b),
    c.SetBboxChanged())
}
function SetPosToObject(a, b) {
    if (a) {
        var c = GetInst(this);
        if (a = a.GetPairedInstance(c)) {
            var [d,e] = a.GetImagePoint(b);
            b = c.GetWorldInfo();
            if (b.GetX() !== d || b.GetY() !== e)
                b.SetXY(d, e),
                b.SetBboxChanged()
        }
    }
}
function MoveForward(a) {
    if (0 !== a) {
        var b = GetWorldInfo(this);
        b.OffsetXY(b.GetCosAngle() * a, b.GetSinAngle() * a);
        b.SetBboxChanged()
    }
}
function MoveAtAngle(a, b) {
    if (0 !== b) {
        var c = GetWorldInfo(this);
        a = C3$jscomp$169.toRadians(a);
        c.OffsetXY(Math.cos(a) * b, Math.sin(a) * b);
        c.SetBboxChanged()
    }
}
function GetX() {
    return GetWorldInfo(this).GetX()
}
function GetY() {
    return GetWorldInfo(this).GetY()
}
function GetDt() {
    const a = GetInst(this);
    return a.GetRuntime().GetDt(a)
}
function CompareWidth(a, b) {
    return C3$jscomp$169.compare(GetWorldInfo(this).GetWidth(), a, b)
}
function CompareHeight(a, b) {
    return C3$jscomp$169.compare(GetWorldInfo(this).GetHeight(), a, b)
}
function SetWidth(a) {
    const b = GetWorldInfo(this);
    b.GetWidth() !== a && (b.SetWidth(a),
    b.SetBboxChanged())
}
function SetHeight(a) {
    const b = GetWorldInfo(this);
    b.GetHeight() !== a && (b.SetHeight(a),
    b.SetBboxChanged())
}
function SetSize(a, b) {
    const c = GetWorldInfo(this);
    if (c.GetWidth() !== a || c.GetHeight() !== b)
        c.SetSize(a, b),
        c.SetBboxChanged()
}
function GetWidth() {
    return GetWorldInfo(this).GetWidth()
}
function GetHeight() {
    return GetWorldInfo(this).GetHeight()
}
function GetBboxLeft() {
    return GetWorldInfo(this).GetBoundingBox().getLeft()
}
function GetBboxTop() {
    return GetWorldInfo(this).GetBoundingBox().getTop()
}
function GetBboxRight() {
    return GetWorldInfo(this).GetBoundingBox().getRight()
}
function GetBboxBottom() {
    return GetWorldInfo(this).GetBoundingBox().getBottom()
}
function GetBboxMidX() {
    const a = GetWorldInfo(this).GetBoundingBox();
    return (a.getLeft() + a.getRight()) / 2
}
function GetBboxMidY() {
    const a = GetWorldInfo(this).GetBoundingBox();
    return (a.getTop() + a.getBottom()) / 2
}
function IsAngleWithin(a, b) {
    return C3$jscomp$169.angleDiff(GetWorldInfo(this).GetAngle(), C3$jscomp$169.toRadians(b)) <= C3$jscomp$169.toRadians(a)
}
function IsAngleClockwiseFrom(a) {
    return C3$jscomp$169.angleClockwise(GetWorldInfo(this).GetAngle(), C3$jscomp$169.toRadians(a))
}
function IsBetweenAngles(a, b) {
    a = C3$jscomp$169.toRadians(a);
    b = C3$jscomp$169.toRadians(b);
    const c = GetWorldInfo(this).GetAngle();
    return C3$jscomp$169.angleClockwise(b, a) ? C3$jscomp$169.angleClockwise(c, a) && !C3$jscomp$169.angleClockwise(c, b) : !(!C3$jscomp$169.angleClockwise(c, a) && C3$jscomp$169.angleClockwise(c, b))
}
function SetAngle(a) {
    const b = GetWorldInfo(this);
    a = C3$jscomp$169.clampAngle(C3$jscomp$169.toRadians(a));
    isNaN(a) || b.GetAngle() === a || (b.SetAngle(a),
    b.SetBboxChanged())
}
function RotateClockwise(a) {
    if (!isNaN(a) && 0 !== a) {
        var b = GetWorldInfo(this);
        b.SetAngle(b.GetAngle() + C3$jscomp$169.toRadians(a));
        b.SetBboxChanged()
    }
}
function RotateCounterclockwise(a) {
    if (!isNaN(a) && 0 !== a) {
        var b = GetWorldInfo(this);
        b.SetAngle(b.GetAngle() - C3$jscomp$169.toRadians(a));
        b.SetBboxChanged()
    }
}
function RotateTowardAngle(a, b) {
    const c = GetWorldInfo(this)
      , d = c.GetAngle();
    a = C3$jscomp$169.angleRotate(d, C3$jscomp$169.toRadians(b), C3$jscomp$169.toRadians(a));
    isNaN(a) || d === a || (c.SetAngle(a),
    c.SetBboxChanged())
}
function RotateTowardPosition(a, b, c) {
    const d = GetWorldInfo(this)
      , e = d.GetAngle();
    b -= d.GetX();
    c -= d.GetY();
    a = C3$jscomp$169.angleRotate(e, Math.atan2(c, b), C3$jscomp$169.toRadians(a));
    isNaN(a) || e === a || (d.SetAngle(a),
    d.SetBboxChanged())
}
function SetTowardPosition(a, b) {
    const c = GetWorldInfo(this)
      , d = c.GetAngle();
    a -= c.GetX();
    b -= c.GetY();
    b = Math.atan2(b, a);
    isNaN(b) || d === b || (c.SetAngle(b),
    c.SetBboxChanged())
}
function GetAngle() {
    return C3$jscomp$169.toDegrees(GetWorldInfo(this).GetAngle())
}
function CompareOpacity(a, b) {
    return C3$jscomp$169.compare(C3$jscomp$169.roundToDp(100 * GetWorldInfo(this).GetOpacity(), 6), a, b)
}
function IsVisible() {
    return GetWorldInfo(this).IsVisible()
}
function SetVisible(a) {
    const b = GetInst(this)
      , c = b.GetWorldInfo();
    a = 2 === a ? !c.IsVisible() : 0 !== a;
    c.IsVisible() !== a && (c.SetVisible(a),
    b.GetRuntime().UpdateRender())
}
function SetOpacity(a) {
    a = C3$jscomp$169.clamp(a / 100, 0, 1);
    const b = GetInst(this)
      , c = b.GetWorldInfo();
    if (c.GetTransformWithParentOpacity()) {
        if (c._GetSceneGraphInfo().GetOwnOpacity() === a)
            return
    } else if (c.GetOpacity() === a)
        return;
    c.SetOpacity(a);
    b.GetRuntime().UpdateRender()
}
function SetDefaultColor(a) {
    tempColor$jscomp$5.setFromRgbValue(a);
    a = GetInst(this);
    const b = a.GetWorldInfo();
    b.GetUnpremultipliedColor().equalsIgnoringAlpha(tempColor$jscomp$5) || (b.SetUnpremultipliedColor(tempColor$jscomp$5),
    a.GetRuntime().UpdateRender())
}
function GetColor() {
    const a = GetWorldInfo(this).GetUnpremultipliedColor();
    return C3$jscomp$169.PackRGBAEx(a.getR(), a.getG(), a.getB(), a.getA())
}
function GetOpacity() {
    return C3$jscomp$169.roundToDp(100 * GetWorldInfo(this).GetOpacity(), 6)
}
function IsOnLayer(a) {
    return a ? GetWorldInfo(this).GetLayer() === a : !1
}
function PickTopBottom(a) {
    const b = this.GetCurrentSol()
      , c = b.GetInstances();
    if (!c.length)
        return !1;
    let d = c[0];
    for (let e = 1, f = c.length; e < f; ++e) {
        const h = c[e]
          , l = h.GetWorldInfo()
          , m = d.GetWorldInfo()
          , p = l.GetLayer().GetIndex()
          , r = m.GetLayer().GetIndex();
        if (0 === a) {
            if (p > r || p === r && l.GetZIndex() > m.GetZIndex())
                d = h
        } else if (p < r || p === r && l.GetZIndex() < m.GetZIndex())
            d = h
    }
    b.PickOne(d);
    return !0
}
function CompareZElevation(a, b, c) {
    const d = GetWorldInfo(this);
    a = 0 === a ? d.GetZElevation() : d.GetTotalZElevation();
    return C3$jscomp$169.compare(a, b, c)
}
function MoveToTop() {
    GetWorldInfo(this).ZOrderMoveToTop()
}
function MoveToBottom() {
    GetWorldInfo(this).ZOrderMoveToBottom()
}
function MoveToLayer(a) {
    a && GetWorldInfo(this).ZOrderMoveToLayer(a)
}
function ZMoveToObject(a, b) {
    a = 0 === a;
    if (b) {
        var c = GetInst(this);
        (b = b.GetFirstPicked(c)) && c.GetWorldInfo().ZOrderMoveAdjacentToInstance(b, a)
    }
}
function SetZElevation(a) {
    const b = GetInst(this)
      , c = b.GetWorldInfo();
    c.GetZElevation() !== a && (c.SetZElevation(a),
    b.GetRuntime().UpdateRender())
}
function LayerNumber() {
    return GetWorldInfo(this).GetLayer().GetIndex()
}
function LayerName() {
    return GetWorldInfo(this).GetLayer().GetName()
}
function ZIndex() {
    return GetWorldInfo(this).GetZIndex()
}
function ZElevation() {
    return GetWorldInfo(this).GetZElevation()
}
function TotalZElevation() {
    return GetWorldInfo(this).GetTotalZElevation()
}
function IsEffectEnabled(a) {
    const b = GetInst(this);
    if (a = b.GetObjectClass().GetEffectList().GetEffectTypeByName(a))
        return a = a.GetIndex(),
        b.GetWorldInfo().GetInstanceEffectList().IsEffectIndexActive(a)
}
function SetEffectEnabled(a, b) {
    const c = GetInst(this);
    if (b = c.GetObjectClass().GetEffectList().GetEffectTypeByName(b)) {
        b = b.GetIndex();
        a = 1 === a;
        var d = c.GetWorldInfo().GetInstanceEffectList();
        d.IsEffectIndexActive(b) !== a && (d.SetEffectIndexActive(b, a),
        d.UpdateActiveEffects(),
        c.GetRuntime().UpdateRender())
    }
}
function SetEffectParam(a, b, c) {
    const d = GetInst(this);
    if (a = d.GetObjectClass().GetEffectList().GetEffectTypeByName(a)) {
        b = Math.floor(b);
        var e = a.GetShaderProgram().GetParameterType(b);
        e && ("color" === e ? (tempColor$jscomp$5.setFromRgbValue(c),
        c = tempColor$jscomp$5) : "percent" === e && (c /= 100),
        a = a.GetIndex(),
        e = d.GetWorldInfo().GetInstanceEffectList(),
        e.SetEffectParameter(a, b, c) && e.IsEffectIndexActive(a) && d.GetRuntime().UpdateRender())
    }
}
const tempRect$jscomp$5 = C3$jscomp$169.New(C3$jscomp$169.Rect)
  , tempCandidates1 = []
  , tempCandidates2 = [];
let needsCollisionFinish = !1
  , rPickType = null
  , rPickFromElseInstances = !1;
const rToPick = new Set;
function CollMemory_Add(a, b, c, d) {
    const e = b.GetUID()
      , f = c.GetUID();
    e < f ? a.Set(b, c, d) : a.Set(c, b, d)
}
function CollMemory_Remove(a, b, c) {
    const d = b.GetUID()
      , e = c.GetUID();
    d < e ? a.Delete(b, c) : a.Delete(c, b)
}
function CollMemory_RemoveInstance(a, b) {
    a.DeleteEither(b)
}
function CollMemory_Get(a, b, c) {
    const d = b.GetUID()
      , e = c.GetUID();
    return d < e ? a.Get(b, c) : a.Get(c, b)
}
function DoOverlapCondition(a, b, c, d) {
    if (!b)
        return !1;
    const e = 0 !== c || 0 !== d
      , f = a.GetWorldInfo()
      , h = a.GetRuntime()
      , l = h.GetCollisionEngine();
    var m = h.GetCurrentCondition();
    const p = m.GetEventBlock().IsOrBlock();
    var r = m.GetObjectClass();
    m = m.IsInverted();
    const v = b.GetCurrentSol();
    r = r !== b;
    rPickType = b;
    needsCollisionFinish = r && !m;
    rPickFromElseInstances = !1;
    let x = 0
      , B = 0
      , A = !1;
    v.IsSelectAll() ? (tempRect$jscomp$5.copy(f.GetBoundingBox()),
    tempRect$jscomp$5.offset(c, d),
    l.GetCollisionCandidates(f.GetLayer(), b, tempRect$jscomp$5, tempCandidates2),
    b = tempCandidates2) : p ? h.IsCurrentConditionFirst() && !v._GetOwnElseInstances().length && v._GetOwnInstances().length ? b = v._GetOwnInstances() : (b = v._GetOwnElseInstances(),
    rPickFromElseInstances = !0) : b = v._GetOwnInstances();
    e && (x = f.GetX(),
    B = f.GetY(),
    f.OffsetXY(c, d),
    f.SetBboxChanged());
    for (const D of b)
        if (l.TestOverlap(a, D)) {
            A = !0;
            if (m)
                break;
            r && rToPick.add(D)
        }
    e && (f.SetXY(x, B),
    f.SetBboxChanged());
    C3$jscomp$169.clearArray(tempCandidates2);
    return A
}
function FinishCollisionConditionPicking(a) {
    a = a.GetRuntime().GetCurrentEvent().IsOrBlock();
    const b = rPickType.GetCurrentSol()
      , c = b._GetOwnInstances()
      , d = b._GetOwnElseInstances();
    b.IsSelectAll() ? (b.SetSetPicked(rToPick),
    a && (C3$jscomp$169.clearArray(d),
    b.AddElseInstances(rToPick, rPickType.GetInstances()))) : a ? rPickFromElseInstances ? b.TransferElseInstancesToOwn(rToPick) : (b.AddElseInstances(rToPick, c),
    b.SetSetPicked(rToPick)) : b.SetSetPicked(rToPick);
    rPickType.ApplySolToContainer()
}
function FinishCollisionCondition(a, b) {
    needsCollisionFinish && (b && FinishCollisionConditionPicking(a),
    rToPick.clear(),
    rPickType = null,
    needsCollisionFinish = !1)
}
function OnCollision(a) {
    if (this._runtime.IsDebugging())
        return DebugOnCollision.call(this, a);
    if (!a)
        return !1;
    var b = this._runtime;
    const c = b.GetCollisionEngine()
      , d = b.GetEventSheetManager()
      , e = d.GetEventStack();
    var f = d.GetCurrentCondition();
    const h = f.GetObjectClass();
    var l = f.GetSavedDataMap()
      , m = f.GetUnsavedDataMap();
    f = e.GetCurrentStackFrame();
    const p = b.GetTickCount()
      , r = p - 1
      , v = f.GetCurrentEvent()
      , x = e.Push(v);
    let B = l.get("collmemory");
    B || (B = C3$jscomp$169.New(C3$jscomp$169.PairMap),
    l.set("collmemory", B));
    m.get("collisionCreatedDestroyCallback") || (m.set("collisionCreatedDestroyCallback", !0),
    b.Dispatcher().addEventListener("instancedestroy", I => CollMemory_RemoveInstance(B, I.instance)));
    l = h.GetCurrentSol();
    b = a.GetCurrentSol();
    l = l.GetInstances();
    m = null;
    for (let I = 0; I < l.length; ++I) {
        const K = l[I];
        b.IsSelectAll() ? (c.GetCollisionCandidates(K.GetWorldInfo().GetLayer(), a, K.GetWorldInfo().GetBoundingBox(), tempCandidates1),
        m = tempCandidates1,
        c.AddRegisteredCollisionCandidates(K, a, m)) : m = b.GetInstances();
        for (let M = 0; M < m.length; ++M) {
            const Q = m[M];
            if (c.TestOverlap(K, Q) || c.CheckRegisteredCollision(K, Q)) {
                var A = CollMemory_Get(B, K, Q)
                  , D = !1
                  , F = -2;
                "number" === typeof A && (D = !0,
                F = A);
                A = !D || F < r;
                CollMemory_Add(B, K, Q, p);
                A && (A = v.GetSolModifiers(),
                d.PushCopySol(A),
                F = h.GetCurrentSol(),
                D = a.GetCurrentSol(),
                F._SetSelectAll(!1),
                D._SetSelectAll(!1),
                h === a ? (D = F._GetOwnInstances(),
                C3$jscomp$169.clearArray(D),
                D.push(K),
                D.push(Q),
                h.ApplySolToContainer()) : (F = F._GetOwnInstances(),
                D = D._GetOwnInstances(),
                C3$jscomp$169.clearArray(F),
                C3$jscomp$169.clearArray(D),
                F.push(K),
                D.push(Q),
                h.ApplySolToContainer(),
                a.ApplySolToContainer()),
                v.Retrigger(f, x),
                d.PopSol(A))
            } else
                CollMemory_Remove(B, K, Q)
        }
        C3$jscomp$169.clearArray(tempCandidates1)
    }
    e.Pop();
    return !1
}
function *DebugOnCollision(a) {
    if (!a)
        return !1;
    var b = this._runtime;
    const c = b.GetCollisionEngine()
      , d = b.GetEventSheetManager()
      , e = d.GetEventStack();
    var f = d.GetCurrentCondition();
    const h = f.GetObjectClass();
    var l = f.GetSavedDataMap()
      , m = f.GetUnsavedDataMap();
    f = e.GetCurrentStackFrame();
    const p = b.GetTickCount()
      , r = p - 1
      , v = f.GetCurrentEvent()
      , x = e.Push(v);
    let B = l.get("collmemory");
    B || (B = C3$jscomp$169.New(C3$jscomp$169.PairMap),
    l.set("collmemory", B));
    m.get("collisionCreatedDestroyCallback") || (m.set("collisionCreatedDestroyCallback", !0),
    b.Dispatcher().addEventListener("instancedestroy", I => CollMemory_RemoveInstance(B, I.instance)));
    l = h.GetCurrentSol();
    b = a.GetCurrentSol();
    l = l.GetInstances();
    m = null;
    for (let I = 0; I < l.length; ++I) {
        const K = l[I];
        b.IsSelectAll() ? (c.GetCollisionCandidates(K.GetWorldInfo().GetLayer(), a, K.GetWorldInfo().GetBoundingBox(), tempCandidates1),
        m = tempCandidates1,
        c.AddRegisteredCollisionCandidates(K, a, m)) : m = b.GetInstances();
        for (let M = 0; M < m.length; ++M) {
            const Q = m[M];
            if (c.TestOverlap(K, Q) || c.CheckRegisteredCollision(K, Q)) {
                var A = CollMemory_Get(B, K, Q)
                  , D = !1
                  , F = -2;
                "number" === typeof A && (D = !0,
                F = A);
                A = !D || F < r;
                CollMemory_Add(B, K, Q, p);
                A && (A = v.GetSolModifiers(),
                d.PushCopySol(A),
                F = h.GetCurrentSol(),
                D = a.GetCurrentSol(),
                F._SetSelectAll(!1),
                D._SetSelectAll(!1),
                h === a ? (D = F._GetOwnInstances(),
                C3$jscomp$169.clearArray(D),
                D.push(K),
                D.push(Q),
                h.ApplySolToContainer()) : (F = F._GetOwnInstances(),
                D = D._GetOwnInstances(),
                C3$jscomp$169.clearArray(F),
                C3$jscomp$169.clearArray(D),
                F.push(K),
                D.push(Q),
                h.ApplySolToContainer(),
                a.ApplySolToContainer()),
                yield*v.DebugRetrigger(f, x),
                d.PopSol(A))
            } else
                CollMemory_Remove(B, K, Q)
        }
        C3$jscomp$169.clearArray(tempCandidates1)
    }
    e.Pop();
    return !1
}
function IsOverlapping(a) {
    return DoOverlapCondition(GetInst(this), a, 0, 0)
}
function IsOverlappingOffset(a, b, c) {
    return DoOverlapCondition(GetInst(this), a, b, c)
}
function HasParent() {
    return GetWorldInfo(this).HasParent()
}
function HasChildren() {
    return GetWorldInfo(this).HasChildren()
}
function PickParent(a, b) {
    const c = this.GetCurrentSol().GetInstances();
    if (0 === c.length)
        return !1;
    const d = a.GetCurrentSol();
    var e = d.GetInstances();
    if (d.IsSelectAll()) {
        var f = [...this._runtime.instancesPendingCreateForObjectClass(a)];
        0 < f.length && (e = e.concat(f))
    }
    if (0 === e.length)
        return !1;
    e = new Set(e);
    f = new Set;
    for (let l = 0, m = c.length; l < m; ++l) {
        var h = c[l];
        if (1 === b)
            for (const p of h.parents())
                p.BelongsToObjectClass(a) && e.has(p) && f.add(p);
        else {
            if (0 === b) {
                if (h = h.GetParent(),
                null === h)
                    continue
            } else
                h = h.GetTopParent();
            h.BelongsToObjectClass(a) && e.has(h) && f.add(h)
        }
    }
    if (0 === f.size)
        return !1;
    d.SetSetPicked(f);
    a.ApplySolToContainer();
    return !0
}
function PickChildren(a, b) {
    const c = this.GetCurrentSol().GetInstances();
    if (0 === c.length)
        return !1;
    const d = a.GetCurrentSol();
    var e = d.GetInstances();
    if (d.IsSelectAll()) {
        var f = [...this._runtime.instancesPendingCreateForObjectClass(a)];
        0 < f.length && (e = e.concat(f))
    }
    if (0 === e.length)
        return !1;
    e = new Set(e);
    f = new Set;
    for (let h = 0, l = c.length; h < l; ++h) {
        const m = c[h];
        2 === b && !m.HasChildren() && m.BelongsToObjectClass(a) && e.has(m) && f.add(m);
        for (const p of 0 === b ? m.children() : m.allChildren())
            2 === b && p.HasChildren() || p.BelongsToObjectClass(a) && e.has(p) && f.add(p)
    }
    if (0 === f.size)
        return !1;
    d.SetSetPicked(f);
    a.ApplySolToContainer();
    return !0
}
function PickNthChild(a, b) {
    const c = this.GetCurrentSol().GetInstances();
    if (0 === c.length)
        return !1;
    const d = a.GetCurrentSol();
    var e = d.GetInstances();
    if (d.IsSelectAll()) {
        var f = [...this._runtime.instancesPendingCreateForObjectClass(a)];
        0 < f.length && (e = e.concat(f))
    }
    if (0 === e.length)
        return !1;
    e = new Set(e);
    f = [];
    for (let h = 0, l = c.length; h < l; ++h) {
        const m = c[h].GetChildAt(b);
        null !== m && m.BelongsToObjectClass(a) && e.has(m) && f.push(m)
    }
    if (0 === f.length)
        return !1;
    d.SetArrayPicked(f);
    a.ApplySolToContainer();
    return !0
}
function CompareChildCount(a, b, c) {
    const d = GetInst(this);
    switch (a) {
    default:
        return C3$jscomp$169.compare(d.GetChildCount(), b, c);
    case 1:
        return C3$jscomp$169.compare(d.GetAllChildCount(), b, c)
    }
}
function AddChild(a, b, c, d, e, f, h, l, m, p) {
    const r = GetInst(this)
      , v = r.GetRuntime().GetCurrentAction().GetObjectClass();
    for (const x of a.allCorrespondingInstances(r, v)) {
        if (!x.GetPlugin().SupportsSceneGraph())
            break;
        r.AddChild(x, {
            transformX: b,
            transformY: c,
            transformWidth: d,
            transformHeight: e,
            transformAngle: f,
            transformOpacity: h,
            transformZElevation: l,
            transformVisibility: m,
            destroyWithParent: p
        })
    }
}
function RemoveChild(a) {
    const b = GetInst(this)
      , c = b.GetRuntime().GetCurrentAction().GetObjectClass();
    for (const d of a.allCorrespondingInstances(b, c))
        b.RemoveChild(d)
}
function RemoveFromParent() {
    const a = GetInst(this);
    a.HasParent() && a.GetParent().RemoveChild(a)
}
function ChildCount() {
    return GetInst(this).GetChildCount()
}
function AllChildCount() {
    return GetInst(this).GetAllChildCount()
}
function SetMeshSize(a, b) {
    a = Math.floor(a);
    b = Math.floor(b);
    const c = GetWorldInfo(this);
    2 > a || 2 > b || !isFinite(a) || !isFinite(b) ? (c.ReleaseMesh(),
    c.SetBboxChanged()) : c.CreateMesh(a, b)
}
function SetMeshPoint(a, b, c, d, e, f, h, l) {
    const m = GetWorldInfo(this);
    m.SetMeshPoint(a, b, {
        mode: 0 === c ? "absolute" : "relative",
        x: d,
        y: e,
        zElevation: f,
        u: h,
        v: l
    }) && m.SetBboxChanged()
}
function MeshColumns() {
    const a = GetWorldInfo(this);
    return a.HasMesh() ? a.GetSourceMesh().GetHSize() : 0
}
function MeshRows() {
    const a = GetWorldInfo(this);
    return a.HasMesh() ? a.GetSourceMesh().GetVSize() : 0
}
function SetElementVisible(a) {
    const b = GetWorldInfo(this);
    a = 2 === a ? !b.IsVisible() : 0 !== a;
    b.IsVisible() !== a && b.SetVisible(a)
}
function SetElementCSSStyle(a, b) {
    this instanceof self.IInstance ? this.setElementCSSStyle(a, b) : this.SetElementCSSStyle(a, b)
}
function SetElementAttribute(a, b) {
    this instanceof self.IInstance ? this.setElementAttribute(a, "" + b) : this.SetElementAttribute(a, "" + b)
}
function RemoveElementAttribute(a) {
    this instanceof self.IInstance ? this.removeElementAttribute(a) : this.RemoveElementAttribute(a)
}
function SetElementFocus() {
    this instanceof self.IInstance ? this.focusElement() : this.FocusElement()
}
function SetElementBlur() {
    this instanceof self.IInstance ? this.blurElement() : this.BlurElement()
}
function IsElementFocused() {
    return this instanceof self.IInstance ? this.isElementFocused() : this.IsElementFocused()
}
function SetElementEnabled(a) {
    this instanceof self.IInstance ? this._setEnabled(0 !== a) : this._SetEnabled(0 !== a)
}
function IsElementEnabled() {
    return this instanceof self.IInstance ? this._isEnabled() : this._IsEnabled()
}
function CompareInstanceVar(a, b, c) {
    return C3$jscomp$169.compare(GetInst(this).GetInstanceVariableValue(a), b, c)
}
function IsBoolInstanceVarSet(a) {
    return !!GetInst(this).GetInstanceVariableValue(a)
}
function TemplateName() {
    return GetInst(this).GetTemplateName()
}
function PickInstVarHiLow(a, b) {
    const c = this.GetCurrentSol()
      , d = c.GetInstances();
    if (!d.length)
        return !1;
    const e = this.IsFamily();
    let f = null
      , h = 0;
    for (let m = 0, p = d.length; m < p; ++m) {
        const r = d[m];
        var l = e ? r.GetObjectClass().GetFamilyInstanceVariableOffset(this.GetFamilyIndex()) : 0;
        l = r.GetInstanceVariableValue(l + b);
        if (null === f || 0 === a && l < h || 1 === a && l > h)
            h = l,
            f = r
    }
    c.PickOne(f);
    return !0
}
function PickByUID(a) {
    return this._runtime.GetCurrentCondition().IsInverted() ? PickByUID_Inverted(this, a) : PickByUID_Normal(this, a)
}
function PickByUID_Normal(a, b) {
    b = a.GetRuntime().GetInstanceByUID(b);
    if (!b)
        return !1;
    const c = a.GetCurrentSol();
    if (!c.IsSelectAll() && !c._GetOwnInstances().includes(b))
        return !1;
    if (a.IsFamily()) {
        if (b.GetObjectClass().BelongsToFamily(a))
            return c.PickOne(b),
            a.ApplySolToContainer(),
            !0
    } else if (b.GetObjectClass() === a)
        return c.PickOne(b),
        a.ApplySolToContainer(),
        !0;
    return !1
}
function PickByUID_Inverted(a, b) {
    const c = a.GetCurrentSol();
    if (c.IsSelectAll()) {
        c._SetSelectAll(!1);
        c.ClearArrays();
        var d = a.GetInstances();
        for (let f = 0, h = d.length; f < h; ++f) {
            var e = d[f];
            e.GetUID() === b ? c._PushElseInstance(e) : c._PushInstance(e)
        }
        a.ApplySolToContainer();
        return !!c._GetOwnInstances().length
    }
    d = c._GetOwnInstances();
    e = 0;
    for (let f = 0, h = d.length; f < h; ++f) {
        const l = d[f];
        d[e] = l;
        l.GetUID() === b ? c._PushElseInstance(l) : ++e
    }
    C3$jscomp$169.truncateArray(d, e);
    a.ApplySolToContainer();
    return !!d.length
}
function Destroy() {
    const a = GetInst(this);
    a.GetRuntime().DestroyInstance(a)
}
function OnCreated() {
    return !0
}
function OnDestroyed() {
    return !0
}
function SetInstanceVar(a, b) {
    GetInst(this).SetInstanceVariableValue(a, b)
}
function AddInstanceVar(a, b) {
    const c = GetInst(this)
      , d = c.GetInstanceVariableValue(a);
    "number" === typeof d && "number" !== typeof b ? b = parseFloat(b) : "string" === typeof d && "string" !== typeof b && (b = b.toString());
    c.SetInstanceVariableValue(a, d + b)
}
function SubInstanceVar(a, b) {
    const c = GetInst(this)
      , d = c.GetInstanceVariableValue(a);
    "number" === typeof d && ("number" !== typeof b && (b = parseFloat(b)),
    c.SetInstanceVariableValue(a, d - b))
}
function SetBoolInstanceVar(a, b) {
    GetInst(this).SetInstanceVariableValue(a, b ? 1 : 0)
}
function ToggleBoolInstanceVar(a) {
    const b = GetInst(this);
    b.SetInstanceVariableValue(a, 0 === b.GetInstanceVariableValue(a) ? 1 : 0)
}
function LoadFromJsonString(a) {
    let b;
    try {
        b = JSON.parse(a)
    } catch (c) {
        console.error("Failed to load from JSON string: ", c);
        return
    }
    a = GetInst(this);
    a.GetRuntime().ClearIntancesNeedingAfterLoad();
    a._OnBeforeLoad("state");
    a.LoadFromJson(b, "state");
    a.GetRuntime().DoAfterLoad("state", {
        ignoreMissingInstances: !0
    })
}
function AsJSON() {
    return JSON.stringify(GetInst(this).SaveToJson("state"))
}
function ObjectTypeName() {
    return GetInst(this).GetObjectClass().GetName()
}
function Count() {
    const a = GetInst(this).GetRuntime()
      , b = a.GetCurrentEventStackFrame().GetExpressionObjectClass();
    let c = b.GetInstanceCount();
    for (const d of a.instancesPendingCreateForObjectClass(b))
        ++c;
    return c
}
function PickedCount() {
    return GetInst(this).GetRuntime().GetCurrentEventStackFrame().GetExpressionObjectClass().GetCurrentSol().GetInstances().length
}
function GetIID() {
    return GetInst(this).GetIID()
}
function GetUID() {
    return GetInst(this).GetUID()
}
C3$jscomp$169.AddCommonACEs = function(a, b) {
    const c = a[1]
      , d = a[4]
      , e = a[5]
      , f = a[6]
      , h = a[7]
      , l = a[8]
      , m = a[10]
      , p = a[11]
      , r = a[12]
      , v = a[13]
      , x = a[14]
      , B = a[15]
      , A = a[16]
      , D = b.Cnds
      , F = b.Acts
      , I = b.Exps;
    a[3] && (D.CompareX = CompareX,
    D.CompareY = CompareY,
    D.IsOnScreen = IsOnScreen,
    D.IsOutsideLayout = IsOutsideLayout,
    D.PickDistance = PickDistance,
    F.SetX = SetX,
    F.SetY = SetY,
    F.SetPos = SetPos,
    F.SetPosToObject = SetPosToObject,
    F.MoveForward = MoveForward,
    F.MoveAtAngle = MoveAtAngle,
    I.X = GetX,
    I.Y = GetY,
    I.dt = GetDt);
    d && (D.CompareWidth = CompareWidth,
    D.CompareHeight = CompareHeight,
    F.SetWidth = SetWidth,
    F.SetHeight = SetHeight,
    F.SetSize = SetSize,
    I.Width = GetWidth,
    I.Height = GetHeight,
    I.BBoxLeft = GetBboxLeft,
    I.BBoxTop = GetBboxTop,
    I.BBoxRight = GetBboxRight,
    I.BBoxBottom = GetBboxBottom,
    I.BBoxMidX = GetBboxMidX,
    I.BBoxMidY = GetBboxMidY);
    e && (D.AngleWithin = IsAngleWithin,
    D.IsClockwiseFrom = IsAngleClockwiseFrom,
    D.IsBetweenAngles = IsBetweenAngles,
    F.SetAngle = SetAngle,
    F.RotateClockwise = RotateClockwise,
    F.RotateCounterclockwise = RotateCounterclockwise,
    F.RotateTowardAngle = RotateTowardAngle,
    F.RotateTowardPosition = RotateTowardPosition,
    F.SetTowardPosition = SetTowardPosition,
    I.Angle = GetAngle);
    f && (D.IsVisible = IsVisible,
    D.CompareOpacity = CompareOpacity,
    F.SetVisible = SetVisible,
    F.SetOpacity = SetOpacity,
    F.SetDefaultColor = SetDefaultColor,
    I.Opacity = GetOpacity,
    I.ColorValue = GetColor);
    h && (D.IsOnLayer = IsOnLayer,
    D.PickTopBottom = PickTopBottom,
    D.CompareZElevation = CompareZElevation,
    F.MoveToTop = MoveToTop,
    F.MoveToBottom = MoveToBottom,
    F.MoveToLayer = MoveToLayer,
    F.ZMoveToObject = ZMoveToObject,
    F.SetZElevation = SetZElevation,
    I.LayerNumber = LayerNumber,
    I.LayerName = LayerName,
    I.ZIndex = ZIndex,
    I.ZElevation = ZElevation,
    I.TotalZElevation = TotalZElevation);
    l && (D.IsEffectEnabled = IsEffectEnabled,
    F.SetEffectEnabled = SetEffectEnabled,
    F.SetEffectParam = SetEffectParam);
    v && (D.HasParent = HasParent,
    D.HasChildren = HasChildren,
    D.PickParent = PickParent,
    D.PickChildren = PickChildren,
    D.PickNthChild = PickNthChild,
    D.CompareChildCount = CompareChildCount,
    F.AddChild = AddChild,
    F.RemoveChild = RemoveChild,
    F.RemoveFromParent = RemoveFromParent,
    I.ChildCount = ChildCount,
    I.AllChildCount = AllChildCount);
    x && (F.SetMeshSize = SetMeshSize,
    F.SetMeshPoint = SetMeshPoint,
    I.MeshColumns = MeshColumns,
    I.MeshRows = MeshRows);
    m && (D.IsVisible = IsVisible,
    F.SetVisible = SetElementVisible,
    F.SetCSSStyle = SetElementCSSStyle,
    F.SetElemAttribute = SetElementAttribute,
    F.RemoveElemAttribute = RemoveElementAttribute);
    p && (D.IsFocused = IsElementFocused,
    F.SetFocus = SetElementFocus,
    F.SetBlur = SetElementBlur);
    r && (D.IsEnabled = IsElementEnabled,
    F.SetEnabled = SetElementEnabled);
    B && (D.OnCollision = OnCollision,
    D.IsOverlapping = IsOverlapping,
    D.IsOverlappingOffset = IsOverlappingOffset,
    b.FinishCollisionCondition = FinishCollisionCondition);
    c || (D.CompareInstanceVar = CompareInstanceVar,
    D.IsBoolInstanceVarSet = IsBoolInstanceVarSet,
    D.PickInstVarHiLow = PickInstVarHiLow,
    D.PickByUID = PickByUID,
    F.SetInstanceVar = SetInstanceVar,
    F.AddInstanceVar = AddInstanceVar,
    F.SubInstanceVar = SubInstanceVar,
    F.SetBoolInstanceVar = SetBoolInstanceVar,
    F.ToggleBoolInstanceVar = ToggleBoolInstanceVar,
    D.OnCreated = OnCreated,
    D.OnDestroyed = OnDestroyed,
    F.Destroy = Destroy,
    F.LoadFromJsonString || (F.LoadFromJsonString = LoadFromJsonString),
    I.AsJSON || (I.AsJSON = AsJSON),
    I.Count = Count,
    I.PickedCount = PickedCount,
    I.IID = GetIID,
    I.UID = GetUID,
    I.ObjectTypeName = ObjectTypeName);
    A && (I.TemplateName = TemplateName)
}
;
"use strict";
const C3$jscomp$170 = self.C3;
C3$jscomp$170.ScheduledWait = class extends C3$jscomp$170.DefendedBase {
    constructor(a) {
        super();
        this._eventSheetManager = a;
        this._type = "";
        this._time = -1;
        this._signalTag = "";
        this._isSignalled = !1;
        this._event = null;
        this._actIndex = 0;
        this._solModifiers = [];
        this._dynamicSolModifiers = null;
        this._sols = new Map;
        this._callingFunctionBlock = null;
        this._asyncId = -1;
        this._functionInnerLocalVars = this._functionParameters = null;
        this._shouldRelease = !1
    }
    Release() {
        this._type = "";
        this._time = -1;
        this._signalTag = "";
        this._functionInnerLocalVars = this._functionParameters = this._callingFunctionBlock = this._event = null;
        this._asyncId = -1;
        C3$jscomp$170.clearArray(this._solModifiers);
        this._dynamicSolModifiers && (this._dynamicSolModifiers.clear(),
        this._dynamicSolModifiers = null);
        for (const a of this._sols.values())
            a.Release();
        this._sols.clear()
    }
    _Init() {
        var a = this._eventSheetManager
          , b = a.GetRuntime().GetAllObjectClasses()
          , c = a.GetCurrentEventStackFrame();
        this._event = c.GetCurrentEvent();
        this._actIndex = c.GetActionIndex() + 1;
        if (c = a.FindFirstFunctionBlockParent(this._event))
            this._callingFunctionBlock = c,
            this._functionParameters = c.CaptureFunctionParameters(),
            this._functionInnerLocalVars = c._GetAllInnerLocalVariables().map(d => d.GetValue()),
            c.IsAsync() && (this._asyncId = c.PauseCurrentAsyncFunction());
        for (const d of b)
            if (b = d.GetCurrentSol(),
            !b.IsSelectAll() || this._event.HasSolModifier(d))
                this._solModifiers.push(d),
                this._sols.set(d, C3$jscomp$170.New(C3$jscomp$170.SolState, b));
        a = a.GetDynamicSolModifiersSet();
        this._dynamicSolModifiers = 0 < a.size ? a : null
    }
    InitTimer(a) {
        this._type = "timer";
        this._Init();
        this._time = this._eventSheetManager.GetRuntime().GetGameTime() + a
    }
    InitSignal(a) {
        this._type = "signal";
        this._Init();
        this._signalTag = a.toLowerCase()
    }
    InitPromise(a) {
        this._type = "promise";
        this._Init();
        a.then( () => this.SetSignalled()).catch(b => {
            console.warn("[C3 runtime] Promise rejected in 'Wait for previous actions to complete': ", b);
            this.SetSignalled()
        }
        )
    }
    IsTimer() {
        return "timer" === this._type
    }
    IsSignal() {
        return "signal" === this._type
    }
    IsPromise() {
        return "promise" === this._type
    }
    GetSignalTag() {
        return this._signalTag
    }
    IsSignalled() {
        return this._isSignalled
    }
    SetSignalled() {
        this._isSignalled = !0
    }
    _ShouldRun() {
        return this.IsTimer() ? this._time <= this._eventSheetManager.GetRuntime().GetGameTime() : this.IsSignalled()
    }
    _RestoreState(a) {
        a._Restore(this._event, this._actIndex);
        for (const [b,c] of this._sols.entries()) {
            const d = b.GetCurrentSol();
            c._Restore(d)
        }
        this._dynamicSolModifiers && a.SetDynamicSolModifiers([...this._dynamicSolModifiers]);
        if (a = this._callingFunctionBlock)
            a.SetFunctionParameters(this._functionParameters),
            a._GetAllInnerLocalVariables().map( (b, c) => b.SetValue(this._functionInnerLocalVars[c])),
            a.IsAsync() && a.ResumeAsyncFunction(this._asyncId)
    }
    _Run(a) {
        this._RestoreState(a);
        this._event._ResumeActionsAndSubEvents(a);
        this._callingFunctionBlock && this._callingFunctionBlock.IsAsync() && this._callingFunctionBlock.MaybeFinishAsyncFunctionCall(this._asyncId);
        this._eventSheetManager.ClearSol(this._solModifiers);
        this._shouldRelease = !0
    }
    async _DebugRun(a) {
        this._RestoreState(a);
        for (const b of this._event._DebugResumeActionsAndSubEvents(a))
            await this._eventSheetManager.GetRuntime().DebugBreak(b);
        this._callingFunctionBlock && this._callingFunctionBlock.IsAsync() && this._callingFunctionBlock.MaybeFinishAsyncFunctionCall(this._asyncId);
        this._eventSheetManager.ClearSol(this._solModifiers);
        this._shouldRelease = !0
    }
    ShouldRelease() {
        return this._shouldRelease
    }
    RemoveInstances(a) {
        for (const b of this._sols.values())
            b.RemoveInstances(a)
    }
    _SaveToJson() {
        const a = {}
          , b = {
            t: this._time,
            st: this._signalTag,
            s: this._isSignalled,
            ev: this._event.GetSID(),
            sm: this._solModifiers.map(c => c.GetSID()),
            dsm: this._dynamicSolModifiers ? [...this._dynamicSolModifiers].map(c => c.GetSID()) : null,
            sols: a
        };
        this._event._HasActionIndex(this._actIndex) && (b.act = this._event.GetActionAt(this._actIndex).GetSID());
        for (const [c,d] of this._sols)
            a[c.GetSID().toString()] = d._SaveToJson();
        return b
    }
    static _CreateFromJson(a, b) {
        const c = a.GetRuntime();
        var d = a.GetEventBlockBySID(b.ev);
        if (!d)
            return null;
        let e = 0;
        if (b.hasOwnProperty("act")) {
            var f = a.GetActionBySID(b.act);
            if (!f)
                return null;
            e = f.GetIndex()
        }
        f = C3$jscomp$170.New(C3$jscomp$170.ScheduledWait, a);
        f._time = b.t;
        f._type = -1 === f._time ? "signal" : "timer";
        f._signalTag = b.st;
        f._isSignalled = b.s;
        f._event = d;
        f._actIndex = e;
        for (var h of b.sm)
            (d = c.GetObjectClassBySID(h)) && f._solModifiers.push(d);
        if (Array.isArray(b.dsm))
            for (var l of b.dsm)
                if (h = c.GetObjectClassBySID(l))
                    f._dynamicSolModifiers || (f._dynamicSolModifiers = new Set),
                    f._dynamicSolModifiers.add(h);
        for (const [m,p] of Object.entries(b.sols))
            if (b = parseInt(m, 10),
            b = c.GetObjectClassBySID(b))
                l = C3$jscomp$170.New(C3$jscomp$170.SolState, null),
                l._LoadFromJson(a, p),
                f._sols.set(b, l);
        return f
    }
}
;
"use strict";
const C3$jscomp$171 = self.C3;
C3$jscomp$171.SolState = class extends C3$jscomp$171.DefendedBase {
    constructor(a) {
        super();
        this._objectClass = null;
        this._isSelectAll = !0;
        this._instances = [];
        a && (this._objectClass = a.GetObjectClass(),
        this._isSelectAll = a.IsSelectAll(),
        C3$jscomp$171.shallowAssignArray(this._instances, a._GetOwnInstances()))
    }
    Release() {
        this._objectClass = null;
        C3$jscomp$171.clearArray(this._instances)
    }
    _Restore(a) {
        a._SetSelectAll(this._isSelectAll);
        C3$jscomp$171.shallowAssignArray(a._GetOwnInstances(), this._instances)
    }
    RemoveInstances(a) {
        C3$jscomp$171.arrayRemoveAllInSet(this._instances, a)
    }
    _SaveToJson() {
        return {
            sa: this._isSelectAll,
            insts: this._instances.map(a => a.GetUID())
        }
    }
    _LoadFromJson(a, b) {
        a = a.GetRuntime();
        this._isSelectAll = !!b.sa;
        C3$jscomp$171.clearArray(this._instances);
        for (const c of b.insts)
            (b = a.GetInstanceByUID(c)) && this._instances.push(b)
    }
}
;
"use strict";
const C3$jscomp$172 = self.C3;
function GetNextParamMap(a, b) {
    let c = a.get(b);
    c || (c = new Map,
    a.set(b, c));
    return c
}
C3$jscomp$172.SDKPluginBase = class extends C3$jscomp$172.DefendedBase {
    constructor(a) {
        super();
        this._runtime = a.runtime;
        this._isSingleGlobal = !!a.isSingleGlobal;
        this._isWorldType = !!a.isWorld;
        this._isRotatable = !!a.isRotatable;
        this._mustPredraw = !!a.mustPredraw;
        this._hasEffects = !!a.hasEffects;
        this._supportsSceneGraph = !!a.supportsSceneGraph;
        this._supportsMesh = !!a.supportsMesh;
        this._isHTMLElementType = !!a.isHTMLElementType;
        this._is3d = !!a.is3d;
        this._sdkVersion = a.sdkVersion;
        this._singleGlobalObjectClass = null;
        this._boundACEMethodCache = new Map;
        this._boundACEMethodCache_1param = new Map;
        this._boundACEMethodCache_2params = new Map;
        this._boundACEMethodCache_3params = new Map;
        this._scriptInterfaceClass = a.scriptInterfaceClass;
        this._iPlugin = null
    }
    Release() {
        this._runtime = null
    }
    GetRuntime() {
        return this._runtime
    }
    OnCreate() {}
    GetConstructor() {
        return 2 <= this.GetSdkVersion() ? this._iPlugin.constructor : this.constructor
    }
    GetSdkVersion() {
        return this._sdkVersion
    }
    GetScriptInterfaceClass(a=!1) {
        let b = this._scriptInterfaceClass;
        a && "function" !== typeof b && 2 <= this.GetSdkVersion() && (b = globalThis.ISDKPluginBase);
        return b
    }
    IsSingleGlobal() {
        return this._isSingleGlobal
    }
    IsWorldType() {
        return this._isWorldType
    }
    IsHTMLElementType() {
        return this._isHTMLElementType
    }
    Is3D() {
        return this._is3d
    }
    IsRotatable() {
        return this._isRotatable
    }
    MustPreDraw() {
        return this._mustPredraw
    }
    HasEffects() {
        return this._hasEffects
    }
    SupportsSceneGraph() {
        return this._supportsSceneGraph
    }
    SupportsMesh() {
        return this._supportsMesh
    }
    _GetBoundACEMethod(a, b) {
        if (!b)
            throw Error("missing 'this' binding");
        let c = this._boundACEMethodCache.get(a);
        if (c)
            return c;
        c = a.bind(b);
        this._boundACEMethodCache.set(a, c);
        return c
    }
    _GetBoundACEMethod_1param(a, b, c) {
        if (!b)
            throw Error("missing 'this' binding");
        const d = GetNextParamMap(this._boundACEMethodCache_1param, a);
        let e = d.get(c);
        if (e)
            return e;
        e = a.bind(b, c);
        d.set(c, e);
        return e
    }
    _GetBoundACEMethod_2params(a, b, c, d) {
        if (!b)
            throw Error("missing 'this' binding");
        var e = GetNextParamMap(this._boundACEMethodCache_2params, a);
        e = GetNextParamMap(e, c);
        let f = e.get(d);
        if (f)
            return f;
        f = a.bind(b, c, d);
        e.set(d, f);
        return f
    }
    _GetBoundACEMethod_3params(a, b, c, d, e) {
        if (!b)
            throw Error("missing 'this' binding");
        var f = GetNextParamMap(this._boundACEMethodCache_3params, a);
        f = GetNextParamMap(f, c);
        f = GetNextParamMap(f, d);
        let h = f.get(e);
        if (h)
            return h;
        h = a.bind(b, c, d, e);
        f.set(e, h);
        return h
    }
    _SetSingleGlobalObjectClass(a) {
        if (!this.IsSingleGlobal())
            throw Error("must be single-global plugin");
        this._singleGlobalObjectClass = a
    }
    GetSingleGlobalObjectClass() {
        if (!this.IsSingleGlobal())
            throw Error("must be single-global plugin");
        return this._singleGlobalObjectClass
    }
    GetSingleGlobalInstance() {
        if (!this.IsSingleGlobal())
            throw Error("must be single-global plugin");
        return this._singleGlobalObjectClass.GetSingleGlobalInstance()
    }
    _InitScriptInterface() {
        const a = this.GetSdkVersion();
        C3$jscomp$172.AddonManager._PushInitObject(this, a);
        const b = this.GetScriptInterfaceClass(!0);
        if (b) {
            if (this._iPlugin = new b,
            !(this._iPlugin instanceof self.IPlugin))
                throw new TypeError("plugin class must derive from IPlugin");
        } else
            this._iPlugin = new self.IPlugin;
        C3$jscomp$172.AddonManager._PopInitObject(a)
    }
    GetIPlugin() {
        return this._iPlugin
    }
}
;
"use strict";
const C3$jscomp$173 = self.C3;
C3$jscomp$173.SDKDOMPluginBase = class extends C3$jscomp$173.SDKPluginBase {
    constructor(a, b) {
        super(a);
        this._domComponentId = b;
        this._nextElementId = 0;
        this._instMap = new Map;
        this.AddElementMessageHandler("elem-focused", c => c._OnElemFocused());
        this.AddElementMessageHandler("elem-blurred", c => {
            c && c._OnElemBlurred()
        }
        )
    }
    Release() {
        super.Release()
    }
    _AddElement(a) {
        const b = this._nextElementId++;
        this._instMap.set(b, a);
        return b
    }
    _RemoveElement(a) {
        this._instMap.delete(a)
    }
    AddElementMessageHandler(a, b) {
        this._runtime.AddDOMComponentMessageHandler(this._domComponentId, a, c => {
            const d = this._instMap.get(c.elementId);
            b(d, c)
        }
        )
    }
}
;
"use strict";
const C3$jscomp$174 = self.C3;
C3$jscomp$174.SDKTypeBase = class extends C3$jscomp$174.DefendedBase {
    constructor(a) {
        super();
        this._objectClass = a;
        this._runtime = a.GetRuntime();
        this._plugin = a.GetPlugin()
    }
    Release() {
        this._plugin = this._runtime = this._objectClass = null
    }
    GetObjectClass() {
        return this._objectClass
    }
    GetRuntime() {
        return this._runtime
    }
    GetPlugin() {
        return this._plugin
    }
    GetImageInfo() {
        return this._objectClass.GetImageInfo()
    }
    OnCreate() {}
    FinishCondition(a) {}
    BeforeRunAction(a) {}
    AfterRunAction(a) {}
    LoadTextures(a) {}
    ReleaseTextures() {}
    OnDynamicTextureLoadComplete() {}
    PreloadTexturesWithInstances(a) {}
    LoadTilemapData() {}
    GetScriptInterfaceClass() {
        return null
    }
    DispatchScriptEvent(a, b, c) {
        a = C3$jscomp$174.New(C3$jscomp$174.Event, a, b);
        a.objectClass = this;
        c && Object.assign(a, c);
        this.GetObjectClass().DispatchUserScriptEvent(a)
    }
}
;
"use strict";
const C3$jscomp$175 = self.C3;
C3$jscomp$175.SDKInstanceBase = class extends C3$jscomp$175.DefendedBase {
    constructor(a, b) {
        super();
        this._inst = a;
        this._domComponentId = b;
        this._wrapperComponentId = null;
        this._runtime = a.GetRuntime();
        this._objectClass = this._inst.GetObjectClass();
        this._sdkType = this._objectClass.GetSdkType();
        this._tick2Func = this._tickFunc = null;
        this._isTicking2 = this._isTicking = !1;
        this._disposables = null;
        this._wasReleased = !1
    }
    Release() {
        this._wasReleased = !0;
        this._StopTicking();
        this._StopTicking2();
        this._tick2Func = this._tickFunc = null;
        this._disposables && (this._disposables.Release(),
        this._disposables = null);
        this._sdkType = this._objectClass = this._runtime = this._inst = null
    }
    WasReleased() {
        return this._wasReleased
    }
    GetInstance() {
        return this._inst
    }
    GetRuntime() {
        return this._runtime
    }
    GetObjectClass() {
        return this._objectClass
    }
    GetPlugin() {
        return this._sdkType.GetPlugin()
    }
    GetSdkType() {
        return this._sdkType
    }
    GetScriptInterface() {
        return this._inst.GetInterfaceClass()
    }
    Trigger(a) {
        return this._runtime.Trigger(a, this._inst, null)
    }
    DebugTrigger(a) {
        return this._runtime.DebugTrigger(a, this._inst, null)
    }
    TriggerAsync(a) {
        return this._runtime.TriggerAsync(a, this._inst, null)
    }
    FastTrigger(a, b) {
        return this._runtime.FastTrigger(a, this._inst, b)
    }
    DebugFastTrigger(a, b) {
        return this._runtime.DebugFastTrigger(a, this._inst, b)
    }
    ScheduleTriggers(a) {
        return this._runtime.ScheduleTriggers(a)
    }
    AddDOMMessageHandler(a, b) {
        this._runtime.AddDOMComponentMessageHandler(this._domComponentId, a, b)
    }
    AddDOMMessageHandlers(a) {
        for (const [b,c] of a)
            this.AddDOMMessageHandler(b, c)
    }
    PostToDOM(a, b) {
        this._runtime.PostComponentMessageToDOM(this._domComponentId, a, b)
    }
    PostToDOMAsync(a, b) {
        return this._runtime.PostComponentMessageToDOMAsync(this._domComponentId, a, b)
    }
    _PostToDOMMaybeSync(a, b) {
        if (this._runtime.IsInWorker())
            this.PostToDOM(a, b);
        else
            return window.c3_runtimeInterface._OnMessageFromRuntime({
                type: "event",
                component: this._domComponentId,
                handler: a,
                data: b,
                responseId: null
            })
    }
    SetWrapperExtensionComponentId(a) {
        if (!a)
            throw Error("cannot set empty component id");
        this._wrapperComponentId = a
    }
    IsWrapperExtensionAvailable() {
        if (!this._wrapperComponentId)
            throw Error("wrapper extension component id not set");
        return this._runtime.HasWrapperComponentId(this._wrapperComponentId)
    }
    AddWrapperExtensionMessageHandler(a, b) {
        if (!this._wrapperComponentId)
            throw Error("wrapper extension component id not set");
        this._runtime.AddWrapperExtensionMessageHandler(this._wrapperComponentId, a, b)
    }
    AddWrapperExtensionMessageHandlers(a) {
        for (const [b,c] of a)
            this.AddWrapperExtensionMessageHandler(b, c)
    }
    SendWrapperExtensionMessage(a, b) {
        if (!this._wrapperComponentId)
            throw Error("wrapper extension component id not set");
        this._runtime.SendWrapperExtensionMessage(this._wrapperComponentId, a, b)
    }
    SendWrapperExtensionMessageAsync(a, b) {
        if (!this._wrapperComponentId)
            throw Error("wrapper extension component id not set");
        return this._runtime.SendWrapperExtensionMessageAsync(this._wrapperComponentId, a, b)
    }
    Tick() {}
    Tick2() {}
    _StartTicking() {
        this._isTicking || (this._tickFunc || (this._tickFunc = () => this.Tick()),
        this._runtime.Dispatcher().addEventListener("tick", this._tickFunc),
        this._isTicking = !0)
    }
    _StopTicking() {
        this._isTicking && (this._runtime.Dispatcher().removeEventListener("tick", this._tickFunc),
        this._isTicking = !1)
    }
    IsTicking() {
        return this._isTicking
    }
    _StartTicking2() {
        this._isTicking2 || (this._tick2Func || (this._tick2Func = () => this.Tick2()),
        this._runtime.Dispatcher().addEventListener("tick2", this._tick2Func),
        this._isTicking2 = !0)
    }
    _StopTicking2() {
        this._isTicking2 && (this._runtime.Dispatcher().removeEventListener("tick2", this._tick2Func),
        this._isTicking2 = !1)
    }
    IsTicking2() {
        return this._isTicking2
    }
    GetDebuggerProperties() {
        return []
    }
    SaveToJson() {
        return null
    }
    LoadFromJson(a) {}
    GetPropertyValueByIndex(a) {}
    SetPropertyValueByIndex(a, b) {}
    OffsetPropertyValueByIndex(a, b, c) {
        if (0 !== b) {
            var d = this.GetPropertyValueByIndex(a);
            if ("number" !== typeof d)
                throw Error("expected number");
            this.SetPropertyValueByIndex(a, d + b, c)
        }
    }
    SetPropertyColorOffsetValueByIndex(a, b, c, d) {}
    CallAction(a, ...b) {
        a.call(this, ...b)
    }
    CallExpression(a, ...b) {
        return a.call(this, ...b)
    }
    GetScriptInterfaceClass() {
        return null
    }
    DispatchScriptEvent(a, b, c) {
        if (this._inst.HasScriptInterface()) {
            var d = this.GetScriptInterface();
            a = C3$jscomp$175.New(C3$jscomp$175.Event, a, b);
            a.instance = d;
            c && Object.assign(a, c);
            d.dispatchEvent(a)
        }
    }
    MustPreDraw() {
        return !1
    }
}
;
"use strict";
const C3$jscomp$176 = self.C3;
C3$jscomp$176.SDKWorldInstanceBase = class extends C3$jscomp$176.SDKInstanceBase {
    constructor(a, b) {
        super(a, b);
        this._worldInfo = a.GetWorldInfo();
        this._renderercontextrestored_handler = this._renderercontextlost_handler = null
    }
    Release() {
        if (this._renderercontextlost_handler) {
            const a = this._runtime.Dispatcher();
            a.removeEventListener("renderercontextlost", this._renderercontextlost_handler);
            a.removeEventListener("renderercontextrestored", this._renderercontextrestored_handler);
            this._renderercontextrestored_handler = this._renderercontextlost_handler = null
        }
        this._worldInfo = null;
        super.Release()
    }
    HandleWebGLContextLoss() {
        this.HandleRendererContextLoss()
    }
    OnWebGLContextLost() {}
    OnWebGLContextRestored() {}
    HandleRendererContextLoss() {
        if (!this._renderercontextlost_handler) {
            this._renderercontextlost_handler = () => this.OnRendererContextLost();
            this._renderercontextrestored_handler = () => this.OnRendererContextRestored();
            var a = this._runtime.Dispatcher();
            a.addEventListener("renderercontextlost", this._renderercontextlost_handler);
            a.addEventListener("renderercontextrestored", this._renderercontextrestored_handler)
        }
    }
    OnRendererContextLost() {
        this.OnWebGLContextLost()
    }
    OnRendererContextRestored() {
        this.OnWebGLContextRestored()
    }
    GetWorldInfo() {
        return this._worldInfo
    }
    IsOriginalSizeKnown() {
        return !1
    }
    GetOriginalWidth() {
        if (!this.IsOriginalSizeKnown())
            throw Error("original size not known");
        const a = this.GetCurrentImageInfo();
        if (a)
            return a.GetWidth()
    }
    GetOriginalHeight() {
        if (!this.IsOriginalSizeKnown())
            throw Error("original size not known");
        const a = this.GetCurrentImageInfo();
        if (a)
            return a.GetHeight()
    }
    GetCurrentImageInfo() {
        return null
    }
    GetCurrentSurfaceSize() {
        var a = this.GetCurrentImageInfo();
        return a && (a = a.GetTexture()) ? [a.GetWidth(), a.GetHeight()] : [100, 100]
    }
    GetCurrentTexRect() {
        const a = this.GetCurrentImageInfo();
        return a ? a.GetTexRect() : null
    }
    GetCurrentTexQuad() {
        const a = this.GetCurrentImageInfo();
        return a ? a.GetTexQuad() : null
    }
    IsCurrentTexRotated() {
        const a = this.GetCurrentImageInfo();
        return a ? a.IsRotated() : !1
    }
    GetImagePoint(a) {
        a = this._inst.GetWorldInfo();
        return [a.GetX(), a.GetY(), a.GetTotalZElevation()]
    }
    LoadTilemapData(a, b, c) {}
    TestPointOverlapTile(a, b) {}
    RendersToOwnZPlane() {
        return !0
    }
}
;
"use strict";
const C3$jscomp$177 = self.C3
  , tempRect$jscomp$6 = C3$jscomp$177.New(C3$jscomp$177.Rect);
C3$jscomp$177.SDKDOMInstanceBase = class extends C3$jscomp$177.SDKWorldInstanceBase {
    constructor(a, b) {
        super(a, b);
        this._elementId = this.GetPlugin()._AddElement(this);
        this._isElementShowing = !0;
        this._autoFontSize = this._elemHasFocus = !1;
        this._autoFontSizeOffset = -.2;
        this._lastRect = C3$jscomp$177.New(C3$jscomp$177.Rect, 0, 0, -1, -1);
        a = this._runtime.GetCanvasManager();
        this._lastWindowWidth = a.GetLastWidth();
        this._lastWindowHeight = a.GetLastHeight();
        this._lastHTMLZIndex = this._lastHTMLIndex = -1;
        this._isPendingUpdateState = !1;
        this._StartTicking()
    }
    Release() {
        this.GetPlugin()._RemoveElement(this._elementId);
        this.PostToDOMElement("destroy");
        this._elementId = -1;
        super.Release()
    }
    _GetElementInDOMMode() {
        if (this._runtime.IsInWorker())
            throw Error("not valid in worker mode");
        return this._PostToDOMElementMaybeSync("get-element")
    }
    PostToDOMElement(a, b) {
        b || (b = {});
        b.elementId = this._elementId;
        this.PostToDOM(a, b)
    }
    _PostToDOMElementMaybeSync(a, b) {
        b || (b = {});
        b.elementId = this._elementId;
        return this._PostToDOMMaybeSync(a, b)
    }
    PostToDOMElementAsync(a, b) {
        b || (b = {});
        b.elementId = this._elementId;
        return this.PostToDOMAsync(a, b)
    }
    CreateElement(a) {
        a || (a = {});
        const b = this.GetWorldInfo();
        a.elementId = this._elementId;
        a.isVisible = b.IsVisible();
        a.htmlIndex = b.GetLayer().GetHTMLIndex();
        a.htmlZIndex = b.GetHTMLZIndex();
        Object.assign(a, this.GetElementState());
        this._isElementShowing = !!a.isVisible;
        this._PostToDOMMaybeSync("create", a);
        this._UpdatePosition(!0)
    }
    SetElementVisible(a) {
        a = !!a;
        this._isElementShowing !== a && (this._isElementShowing = a,
        this.PostToDOMElement("set-visible", {
            isVisible: a
        }))
    }
    Tick() {
        this._UpdatePosition(!1)
    }
    _ShouldPreserveElement() {
        const a = this._runtime.GetCanvasManager().GetFullscreenMode();
        return "Android" === C3$jscomp$177.Platform.OS && ("scale-inner" === a || "scale-outer" === a || "crop" === a)
    }
    _UpdatePosition(a) {
        if (!this.GetInstance().IsDestroyed()) {
            var b = this.GetWorldInfo()
              , c = b.GetLayer()
              , d = b.GetBoundingBox()
              , [e,f] = c.LayerToCanvasCss(d.getLeft(), d.getTop())
              , [h,l] = c.LayerToCanvasCss(d.getRight(), d.getBottom())
              , m = this._runtime.GetCanvasManager();
            d = m.GetCssWidth();
            var p = m.GetCssHeight();
            b.IsVisible() && c.IsVisible() ? !this._ShouldPreserveElement() && (0 >= h || 0 >= l || e >= d || f >= p) ? this.SetElementVisible(!1) : (tempRect$jscomp$6.set(e, f, h, l),
            d = m.GetLastWidth(),
            p = m.GetLastHeight(),
            m = c.GetHTMLIndex(),
            b = b.GetHTMLZIndex(),
            !a && tempRect$jscomp$6.equals(this._lastRect) && this._lastWindowWidth === d && this._lastWindowHeight === p && this._lastHTMLIndex === m && this._lastHTMLZIndex === b ? this.SetElementVisible(!0) : (this._lastRect.copy(tempRect$jscomp$6),
            this._lastWindowWidth = d,
            this._lastWindowHeight = p,
            this._lastHTMLIndex = m,
            this._lastHTMLZIndex = b,
            this.SetElementVisible(!0),
            a = null,
            this._autoFontSize && (a = c.GetDisplayScale() + this._autoFontSizeOffset),
            this.PostToDOMElement("update-position", {
                left: Math.round(this._lastRect.getLeft()),
                top: Math.round(this._lastRect.getTop()),
                width: Math.round(this._lastRect.width()),
                height: Math.round(this._lastRect.height()),
                htmlIndex: m,
                htmlZIndex: b,
                fontSize: a
            }))) : this.SetElementVisible(!1)
        }
    }
    FocusElement() {
        this._PostToDOMElementMaybeSync("focus", {
            focus: !0
        })
    }
    BlurElement() {
        this._PostToDOMElementMaybeSync("focus", {
            focus: !1
        })
    }
    _OnElemFocused() {
        this._elemHasFocus = !0
    }
    _OnElemBlurred() {
        this._elemHasFocus = !1
    }
    IsElementFocused() {
        return this._elemHasFocus
    }
    SetElementCSSStyle(a, b) {
        this.PostToDOMElement("set-css-style", {
            prop: C3$jscomp$177.CSSToCamelCase(a),
            val: b
        })
    }
    SetElementAttribute(a, b) {
        this.PostToDOMElement("set-attribute", {
            name: a,
            val: b
        })
    }
    RemoveElementAttribute(a) {
        this.PostToDOMElement("remove-attribute", {
            name: a
        })
    }
    UpdateElementState() {
        this._isPendingUpdateState || (this._isPendingUpdateState = !0,
        Promise.resolve().then( () => {
            this._isPendingUpdateState = !1;
            this.PostToDOMElement("update-state", this.GetElementState())
        }
        ))
    }
    GetElementState() {}
    GetElementId() {
        return this._elementId
    }
}
;
"use strict";
const C3$jscomp$178 = self.C3
  , IBehavior$jscomp$1 = self.IBehavior;
C3$jscomp$178.SDKBehaviorBase = class extends C3$jscomp$178.DefendedBase {
    constructor(a) {
        super();
        this._runtime = a.runtime;
        this._myObjectClasses = C3$jscomp$178.New(C3$jscomp$178.ArraySet);
        this._myInstances = C3$jscomp$178.New(C3$jscomp$178.ArraySet);
        this._sdkVersion = a.sdkVersion;
        this._scriptInterfaceClass = a.scriptInterfaceClass;
        this._iBehavior = null
    }
    Release() {
        this._myInstances.Release();
        this._myObjectClasses.Release();
        this._runtime = null
    }
    GetRuntime() {
        return this._runtime
    }
    OnCreate() {}
    GetSdkVersion() {
        return this._sdkVersion
    }
    GetScriptInterfaceClass(a=!1) {
        let b = this._scriptInterfaceClass;
        a && "function" !== typeof b && 2 <= this.GetSdkVersion() && (b = globalThis.ISDKBehaviorBase);
        return b
    }
    _AddObjectClass(a) {
        this._myObjectClasses.Add(a)
    }
    GetObjectClasses() {
        return this._myObjectClasses.GetArray()
    }
    _AddInstance(a) {
        this._myInstances.Add(a)
    }
    _RemoveInstance(a) {
        this._myInstances.Delete(a)
    }
    GetInstances() {
        return this._myInstances.GetArray()
    }
    _InitScriptInterface() {
        const a = this.GetSdkVersion();
        C3$jscomp$178.AddonManager._PushInitObject(this, a);
        const b = this.GetScriptInterfaceClass(!0);
        if (b) {
            if (this._iBehavior = new b,
            !(this._iBehavior instanceof IBehavior$jscomp$1))
                throw new TypeError("behavior class must derive from IBehavior");
        } else
            this._iBehavior = new IBehavior$jscomp$1;
        C3$jscomp$178.AddonManager._PopInitObject(a)
    }
    GetIBehavior() {
        return this._iBehavior
    }
}
;
"use strict";
const C3$jscomp$179 = self.C3;
C3$jscomp$179.SDKBehaviorTypeBase = class extends C3$jscomp$179.DefendedBase {
    constructor(a) {
        super();
        this._runtime = a.GetRuntime();
        this._behaviorType = a;
        this._objectClass = a.GetObjectClass();
        this._behavior = a.GetBehavior();
        this._behavior._AddObjectClass(this._objectClass)
    }
    Release() {
        this._behavior = this._objectClass = this._behaviorType = this._runtime = null
    }
    OnCreate() {}
    GetBehaviorType() {
        return this._behaviorType
    }
    GetObjectClass() {
        return this._objectClass
    }
    GetRuntime() {
        return this._runtime
    }
    GetBehavior() {
        return this._behavior
    }
}
;
"use strict";
const C3$jscomp$180 = self.C3;
C3$jscomp$180.SDKBehaviorInstanceBase = class extends C3$jscomp$180.DefendedBase {
    constructor(a, b) {
        super();
        this._behInst = a;
        this._domComponentId = b;
        this._inst = a.GetObjectInstance();
        this._runtime = a.GetRuntime();
        this._behaviorType = a.GetBehaviorType();
        this._sdkType = this._behaviorType.GetSdkType();
        this._isPostTicking = this._isTicking2 = this._isTicking = !1;
        this._disposables = null
    }
    Release() {
        this._StopTicking();
        this._StopTicking2();
        this._StopPostTicking();
        this._disposables && (this._disposables.Release(),
        this._disposables = null);
        this._sdkType = this._behaviorType = this._runtime = this._inst = this._behInst = null
    }
    GetBehavior() {
        return this._behaviorType.GetBehavior()
    }
    GetBehaviorInstance() {
        return this._behInst
    }
    GetObjectInstance() {
        return this._inst
    }
    GetObjectClass() {
        return this._inst.GetObjectClass()
    }
    GetWorldInfo() {
        return this._inst.GetWorldInfo()
    }
    GetRuntime() {
        return this._runtime
    }
    GetBehaviorType() {
        return this._behaviorType
    }
    GetSdkType() {
        return this._sdkType
    }
    GetScriptInterface() {
        return this._behInst.GetScriptInterface()
    }
    Trigger(a) {
        return this._runtime.Trigger(a, this._inst, this._behaviorType)
    }
    DebugTrigger(a) {
        return this._runtime.DebugTrigger(a, this._inst, this._behaviorType)
    }
    TriggerAsync(a) {
        return this._runtime.TriggerAsync(a, this._inst, this._behaviorType)
    }
    PostCreate() {}
    Tick() {}
    Tick2() {}
    PostTick() {}
    _StartTicking() {
        this._isTicking || (this._runtime._AddBehInstToTick(this),
        this._isTicking = !0)
    }
    _StopTicking() {
        this._isTicking && (this._runtime._RemoveBehInstToTick(this),
        this._isTicking = !1)
    }
    IsTicking() {
        return this._isTicking
    }
    _StartTicking2() {
        this._isTicking2 || (this._runtime._AddBehInstToTick2(this),
        this._isTicking2 = !0)
    }
    _StopTicking2() {
        this._isTicking2 && (this._runtime._RemoveBehInstToTick2(this),
        this._isTicking2 = !1)
    }
    IsTicking2() {
        return this._isTicking2
    }
    _StartPostTicking() {
        this._isPostTicking || (this._runtime._AddBehInstToPostTick(this),
        this._isPostTicking = !0)
    }
    _StopPostTicking() {
        this._isPostTicking && (this._runtime._RemoveBehInstToPostTick(this),
        this._isPostTicking = !1)
    }
    IsPostTicking() {
        return this._isPostTicking
    }
    GetDebuggerProperties() {
        return []
    }
    AddDOMMessageHandler(a, b) {
        this._runtime.AddDOMComponentMessageHandler(this._domComponentId, a, b)
    }
    OnSpriteFrameChanged(a, b) {}
    SaveToJson() {
        return null
    }
    LoadFromJson(a) {}
    GetPropertyValueByIndex(a) {}
    SetPropertyValueByIndex(a, b) {}
    OffsetPropertyValueByIndex(a, b) {
        if (0 !== b) {
            var c = this.GetPropertyValueByIndex(a);
            if ("number" !== typeof c)
                throw Error("expected number");
            this.SetPropertyValueByIndex(a, c + b)
        }
    }
    SetPropertyColorOffsetValueByIndex(a, b, c, d) {}
    CallAction(a, ...b) {
        a.call(this, ...b)
    }
    CallExpression(a, ...b) {
        return a.call(this, ...b)
    }
    GetScriptInterfaceClass() {
        return null
    }
    DispatchScriptEvent(a, b, c) {
        if (this._behInst.HasScriptInterface()) {
            var d = this.GetScriptInterface();
            a = C3$jscomp$180.New(C3$jscomp$180.Event, a, b);
            a.behaviorInstance = d;
            a.instance = d.instance;
            c && Object.assign(a, c);
            d.dispatchEvent(a)
        }
    }
}
;
"use strict";
const C3$jscomp$181 = self.C3;
C3$jscomp$181.Plugins = {};
C3$jscomp$181.Behaviors = {};
const internalApiToken$jscomp$14 = C3$jscomp$181._GetInternalAPIToken();
function ValidateInternalAPIToken(a) {
    if (a !== internalApiToken$jscomp$14)
        throw Error("invalid internal API token");
}
let initObjectStack = []
  , initObjectStack2 = []
  , initPropertiesStack = []
  , originalPushInitObject = null
  , originalPopInitObject = null
  , originalGetInitObject = null
  , originalGetInitObject2 = null;
const pluginsByCtor = new Map
  , behaviorsByCtor = new Map;
C3$jscomp$181.AddonManager = class extends C3$jscomp$181.DefendedBase {
    constructor(a, b) {
        super();
        this._runtime = a;
        this._allPlugins = [];
        this._systemPlugin = null;
        this._allBehaviors = [];
        this._delayCreateBehaviors = new Map;
        this._jumpthruBehavior = this._solidBehavior = null;
        this._wrapperComponentIds = new Set(b)
    }
    CreatePlugin(a) {
        const b = a[19]
          , c = this._runtime.GetObjectReference(a[0]);
        if (!c)
            throw Error("missing plugin");
        C3$jscomp$181.AddCommonACEs(a, c);
        a = C3$jscomp$181.New(2 <= b ? C3$jscomp$181.SDKPluginBase : c, {
            runtime: this._runtime,
            isSingleGlobal: a[1],
            isWorld: a[2],
            isRotatable: a[5],
            hasEffects: a[8],
            mustPredraw: a[9],
            supportsSceneGraph: a[13],
            supportsMesh: a[14],
            isHTMLElementType: a[17],
            is3d: a[18],
            sdkVersion: b,
            scriptInterfaceClass: 2 <= b ? c : null
        });
        a.OnCreate();
        this._allPlugins.push(a);
        pluginsByCtor.set(c, a)
    }
    CreateSystemPlugin() {
        this._systemPlugin = C3$jscomp$181.New(C3$jscomp$181.Plugins.System, {
            runtime: this._runtime,
            isSingleGlobal: !0
        });
        this._systemPlugin.OnCreate()
    }
    CreateBehavior(a) {
        const b = a[1]
          , c = this._runtime.GetObjectReference(a[0]);
        if (!c)
            throw Error("missing behavior");
        this._delayCreateBehaviors.set(c, () => {
            const d = C3$jscomp$181.New(2 <= b ? C3$jscomp$181.SDKBehaviorBase : c, {
                runtime: this._runtime,
                sdkVersion: b,
                scriptInterfaceClass: 2 <= b ? c : null
            });
            d.OnCreate();
            this._allBehaviors.push(d);
            behaviorsByCtor.set(c, d);
            !this._solidBehavior && C3$jscomp$181.Behaviors.solid && d instanceof C3$jscomp$181.Behaviors.solid ? this._solidBehavior = d : !this._jumpthruBehavior && C3$jscomp$181.Behaviors.jumpthru && d instanceof C3$jscomp$181.Behaviors.jumpthru && (this._jumpthruBehavior = d);
            d._InitScriptInterface()
        }
        )
    }
    _DelayCreateBehavior(a) {
        const b = this._delayCreateBehaviors.get(a);
        b && (b(),
        this._delayCreateBehaviors.delete(a))
    }
    static _PushInitObject(a, b=1) {
        if (C3$jscomp$181.AddonManager._PushInitObject !== originalPushInitObject)
            throw Error("invalid method");
        1 === b && initObjectStack.push(a);
        initObjectStack2.push(a)
    }
    static _PopInitObject(a=1) {
        if (C3$jscomp$181.AddonManager._PopInitObject !== originalPopInitObject)
            throw Error("invalid method");
        1 === a && initObjectStack.pop();
        initObjectStack2.pop()
    }
    static _GetInitObject() {
        if (C3$jscomp$181.AddonManager._GetInitObject !== originalGetInitObject)
            throw Error("invalid method");
        if (0 === initObjectStack.length)
            throw Error("no init object set");
        return initObjectStack.at(-1)
    }
    static _GetInitObject2(a) {
        if (C3$jscomp$181.AddonManager._GetInitObject2 !== originalGetInitObject2)
            throw Error("invalid method");
        ValidateInternalAPIToken(a);
        if (0 === initObjectStack2.length)
            throw Error("no init object set");
        return initObjectStack2.at(-1)
    }
    static _PushInitProperties(a) {
        initPropertiesStack.push(a)
    }
    static _PopInitProperties() {
        initPropertiesStack.pop()
    }
    static _GetInitProperties() {
        if (0 === initPropertiesStack.length)
            throw Error("no init properties set");
        return initPropertiesStack.at(-1)
    }
    _InitAddonScriptInterfaces() {
        for (const a of this._allPlugins)
            a._InitScriptInterface()
    }
    static GetPluginByConstructorFunction(a) {
        return pluginsByCtor.get(a) || null
    }
    static GetBehaviorByConstructorFunction(a) {
        return behaviorsByCtor.get(a) || null
    }
    GetSystemPlugin() {
        return this._systemPlugin
    }
    GetSolidBehavior() {
        return this._solidBehavior
    }
    GetJumpthruBehavior() {
        return this._jumpthruBehavior
    }
    HasWrapperComponentId(a) {
        return this._wrapperComponentIds.has(a)
    }
}
;
originalPushInitObject = C3$jscomp$181.AddonManager._PushInitObject;
originalPopInitObject = C3$jscomp$181.AddonManager._PopInitObject;
originalGetInitObject = C3$jscomp$181.AddonManager._GetInitObject;
originalGetInitObject2 = C3$jscomp$181.AddonManager._GetInitObject2;
"use strict";
const C3$jscomp$182 = self.C3
  , allImageInfos = new Set;
C3$jscomp$182.ImageInfo = class extends C3$jscomp$182.DefendedBase {
    constructor() {
        super();
        this._generation = 0;
        this._url = "";
        this._height = this._width = this._offsetY = this._offsetX = this._size = 0;
        this._hasMetaData = this._isRotated = !1;
        this._imageAsset = null;
        this._textureState = "";
        this._rcTex = C3$jscomp$182.New(C3$jscomp$182.Rect);
        this._quadTex = C3$jscomp$182.New(C3$jscomp$182.Quad);
        this._blobUrl = "";
        this._iImageInfo = new self.IImageInfo(this);
        allImageInfos.add(this)
    }
    Release() {
        this.ReleaseTexture();
        this._imageAsset && 0 === this._imageAsset.GetRefCount() && this._imageAsset.Release();
        this._imageAsset = null;
        allImageInfos.delete(this);
        this.ReleaseBlobURL()
    }
    static OnRendererContextLost() {
        for (const a of allImageInfos)
            a._textureState = "",
            a._rcTex.set(0, 0, 0, 0),
            a._quadTex.setFromRect(a._rcTex)
    }
    LoadData(a) {
        this._url = a[0];
        this._size = a[1];
        this._offsetX = a[2];
        this._offsetY = a[3];
        this._width = a[4];
        this._height = a[5];
        this._isRotated = a[6];
        this._hasMetaData = !0
    }
    LoadDynamicAsset(a, b) {
        if (this._imageAsset)
            throw Error("already loaded asset");
        this._url = b;
        const c = {};
        C3$jscomp$182.IsAbsoluteURL(b) && (c.loadPolicy = "remote");
        this.LoadAsset(a, c);
        return this._imageAsset.Load()
    }
    LoadDynamicBlobAsset(a, b) {
        if (this._imageAsset)
            throw Error("already loaded asset");
        this._url = "";
        this._size = b.size;
        this._imageAsset = C3$jscomp$182.New(C3$jscomp$182.ImageAsset, a.GetAssetManager(), {
            blob: b,
            size: this._size,
            loadPolicy: "local"
        })
    }
    ReplaceWith(a) {
        if (a === this)
            throw Error("cannot replace with self");
        this._generation++;
        this.ReleaseTexture();
        this._url = a._url;
        this._size = a._size;
        this._offsetX = a._offsetX;
        this._offsetY = a._offsetY;
        this._width = a._width;
        this._height = a._height;
        this._isRotated = a._isRotated;
        this._hasMetaData = a._hasMetaData;
        this._imageAsset = a._imageAsset;
        this._textureState = a._textureState;
        this._rcTex = a._rcTex;
        this._quadTex = a._quadTex;
        this.ReleaseBlobURL()
    }
    GetURL() {
        return this._url
    }
    GetSize() {
        return this._size
    }
    GetOffsetX() {
        return this._offsetX
    }
    GetOffsetY() {
        return this._offsetY
    }
    IsRotated() {
        return this._isRotated
    }
    GetWidth() {
        return this._width
    }
    GetHeight() {
        return this._height
    }
    GetSheetWidth() {
        return this._imageAsset.GetWidth()
    }
    GetSheetHeight() {
        return this._imageAsset.GetHeight()
    }
    LoadAsset(a, b) {
        if (this._imageAsset)
            throw Error("already got asset");
        b = Object.assign({}, b, {
            url: this.GetURL(),
            size: this.GetSize()
        });
        this._imageAsset = a.LoadImage(b)
    }
    IsLoaded() {
        return this._imageAsset && this._imageAsset.IsLoaded()
    }
    async LoadStaticTexture(a, b) {
        if (!this._imageAsset)
            throw Error("no asset");
        if (this._textureState)
            throw Error("already loaded texture");
        const c = this._generation;
        this._textureState = "loading";
        a = await this._imageAsset.LoadStaticTexture(a, b);
        if (this._generation !== c)
            return null;
        if (!a)
            return this._textureState = "",
            null;
        this._textureState = "loaded";
        this._hasMetaData || (this._width = a.GetWidth(),
        this._height = a.GetHeight(),
        this._hasMetaData = !0);
        this._rcTex.set(this._offsetX, this._offsetY, this._offsetX + (this._isRotated ? this._height : this._width), this._offsetY + (this._isRotated ? this._width : this._height));
        this._rcTex.divide(a.GetWidth(), a.GetHeight());
        this._quadTex.setFromRect(this._rcTex);
        this._isRotated && this._quadTex.rotatePointsAnticlockwise();
        return a
    }
    ReleaseTexture() {
        this._textureState && (this._imageAsset && this._imageAsset.ReleaseTexture(),
        this._textureState = "",
        this._rcTex.set(0, 0, 0, 0),
        this._quadTex.setFromRect(this._rcTex))
    }
    GetTexture() {
        return this._imageAsset && "loaded" === this._textureState ? this._imageAsset.GetTexture() : null
    }
    GetTexRect() {
        return this._rcTex
    }
    GetTexQuad() {
        return this._quadTex
    }
    GetIImageInfo() {
        return this._iImageInfo
    }
    GetImageAsset() {
        return this._imageAsset
    }
    async ExtractImageToCanvas(a) {
        a || (a = await this._imageAsset.LoadToDrawable());
        const b = C3$jscomp$182.CreateCanvas(this._width, this._height)
          , c = b.getContext("2d");
        this._isRotated ? (c.rotate(Math.PI / -2),
        c.translate(-this._height, 0),
        c.drawImage(a, this._offsetX, this._offsetY, this._height, this._width, 0, 0, this._height, this._width)) : c.drawImage(a, this._offsetX, this._offsetY, this._width, this._height, 0, 0, this._width, this._height);
        return b
    }
    async ExtractImageToBlobURL(a) {
        if (this._blobUrl)
            return this._blobUrl;
        a = await this.ExtractImageToCanvas(a);
        a = await C3$jscomp$182.CanvasToBlob(a);
        return this._blobUrl = URL.createObjectURL(a)
    }
    ReleaseBlobURL() {
        this._blobUrl && (URL.revokeObjectURL(this._blobUrl),
        this._blobUrl = "")
    }
}
;
"use strict";
const C3$jscomp$183 = self.C3;
C3$jscomp$183.AnimationInfo = class extends C3$jscomp$183.DefendedBase {
    constructor(a) {
        super();
        this._name = a[0];
        this._speed = a[1];
        this._isLooping = !!a[2];
        this._repeatCount = a[3];
        this._repeatTo = a[4];
        this._isPingPong = !!a[5];
        this._sid = a[6];
        this._frames = a[7].map(b => C3$jscomp$183.New(C3$jscomp$183.AnimationFrameInfo, b));
        this._iAnimation = new self.IAnimation(this)
    }
    static CreateDynamic(a, b) {
        b = C3$jscomp$183.New(C3$jscomp$183.AnimationInfo, [b, 0, !1, 0, 0, !1, Math.floor(1E15 * Math.random()), []]);
        b._frames.push(C3$jscomp$183.AnimationFrameInfo.CreateDynamic(a));
        return b
    }
    Release() {
        for (const a of this._frames)
            a.Release();
        C3$jscomp$183.clearArray(this._frames)
    }
    LoadAllAssets(a) {
        for (const b of this._frames)
            b.GetImageInfo().LoadAsset(a)
    }
    LoadAllTextures(a, b) {
        return Promise.all(this._frames.map(c => c.GetImageInfo().LoadStaticTexture(a, b)))
    }
    ReleaseAllTextures() {
        for (const a of this._frames)
            a.GetImageInfo().ReleaseTexture()
    }
    GetName() {
        return this._name
    }
    GetSID() {
        return this._sid
    }
    GetFrameCount() {
        return this._frames.length
    }
    GetFrames() {
        return this._frames
    }
    GetFrameAt(a) {
        a = Math.floor(a);
        if (0 > a || a >= this._frames.length)
            throw new RangeError("invalid frame");
        return this._frames[a]
    }
    InsertFrameAt(a, b) {
        b = Math.floor(b);
        0 > b ? this._frames.unshift(a) : b >= this._frames.length ? this._frames.push(a) : this._frames.splice(b, 0, a)
    }
    RemoveFrameAt(a) {
        a = Math.floor(a);
        if (0 > a || a >= this._frames.length)
            throw new RangeError("invalid frame");
        this._frames[a].Release();
        this._frames.splice(a, 1)
    }
    GetFrameIndexByTag(a) {
        for (let b = 0, c = this._frames.length; b < c; ++b)
            if (C3$jscomp$183.equalsNoCase(this._frames[b].GetTag(), a))
                return b;
        return -1
    }
    FrameTagOrIndexToIndex(a) {
        if ("string" === typeof a) {
            const b = this.GetFrameIndexByTag(a);
            if (-1 === b)
                throw Error(`cannot find animation frame with tag ${a}`);
            return b
        }
        return a
    }
    GetSpeed() {
        return this._speed
    }
    IsLooping() {
        return this._isLooping
    }
    GetRepeatCount() {
        return this._repeatCount
    }
    GetRepeatTo() {
        return this._repeatTo
    }
    IsPingPong() {
        return this._isPingPong
    }
    GetIAnimation() {
        return this._iAnimation
    }
}
;
"use strict";
const C3$jscomp$184 = self.C3
  , EMPTY_IMAGE_BLOB = ( () => {
    const a = atob("iVBORw0KGgoAAAANSUhEUgAAAGQAAABkAQMAAABKLAcXAAAAAXNSR0IArs4c6QAAAANQTFRFAAAAp3o92gAAAAF0Uk5TAEDm2GYAAAATSURBVBgZYxgFo2AUjIJRQFcAAAV4AAHcRQIbAAAAAElFTkSuQmCC")
      , b = new Uint8Array(a.length);
    for (let c = 0, d = a.length; c < d; ++c)
        b[c] = a.charCodeAt(c);
    return new Blob([b],{
        type: "image/png"
    })
}
)();
C3$jscomp$184.AnimationFrameInfo = class extends C3$jscomp$184.DefendedBase {
    constructor(a) {
        super();
        this._imageInfo = C3$jscomp$184.New(C3$jscomp$184.ImageInfo);
        this._imageInfo.LoadData(a);
        this._duration = a[7];
        this._origin = C3$jscomp$184.New(C3$jscomp$184.Vector2, a[8], a[9]);
        this._imagePoints = a[10].map(c => C3$jscomp$184.New(C3$jscomp$184.ImagePoint, this, c));
        this._imagePointsByName = new Map;
        for (var b of this._imagePoints)
            this._imagePointsByName.set(b.GetName().toLowerCase(), b);
        this._collisionPoly = null;
        b = a[11];
        6 <= b.length && (this._collisionPoly = C3$jscomp$184.New(C3$jscomp$184.CollisionPoly, b));
        this._tag = a[12] ? a[12] : "";
        this._iAnimationFrame = new self.IAnimationFrame(this)
    }
    static CreateDynamic(a) {
        const b = C3$jscomp$184.New(C3$jscomp$184.AnimationFrameInfo, ["", 0, 0, 0, 100, 100, !1, 1, 0, 0, [], [], ""]);
        b._imageInfo.LoadDynamicBlobAsset(a, EMPTY_IMAGE_BLOB);
        return b
    }
    Release() {
        this._collisionPoly && (this._collisionPoly.Release(),
        this._collisionPoly = null);
        this._imageInfo.Release();
        this._imageInfo = null
    }
    GetImageInfo() {
        return this._imageInfo
    }
    GetDuration() {
        return this._duration
    }
    GetOriginX() {
        return this._origin.getX()
    }
    GetOriginY() {
        return this._origin.getY()
    }
    GetCollisionPoly() {
        return this._collisionPoly
    }
    GetImagePointByName(a) {
        return this._imagePointsByName.get(a.toLowerCase()) || null
    }
    GetImagePointByIndex(a) {
        a = Math.floor(a);
        return 0 > a || a >= this._imagePoints.length ? null : this._imagePoints[a]
    }
    GetImagePointCount() {
        return this._imagePoints.length
    }
    GetTag() {
        return this._tag
    }
    GetIAnimationFrame() {
        return this._iAnimationFrame
    }
}
;
"use strict";
const C3$jscomp$185 = self.C3;
C3$jscomp$185.ImagePoint = class extends C3$jscomp$185.DefendedBase {
    constructor(a, b) {
        super();
        this._afi = a;
        this._name = b[0];
        this._pos = C3$jscomp$185.New(C3$jscomp$185.Vector2, b[1], b[2])
    }
    Release() {}
    GetName() {
        return this._name
    }
    GetX() {
        return this._pos.getX()
    }
    GetY() {
        return this._pos.getY()
    }
    GetVec2() {
        return this._pos
    }
}
;
"use strict";
const C3$jscomp$186 = self.C3
  , C3Debugger$jscomp$1 = self.C3Debugger
  , IObjectClass$jscomp$1 = self.IObjectClass;
C3$jscomp$186.ObjectClass = class extends C3$jscomp$186.DefendedBase {
    constructor(a, b, c) {
        super();
        var d = a.GetObjectReference(c[1]);
        this._runtime = a;
        this._plugin = C3$jscomp$186.AddonManager.GetPluginByConstructorFunction(d);
        this._sdkType = null;
        this._instSdkCtor = d.Instance;
        this._index = b;
        this._sid = c[11];
        this._name = c[0];
        this._jsPropName = this._runtime.GetJsPropName(c[14]);
        this._isGlobal = !!c[9];
        this._isFamily = !!c[2];
        this._isOnLoaderLayout = !!c[10];
        this._instVars = c[3].map(h => ({
            sid: h[0],
            type: h[1],
            name: h[2],
            jsPropName: a.GetJsPropName(h[3])
        }));
        this._behaviorsCount = c[4];
        this._effectsCount = c[5];
        this._isWorldType = this._plugin.IsWorldType();
        this._dispatcher = C3$jscomp$186.New(C3$jscomp$186.Event.Dispatcher);
        this._effectList = null;
        const [e,f] = a.GetCollisionEngine().GetCollisionCellSize();
        this._collisionGrid = C3$jscomp$186.New(C3$jscomp$186.SparseGrid, e, f);
        this._anyCollisionCellChanged = !0;
        this._anyInstanceParallaxed = !1;
        this._familyMembersSet = this._familyMembers = null;
        this._familyIndex = -1;
        this._familyEffectMap = this._familyBehaviorMap = this._familyInstVarMap = this._familiesSet = this._families = null;
        this._isInContainer = !1;
        this._container = null;
        this._behaviorTypes = c[8].map(h => C3$jscomp$186.BehaviorType.Create(this, h));
        this._behaviorTypesIncludingInherited = [];
        this._behaviorsByName = new Map;
        this._behaviorNameToIndex = new Map;
        this._usedBehaviorCtors = new Set;
        this._customActionMap = new Map;
        this._solStack = C3$jscomp$186.New(C3$jscomp$186.SolStack, this);
        this._defaultInstanceData = null;
        this._defaultLayerIndex = 0;
        this._isContained = !1;
        this._animationsBySid = this._animationsByName = this._animations = this._imageInfo = this._container = null;
        this._textureRefCount = 0;
        this._savedData = new Map;
        this._unsavedData = new Map;
        this._instances = [];
        this._iidsStale = !0;
        this._plugin.HasEffects() && (this._effectList = C3$jscomp$186.New(C3$jscomp$186.EffectList, this, c[12]));
        c[6] && (this._imageInfo = C3$jscomp$186.New(C3$jscomp$186.ImageInfo),
        this._imageInfo.LoadData(c[6]));
        if (c[7]) {
            this._animations = c[7].map(h => C3$jscomp$186.New(C3$jscomp$186.AnimationInfo, h));
            this._animationsByName = new Map;
            this._animationsBySid = new Map;
            for (const h of this._animations)
                this._animationsByName.set(h.GetName().toLowerCase(), h),
                this._animationsBySid.set(h.GetSID(), h)
        }
        this._isFamily ? (this._familyMembers = [],
        this._familyMembersSet = new Set,
        this._familyIndex = this._runtime._GetNextFamilyIndex()) : (this._families = [],
        this._familiesSet = new Set,
        this._familyInstVarMap = [],
        this._familyBehaviorMap = [],
        this._familyEffectMap = []);
        b = this._plugin.GetSdkVersion();
        if (2 > b && (this._sdkType = C3$jscomp$186.New(d.Type, this, c[15]),
        !(this._sdkType instanceof C3$jscomp$186.SDKTypeBase)))
            throw Error("v1 sdk type must derive from SDKTypeBase");
        this._instanceUserScriptClass = this._iObjectClass = null;
        this._userScriptDispatcher = C3$jscomp$186.New(C3$jscomp$186.Event.Dispatcher);
        C3$jscomp$186.AddonManager._PushInitObject(this, b);
        2 <= b ? (d = d.Type,
        d || (d = globalThis.ISDKObjectTypeBase)) : d = this._sdkType.GetScriptInterfaceClass();
        if (d) {
            this._iObjectClass = new d(2 > b ? this : null);
            if (2 > b && !(this._iObjectClass instanceof IObjectClass$jscomp$1))
                throw new TypeError("script interface class must derive from IObjectClass");
            if (2 <= b && !(this._iObjectClass instanceof globalThis.ISDKObjectTypeBase))
                throw new TypeError("script interface class must derive from ISDKObjectTypeBase");
        } else
            this._iObjectClass = new IObjectClass$jscomp$1;
        C3$jscomp$186.AddonManager._PopInitObject(b);
        c[13] && (d = c[13]) && this._sdkType.LoadTilemapData(d[0], d[1], d[2]);
        this._runtime.UsesLoaderLayout() && !this._isFamily && !this._isOnLoaderLayout && this._isWorldType || this.OnCreate();
        this._plugin.IsSingleGlobal() && (this._plugin._SetSingleGlobalObjectClass(this),
        this._CreateSingleGlobalInstance(c));
        this._loadInstancesJson = null
    }
    static Create(a, b, c) {
        return C3$jscomp$186.New(C3$jscomp$186.ObjectClass, a, b, c)
    }
    Release() {
        this._dispatcher.Release();
        this._dispatcher = null;
        this._imageInfo && (this._imageInfo.Release(),
        this._imageInfo = null);
        if (this._animations) {
            for (const a of this._animations)
                a.Release();
            C3$jscomp$186.clearArray(this._animations);
            this._animationsByName.clear();
            this._animationsBySid.clear()
        }
        this._loadInstancesJson = null;
        this._solStack.Release();
        this._solStack = null;
        this._savedData.clear();
        this._unsavedData.clear();
        this._runtime = this._container = null
    }
    _LoadFamily(a) {
        for (let b = 1, c = a.length; b < c; ++b) {
            const d = this._runtime.GetObjectClassByIndex(a[b]);
            this._familyMembers.push(d);
            this._familyMembersSet.add(d);
            d._families.push(this);
            d._familiesSet.add(this)
        }
    }
    _SetContainer(a) {
        this._isInContainer = !0;
        this._container = a
    }
    IsInContainer() {
        return this._isInContainer
    }
    GetContainer() {
        return this._container
    }
    _OnAfterCreate() {
        var a = 0;
        if (!this._isFamily)
            for (var b of this._families)
                for (var c of b.GetBehaviorTypes()) {
                    const f = c.GetName().toLowerCase();
                    this._behaviorsByName.set(f, c);
                    this._behaviorNameToIndex.set(f, a);
                    this._behaviorTypesIncludingInherited.push(c);
                    ++a
                }
        for (var d of this.GetBehaviorTypes())
            b = d.GetName().toLowerCase(),
            this._behaviorsByName.set(b, d),
            this._behaviorNameToIndex.set(b, a),
            this._behaviorTypesIncludingInherited.push(d),
            ++a;
        for (var e of this._behaviorTypesIncludingInherited)
            this._usedBehaviorCtors.add(e.GetBehavior().constructor);
        if (!this._isFamily && this._families.length) {
            a = this._runtime.GetFamilyCount();
            C3$jscomp$186.extendArray(this._familyInstVarMap, a, 0);
            C3$jscomp$186.extendArray(this._familyBehaviorMap, a, 0);
            C3$jscomp$186.extendArray(this._familyEffectMap, a, 0);
            a = [];
            b = e = d = 0;
            for (const f of this._families)
                if (c = f.GetFamilyIndex(),
                this._familyInstVarMap[c] = d,
                d += f.GetInstanceVariablesCount(),
                this._familyBehaviorMap[c] = e,
                e += f.GetBehaviorTypesCount(),
                this._familyEffectMap[c] = b,
                b += f.GetEffectTypesCount(),
                (c = f.GetEffectList()) && this._effectList)
                    for (const h of c.GetAllEffectTypes())
                        a.push(h.Clone(this._effectList));
            this._effectList && this._effectList.PrependEffectTypes(a)
        }
    }
    _CreateSingleGlobalInstance(a) {
        const b = this._runtime._GetNewUID()
          , c = C3$jscomp$186.New(C3$jscomp$186.Instance, {
            runtime: this._runtime,
            objectType: this,
            uid: b
        });
        c._CreateSdkInstance(a[16], []);
        this._runtime._MapInstanceByUID(b, c);
        this._instances.push(c)
    }
    GetSdkType() {
        return this._sdkType
    }
    IsOnLoaderLayout() {
        return this._isOnLoaderLayout
    }
    Dispatcher() {
        return this._dispatcher
    }
    OnCreate() {
        this._isFamily || (this._sdkType ? this._sdkType.OnCreate() : this._iObjectClass._onCreate())
    }
    HasLoadedTextures() {
        return 0 < this._textureRefCount
    }
    async LoadTextures(a) {
        this._isFamily || (this._textureRefCount++,
        1 === this._textureRefCount && (this._sdkType ? await this._sdkType.LoadTextures(a) : await this._iObjectClass._loadTextures(this._runtime.GetCanvasManager().GetIRenderer())))
    }
    ReleaseTextures() {
        if (!this._isFamily) {
            this._textureRefCount--;
            if (0 > this._textureRefCount)
                throw Error("released textures too many times");
            0 === this._textureRefCount && (this._sdkType ? this._sdkType.ReleaseTextures() : this._iObjectClass._releaseTextures(this._runtime.GetCanvasManager().GetIRenderer()))
        }
    }
    OnDynamicTextureLoadComplete() {
        if (this._isFamily)
            throw Error("not applicable to family");
        this._sdkType ? this._sdkType.OnDynamicTextureLoadComplete() : this._iObjectClass._onDynamicTextureLoadComplete()
    }
    async PreloadTexturesWithInstances(a) {
        this._isFamily || (this._sdkType ? await this._sdkType.PreloadTexturesWithInstances(a) : await this._iObjectClass._preloadTexturesWithInstances(this._runtime.GetCanvasManager().GetIRenderer()))
    }
    GetRuntime() {
        return this._runtime
    }
    GetPlugin() {
        return this._plugin
    }
    GetInstanceSdkCtor() {
        return this._instSdkCtor
    }
    GetName() {
        return this._name
    }
    GetJsPropName() {
        return this._jsPropName
    }
    GetIndex() {
        return this._index
    }
    GetSID() {
        return this._sid
    }
    IsFamily() {
        return this._isFamily
    }
    IsGlobal() {
        return this._isGlobal
    }
    IsWorldType() {
        return this._isWorldType
    }
    GetFamilyIndex() {
        return this._familyIndex
    }
    GetBehaviorTypes() {
        return this._behaviorTypes
    }
    GetBehaviorTypesCount() {
        return this._behaviorsCount
    }
    UsesBehaviorByCtor(a) {
        return a && this._usedBehaviorCtors.has(a)
    }
    GetInstanceVariablesCount() {
        return this._instVars.length
    }
    GetInstanceVariableSIDs() {
        return this._instVars.map(a => a.sid)
    }
    GetInstanceVariableIndexBySID(a) {
        return this._instVars.findIndex(b => b.sid === a)
    }
    GetInstanceVariableIndexByName(a) {
        return this._instVars.findIndex(b => b.name === a)
    }
    _GetAllInstanceVariableNames() {
        return this._instVars.map(a => a.name)
    }
    _GetAllInstanceVariableJsPropNames() {
        return this._instVars.map(a => a.jsPropName)
    }
    GetInstanceVariableType(a) {
        a = Math.floor(a);
        if (0 > a || a >= this._instVars.length)
            throw new RangeError("invalid instance variable index");
        return this._instVars[a].type
    }
    GetInstanceVariableName(a) {
        a = Math.floor(a);
        if (0 > a || a >= this._instVars.length)
            throw new RangeError("invalid instance variable index");
        return this._instVars[a].name
    }
    GetEffectTypesCount() {
        return this._effectsCount
    }
    GetBehaviorTypesIncludingInherited() {
        return this._behaviorTypesIncludingInherited
    }
    GetBehaviorTypeByName(a) {
        return this._behaviorsByName.get(a.toLowerCase()) || null
    }
    GetBehaviorIndexByName(a) {
        a = this._behaviorNameToIndex.get(a.toLowerCase());
        return "undefined" === typeof a ? -1 : a
    }
    GetEffectList() {
        return this._effectList
    }
    HasEffects() {
        return this._plugin.HasEffects()
    }
    UsesEffects() {
        return this._effectList && this._effectList.HasAnyEffectType()
    }
    GetSolStack() {
        return this._solStack
    }
    GetCurrentSol() {
        return this._solStack.GetCurrentSol()
    }
    GetImageInfo() {
        return this._imageInfo
    }
    SetDefaultInstanceData(a) {
        this._defaultInstanceData = a
    }
    GetDefaultInstanceData() {
        return this._defaultInstanceData
    }
    _SetDefaultLayerIndex(a) {
        this._defaultLayerIndex = a
    }
    GetDefaultLayerIndex() {
        return this._defaultLayerIndex
    }
    GetAnimations() {
        return this._animations
    }
    GetAnimationCount() {
        return this._animations.length
    }
    GetFamilies() {
        return this._families
    }
    BelongsToFamily(a) {
        return this._familiesSet.has(a)
    }
    GetFamilyMembers() {
        return this._familyMembers
    }
    FamilyHasMember(a) {
        return this._familyMembersSet.has(a)
    }
    GetFamilyBehaviorOffset(a) {
        return this._familyBehaviorMap[a]
    }
    GetFamilyInstanceVariableOffset(a) {
        return this._familyInstVarMap[a]
    }
    AddCustomAction(a) {
        this._customActionMap.set(a.GetACEName().toLowerCase(), a)
    }
    HasOwnCustomActionByName(a) {
        return !!this.GetOwnCustomActionByName(a)
    }
    GetOwnCustomActionByName(a) {
        return (a = this._customActionMap.get(a.toLowerCase())) && a.IsEnabled() ? a : null
    }
    GetAllAnimations() {
        return this._animations
    }
    GetAnimationByName(a) {
        if (!this._animations)
            throw Error("no animations");
        return this._animationsByName.get(a.toLowerCase()) || null
    }
    GetAnimationBySID(a) {
        if (!this._animations)
            throw Error("no animations");
        return this._animationsBySid.get(a) || null
    }
    AddAnimation(a) {
        if (this.GetAnimationByName(a))
            throw Error(`animation name '${a}' already exists`);
        a = C3$jscomp$186.AnimationInfo.CreateDynamic(this.GetRuntime(), a);
        this._animations.push(a);
        this._animationsByName.set(a.GetName().toLowerCase(), a);
        this._animationsBySid.set(a.GetSID(), a);
        return a
    }
    RemoveAnimation(a) {
        const b = this.GetAnimationByName(a);
        if (!b)
            throw Error(`animation name '${a}' does not exist`);
        if (1 === this._animations.length)
            throw Error("cannot remove last animation");
        a = this._animations.indexOf(b);
        this._animations.splice(a, 1);
        this._animationsByName.delete(b.GetName().toLowerCase());
        this._animationsBySid.delete(b.GetSID());
        b.Release()
    }
    GetFirstAnimation() {
        if (!this._animations)
            throw Error("no animations");
        return this._animations[0]
    }
    GetFirstAnimationFrame() {
        return this.GetFirstAnimation().GetFrameAt(0)
    }
    GetDefaultInstanceSize() {
        if (this._animations) {
            const a = this.GetFirstAnimationFrame().GetImageInfo();
            return [a.GetWidth(), a.GetHeight()]
        }
        return this._imageInfo ? [this._imageInfo.GetWidth(), this._imageInfo.GetHeight()] : [100, 100]
    }
    GetSingleGlobalInstance() {
        if (!this._plugin.IsSingleGlobal())
            throw Error("not a single-global plugin");
        return this._instances[0]
    }
    GetInstances() {
        return this._instances
    }
    *instances() {
        yield*this._instances
    }
    *instancesIncludingPendingCreate() {
        yield*this._instances;
        yield*this._runtime.instancesPendingCreateForObjectClass(this)
    }
    GetInstanceCount() {
        return this._instances.length
    }
    _AddInstance(a) {
        this._instances.push(a)
    }
    _SetIIDsStale() {
        this._iidsStale = !0
    }
    _UpdateIIDs() {
        if (this._iidsStale && !this._isFamily) {
            var a = this._instances
              , b = 0;
            for (let c = a.length; b < c; ++b)
                a[b]._SetIID(b);
            a = this._runtime._GetInstancesPendingCreate();
            for (const c of a)
                c.GetObjectClass() === this && c._SetIID(b++);
            this._iidsStale = !1
        }
    }
    GetInstanceByIID(a) {
        var b = this._instances;
        if (a < b.length)
            return b[a];
        a -= b.length;
        b = this._runtime._GetInstancesPendingCreate();
        for (const c of b)
            if (c.GetObjectClass() === this) {
                if (0 === a)
                    return c;
                --a
            }
        return null
    }
    GetFirstPicked(a) {
        if (a && a.IsInContainer() && a.GetObjectClass() !== this)
            for (const b of a.siblings())
                if (b.GetObjectClass() === this)
                    return b;
        a = this.GetCurrentSol().GetInstances();
        return a.length ? a[0] : null
    }
    GetPairedInstance(a) {
        const b = this.GetCurrentSol().GetInstances();
        return 0 < b.length ? b[a.GetIID() % b.length] : null
    }
    *allCorrespondingInstances(a, b) {
        const c = this.GetCurrentSol().GetInstances();
        var d = c.length;
        const e = b.GetCurrentSol()
          , f = b.GetCurrentSol().GetInstances()
          , h = f.length;
        var l = a.GetIID();
        if (b.IsFamily() || !e.IsSelectAll())
            l = f.indexOf(a);
        a = Math.ceil(d / h);
        d %= h;
        0 === d || l < d ? (l *= a,
        d = a) : (l = d * a + (l - d) * (a - 1),
        d = a - 1);
        for (let m = l, p = l + d; m < p; ++m)
            yield c[m]
    }
    FinishCondition(a) {
        this._sdkType?.FinishCondition(a)
    }
    ApplySolToContainer() {
        if (this._isInContainer && !this._isFamily) {
            this._UpdateIIDs();
            var a = this.GetCurrentSol()
              , b = a._GetOwnInstances()
              , c = a.IsSelectAll()
              , d = this._runtime.GetCurrentEventStackFrame();
            d = d && d.GetCurrentEvent() && d.GetCurrentEvent().IsOrBlock();
            for (const h of this._container.objectTypes())
                if (h !== this) {
                    h._UpdateIIDs();
                    var e = h.GetCurrentSol();
                    e._SetSelectAll(c);
                    if (!c) {
                        var f = e._GetOwnInstances();
                        C3$jscomp$186.clearArray(f);
                        for (const l of b)
                            f.push(h.GetInstanceByIID(l.GetIID()));
                        if (d) {
                            f = a._GetOwnElseInstances();
                            e = e._GetOwnElseInstances();
                            C3$jscomp$186.clearArray(e);
                            for (const l of f)
                                e.push(h.GetInstanceByIID(l.GetIID()))
                        }
                    }
                }
        }
    }
    _TruncateContainerSols(a, b) {
        for (const c of this.GetContainer().objectTypes()) {
            const d = c.GetCurrentSol();
            a ? C3$jscomp$186.truncateArray(d._GetOwnElseInstances(), b) : C3$jscomp$186.truncateArray(d._GetOwnInstances(), b)
        }
    }
    _GetCollisionCellGrid() {
        return this._collisionGrid
    }
    _SetAnyCollisionCellChanged(a) {
        this._anyCollisionCellChanged = !!a
    }
    _SetAnyInstanceParallaxed(a) {
        this._anyInstanceParallaxed = !!a
    }
    IsAnyInstanceParallaxed() {
        return this._anyInstanceParallaxed
    }
    _UpdateAllCollisionCells() {
        if (this._anyCollisionCellChanged && this._isWorldType) {
            for (const a of this._instances)
                a.GetWorldInfo()._UpdateCollisionCell();
            for (const a of this._runtime._GetInstancesPendingCreate())
                a.GetObjectClass() === this && a.GetWorldInfo()._UpdateCollisionCell();
            this._anyCollisionCellChanged = !1
        }
    }
    GetSavedDataMap() {
        this._savedData || (this._savedData = new Map);
        return this._savedData
    }
    GetUnsavedDataMap() {
        this._unsavedData || (this._unsavedData = new Map);
        return this._unsavedData
    }
    HasSolidBehavior() {
        return this.UsesBehaviorByCtor(C3$jscomp$186.Behaviors.solid)
    }
    HasJumpthruBehavior() {
        return this.UsesBehaviorByCtor(C3$jscomp$186.Behaviors.jumpthru)
    }
    HasNoSaveBehavior() {
        return this.UsesBehaviorByCtor(C3$jscomp$186.Behaviors.NoSave)
    }
    HasPersistBehavior() {
        return this.UsesBehaviorByCtor(C3$jscomp$186.Behaviors.Persist)
    }
    _SaveToJson() {
        const a = {
            instances: this._instances.map(b => b.SaveToJson())
        };
        this._savedData && this._savedData.size && (a.ex = C3$jscomp$186.ToSuperJSON(this._savedData));
        return a
    }
    _LoadFromJson(a) {
        this._savedData && (this._savedData.clear(),
        this._savedData = null);
        var b = a.ex;
        b && (this._savedData = C3$jscomp$186.FromSuperJSON(b));
        b = this._instances;
        a = a.instances;
        for (let c = 0, d = Math.min(b.length, a.length); c < d; ++c)
            b[c].LoadFromJson(a[c]);
        for (let c = a.length, d = b.length; c < d; ++c)
            this._runtime.DestroyInstance(b[c]);
        for (let c = b.length, d = a.length; c < d; ++c) {
            b = a[c];
            let e = null;
            if (this.IsWorldType() && (e = this._runtime.GetMainRunningLayout().GetLayerBySID(b.w.l),
            !e))
                continue;
            this._runtime.CreateInstanceFromData(this._defaultInstanceData || this, e, !1, 0, 0, !0).LoadFromJson(b)
        }
        this._loadInstancesJson = a;
        this._SetIIDsStale()
    }
    _GetLoadInstancesJson() {
        return this._loadInstancesJson
    }
    _ClearLoadInstancesJson() {
        this._loadInstancesJson = null
    }
    _SetupSceneGraphConnectionsOnChangeOfLayout() {
        for (let a = 0, b = this._instances; a < b; ++a)
            this._instances[a]._SetupSceneGraphConnectionsOnChangeOfLayout()
    }
    GetIObjectClass() {
        return this._iObjectClass
    }
    UserScriptDispatcher() {
        return this._userScriptDispatcher
    }
    _GetUserScriptInstanceClass() {
        return this._instanceUserScriptClass
    }
    _SetUserScriptInstanceClass(a) {
        this._instanceUserScriptClass = a
    }
    DispatchUserScriptEvent(a) {
        var b = this._runtime;
        (b = b.IsDebug() && !b.GetEventSheetManager().IsInEventEngine()) && C3Debugger$jscomp$1.StartMeasuringScriptTime();
        this._userScriptDispatcher.dispatchEvent(a);
        b && C3Debugger$jscomp$1.AddScriptTime()
    }
}
;
"use strict";
const C3$jscomp$187 = self.C3;
C3$jscomp$187.Container = class extends C3$jscomp$187.DefendedBase {
    constructor(a, b) {
        super();
        this._runtime = a;
        this._objectTypes = b;
        for (const c of this._objectTypes)
            c._SetContainer(this)
    }
    Release() {
        this._runtime = null
    }
    GetRuntime() {
        return this._runtime
    }
    GetObjectTypes() {
        return this._objectTypes
    }
    objectTypes() {
        return this._objectTypes
    }
    HasAnyWorldType() {
        return this._objectTypes.some(a => a.IsWorldType())
    }
}
;
"use strict";
const C3$jscomp$188 = self.C3
  , C3Debugger$jscomp$2 = self.C3Debugger
  , originalAddonManager = C3$jscomp$188.AddonManager
  , EMPTY_ARRAY$jscomp$1 = [];
let nextPuid = 0;
const savedDataMaps = new WeakMap
  , unsavedDataMaps = new WeakMap
  , FLAG_DESTROYED = 1
  , FLAG_TILEMAP = 2
  , FLAG_MUST_PREDRAW = 4
  , FLAG_SOLID_ENABLED = 8
  , FLAG_JUMPTHRU_ENABLED = 16
  , FLAG_MUST_MITIGATE_Z_FIGHTING = 32
  , FLAG_IS_DRAWING_WITH_EFFECTS = 64;
C3$jscomp$188.Instance = class extends C3$jscomp$188.DefendedBase {
    constructor(a) {
        if (C3$jscomp$188.AddonManager !== originalAddonManager)
            throw Error("invalid addon manager");
        super();
        this._runtime = a.runtime;
        this._objectType = a.objectType;
        this._iScriptInterface = this._sdkInst = this._worldInfo = null;
        this._iid = 0;
        this._uid = a.uid;
        this._puid = nextPuid++;
        this._flags = 0;
        this._behaviorInstances = this._instVarValues = EMPTY_ARRAY$jscomp$1;
        var b = this._objectType.GetBehaviorTypesIncludingInherited();
        0 < b.length && (this._behaviorInstances = b.map( (c, d) => C3$jscomp$188.New(C3$jscomp$188.BehaviorInstance, {
            runtime: this._runtime,
            behaviorType: c,
            instance: this,
            index: d
        })));
        this._siblings = this._objectType.IsInContainer() ? [] : null;
        this._timeScale = -1;
        this._dispatcher = null;
        b = this.GetPlugin();
        b.MustPreDraw() && (this._flags |= FLAG_MUST_PREDRAW);
        if (b.IsWorldType())
            if (this._worldInfo = C3$jscomp$188.New(C3$jscomp$188.WorldInfo, this, a.layer),
            a.worldData)
                this._worldInfo.Init(a.worldData);
            else {
                this._worldInfo.InitNoData();
                const [c,d] = this._objectType.GetDefaultInstanceSize();
                this._worldInfo.SetSize(c, d);
                this.GetObjectClass().UsesEffects() && this._worldInfo.GetInstanceEffectList().LoadDefaultEffectParameters()
            }
        a.instVarData ? this._LoadInstanceVariableData(a.instVarData) : this._LoadDefaultInstanceVariables()
    }
    Release() {
        this._iScriptInterface && (this._iScriptInterface._release(),
        this._iScriptInterface = null);
        if (0 < this._behaviorInstances.length) {
            for (var a of this._behaviorInstances)
                a.Release();
            C3$jscomp$188.clearArray(this._behaviorInstances)
        }
        this._sdkInst && (this._sdkInst.Release(),
        this._sdkInst = null);
        if (a = savedDataMaps.get(this))
            a.clear(),
            savedDataMaps.delete(this);
        if (a = unsavedDataMaps.get(this))
            a.clear(),
            unsavedDataMaps.delete(this);
        this._siblings && C3$jscomp$188.clearArray(this._siblings);
        this._dispatcher && (this._dispatcher.Release(),
        this._dispatcher = null);
        this._objectType = this._runtime = null;
        0 < this._instVarValues.length && C3$jscomp$188.clearArray(this._instVarValues);
        this._worldInfo && (this._worldInfo.Release(),
        this._worldInfo = null)
    }
    _LoadInstanceVariableData(a) {
        0 < a.length && (this._instVarValues = [],
        C3$jscomp$188.shallowAssignArray(this._instVarValues, a))
    }
    _LoadDefaultInstanceVariables() {
        const a = this._objectType.GetInstanceVariablesCount();
        if (0 !== a) {
            this._instVarValues = [];
            var b = [0, 0, ""];
            for (let c = 0; c < a; ++c)
                this._instVarValues.push(b[this._objectType.GetInstanceVariableType(c)])
        }
    }
    _CreateSdkInstance(a, b) {
        if (this._sdkInst)
            throw Error("already got sdk instance");
        for (let c = 0, d = this._behaviorInstances.length; c < d; ++c)
            this._behaviorInstances[c]._CreateSdkInstance(b ? b[c] : null);
        if (2 > this.GetPlugin().GetSdkVersion()) {
            this._sdkInst = C3$jscomp$188.New(this._objectType.GetInstanceSdkCtor(), this, a);
            if (!(this._sdkInst instanceof C3$jscomp$188.SDKInstanceBase))
                throw Error("sdk type must derive from SDKInstanceBase");
            !this.GetPlugin().IsWorldType() && this._objectType._GetUserScriptInstanceClass() && this.GetInterfaceClass()
        } else
            b = this.GetPlugin().GetScriptInterfaceClass(),
            this._InitUserScriptInterface(b.Instance, a)
    }
    GetSdkInstance() {
        return this._sdkInst ?? this._iScriptInterface
    }
    GetWorldInfo() {
        return this._worldInfo
    }
    GetRuntime() {
        return this._runtime
    }
    GetTimeScale() {
        return this._timeScale
    }
    GetActiveTimeScale() {
        const a = this._timeScale;
        return -1 === a ? this.GetRuntime().GetTimeScale() : a
    }
    SetTimeScale(a) {
        a = +a;
        if (0 > a || !isFinite(a))
            a = 0;
        this._timeScale = a;
        this.GetObjectClass().UsesEffects() && this._runtime._SetTrackingInstanceTime(this, !0)
    }
    RestoreTimeScale() {
        this._timeScale = -1;
        this.GetObjectClass().UsesEffects() && this._runtime._SetTrackingInstanceTime(this, !1)
    }
    GetInstanceGameTime() {
        return this._runtime._GetInstanceGameTime(this)
    }
    Dispatcher() {
        this._dispatcher || (this._dispatcher = C3$jscomp$188.New(C3$jscomp$188.Event.Dispatcher));
        return this._dispatcher
    }
    Draw(a) {
        this._sdkInst ? this._sdkInst.Draw(a) : this._iScriptInterface._draw(this._runtime.GetCanvasManager().GetIRenderer())
    }
    OnCreate(a) {
        this._sdkInst.OnCreate(a)
    }
    _SetHasTilemap() {
        this._flags |= FLAG_TILEMAP
    }
    HasTilemap() {
        return 0 !== (this._flags & FLAG_TILEMAP)
    }
    _MarkDestroyed() {
        this._flags |= FLAG_DESTROYED
    }
    IsDestroyed() {
        return 0 !== (this._flags & FLAG_DESTROYED)
    }
    MustPreDraw() {
        return 0 !== (this._flags & FLAG_MUST_PREDRAW) || this._sdkInst.MustPreDraw()
    }
    SetMustMitigateZFighting() {
        this._flags |= FLAG_MUST_MITIGATE_Z_FIGHTING
    }
    MustMitigateZFighting() {
        return 0 !== (this._flags & FLAG_MUST_MITIGATE_Z_FIGHTING)
    }
    _IsSolidEnabled() {
        return 0 !== (this._flags & FLAG_SOLID_ENABLED)
    }
    _SetSolidEnabled(a) {
        this._flags = a ? this._flags | FLAG_SOLID_ENABLED : this._flags & ~FLAG_SOLID_ENABLED
    }
    _IsJumpthruEnabled() {
        return 0 !== (this._flags & FLAG_JUMPTHRU_ENABLED)
    }
    _SetJumpthruEnabled(a) {
        this._flags = a ? this._flags | FLAG_JUMPTHRU_ENABLED : this._flags & ~FLAG_JUMPTHRU_ENABLED
    }
    _IsDrawingWithEffects() {
        return 0 !== (this._flags & FLAG_IS_DRAWING_WITH_EFFECTS)
    }
    _SetIsDrawingWithEffects(a) {
        this._flags = a ? this._flags | FLAG_IS_DRAWING_WITH_EFFECTS : this._flags & ~FLAG_IS_DRAWING_WITH_EFFECTS
    }
    SetFlag(a, b) {
        a <<= 16;
        this._flags = b ? this._flags | a : this._flags & ~a
    }
    GetFlag(a) {
        return 0 !== (this._flags & a << 16)
    }
    GetCurrentImageInfo() {
        return this._sdkInst.GetCurrentImageInfo()
    }
    GetCurrentSurfaceSize() {
        return this._sdkInst.GetCurrentSurfaceSize()
    }
    GetCurrentTexRect() {
        return this._sdkInst.GetCurrentTexRect()
    }
    GetCurrentTexQuad() {
        return this._sdkInst.GetCurrentTexQuad()
    }
    IsCurrentTexRotated() {
        return this._sdkInst.IsCurrentTexRotated()
    }
    GetImagePoint(a) {
        return this._sdkInst.GetImagePoint(a)
    }
    GetObjectClass() {
        return this._objectType
    }
    RendersToOwnZPlane() {
        return this._sdkInst.RendersToOwnZPlane()
    }
    BelongsToObjectClass(a) {
        return a.IsFamily() ? a.FamilyHasMember(this.GetObjectClass()) : this.GetObjectClass() === a
    }
    CollectInstancesToPick(a, b, c) {
        const d = (e, f) => {
            f = f || e.GetObjectClass();
            const h = a.get(f);
            h ? h.add(e) : a.set(f, new Set([e]))
        }
        ;
        d(this, b);
        if (this.IsInContainer())
            for (const e of this.siblings())
                d(e);
        if (c)
            for (const e of this.allChildren())
                d(e)
    }
    VerifySupportsSceneGraph() {
        if (!this.GetPlugin().SupportsSceneGraph())
            throw Error("object does not support scene graph");
    }
    HasParent() {
        return null !== this.GetParent()
    }
    GetParent() {
        var a = this.GetWorldInfo();
        return a ? (a = a.GetParent()) ? a.GetInstance() : null : null
    }
    GetTopParent() {
        var a = this.GetWorldInfo();
        return a ? (a = a.GetTopParent()) ? a.GetInstance() : null : null
    }
    *parents() {
        const a = this.GetWorldInfo();
        if (a)
            for (const b of a.parents())
                yield b.GetInstance()
    }
    HasChild(a) {
        if (!a)
            return !1;
        for (const b of this.children())
            if (b === a)
                return !0;
        return !1
    }
    HasChildren() {
        const a = this.GetWorldInfo();
        return a ? a.HasChildren() : !1
    }
    GetChildrenOfObjectClass(a) {
        const b = this.GetWorldInfo();
        if (!b)
            return [];
        const c = a.GetName();
        return b.GetChildren().map(d => d.GetInstance()).filter(d => d.GetObjectClass().GetName() === c)
    }
    GetChildren() {
        const a = this.GetWorldInfo();
        return a ? a.GetChildren().map(b => b.GetInstance()) : []
    }
    *children() {
        const a = this.GetWorldInfo();
        if (a)
            for (const b of a.children())
                yield b.GetInstance()
    }
    *allChildren() {
        const a = this.GetWorldInfo();
        if (a)
            for (const b of a.allChildren())
                yield b.GetInstance()
    }
    GetChildCount() {
        const a = this.GetWorldInfo();
        return a ? a.GetChildCount() : 0
    }
    GetParentCount() {
        return [...this.parents()].length
    }
    GetAllChildCount() {
        const a = this.GetWorldInfo();
        return a ? a.GetAllChildCount() : 0
    }
    GetChildAt(a) {
        const b = this.GetWorldInfo();
        return b ? (a = b.GetChildAt(a)) ? a.GetInstance() : null : null
    }
    GetIndexInParent() {
        const a = this.GetWorldInfo();
        if (!a)
            return NaN;
        const b = a.GetParent();
        return b ? b.GetChildIndex(a) : NaN
    }
    AddChild(a, b) {
        this.VerifySupportsSceneGraph();
        a.VerifySupportsSceneGraph();
        this.GetWorldInfo().AddChild(a.GetWorldInfo(), b || {})
    }
    RemoveChild(a) {
        const b = this.GetWorldInfo();
        b && b.RemoveChild(a.GetWorldInfo())
    }
    GetDestroyWithParent() {
        const a = this.GetWorldInfo();
        return a ? a.GetDestroyWithParent() : !1
    }
    SetupInitialSceneGraphConnections() {
        var a = this.GetWorldInfo();
        if (a && (a = a.GetSceneGraphChildrenExportData()))
            for (const b of a)
                if (a = this._runtime.GetInstanceByUID(b[2])) {
                    const c = b[3];
                    this.AddChild(a, {
                        transformX: !!(c >> 0 & 1),
                        transformY: !!(c >> 1 & 1),
                        transformWidth: !!(c >> 2 & 1),
                        transformHeight: !!(c >> 3 & 1),
                        transformAngle: !!(c >> 4 & 1),
                        destroyWithParent: !!(c >> 5 & 1),
                        transformZElevation: !!(c >> 6 & 1),
                        transformOpacity: !!(c >> 7 & 1),
                        transformVisibility: !!(c >> 8 & 1)
                    })
                }
    }
    SetupPersistedSceneGraphConnections(a, b) {
        if (a = a.get(this))
            for (const c of a.sceneGraphJson.children) {
                a = b.get(c.index);
                if (!a)
                    continue;
                const d = c.flags;
                this.AddChild(a, {
                    transformX: !!(d >> 0 & 1),
                    transformY: !!(d >> 1 & 1),
                    transformWidth: !!(d >> 2 & 1),
                    transformHeight: !!(d >> 3 & 1),
                    transformAngle: !!(d >> 4 & 1),
                    destroyWithParent: !!(d >> 5 & 1),
                    transformZElevation: !!(d >> 6 & 1),
                    transformOpacity: !!(d >> 7 & 1),
                    transformVisibility: !!(d >> 8 & 1)
                })
            }
    }
    GetTemplateName() {
        const a = this._runtime.GetTemplateManager();
        return a ? a.GetInstanceTemplateName(this) : ""
    }
    IsInContainer() {
        return null !== this._siblings
    }
    _AddSibling(a) {
        this._siblings.push(a)
    }
    GetSiblings() {
        return this._siblings
    }
    HasSibling(a) {
        return !!this.GetSibling(a)
    }
    GetSibling(a) {
        const b = this.siblings();
        if (null === b || 0 === b.length)
            return !1;
        for (const c of b)
            if (c.GetObjectClass() === a)
                return c;
        return null
    }
    siblings() {
        return this._siblings
    }
    SetSiblingsSinglePicked() {
        for (const a of this.siblings())
            a.GetObjectClass().GetCurrentSol().SetSinglePicked(a)
    }
    _PushSiblingsToSolInstances() {
        for (const a of this.siblings())
            a.GetObjectClass().GetCurrentSol()._PushInstance(a)
    }
    _SetSiblingsToSolInstancesIndex(a) {
        for (const b of this.siblings())
            b.GetObjectClass().GetCurrentSol()._GetOwnInstances()[a] = b
    }
    _PushSiblingsToSolElseInstances() {
        for (const a of this.siblings())
            a.GetObjectClass().GetCurrentSol()._PushElseInstance(a)
    }
    _SetSiblingsToSolElseInstancesIndex(a) {
        for (const b of this.siblings())
            b.GetObjectClass().GetCurrentSol()._GetOwnElseInstances()[a] = b
    }
    GetPlugin() {
        return this._objectType.GetPlugin()
    }
    _SetIID(a) {
        this._iid = a
    }
    GetIID() {
        this._objectType._UpdateIIDs();
        return this._iid
    }
    GetUID() {
        return this._uid
    }
    GetPUID() {
        return this._puid
    }
    GetBehaviorInstances() {
        return this._behaviorInstances
    }
    GetBehaviorInstanceFromCtor(a) {
        if (!a)
            return null;
        for (const b of this._behaviorInstances)
            if (b.GetBehavior()instanceof a)
                return b;
        return null
    }
    GetBehaviorSdkInstanceFromCtor(a) {
        return a ? (a = this.GetBehaviorInstanceFromCtor(a)) ? a.GetSdkInstance() : null : null
    }
    GetBehaviorIndexBySID(a) {
        const b = this._behaviorInstances;
        for (let c = 0, d = b.length; c < d; ++c)
            if (b[c].GetBehaviorType().GetSID() === a)
                return c;
        return -1
    }
    GetAllInstanceVariableValues() {
        return this._instVarValues
    }
    _GetAllInstanceVariableNames() {
        return this._objectType._GetAllInstanceVariableNames()
    }
    GetInstanceVariableCount() {
        return this._instVarValues.length
    }
    GetInstanceVariableValue(a) {
        a |= 0;
        const b = this._instVarValues;
        if (0 > a || a >= b.length)
            throw new RangeError("invalid instance variable");
        return b[a]
    }
    _GetInstanceVariableValueUnchecked(a) {
        return this._instVarValues[a]
    }
    _GetInstanceVariableTypedValue(a) {
        const b = this._instVarValues[a];
        return 0 === this._objectType.GetInstanceVariableType(a) ? !!b : b
    }
    SetInstanceVariableValue(a, b) {
        a |= 0;
        const c = this._instVarValues;
        if (0 > a || a >= c.length)
            throw new RangeError("invalid instance variable");
        switch (this._objectType.GetInstanceVariableType(a)) {
        case 0:
            c[a] = b ? 1 : 0;
            break;
        case 1:
            c[a] = "number" === typeof b ? b : parseFloat(b);
            break;
        case 2:
            c[a] = "string" === typeof b ? b : b.toString();
            break;
        default:
            throw Error("unknown instance variable type");
        }
    }
    SetInstanceVariableOffset(a, b) {
        if (0 !== b) {
            a |= 0;
            var c = this._instVarValues;
            if (0 > a || a >= c.length)
                throw new RangeError("invalid instance variable");
            var d = c[a];
            if ("number" === typeof d)
                c[a] = "number" === typeof b ? c[a] + b : c[a] + parseFloat(b);
            else {
                if ("boolean" === typeof d)
                    throw Error("can not set offset of boolean variable");
                if ("string" === typeof d)
                    throw Error("can not set offset of string variable");
                throw Error("unknown instance variable type");
            }
        }
    }
    GetSavedDataMap() {
        let a = savedDataMaps.get(this);
        if (a)
            return a;
        a = new Map;
        savedDataMaps.set(this, a);
        return a
    }
    GetUnsavedDataMap() {
        let a = unsavedDataMaps.get(this);
        if (a)
            return a;
        a = new Map;
        unsavedDataMaps.set(this, a);
        return a
    }
    _HasAnyCreateDestroyHandler(a) {
        const b = this.GetObjectClass();
        if (b.UserScriptDispatcher().HasAnyHandlerFor(a))
            return !0;
        for (const c of b.GetFamilies())
            if (c.UserScriptDispatcher().HasAnyHandlerFor(a))
                return !0;
        return this._runtime.UserScriptDispatcher().HasAnyHandlerFor(a) ? !0 : !1
    }
    _TriggerOnCreatedOnSelfAndRelated() {
        const a = new Set;
        a.add(this);
        const b = this.GetWorldInfo();
        if (b && b.HasChildren())
            for (const c of this.allChildren())
                if (a.add(c),
                c.IsInContainer())
                    for (const d of c.siblings())
                        a.add(d);
        if (this.IsInContainer())
            for (const c of this.siblings())
                a.add(c);
        for (const c of a.values())
            c._TriggerOnCreated()
    }
    _TriggerOnCreated() {
        this._objectType._GetUserScriptInstanceClass() && this.GetInterfaceClass();
        for (var a of this._behaviorInstances)
            a.PostCreate();
        if (this._HasAnyCreateDestroyHandler("instancecreate")) {
            a = this.GetObjectClass();
            const b = new C3$jscomp$188.Event("instancecreate");
            b.instance = this.GetInterfaceClass();
            a.DispatchUserScriptEvent(b);
            for (const c of a.GetFamilies())
                c.DispatchUserScriptEvent(b);
            this._runtime.DispatchUserScriptEvent(b)
        }
        this._runtime.Trigger(this.GetPlugin().GetConstructor().Cnds.OnCreated, this, null)
    }
    _TriggerOnDestroyed() {
        this._runtime.Trigger(this.GetPlugin().GetConstructor().Cnds.OnDestroyed, this, null)
    }
    _FireDestroyedScriptEvents(a) {
        if (this._iScriptInterface) {
            var b = new C3$jscomp$188.Event("destroy");
            b.isEndingLayout = a;
            this.DispatchUserScriptEvent(b)
        }
        if (this._HasAnyCreateDestroyHandler("instancedestroy")) {
            b = this.GetObjectClass();
            var c = new C3$jscomp$188.Event("instancedestroy");
            c.instance = this.GetInterfaceClass();
            c.isEndingLayout = a;
            b.DispatchUserScriptEvent(c);
            for (const d of b.GetFamilies())
                d.DispatchUserScriptEvent(c);
            this._runtime.DispatchUserScriptEvent(c)
        }
    }
    _GetDebuggerProperties() {
        return this._sdkInst ? this._sdkInst.GetDebuggerProperties() : this._iScriptInterface.getDebuggerProperties()
    }
    SaveToJson(a="full", b=null) {
        const c = {};
        "full" === a ? c.uid = this.GetUID() : c.c3 = !0;
        if ("visual-state" !== a) {
            var d = savedDataMaps.get(this);
            d && d.size && (c.ex = C3$jscomp$188.ToSuperJSON(d));
            -1 !== this.GetTimeScale() && (c.mts = this.GetTimeScale());
            if (0 < this._objectType.GetInstanceVariablesCount()) {
                d = {};
                var e = this._objectType.GetInstanceVariableSIDs();
                for (let f = 0, h = this._instVarValues.length; f < h; ++f)
                    d[e[f].toString()] = this._instVarValues[f];
                c.ivs = d
            }
            if (this._behaviorInstances.length) {
                d = {};
                for (const f of this._behaviorInstances)
                    (e = f.SaveToJson(a)) && (d[f.GetBehaviorType().GetSID().toString()] = e);
                c.behs = d
            }
        }
        this._worldInfo && (c.w = this._worldInfo._SaveToJson(a, b));
        (a = this._sdkInst ? this._sdkInst.SaveToJson() : this._iScriptInterface._saveToJson()) && (c.data = a);
        return c
    }
    _OnBeforeLoad(a="full") {
        this._worldInfo && this._worldInfo._OnBeforeLoad(a)
    }
    _OnAfterLoad(a, b="full", c=null) {
        this._worldInfo && this._worldInfo._OnAfterLoad(a, b, c)
    }
    _OnAfterLoad2(a, b="full", c=null) {
        this._worldInfo && this._worldInfo._OnAfterLoad2(a, b, c)
    }
    _SetupSceneGraphConnectionsOnChangeOfLayout() {
        this.GetPlugin().IsWorldType() && this._worldInfo._SetupSceneGraphConnectionsOnChangeOfLayout()
    }
    LoadFromJson(a, b="full") {
        if ("full" === b)
            this._uid = a.uid;
        else if (!a.c3)
            return;
        if ("visual-state" !== b) {
            var c = savedDataMaps.get(this);
            c && (c.clear(),
            savedDataMaps.delete(this));
            if (c = a.ex)
                c = C3$jscomp$188.FromSuperJSON(c),
                savedDataMaps.set(this, c);
            this._timeScale = a.hasOwnProperty("mts") ? a.mts : -1;
            if (c = a.ivs)
                for (const [f,h] of Object.entries(c))
                    if (c = parseInt(f, 10),
                    c = this._objectType.GetInstanceVariableIndexBySID(c),
                    !(0 > c || c >= this._instVarValues.length)) {
                        var d = h;
                        null === d && (d = NaN);
                        this._instVarValues[c] = d
                    }
        }
        if (this.GetPlugin().IsWorldType() && (c = a.w)) {
            var e = c.l;
            this._worldInfo.GetLayer().GetSID() !== e && (d = this._worldInfo.GetLayer(),
            (e = d.GetLayout().GetLayerBySID(e)) ? (this._worldInfo._SetLayer(e),
            d._RemoveInstance(this, !0),
            e._AddInstance(this, !0),
            e.SetZIndicesChanged(this),
            this._worldInfo.SetBboxChanged()) : "full" === b && this._runtime.DestroyInstance(this));
            this._worldInfo._LoadFromJson(c, b)
        }
        if ("visual-state" !== b && (c = a.behs))
            for (const [f,h] of Object.entries(c))
                c = parseInt(f, 10),
                c = this.GetBehaviorIndexBySID(c),
                0 > c || c >= this._behaviorInstances.length || this._behaviorInstances[c].LoadFromJson(h, b);
        (a = a.data) && (this._sdkInst ? this._sdkInst.LoadFromJson(a, b) : this._iScriptInterface._loadFromJson(a))
    }
    GetInterfaceClass() {
        return this._iScriptInterface || this._InitUserScriptInterface()
    }
    HasScriptInterface() {
        return !!this._iScriptInterface
    }
    _InitUserScriptInterface(a, b) {
        const c = this._worldInfo ? a ? self.ISDKWorldInstanceBase : self.IWorldInstance : a ? self.ISDKInstanceBase : self.IInstance;
        a = a || this._sdkInst.GetScriptInterfaceClass();
        const d = this._objectType._GetUserScriptInstanceClass()
          , e = d || a || c
          , f = this.GetPlugin().GetSdkVersion();
        C3$jscomp$188.AddonManager._PushInitObject(this, f);
        C3$jscomp$188.AddonManager._PushInitProperties(b);
        this._iScriptInterface = new e;
        C3$jscomp$188.AddonManager._PopInitProperties();
        C3$jscomp$188.AddonManager._PopInitObject(f);
        if (a && !(this._iScriptInterface instanceof c))
            throw new TypeError(`script interface class '${a.name}' does not extend the right base class '${c.name}'`);
        if (d && !(this._iScriptInterface instanceof (a || c)))
            throw new TypeError(`setInstanceClass(): class '${d.name}' does not extend the right base class - check it extends the right class, e.g. globalThis.InstanceType.MyObjectName`);
        return this._iScriptInterface
    }
    _GetInstVarsScriptDescriptor(a) {
        if (0 !== this._instVarValues.length) {
            var b = {}
              , c = this._objectType._GetAllInstanceVariableJsPropNames();
            for (let d = 0, e = c.length; d < e; ++d)
                b[c[d]] = {
                    configurable: !1,
                    enumerable: !0,
                    get: C3$jscomp$188.Instance.prototype._GetInstanceVariableTypedValue.bind(this, d),
                    set: C3$jscomp$188.Instance.prototype.SetInstanceVariableValue.bind(this, d)
                };
            b = Object.create(Object.prototype, b);
            a.instVars = {
                value: b,
                writable: !1
            }
        }
    }
    _GetBehaviorsScriptDescriptor(a) {
        var b = this._behaviorInstances;
        if (0 !== b.length) {
            var c = {};
            for (const d of b)
                c[d.GetBehaviorType().GetJsPropName()] = {
                    value: d.GetScriptInterface(),
                    writable: !1
                };
            b = Object.create(Object.prototype, c);
            a.behaviors = {
                value: b,
                writable: !1
            }
        }
    }
    DispatchUserScriptEvent(a) {
        if (this.HasScriptInterface()) {
            var b = this.GetInterfaceClass();
            a.instance = b;
            var c = this._runtime;
            (c = c.IsDebug() && !c.GetEventSheetManager().IsInEventEngine()) && C3Debugger$jscomp$2.StartMeasuringScriptTime();
            b.dispatchEvent(a);
            c && C3Debugger$jscomp$2.AddScriptTime()
        }
    }
}
;
"use strict";
const C3$jscomp$189 = self.C3;
C3$jscomp$189.SceneGraphInfo = class extends C3$jscomp$189.DefendedBase {
    constructor(a) {
        super();
        this._owner = a;
        this._parent = null;
        this._children = [];
        this._startWidth = a.GetWidth();
        this._startHeight = a.GetHeight();
        this._startScaleY = this._startScaleX = 1;
        this._parentStartAngle = 0;
        this._ownOpacity = 1;
        this._startOpacity = a.GetOpacity();
        this._tmpSceneGraphChildrenIndexes = this._tmpSceneGraphChildren = null;
        this._indexInParent = NaN
    }
    Release() {
        this._tmpSceneGraphChildrenIndexes = this._tmpSceneGraphChildren = this._parent = null;
        this._indexInParent = NaN;
        C3$jscomp$189.clearArray(this._children)
    }
    SetParent(a) {
        this._startOpacity = this._ownOpacity = this._owner.GetOpacity();
        this._parentStartAngle = (this._parent = a) ? a.GetAngle() : 0
    }
    GetParent() {
        return this._parent
    }
    HasChildren() {
        return 0 < this._children.length
    }
    GetChildren() {
        return this._children
    }
    _MaybeSortChildren() {
        this.HasChildren() && 1 !== this._children.length && (this._tmpSceneGraphChildrenIndexes ? this._children.sort( (a, b) => {
            a = this._tmpSceneGraphChildrenIndexes.get(a.GetInstance());
            b = this._tmpSceneGraphChildrenIndexes.get(b.GetInstance());
            return C3$jscomp$189.IsFiniteNumber(a) && C3$jscomp$189.IsFiniteNumber(b) ? a - b : 0
        }
        ) : this._children.sort( (a, b) => {
            a = a._GetSceneGraphInfo()._GetIndexInParent();
            b = b._GetSceneGraphInfo()._GetIndexInParent();
            return C3$jscomp$189.IsFiniteNumber(a) && C3$jscomp$189.IsFiniteNumber(b) ? a - b : 0
        }
        ))
    }
    _GetIndexInParent() {
        return this._indexInParent
    }
    GetStartScaleX() {
        return this._startScaleX
    }
    SetStartScaleX(a) {
        this._startScaleX = a
    }
    GetStartScaleY() {
        return this._startScaleY
    }
    SetStartScaleY(a) {
        this._startScaleY = a
    }
    GetStartOpacity() {
        return this._startOpacity
    }
    GetOwnOpacity() {
        return this._ownOpacity
    }
    SetOwnOpacity(a) {
        this._ownOpacity = a
    }
    _GetStartWidth() {
        return 0 === this._startWidth ? Number.EPSILON : this._startWidth
    }
    _GetStartHeight() {
        return 0 === this._startHeight ? Number.EPSILON : this._startHeight
    }
    GetParentScaleX() {
        if (this._owner.GetTransformWithParentWidth()) {
            var a = this._parent;
            let b = a.GetWidth()
              , c = a._GetSceneGraphInfo()._GetStartWidth();
            0 === b && (b = Number.EPSILON);
            return c === Number.EPSILON && b === Number.EPSILON ? 1 : c === Number.EPSILON && b !== Number.EPSILON && (a = a.GetInstance().GetSdkInstance(),
            a.IsOriginalSizeKnown()) ? 1 + b / a.GetOriginalWidth() : b / c
        }
        return 1
    }
    GetParentScaleY() {
        if (this._owner.GetTransformWithParentHeight()) {
            var a = this._parent;
            let b = a.GetHeight()
              , c = a._GetSceneGraphInfo()._GetStartHeight();
            0 === b && (b = Number.EPSILON);
            return c === Number.EPSILON && b === Number.EPSILON ? 1 : c === Number.EPSILON && b !== Number.EPSILON && (a = a.GetInstance().GetSdkInstance(),
            a.IsOriginalSizeKnown()) ? 1 + b / a.GetOriginalHeight() : b / c
        }
        return 1
    }
    GetParentStartAngle() {
        return this._parentStartAngle
    }
    _SaveToJsonProperties() {
        return {
            sw: this._startWidth,
            sh: this._startHeight,
            sx: this._startScaleX,
            sy: this._startScaleY,
            psa: this._parentStartAngle,
            oo: this._ownOpacity,
            so: this._startOpacity,
            pi: this._owner.GetInstance().GetIndexInParent()
        }
    }
    _SaveToJson(a, b=null) {
        const c = this._SaveToJsonProperties();
        return b && b.selfOnly ? Object.assign(c, {
            p: null,
            c: []
        }) : Object.assign(c, {
            p: this._GetParentJson(a),
            c: this._GetChildrenJson(a)
        })
    }
    _GetFlagsString(a) {
        let b = "";
        a.GetTransformWithParentX() && (b += "x");
        a.GetTransformWithParentY() && (b += "y");
        a.GetTransformWithParentWidth() && (b += "w");
        a.GetTransformWithParentHeight() && (b += "h");
        a.GetTransformWithParentAngle() && (b += "a");
        a.GetTransformWithParentZElevation() && (b += "z");
        a.GetDestroyWithParent() && (b += "d");
        a.GetTransformWithParentOpacity() && (b += "o");
        a.GetTransformWithParentVisibility() && (b += "v");
        return b
    }
    _GetParentJson(a) {
        return this._parent && this._parent.GetInstance() && !this._parent.GetInstance().IsDestroyed() ? this._GetInstanceJson(this._parent, this._owner, a) : null
    }
    _GetChildrenJson(a) {
        return this._children.map(b => this._GetInstanceJson(b, b, a)).filter(b => b)
    }
    _GetInstanceJson(a, b, c) {
        if ((a = a.GetInstance()) && a.IsDestroyed())
            return null;
        const d = {};
        d.uid = a.GetUID();
        d.f = this._GetFlagsString(b);
        d.offsets = b._SaveSceneGraphPropertiesToJson();
        d.data = C3$jscomp$189.SceneGraphInfo.GetSceneGraphInstanceDataFromInstance(a);
        d.oci = a.GetObjectClass().GetIndex();
        "state" === c ? (d.inst = a.SaveToJson("full", {
            selfOnly: !0
        }),
        d.instIndex = NaN) : (d.instIndex = a.GetObjectClass().GetInstances().indexOf(a),
        d.inst = null);
        return d
    }
    _LoadFromJson(a) {
        this._startWidth = a.sw;
        this._startHeight = a.sh;
        this._startScaleX = a.sx;
        this._startScaleY = a.sy;
        this._parentStartAngle = a.psa;
        this._ownOpacity = a.oo;
        this._startOpacity = a.so;
        this._indexInParent = C3$jscomp$189.IsFiniteNumber(a.pi) ? a.pi : NaN
    }
    _SetTmpSceneGraphChildren(a, b) {
        if (!a && !b && this._tmpSceneGraphChildren)
            for (const c of this._tmpSceneGraphChildren)
                c.IsDestroyed() || c.HasParent() || c.GetRuntime().DestroyInstance(c);
        this._tmpSceneGraphChildren = a;
        this._tmpSceneGraphChildrenIndexes = b
    }
    _OnAfterLoad(a, b) {
        const c = this._owner
          , d = c.GetRuntime()
          , e = new Set;
        if (a.p && !this._parent) {
            var f = d.GetInstanceByUID(a.p.uid);
            if (f) {
                var h = f.GetWorldInfo();
                f.HasChild(this._owner.GetInstance()) ? this._parent = h : (f.AddChild(this._owner.GetInstance(), this._GetFlagsObj(a.p.f)),
                e.has(this._owner) || (this._owner._LoadSceneGraphPropertiesFromJson(a.p.offsets),
                this._LoadInstancePropertiesFromJson(this._owner.GetInstance(), a.p)),
                e.add(this._owner),
                f.GetWorldInfo()._GetSceneGraphInfo()._MaybeSortChildren())
            } else
                C3$jscomp$189.IsFiniteNumber(a.p.oci) && (f = d.GetObjectClassByIndex(a.p.oci),
                d.GetSystemPlugin(),
                f = d.CreateInstance(f, c.GetLayer(), 0, 0, !0)) && (h = this._GetInstanceData(a.p, d),
                f.LoadFromJson(h),
                f.GetWorldInfo().GetLayer().SortAndAddInstancesByZIndex(f),
                f.AddChild(c.GetInstance(), this._GetFlagsObj(a.p.f)),
                f.GetWorldInfo()._GetSceneGraphInfo()._MaybeSortChildren())
        }
        f = [];
        for (var l of a.c)
            (h = d.GetInstanceByUID(l.uid)) && f.push(h);
        l = 0;
        for (const r of a.c) {
            if (h = d.GetInstanceByUID(r.uid)) {
                if (this._tmpSceneGraphChildren)
                    if (this._tmpSceneGraphChildren.includes(h)) {
                        var m = h;
                        if (m.GetObjectClass() !== h.GetObjectClass()) {
                            l++;
                            continue
                        }
                        if (m.IsDestroyed()) {
                            l++;
                            continue
                        }
                        h = a.c[l];
                        this._AddAndSetChildInstance(m.GetWorldInfo(), h, e, !0);
                        l++;
                        continue
                    } else if (this._tmpSceneGraphChildren[l]) {
                        m = this._tmpSceneGraphChildren[l];
                        if (m.GetObjectClass() !== h.GetObjectClass()) {
                            l++;
                            continue
                        }
                        if (m.IsDestroyed()) {
                            l++;
                            continue
                        }
                        h = a.c[l];
                        this._AddAndSetChildInstance(m.GetWorldInfo(), h, e, !0);
                        l++;
                        continue
                    }
                var p = h.GetObjectClass();
                m = this._GetInstancesOfObjectClassCount(f, p);
                p = c.GetInstance().GetChildrenOfObjectClass(p).length;
                if (m === p) {
                    if (h = c.GetInstance().GetChildAt(l))
                        if (m = h.GetWorldInfo())
                            e.has(m) || (m._LoadSceneGraphPropertiesFromJson(r.offsets),
                            this._LoadInstancePropertiesFromJson(h, r)),
                            e.add(m);
                    l++;
                    continue
                }
                if (h.HasParent()) {
                    h = this._CreateNewChildInstance(r, b);
                    this._AddAndSetChildInstance(h, r, e);
                    l++;
                    continue
                }
                this._AddAndSetChildInstance(h.GetWorldInfo(), r, e)
            } else if (this._tmpSceneGraphChildren && this._tmpSceneGraphChildren[l]) {
                h = this._tmpSceneGraphChildren[l];
                m = d.GetObjectClassByIndex(this._GetObjectClassIndex(r));
                if (h.GetObjectClass() !== m) {
                    l++;
                    continue
                }
                if (h.IsDestroyed()) {
                    l++;
                    continue
                }
                m = a.c[l];
                this._AddAndSetChildInstance(h.GetWorldInfo(), m, e)
            } else
                h = this._CreateNewChildInstance(r, b),
                this._AddAndSetChildInstance(h, r, e);
            l++
        }
    }
    _GetFlagsObj(a) {
        const b = {};
        b.transformX = a.includes("x");
        b.transformY = a.includes("y");
        b.transformWidth = a.includes("w");
        b.transformHeight = a.includes("h");
        b.transformAngle = a.includes("a");
        b.transformZElevation = a.includes("z");
        b.destroyWithParent = a.includes("d");
        b.transformOpacity = a.includes("o");
        b.transformVisibility = a.includes("v");
        return b
    }
    _GetObjectClassIndex(a) {
        return C3$jscomp$189.IsFiniteNumber(a.oci) ? a.oci : a[1]
    }
    _CreateNewChildInstance(a, b) {
        if (C3$jscomp$189.IsFiniteNumber(a.oci)) {
            var c = this._owner;
            b = c.GetRuntime();
            if (a.data)
                c = b.CreateInstanceFromData(a.data, c.GetLayer(), !1, 0, 0, !1, !0);
            else {
                const d = b.GetObjectClassByIndex(a.oci);
                c = b.CreateInstance(d, c.GetLayer(), 0, 0, !0)
            }
            if (c)
                return a = this._GetInstanceData(a, b),
                c.LoadFromJson(a),
                a = c.GetWorldInfo(),
                a.GetLayer().SortAndAddInstancesByZIndex(c, !0),
                a
        }
    }
    _AddAndSetChildInstance(a, b, c, d=!0) {
        this._owner.AddChild(a, this._GetFlagsObj(b.f)) && d && (c.has(a) || (a._LoadSceneGraphPropertiesFromJson(b.offsets),
        this._LoadInstancePropertiesFromJson(a.GetInstance(), b)),
        c.add(a));
        this._MaybeSortChildren()
    }
    _LoadInstancePropertiesFromJson(a, b) {
        if (b = this._GetInstanceData(b, this._owner.GetRuntime()))
            b = JSON.parse(JSON.stringify(b)),
            b.w = null,
            a.LoadFromJson(b)
    }
    _GetInstancesOfObjectClassCount(a, b) {
        return a.filter(c => c.GetObjectClass().GetName() === b.GetName()).length
    }
    _GetInstanceData(a, b) {
        if (C3$jscomp$189.IsFiniteNumber(a.instIndex))
            return b.GetObjectClassByIndex(a.oci)._GetLoadInstancesJson()[a.instIndex];
        if (C3$jscomp$189.IsString(a.inst))
            return JSON.parse(a.inst);
        if (a.inst)
            return a.inst
    }
    static GetSceneGraphInstanceDataFromInstance(a) {
        let b = a.GetWorldInfo().GetLayer().GetInitialInstanceData(a.GetUID());
        if (!b)
            return null;
        b = JSON.parse(JSON.stringify(b));
        const c = [];
        for (const d of [...a.GetChildren()]) {
            const e = d.GetWorldInfo();
            c.push([e.GetLayout().GetSID(), e.GetLayer().GetIndex(), d.GetUID(), C3$jscomp$189.SceneGraphInfo._GetFlagsNumber(e), d.GetObjectClass().IsInContainer() ? 1 : 0, e.GetZIndex(), C3$jscomp$189.SceneGraphInfo.GetSceneGraphInstanceDataFromInstance(d)])
        }
        C3$jscomp$189.IsArray(b[0][14]) ? b[0][14][1] = c : (b[0][14] = [],
        b[0][14][0] = C3$jscomp$189.SceneGraphInfo._GetDefaultFlagsNumber(),
        b[0][14][1] = c,
        b[0][14][2] = a.GetWorldInfo().GetZIndex());
        return b
    }
    static _GetFlagsNumber(a) {
        let b;
        b = 0 | Number(a.GetTransformWithParentVisibility()) << 8;
        b |= Number(a.GetTransformWithParentOpacity()) << 7;
        b |= Number(a.GetTransformWithParentZElevation()) << 6;
        b |= Number(a.GetDestroyWithParent()) << 5;
        b |= Number(a.GetTransformWithParentAngle()) << 4;
        b |= Number(a.GetTransformWithParentHeight()) << 3;
        b |= Number(a.GetTransformWithParentWidth()) << 2;
        b |= Number(a.GetTransformWithParentY()) << 1;
        return b |= Number(a.GetTransformWithParentX()) << 0
    }
    static _GetDefaultFlagsNumber(a) {
        return 511
    }
}
;
"use strict";
const C3$jscomp$190 = self.C3
  , tempRect$jscomp$7 = C3$jscomp$190.New(C3$jscomp$190.Rect)
  , tempQuad$jscomp$3 = C3$jscomp$190.New(C3$jscomp$190.Quad)
  , bboxChangeEvent = C3$jscomp$190.New(C3$jscomp$190.Event, "bboxchange", !1)
  , tempColor$jscomp$6 = C3$jscomp$190.New(C3$jscomp$190.Color, 0, 0, 0, 0)
  , tempCollisionPoly = C3$jscomp$190.New(C3$jscomp$190.CollisionPoly)
  , DEFAULT_COLOR = C3$jscomp$190.New(C3$jscomp$190.Color, 1, 1, 1, 1)
  , DEFAULT_RENDER_CELLS = C3$jscomp$190.New(C3$jscomp$190.Rect, 0, 0, -1, -1)
  , DEFAULT_COLLISION_CELLS = C3$jscomp$190.New(C3$jscomp$190.Rect, 0, 0, -1, -1)
  , VALID_SET_MESH_POINT_MODES = new Set(["absolute", "relative"])
  , EMPTY_ARRAY$jscomp$2 = [];
let enableUpdateRendererStateGroup = !0;
const FLAG_IS_VISIBLE = 1
  , FLAG_BBOX_CHANGED = 2
  , FLAG_ENABLE_BBOX_CHANGED_EVENT = 4
  , FLAG_COLLISION_ENABLED = 8
  , FLAG_COLLISION_CELL_CHANGED = 16
  , FLAG_SOLID_FILTER_INCLUSIVE = 32
  , FLAG_HAS_ANY_ACTIVE_EFFECT = 64
  , FLAG_IS_ROTATABLE = 128
  , FLAG_DESTROYED$jscomp$1 = 256
  , FLAG_DESTROY_WITH_PARENT = 512
  , FLAG_TRANSFORM_WITH_PARENT_X = 1024
  , FLAG_TRANSFORM_WITH_PARENT_Y = 2048
  , FLAG_TRANSFORM_WITH_PARENT_W = 4096
  , FLAG_TRANSFORM_WITH_PARENT_H = 8192
  , FLAG_TRANSFORM_WITH_PARENT_A = 16384
  , FLAG_TRANSFORM_WITH_PARENT_Z_ELEVATION = 32768
  , FLAG_TRANSFORM_WITH_PARENT_OPACITY = 4194304
  , FLAG_TRANSFORM_WITH_PARENT_VISIBILITY = 8388608
  , MASK_ALL_SCENE_GRAPH_FLAGS = FLAG_DESTROY_WITH_PARENT | FLAG_TRANSFORM_WITH_PARENT_X | FLAG_TRANSFORM_WITH_PARENT_Y | FLAG_TRANSFORM_WITH_PARENT_W | FLAG_TRANSFORM_WITH_PARENT_H | FLAG_TRANSFORM_WITH_PARENT_A | FLAG_TRANSFORM_WITH_PARENT_Z_ELEVATION | FLAG_TRANSFORM_WITH_PARENT_OPACITY | FLAG_TRANSFORM_WITH_PARENT_VISIBILITY
  , FLAG_MESH_CHANGED = 65536
  , FLAG_PHYSICS_BODY_CHANGED = 131072
  , FLAG_SIN_COS_ANGLE_CHANGED = 262144
  , FLAG_USE_POINTS_SHADER_PROGRAM = 524288
  , FLAG_DRAW_BACK_FACE_ONLY = 1048576
  , FLAG_DRAW_NON_BACK_FACES_ONLY = 2097152
  , FLAG_BLEND_MODE_MASK = 2080374784
  , sceneGraphExportDataMap = new WeakMap
  , sceneGraphZIndexMap = new WeakMap;
C3$jscomp$190.WorldInfo = class extends C3$jscomp$190.DefendedBase {
    constructor(a, b) {
        super();
        this._inst = a;
        this._objectClass = a.GetObjectClass();
        this._runtime = a.GetRuntime();
        this._layer = b;
        this._htmlZIndex = this._zIndex = -1;
        this._flags = FLAG_IS_VISIBLE | FLAG_BBOX_CHANGED | FLAG_COLLISION_ENABLED | FLAG_COLLISION_CELL_CHANGED | FLAG_MESH_CHANGED | FLAG_PHYSICS_BODY_CHANGED;
        this._objectClass.GetPlugin().IsRotatable() && (this._flags |= FLAG_IS_ROTATABLE);
        this._oy = this._ox = this._cosA = this._sinA = this._a = this._depth = this._h = this._w = this._zElevation = this._y = this._x = NaN;
        this._boundingBox = C3$jscomp$190.New(C3$jscomp$190.Rect);
        this._boundingQuad = C3$jscomp$190.New(C3$jscomp$190.Quad);
        this._collisionCells = DEFAULT_COLLISION_CELLS;
        this._renderCells = DEFAULT_RENDER_CELLS;
        this._solidFilterTags = this._transformedPolyInfo = this._sourceCollisionPoly = null;
        this._colorPremultiplied = this._color = DEFAULT_COLOR;
        this._instanceEffectList = this._stateGroup = null;
        this._inst.GetObjectClass().UsesEffects() && (this._instanceEffectList = C3$jscomp$190.New(C3$jscomp$190.InstanceEffectList, this._inst, this));
        this._tmpSceneGraphChildrenIndexes = this._tmpSceneGraphChildren = this._sceneGraphInfo = null;
        this._tmpHierarchyPosition = -1;
        this._meshInfo = null
    }
    _MarkDestroyed() {
        this._flags |= FLAG_DESTROYED$jscomp$1
    }
    Release() {
        this._stateGroup && (this._runtime.GetRenderer().ReleaseStateGroup(this._stateGroup),
        this._stateGroup = null);
        this._sourceCollisionPoly = null;
        this._transformedPolyInfo && (this._transformedPolyInfo.poly.Release(),
        this._transformedPolyInfo = null);
        this._solidFilterTags && (this._solidFilterTags.clear(),
        this._solidFilterTags = null);
        this.ReleaseMesh();
        this._instanceEffectList && this._instanceEffectList.Release();
        this.HasParent() && this.GetParent().RemoveChild(this);
        if (this.HasChildren()) {
            const a = [...this.GetChildren()];
            for (const b of a)
                this.RemoveChild(b)
        }
        this._ReleaseSceneGraphInfo();
        this._ReleaseTmpSceneGraphInfo();
        sceneGraphExportDataMap.delete(this);
        sceneGraphZIndexMap.delete(this);
        this._layer = this._runtime = this._objectClass = this._inst = null
    }
    Init(a) {
        enableUpdateRendererStateGroup = !1;
        this.SetXY(a[0], a[1]);
        this.SetZElevation(a[2]);
        this.SetSize(a[3], a[4]);
        this._depth = 0;
        this.IsRotatable() ? this.SetAngle(a[6]) : this._a = 0;
        tempColor$jscomp$6.setFromJSON(a[7]);
        this._SetColor(tempColor$jscomp$6);
        this.SetOriginX(a[8]);
        this.SetOriginY(a[9]);
        this.SetBlendMode(a[10]);
        this._instanceEffectList && this._instanceEffectList._LoadEffectParameters(a[12]);
        a[14] && sceneGraphExportDataMap.set(this, {
            childrenData: a[14][1],
            zIndexData: a[14][2]
        });
        if (a[15]) {
            var b = a[15];
            this.CreateMesh(b[0], b[1]);
            var c = this.GetSourceMesh();
            b = b[2];
            for (let f = 0, h = b.length; f < h; ++f) {
                var d = b[f];
                for (let l = 0, m = d.length; l < m; ++l) {
                    var e = d[l];
                    const p = c.GetMeshPointAt(l, f);
                    p.SetX(e[0]);
                    p.SetY(e[1]);
                    p.SetZElevation(e[2]);
                    p.SetU(e[3]);
                    p.SetV(e[4])
                }
            }
        }
        a[16] && (c = a[16][0],
        a = a[16][1],
        b = !!a,
        d = !b,
        e = this._runtime.GetTemplateManager(),
        b && e && e.MapInstanceToTemplateName(this.GetInstance(), a),
        d && e && e.MapInstanceToTemplateName(this.GetInstance(), c));
        enableUpdateRendererStateGroup = !0;
        this._UpdateRendererStateGroup()
    }
    InitNoData() {
        this._sinA = this._a = this._depth = this._h = this._w = this._zElevation = this._y = this._x = 0;
        this._cosA = 1;
        this._oy = this._ox = 0;
        this._UpdateRendererStateGroup()
    }
    GetRuntime() {
        return this._runtime
    }
    GetObjectClass() {
        return this._objectClass
    }
    GetInstance() {
        return this._inst
    }
    _GetParentOffsetAngle() {
        return this.GetTransformWithParentAngle() ? this._MaybeReflectAngleForMirrorFlip(this.GetParent()._GetAngleNoReflect() - this._sceneGraphInfo.GetParentStartAngle()) : 0
    }
    SetX(a) {
        a = +a;
        if (this.GetTransformWithParentX()) {
            const b = this._sceneGraphInfo;
            a -= this.GetX();
            const c = -this._GetParentOffsetAngle();
            0 === c ? this._x += a / b.GetParentScaleX() : (this._x += Math.cos(c) * a / b.GetParentScaleX(),
            this.GetTransformWithParentY() && (this._y += Math.sin(c) * a / b.GetParentScaleY()))
        } else
            this._x = a
    }
    OffsetX(a, b=!1) {
        a = +a;
        b ? this._x += a : this.GetTransformWithParentX() ? this.SetX(this.GetX() + a) : this._x += a
    }
    GetX() {
        if (this.GetTransformWithParentX()) {
            let a = this._x;
            const b = this._sceneGraphInfo
              , c = this.GetParent()
              , d = this._GetParentOffsetAngle();
            0 === d ? a *= b.GetParentScaleX() : (a = a * b.GetParentScaleX() * Math.cos(d),
            this.GetTransformWithParentY() && (a -= this._y * b.GetParentScaleY() * Math.sin(d)));
            return c.GetX() + a
        }
        return this._x
    }
    SetY(a) {
        a = +a;
        if (this.GetTransformWithParentY()) {
            const b = this._sceneGraphInfo;
            a -= this.GetY();
            const c = -this._GetParentOffsetAngle();
            0 === c ? this._y += a / b.GetParentScaleY() : (this.GetTransformWithParentX() && (this._x -= Math.sin(c) * a / b.GetParentScaleX()),
            this._y += Math.cos(c) * a / b.GetParentScaleY())
        } else
            this._y = a
    }
    OffsetY(a, b=!1) {
        a = +a;
        b ? this._y += a : this.GetTransformWithParentY() ? this.SetY(this.GetY() + a) : this._y += a
    }
    GetY() {
        if (this.GetTransformWithParentY()) {
            let a = this._y;
            const b = this._sceneGraphInfo
              , c = this.GetParent()
              , d = this._GetParentOffsetAngle();
            0 === d ? a *= b.GetParentScaleY() : (a = a * b.GetParentScaleY() * Math.cos(d),
            this.GetTransformWithParentX() && (a += this._x * b.GetParentScaleX() * Math.sin(d)));
            return c.GetY() + a
        }
        return this._y
    }
    SetXY(a, b) {
        a = +a;
        b = +b;
        if (this.GetTransformWithParentXOrY()) {
            const d = this.GetTransformWithParentX()
              , e = this.GetTransformWithParentY()
              , f = this._sceneGraphInfo
              , h = a - this.GetX()
              , l = b - this.GetY();
            var c = -this._GetParentOffsetAngle();
            if (0 === c)
                this._x = d ? this._x + h / f.GetParentScaleX() : a,
                this._y = e ? this._y + l / f.GetParentScaleY() : b;
            else {
                const m = Math.sin(c);
                c = Math.cos(c);
                this._x = d ? e ? this._x + (c * h - m * l) / f.GetParentScaleX() : this._x + c * h / f.GetParentScaleX() : a;
                this._y = e ? d ? this._y + (m * h + c * l) / f.GetParentScaleY() : this._y + c * l / f.GetParentScaleY() : b
            }
        } else
            this._x = a,
            this._y = b
    }
    GetXY() {
        return [this.GetX(), this.GetY()]
    }
    OffsetXY(a, b) {
        a = +a;
        b = +b;
        this.GetTransformWithParentXOrY() ? this.SetXY(this.GetX() + a, this.GetY() + b) : (this._x += a,
        this._y += b)
    }
    EqualsXY(a, b) {
        return this.GetX() === a && this.GetY() === b
    }
    SetZElevation(a) {
        a = +a;
        this.GetTransformWithParentZElevation() && (a -= this.GetParent().GetZElevation());
        this._zElevation !== a && (this._zElevation = a,
        this._UpdateZElevation(),
        a = this.GetLayer(),
        0 !== this._zElevation && a._SetAnyInstanceZElevated(),
        a.SetZIndicesChanged(this))
    }
    _UpdateZElevation() {
        this._UpdateRendererStateGroup();
        if (this.HasChildren()) {
            const a = this.GetChildren();
            for (let b = 0, c = a.length; b < c; b++) {
                const d = a[b];
                d.GetTransformWithParentZElevation() && d._UpdateZElevation()
            }
        }
    }
    OffsetZElevation(a) {
        this.SetZElevation(this.GetZElevation() + a)
    }
    GetZElevation() {
        return this.GetTransformWithParentZElevation() ? this.GetParent().GetZElevation() + this._zElevation : this._zElevation
    }
    GetTotalZElevation() {
        return this.GetLayer().GetZElevation() + this.GetZElevation()
    }
    SetWidth(a) {
        a = +a;
        if (this.GetTransformWithParentWidth()) {
            const b = this.GetWidth();
            this._w = 0 === b ? Number.EPSILON : a / b * this._w
        } else
            this._w = a;
        this._MarkSinCosAngleChanged()
    }
    OffsetWidth(a, b) {
        a = +a;
        b ? this._w += a : this.GetTransformWithParentWidth() ? this.SetWidth(this.GetWidth() + a) : this._w += a;
        this._MarkSinCosAngleChanged()
    }
    GetWidth() {
        if (this.GetTransformWithParentWidth()) {
            const a = this.GetParent()
              , b = a.GetWidth();
            return a._GetSceneGraphInfo()._GetStartWidth() === Number.EPSILON ? (this._GetSceneGraphInfo()._GetStartWidth() + b) * this._w : b * this._w
        }
        return this._w
    }
    SetHeight(a) {
        a = +a;
        if (this.GetTransformWithParentHeight()) {
            const b = this.GetHeight();
            this._h = 0 === b ? Number.EPSILON : a / b * this._h
        } else
            this._h = a;
        this._MarkSinCosAngleChanged()
    }
    OffsetHeight(a, b) {
        a = +a;
        b ? this._h += a : this.GetTransformWithParentHeight() ? this.SetHeight(this.GetHeight() + a) : this._h += a;
        this._MarkSinCosAngleChanged()
    }
    GetHeight() {
        if (this.GetTransformWithParentHeight()) {
            const a = this.GetParent()
              , b = a.GetHeight();
            return a._GetSceneGraphInfo()._GetStartHeight() === Number.EPSILON ? (this._GetSceneGraphInfo()._GetStartHeight() + b) * this._h : b * this._h
        }
        return this._h
    }
    SetSize(a, b) {
        a = +a;
        b = +b;
        if (this.GetTransformWithParentWidth()) {
            const c = this.GetWidth();
            this._w = 0 === c ? Number.EPSILON : a / c * this._w
        } else
            this._w = a;
        this.GetTransformWithParentHeight() ? (a = this.GetHeight(),
        this._h = 0 === a ? Number.EPSILON : b / a * this._h) : this._h = b;
        this._MarkSinCosAngleChanged()
    }
    GetSize() {
        return [this.GetWidth(), this.GetHeight()]
    }
    GetDepth() {
        return this._depth
    }
    SetDepth(a) {
        if (0 > a)
            throw new RangeError("invalid depth");
        this._depth = a
    }
    GetSceneGraphScale() {
        if (this.HasParent()) {
            const a = this._sceneGraphInfo;
            return Math.min(a.GetParentScaleX(), a.GetParentScaleY())
        }
        return 1
    }
    IsRotatable() {
        return 0 !== (this._flags & FLAG_IS_ROTATABLE)
    }
    SetAngle(a) {
        a = +a;
        this.IsRotatable() && (this.GetTransformWithParentAngle() && (a -= this.GetParent().GetAngle()),
        a = C3$jscomp$190.clampAngle(a),
        this._a !== a && (this._a = a,
        this._MarkSinCosAngleChanged()))
    }
    OffsetAngle(a) {
        a = +a;
        0 !== a && this.IsRotatable() && (this._a = C3$jscomp$190.clampAngle(this._a + a),
        this._MarkSinCosAngleChanged())
    }
    _MarkSinCosAngleChanged() {
        this._flags |= FLAG_SIN_COS_ANGLE_CHANGED;
        if (this.HasChildren()) {
            const a = this.GetChildren();
            for (let b = 0, c = a.length; b < c; b++)
                a[b]._MarkSinCosAngleChanged()
        }
    }
    GetAngle() {
        return this.GetTransformWithParentAngle() && this.IsRotatable() ? this._MaybeReflectAngleForMirrorFlip(C3$jscomp$190.clampAngle(this.GetParent()._GetAngleNoReflect() + this._a)) : this._a
    }
    _GetAngleNoReflect() {
        return this.GetTransformWithParentAngle() && this.IsRotatable() ? C3$jscomp$190.clampAngle(this.GetParent()._GetAngleNoReflect() + this._a) : this._a
    }
    _MaybeReflectAngleForMirrorFlip(a) {
        this.GetTransformWithParentWidth() && 0 > this.GetTopParent().GetWidth() && (a = C3$jscomp$190.clampAngle(C3$jscomp$190.angleReflect(a, this.GetTopParent().GetAngle() + Math.PI)));
        this.GetTransformWithParentHeight() && 0 > this.GetTopParent().GetHeight() && (a = C3$jscomp$190.angleReflect(a, this.GetTopParent().GetAngle()));
        return a
    }
    _NeedsReflectAngleForMirrorOrFlip() {
        const a = this.GetParent();
        return this.GetTransformWithParentWidth() && 0 > a.GetWidth() || this.GetTransformWithParentHeight() && 0 > a.GetHeight() ? !0 : !1
    }
    _NeedsReflectAngleForMirrorAndFlip() {
        const a = this.GetParent();
        return this.GetTransformWithParentWidth() && 0 > a.GetWidth() && this.GetTransformWithParentHeight() && 0 > a.GetHeight() ? !0 : !1
    }
    _MaybeUpdateSinCosAngle() {
        const a = this._flags;
        if (0 !== (a & FLAG_SIN_COS_ANGLE_CHANGED)) {
            var b = this.GetAngle();
            this._sinA = Math.sin(b);
            this._cosA = Math.cos(b);
            this._flags = a & ~FLAG_SIN_COS_ANGLE_CHANGED
        }
    }
    GetSinAngle() {
        this._MaybeUpdateSinCosAngle();
        return this._sinA
    }
    GetCosAngle() {
        this._MaybeUpdateSinCosAngle();
        return this._cosA
    }
    SetOriginX(a) {
        this._ox = +a
    }
    OffsetOriginX(a) {
        this._ox += +a
    }
    GetOriginX() {
        return this._ox
    }
    SetOriginY(a) {
        this._oy = +a
    }
    OffsetOriginY(a) {
        this._oy += +a
    }
    GetOriginY() {
        return this._oy
    }
    _SetColor(a) {
        this._color.equals(a) || (this._color === DEFAULT_COLOR ? (this._color = C3$jscomp$190.New(C3$jscomp$190.Color, a),
        this._colorPremultiplied = C3$jscomp$190.New(C3$jscomp$190.Color, a),
        this._colorPremultiplied.premultiply()) : a.equalsRgba(1, 1, 1, 1) ? this._colorPremultiplied = this._color = DEFAULT_COLOR : (this._color.set(a),
        this._colorPremultiplied.set(a),
        this._colorPremultiplied.premultiply()),
        this._UpdateRendererStateGroup())
    }
    SetOpacity(a) {
        a = C3$jscomp$190.clamp(+a, 0, 1);
        if (this.GetTransformWithParentOpacity()) {
            if (this._GetSceneGraphInfo().GetOwnOpacity() === a)
                return;
            this._GetSceneGraphInfo().SetOwnOpacity(a);
            a = this.GetOpacity()
        } else if (this._color.a === a)
            return;
        this._SetColorWithOpacity(a)
    }
    _SetOpacityOfChildren() {
        if (this.HasChildren()) {
            var a = this.GetChildren();
            for (let b = 0, c = a.length; b < c; b++) {
                const d = a[b];
                d._SetColorWithOpacity(d.GetOpacity())
            }
        }
    }
    _SetColorWithOpacity(a) {
        tempColor$jscomp$6.copyRgb(this._color);
        tempColor$jscomp$6.a = a;
        this._SetColor(tempColor$jscomp$6);
        this._SetOpacityOfChildren()
    }
    OffsetOpacity(a) {
        this.GetTransformWithParentOpacity() ? this.SetOpacity(this._GetSceneGraphInfo().GetOwnOpacity() + a) : this.SetOpacity(this.GetOpacity() + a)
    }
    GetOpacity() {
        return this.GetTransformWithParentOpacity() ? this.GetParent().GetOpacity() * this._GetSceneGraphInfo().GetOwnOpacity() : this._color.a
    }
    SetUnpremultipliedColor(a) {
        this._color.equalsIgnoringAlpha(a) || (tempColor$jscomp$6.copyRgb(a),
        tempColor$jscomp$6.a = this.GetOpacity(),
        this._SetColor(tempColor$jscomp$6))
    }
    SetUnpremultipliedColorRGB(a, b, c) {
        tempColor$jscomp$6.setRgb(a, b, c);
        this.SetUnpremultipliedColor(tempColor$jscomp$6)
    }
    OffsetUnpremultipliedColorRGB(a, b, c) {
        if (0 !== a || 0 !== b || 0 !== c)
            tempColor$jscomp$6.copyRgb(this._color),
            tempColor$jscomp$6.r += a,
            tempColor$jscomp$6.g += b,
            tempColor$jscomp$6.b += c,
            this.SetUnpremultipliedColor(tempColor$jscomp$6)
    }
    GetUnpremultipliedColor() {
        return this._color
    }
    GetPremultipliedColor() {
        return this._colorPremultiplied
    }
    GetDestroyWithParent() {
        return 0 !== (this._flags & FLAG_DESTROY_WITH_PARENT)
    }
    SetDestroyWithParent(a) {
        this._SetFlag(FLAG_DESTROY_WITH_PARENT, a)
    }
    GetTransformWithParentX() {
        return 0 !== (this._flags & FLAG_TRANSFORM_WITH_PARENT_X)
    }
    SetTransformWithParentX(a) {
        this._SetFlag(FLAG_TRANSFORM_WITH_PARENT_X, a)
    }
    GetTransformWithParentY() {
        return 0 !== (this._flags & FLAG_TRANSFORM_WITH_PARENT_Y)
    }
    GetTransformWithParentXOrY() {
        return 0 !== (this._flags & (FLAG_TRANSFORM_WITH_PARENT_X | FLAG_TRANSFORM_WITH_PARENT_Y))
    }
    SetTransformWithParentY(a) {
        this._SetFlag(FLAG_TRANSFORM_WITH_PARENT_Y, a)
    }
    GetTransformWithParentWidth() {
        return 0 !== (this._flags & FLAG_TRANSFORM_WITH_PARENT_W)
    }
    SetTransformWithParentWidth(a) {
        this._SetFlag(FLAG_TRANSFORM_WITH_PARENT_W, a)
    }
    GetTransformWithParentHeight() {
        return 0 !== (this._flags & FLAG_TRANSFORM_WITH_PARENT_H)
    }
    SetTransformWithParentHeight(a) {
        this._SetFlag(FLAG_TRANSFORM_WITH_PARENT_H, a)
    }
    GetTransformWithParentAngle() {
        return 0 !== (this._flags & FLAG_TRANSFORM_WITH_PARENT_A)
    }
    SetTransformWithParentAngle(a) {
        this._SetFlag(FLAG_TRANSFORM_WITH_PARENT_A, a)
    }
    GetTransformWithParentZElevation() {
        return 0 !== (this._flags & FLAG_TRANSFORM_WITH_PARENT_Z_ELEVATION)
    }
    SetTransformWithParentZElevation(a) {
        this._SetFlag(FLAG_TRANSFORM_WITH_PARENT_Z_ELEVATION, a)
    }
    GetTransformWithParentOpacity() {
        return 0 !== (this._flags & FLAG_TRANSFORM_WITH_PARENT_OPACITY)
    }
    SetTransformWithParentOpacity(a) {
        this._SetFlag(FLAG_TRANSFORM_WITH_PARENT_OPACITY, a)
    }
    GetTransformWithParentVisibility() {
        return 0 !== (this._flags & FLAG_TRANSFORM_WITH_PARENT_VISIBILITY)
    }
    SetTransformWithParentVisibility(a) {
        this._SetFlag(FLAG_TRANSFORM_WITH_PARENT_VISIBILITY, a)
    }
    _ClearAllSceneGraphFlags() {
        this._flags &= ~MASK_ALL_SCENE_GRAPH_FLAGS
    }
    AddChild(a, b) {
        if (a === this || a.HasParent() || this._HasChildRecursive(a) || this._HasAnyParent(a))
            return !1;
        var c = a.GetX()
          , d = a.GetY()
          , e = a.GetWidth();
        const f = a.GetHeight()
          , h = a.GetAngle()
          , l = a.GetZElevation()
          , m = a.GetOpacity();
        a._SetParent(this);
        a.SetTransformWithParentX(b.transformX);
        a.SetTransformWithParentY(b.transformY);
        a.SetTransformWithParentWidth(b.transformWidth);
        a.SetTransformWithParentHeight(b.transformHeight);
        a.SetTransformWithParentAngle(b.transformAngle);
        a.SetTransformWithParentZElevation(b.transformZElevation);
        a.SetTransformWithParentOpacity(b.transformOpacity);
        a.SetTransformWithParentVisibility(b.transformVisibility);
        a.SetDestroyWithParent(b.destroyWithParent);
        b.transformX && (a._x = c - this.GetX(),
        b.transformWidth && (c = this.GetWidth() / this._sceneGraphInfo._GetStartWidth(),
        0 !== c && (a._x /= c)));
        b.transformY && (a._y = d - this.GetY(),
        b.transformHeight && (d = this.GetHeight() / this._sceneGraphInfo._GetStartHeight(),
        0 !== d && (a._y /= d)));
        b.transformWidth && (d = this.GetWidth(),
        0 === d || d === Number.EPSILON ? (a._w = 1,
        a._sceneGraphInfo.SetStartScaleX(1)) : (a._w = e / this.GetWidth(),
        a._sceneGraphInfo.SetStartScaleX(a._w)));
        b.transformHeight && (e = this.GetHeight(),
        0 === e || e === Number.EPSILON ? (a._h = 1,
        a._sceneGraphInfo.SetStartScaleY(1)) : (a._h = f / this.GetHeight(),
        a._sceneGraphInfo.SetStartScaleY(a._h)));
        b.transformAngle && (a._a = h - this.GetAngle());
        b.transformZElevation && (a._zElevation = l - this.GetZElevation());
        b.transformOpacity && a._sceneGraphInfo.SetOwnOpacity(m);
        b.transformVisibility && a.SetVisible(this.IsVisible());
        this._AddChildToSceneGraphInfo(a);
        this.SetBboxChanged();
        this._SetOpacityOfChildren();
        return !0
    }
    RemoveChild(a) {
        if (a.GetParent() === this) {
            var b = a.GetX()
              , c = a.GetY()
              , d = a.GetWidth()
              , e = a.GetHeight()
              , f = a.GetAngle()
              , h = a.GetZElevation()
              , l = a.GetOpacity();
            a._SetParent(null);
            a._ClearAllSceneGraphFlags();
            a.SetXY(b, c);
            a.SetSize(d, e);
            a.SetAngle(f);
            a.SetZElevation(h);
            a.SetOpacity(l);
            this._RemoveChildFromSceneGraphInfo(a);
            this.SetBboxChanged()
        }
    }
    GetTmpHierarchyPosition() {
        return this._tmpHierarchyPosition
    }
    _ResetAllSceneGraphState() {
        this._BuildTmpSceneGraphData();
        var a = [...this.children()];
        for (const b of a)
            this.RemoveChild(b);
        (a = this.GetParent()) && a.RemoveChild(this);
        this._ClearAllSceneGraphFlags()
    }
    _BuildTmpSceneGraphData() {
        this._SetTmpHierarchyPosition();
        if (!this._tmpSceneGraphChildren) {
            var a = [...this.children()];
            a.length && (this._tmpSceneGraphChildren = [],
            this._tmpSceneGraphChildrenIndexes = new WeakMap);
            var b = 0;
            for (const c of a)
                a = c.GetInstance(),
                this._tmpSceneGraphChildren.push(a),
                this._tmpSceneGraphChildrenIndexes.set(a, b),
                b++
        }
        (b = this.GetParent()) && b._BuildTmpSceneGraphData()
    }
    _SetTmpHierarchyPosition() {
        if (-1 === this._tmpHierarchyPosition) {
            var a = [...this.parents()];
            this._tmpHierarchyPosition = a.length;
            for (const b of a)
                b._SetTmpHierarchyPosition();
            a = [...this.children()];
            for (const b of a)
                b._SetTmpHierarchyPosition()
        }
    }
    _ReleaseTmpSceneGraphInfo() {
        this._tmpSceneGraphChildren && (this._tmpSceneGraphChildren.length = 0);
        this._tmpSceneGraphChildrenIndexes = this._tmpSceneGraphChildren = null;
        const a = this.GetParent();
        a && a._ReleaseTmpSceneGraphInfo();
        this._tmpHierarchyPosition = -1
    }
    HasParent() {
        return null !== this.GetParent()
    }
    GetParent() {
        const a = this._sceneGraphInfo;
        return null !== a ? a.GetParent() : null
    }
    GetTopParent() {
        let a = this;
        for (; a.HasParent(); )
            a = a.GetParent();
        return a
    }
    *parents() {
        let a = this.GetParent();
        for (; a; )
            yield a,
            a = a.GetParent()
    }
    HasChild(a) {
        return this.GetChildren().includes(a)
    }
    HasChildren() {
        const a = this._sceneGraphInfo;
        return null !== a ? a.HasChildren() : !1
    }
    GetChildren() {
        const a = this._sceneGraphInfo;
        return null !== a ? a.GetChildren() : EMPTY_ARRAY$jscomp$2
    }
    children() {
        return this.GetChildren()
    }
    *allChildren() {
        for (const a of this.children())
            yield a,
            yield*a.allChildren()
    }
    GetChildCount() {
        return this.GetChildren().length
    }
    GetAllChildCount() {
        return [...this.allChildren()].length
    }
    GetChildAt(a) {
        const b = this.GetChildren();
        a = Math.floor(+a);
        return 0 > a || a >= b.length ? null : b[a]
    }
    GetChildIndex(a) {
        if (!a)
            return NaN;
        const b = this.GetChildren();
        if (!b)
            return NaN;
        for (let c = 0; c < b.length; c++)
            if (a === b[c])
                return c;
        return NaN
    }
    _CreateSceneGraphInfo(a) {
        this._sceneGraphInfo || (this._sceneGraphInfo = C3$jscomp$190.New(C3$jscomp$190.SceneGraphInfo, this));
        a && this._sceneGraphInfo.SetParent(a)
    }
    _GetSceneGraphInfo() {
        return this._sceneGraphInfo
    }
    _ReleaseSceneGraphInfo() {
        this._sceneGraphInfo && (this._sceneGraphInfo.Release(),
        this._sceneGraphInfo = null)
    }
    _SetParent(a) {
        a ? (a._CreateSceneGraphInfo(null),
        this._CreateSceneGraphInfo(a)) : (this._sceneGraphInfo && this._sceneGraphInfo.SetParent(null),
        this.HasChildren() || this._ReleaseSceneGraphInfo())
    }
    _HasAnyParent(a) {
        if (!this.HasParent())
            return !1;
        const b = this.GetParent();
        return b === a ? !0 : b._HasAnyParent(a)
    }
    _HasChildRecursive(a) {
        if (this.HasChild(a))
            return !0;
        for (const b of this.GetChildren())
            if (b._HasChildRecursive(a))
                return !0;
        return !1
    }
    _AddChildToSceneGraphInfo(a) {
        this._sceneGraphInfo.GetChildren().push(a)
    }
    _RemoveChildFromSceneGraphInfo(a) {
        const b = this._sceneGraphInfo.GetChildren()
          , c = b.indexOf(a);
        -1 !== c && b.splice(c, 1);
        0 !== b.length || this.HasParent() || this._ReleaseSceneGraphInfo();
        a.HasChildren() || a._ReleaseSceneGraphInfo()
    }
    GetSceneGraphChildrenExportData() {
        const a = sceneGraphExportDataMap.get(this);
        return a ? a.childrenData : null
    }
    GetSceneGraphZIndexExportData() {
        const a = sceneGraphExportDataMap.get(this);
        return a ? a.zIndexData : NaN
    }
    GetSceneGraphZIndex() {
        const a = sceneGraphZIndexMap.get(this);
        return C3$jscomp$190.IsFiniteNumber(a) ? a : NaN
    }
    SetSceneGraphZIndex(a) {
        sceneGraphZIndexMap.set(this, a)
    }
    SetUsePointsShaderProgram() {
        this._SetFlag(FLAG_USE_POINTS_SHADER_PROGRAM, !0);
        this._UpdateRendererStateGroup()
    }
    _UpdateRendererStateGroup() {
        if (enableUpdateRendererStateGroup) {
            var a = this._runtime.GetRenderer();
            this._stateGroup && a.ReleaseStateGroup(this._stateGroup);
            var b = 0 !== (this._flags & FLAG_USE_POINTS_SHADER_PROGRAM) ? a.GetPointsRenderingProgram() || "<point>" : a.GetTextureFillShaderProgram() || "<default>";
            this._stateGroup = a.AcquireStateGroup(b, this.GetBlendMode(), this._colorPremultiplied, this.GetZElevation())
        }
    }
    GetRendererStateGroup() {
        return this._stateGroup
    }
    HasDefaultColor() {
        return this._color === DEFAULT_COLOR
    }
    SetBlendMode(a) {
        a |= 0;
        if (0 > a || 31 < a)
            throw new RangeError("invalid blend mode");
        this.GetBlendMode() !== a && (this._flags = this._flags & ~FLAG_BLEND_MODE_MASK | a << 26,
        this._UpdateRendererStateGroup())
    }
    GetBlendMode() {
        return (this._flags & FLAG_BLEND_MODE_MASK) >> 26
    }
    _SetLayer(a, b) {
        (b = b && this._layer !== a) && this._RemoveFromRenderCells();
        this._layer = a;
        b && this._UpdateRenderCell();
        0 !== this.GetZElevation() && this._layer._SetAnyInstanceZElevated()
    }
    GetLayer() {
        return this._layer
    }
    GetLayout() {
        return this.GetLayer().GetLayout()
    }
    _SetZIndex(a) {
        this._zIndex = a | 0
    }
    GetZIndex() {
        this._layer._UpdateZIndices();
        return this._zIndex
    }
    _SetHTMLZIndex(a) {
        this._htmlZIndex = a | 0
    }
    GetHTMLZIndex() {
        this._layer._UpdateHTMLZIndices();
        return this._htmlZIndex
    }
    _GetLastCachedZIndex() {
        return this._zIndex
    }
    _SetFlag(a, b) {
        this._flags = b ? this._flags | a : this._flags & ~a
    }
    IsVisible() {
        return 0 !== (this._flags & FLAG_IS_VISIBLE)
    }
    SetVisible(a) {
        this._SetFlag(FLAG_IS_VISIBLE, a);
        if (this.HasChildren())
            for (const b of this.GetChildren())
                b.GetTransformWithParentVisibility() && b.SetVisible(a)
    }
    IsCollisionEnabled() {
        return 0 !== (this._flags & FLAG_COLLISION_ENABLED)
    }
    SetCollisionEnabled(a) {
        a = !!a;
        this.IsCollisionEnabled() !== a && (this._SetFlag(FLAG_COLLISION_ENABLED, a),
        a ? this.SetBboxChanged() : this._RemoveFromCollisionCells())
    }
    SetSolidCollisionFilter(a, b) {
        this._SetFlag(FLAG_SOLID_FILTER_INCLUSIVE, a);
        this._solidFilterTags && this._solidFilterTags.clear();
        if (b.trim()) {
            this._solidFilterTags || (this._solidFilterTags = new Set);
            for (const c of b.split(" "))
                c && this._solidFilterTags.add(c.toLowerCase())
        } else
            this._solidFilterTags = null
    }
    IsSolidCollisionAllowed(a) {
        const b = 0 !== (this._flags & FLAG_SOLID_FILTER_INCLUSIVE)
          , c = this._solidFilterTags;
        if (!a || !c)
            return !b;
        for (const d of c)
            if (a.has(d))
                return b;
        return !b
    }
    SetBboxChanged() {
        this._flags = this._flags | FLAG_BBOX_CHANGED | FLAG_COLLISION_CELL_CHANGED | FLAG_MESH_CHANGED;
        this._objectClass._SetAnyCollisionCellChanged(!0);
        this._runtime.UpdateRender();
        this._layer.UsesRenderCells() && (this.CalculateBbox(this._boundingBox, this._boundingQuad, !0),
        this._flags &= ~FLAG_BBOX_CHANGED,
        this._UpdateRenderCell());
        0 !== (this._flags & FLAG_ENABLE_BBOX_CHANGED_EVENT) && this._inst.Dispatcher().dispatchEvent(bboxChangeEvent);
        if (null !== this._sceneGraphInfo) {
            const a = this._sceneGraphInfo.GetChildren();
            for (let b = 0, c = a.length; b < c; ++b)
                a[b].SetBboxChanged()
        }
    }
    CalculateBbox(a, b, c) {
        const d = this.GetX()
          , e = this.GetY()
          , f = this.GetWidth()
          , h = this.GetHeight()
          , l = this.GetAngle();
        a.setWH(d - this._ox * f, e - this._oy * h, f, h);
        c && this.HasMesh() && this._ExpandBboxForMesh(a);
        0 === l ? b.setFromRect(a) : (a.offset(-d, -e),
        b.setFromRotatedRectPrecalc(a, this.GetSinAngle(), this.GetCosAngle()),
        b.offset(d, e),
        b.getBoundingBox(a));
        a.normalize()
    }
    _UpdateBbox() {
        const a = this._flags;
        0 !== (a & FLAG_BBOX_CHANGED) && (this.CalculateBbox(this._boundingBox, this._boundingQuad, !0),
        this._flags = a & ~FLAG_BBOX_CHANGED)
    }
    GetBoundingBox() {
        this._UpdateBbox();
        return this._boundingBox
    }
    GetBoundingQuad() {
        this._UpdateBbox();
        return this._boundingQuad
    }
    PixelRoundQuad(a) {
        var b = this.GetX()
          , c = this.GetY();
        b = Math.round(b) - b;
        c = Math.round(c) - c;
        if (0 === b && 0 === c)
            return a;
        tempQuad$jscomp$3.copy(a);
        tempQuad$jscomp$3.offset(b, c);
        return tempQuad$jscomp$3
    }
    OverwriteBoundingBox(a) {
        this._boundingBox.copy(a);
        this._boundingQuad.setFromRect(this._boundingBox);
        this._flags &= ~FLAG_BBOX_CHANGED;
        this._UpdateCollisionCell();
        this._UpdateRenderCell()
    }
    SetBboxChangeEventEnabled(a) {
        this._SetFlag(FLAG_ENABLE_BBOX_CHANGED_EVENT, a)
    }
    IsBboxChangeEventEnabled() {
        return 0 !== (this._flags & FLAG_ENABLE_BBOX_CHANGED_EVENT)
    }
    IsInViewport(a, b, c) {
        return b && 0 !== this.GetDepth() ? this.IsInViewport3D(this.GetLayer()._GetViewFrustum()) : 0 === this.GetZElevation() || c ? a.intersectsRect(this.GetBoundingBox()) : this._IsInViewport_ZElevated()
    }
    _IsInViewport_ZElevated() {
        const a = this.GetLayer()
          , b = this.GetTotalZElevation();
        if (b >= a.GetCameraZ())
            return !1;
        a.GetViewportForZ(b, tempRect$jscomp$7);
        return tempRect$jscomp$7.intersectsRect(this.GetBoundingBox())
    }
    IsInViewport3D(a) {
        var b = this.GetBoundingBox();
        const c = b.getLeft()
          , d = b.getRight()
          , e = b.getTop();
        b = b.getBottom();
        const f = this.GetTotalZElevation()
          , h = f + this.GetDepth();
        return a.ContainsAABB(c, e, f, d, b, h)
    }
    IsInViewport2() {
        const a = this.GetLayer();
        if (a.Has3DCamera())
            return this.IsInViewport3D(a._GetViewFrustum());
        const b = a.GetLayout();
        return this.IsInViewport(a.GetViewport(), b.HasVanishingPointOutsideViewport(), b.IsOrthographicProjection())
    }
    _SetDrawBackFaceOnly(a) {
        this._SetFlag(FLAG_DRAW_BACK_FACE_ONLY, a)
    }
    _SetDrawNonBackFacesOnly(a) {
        this._SetFlag(FLAG_DRAW_NON_BACK_FACES_ONLY, a)
    }
    IsDrawBackFaceOnly() {
        return 0 !== (this._flags & FLAG_DRAW_BACK_FACE_ONLY)
    }
    IsDrawNonBackFacesOnly() {
        return 0 !== (this._flags & FLAG_DRAW_NON_BACK_FACES_ONLY)
    }
    SetSourceCollisionPoly(a) {
        this._sourceCollisionPoly = a;
        this._DiscardTransformedCollisionPoly();
        this.HasMesh() && (this._meshInfo.meshPoly = null)
    }
    GetSourceCollisionPoly() {
        return this._sourceCollisionPoly
    }
    HasOwnCollisionPoly() {
        return null !== this._sourceCollisionPoly || this.HasMesh()
    }
    GetTransformedCollisionPoly() {
        return this._GetCustomTransformedCollisionPolyPrecalc(this.GetWidth(), this.GetHeight(), this.GetAngle(), this.GetSinAngle(), this.GetCosAngle())
    }
    GetCustomTransformedCollisionPoly(a, b, c) {
        let d = 0
          , e = 1;
        0 !== c && (d = Math.sin(c),
        e = Math.cos(c));
        return this._GetCustomTransformedCollisionPolyPrecalc(a, b, c, d, e)
    }
    _GetCustomTransformedCollisionPolyPrecalc(a, b, c, d, e) {
        let f = this._transformedPolyInfo;
        null === f && (this._transformedPolyInfo = f = {
            poly: C3$jscomp$190.New(C3$jscomp$190.CollisionPoly),
            width: NaN,
            height: NaN,
            angle: NaN
        });
        const h = f.poly;
        if (f.width === a && f.height === b && f.angle === c)
            return h;
        const l = this._sourceCollisionPoly;
        if (this.HasMesh()) {
            const m = this.GetOriginX()
              , p = this.GetOriginY()
              , r = this.GetSourceMesh();
            let v = this._meshInfo.meshPoly;
            v || (l ? (tempCollisionPoly.copy(l),
            tempCollisionPoly.offset(m, p)) : tempCollisionPoly.setDefaultPoints(),
            v = r.InsertPolyMeshVertices(tempCollisionPoly),
            this._meshInfo.meshPoly = v);
            r.TransformCollisionPoly(v, h);
            h.offset(-m, -p);
            h.transformPrecalc(a, b, d, e)
        } else
            l ? (h.copy(l),
            h.transformPrecalc(a, b, d, e)) : h.setFromQuad(this.GetBoundingQuad(), -this.GetX(), -this.GetY());
        f.width = a;
        f.height = b;
        f.angle = c;
        return h
    }
    _DiscardTransformedCollisionPoly() {
        this.SetPhysicsBodyChanged(!0);
        const a = this._transformedPolyInfo;
        null !== a && (a.width = NaN)
    }
    CreateMesh(a, b) {
        a = Math.floor(a);
        b = Math.floor(b);
        if (!this.GetInstance().GetPlugin().SupportsMesh())
            throw Error("object does not support mesh");
        this.ReleaseMesh();
        this._meshInfo = {
            sourceMesh: C3$jscomp$190.New(C3$jscomp$190.Gfx.Mesh, a, b),
            transformedMesh: C3$jscomp$190.New(C3$jscomp$190.Gfx.Mesh, a, b),
            meshPoly: null
        }
    }
    HasMesh() {
        return null !== this._meshInfo
    }
    GetSourceMesh() {
        if (!this.HasMesh())
            throw Error("no mesh");
        return this._meshInfo.sourceMesh
    }
    GetTransformedMesh() {
        if (!this.HasMesh())
            throw Error("no mesh");
        return this._meshInfo.transformedMesh
    }
    SetMeshChanged(a) {
        this._SetFlag(FLAG_MESH_CHANGED, a)
    }
    IsMeshChanged() {
        return 0 !== (this._flags & FLAG_MESH_CHANGED)
    }
    SetPhysicsBodyChanged(a) {
        this._SetFlag(FLAG_PHYSICS_BODY_CHANGED, a)
    }
    IsPhysicsBodyChanged() {
        return 0 !== (this._flags & FLAG_PHYSICS_BODY_CHANGED)
    }
    _ExpandBboxForMesh(a) {
        const b = this._meshInfo.sourceMesh
          , c = Math.min(b.GetMinX(), 0)
          , d = Math.min(b.GetMinY(), 0)
          , e = Math.max(b.GetMaxX(), 1)
          , f = Math.max(b.GetMaxY(), 1)
          , h = a.width()
          , l = a.height();
        a.offsetLeft(c * h);
        a.offsetTop(d * l);
        a.offsetRight((e - 1) * h);
        a.offsetBottom((f - 1) * l);
        this._depth = b.GetMaxZ()
    }
    ReleaseMesh() {
        this._meshInfo && (this._meshInfo.sourceMesh.Release(),
        this._meshInfo.transformedMesh.Release(),
        this._meshInfo = null,
        this._DiscardTransformedCollisionPoly())
    }
    SetMeshPoint(a, b, c) {
        a = Math.floor(a);
        b = Math.floor(b);
        var d = c.mode || "absolute";
        if (!VALID_SET_MESH_POINT_MODES.has(d))
            throw Error("invalid mode");
        d = "relative" === d;
        let e = c.x
          , f = c.y;
        const h = c.zElevation;
        let l = "number" === typeof c.u ? c.u : d ? 0 : -1;
        c = "number" === typeof c.v ? c.v : d ? 0 : -1;
        if (!this.HasMesh())
            return !1;
        const m = this.GetSourceMesh()
          , p = m.GetMeshPointAt(a, b);
        if (null === p)
            return !1;
        let r = !1;
        "number" === typeof h && p.GetZElevation() !== h && (p.SetZElevation(h),
        r = !0);
        d && (e += a / (m.GetHSize() - 1),
        f += b / (m.GetVSize() - 1));
        -1 !== l || d ? (d && (l += a / (m.GetHSize() - 1)),
        l = C3$jscomp$190.clamp(l, 0, 1)) : l = p.GetU();
        -1 !== c || d ? (d && (c += b / (m.GetVSize() - 1)),
        c = C3$jscomp$190.clamp(c, 0, 1)) : c = p.GetV();
        if (p.GetX() === e && p.GetY() === f && p.GetU() === l && p.GetV() === c)
            return r;
        p.SetX(e);
        p.SetY(f);
        p.SetU(l);
        p.SetV(c);
        this._DiscardTransformedCollisionPoly();
        return !0
    }
    HasTilemap() {
        return this._inst.HasTilemap()
    }
    ContainsPoint(a, b) {
        return this.GetBoundingBox().containsPoint(a, b) && this.GetBoundingQuad().containsPoint(a, b) ? this.HasTilemap() ? this._inst.GetSdkInstance().TestPointOverlapTile(a, b) : this.HasOwnCollisionPoly() ? this.GetTransformedCollisionPoly().containsPoint(a - this.GetX(), b - this.GetY()) : !0 : !1
    }
    _IsCollisionCellChanged() {
        return 0 !== (this._flags & FLAG_COLLISION_CELL_CHANGED)
    }
    _UpdateCollisionCell() {
        if (this._IsCollisionCellChanged() && this.IsCollisionEnabled() && 0 === (this._flags & FLAG_DESTROYED$jscomp$1)) {
            var a = this.GetBoundingBox()
              , b = this._objectClass._GetCollisionCellGrid()
              , c = this._collisionCells;
            tempRect$jscomp$7.set(b.XToCell(a.getLeft()), b.YToCell(a.getTop()), b.XToCell(a.getRight()), b.YToCell(a.getBottom()));
            c.equals(tempRect$jscomp$7) || (a = this._inst,
            c === DEFAULT_COLLISION_CELLS ? (b.Update(a, null, tempRect$jscomp$7),
            this._collisionCells = C3$jscomp$190.New(C3$jscomp$190.Rect, tempRect$jscomp$7)) : (b.Update(a, c, tempRect$jscomp$7),
            c.copy(tempRect$jscomp$7)),
            this._flags &= ~FLAG_COLLISION_CELL_CHANGED)
        }
    }
    _SetCollisionCellChanged() {
        this._flags |= FLAG_COLLISION_CELL_CHANGED
    }
    _RemoveFromCollisionCells() {
        const a = this._collisionCells;
        a !== DEFAULT_COLLISION_CELLS && (this._objectClass._GetCollisionCellGrid().Update(this._inst, a, null),
        this._collisionCells = DEFAULT_COLLISION_CELLS)
    }
    _UpdateRenderCell() {
        const a = this.GetLayer();
        if (a.UsesRenderCells() && 0 === (this._flags & FLAG_DESTROYED$jscomp$1)) {
            var b = a.GetRenderGrid()
              , c = this.GetBoundingBox()
              , d = this._renderCells;
            tempRect$jscomp$7.set(b.XToCell(c.getLeft()), b.YToCell(c.getTop()), b.XToCell(c.getRight()), b.YToCell(c.getBottom()));
            d.equals(tempRect$jscomp$7) || (c = this._inst,
            d === DEFAULT_RENDER_CELLS ? (b.Update(c, null, tempRect$jscomp$7),
            this._renderCells = C3$jscomp$190.New(C3$jscomp$190.Rect, tempRect$jscomp$7)) : (b.Update(c, d, tempRect$jscomp$7),
            d.copy(tempRect$jscomp$7)),
            a.SetRenderListStale())
        }
    }
    _RemoveFromRenderCells() {
        const a = this._renderCells;
        a !== DEFAULT_RENDER_CELLS && (this.GetLayer().GetRenderGrid().Update(this._inst, a, null),
        this._renderCells = DEFAULT_RENDER_CELLS)
    }
    GetRenderCellRange() {
        return this._renderCells
    }
    ZOrderMoveToTop() {
        const a = this._inst
          , b = this._layer
          , c = b._GetInstances();
        c.length && c.at(-1) === a || (b._RemoveInstance(a, !1),
        b._AddInstance(a, !1),
        this._runtime.UpdateRender())
    }
    ZOrderMoveToBottom() {
        const a = this._inst
          , b = this._layer
          , c = b._GetInstances();
        c.length && c[0] === a || (b._RemoveInstance(a, !1),
        b._PrependInstance(a, !1),
        this._runtime.UpdateRender())
    }
    ZOrderMoveToLayer(a) {
        const b = this._inst
          , c = this._layer;
        if (c.GetLayout() !== a.GetLayout())
            throw Error("layer from different layout");
        a !== c && (c._RemoveInstance(b, !0),
        this._SetLayer(a),
        a._AddInstance(b, !0),
        this._runtime.UpdateRender())
    }
    ZOrderMoveAdjacentToInstance(a, b) {
        const c = this._inst;
        let d = !1;
        const e = this._layer;
        if (a.GetUID() !== c.GetUID()) {
            var f = a.GetWorldInfo();
            if (!f)
                throw Error("expected world instance");
            f = f.GetLayer();
            e.GetIndex() !== f.GetIndex() && (e._RemoveInstance(c, !0),
            this._SetLayer(f),
            f._AddInstance(c, !0),
            d = !0);
            a = f.MoveInstanceAdjacent(c, a, !!b);
            (d || a) && this._runtime.UpdateRender()
        }
    }
    GetInstanceEffectList() {
        return this._instanceEffectList
    }
    _SetHasAnyActiveEffect(a) {
        this._SetFlag(FLAG_HAS_ANY_ACTIVE_EFFECT, a)
    }
    HasAnyActiveEffect() {
        return 0 !== (this._flags & FLAG_HAS_ANY_ACTIVE_EFFECT)
    }
    _SaveToJson(a, b=null) {
        const c = {
            x: this.GetX(),
            y: this.GetY(),
            w: this.GetWidth(),
            h: this.GetHeight(),
            l: this.GetLayer().GetSID(),
            zi: this.GetZIndex()
        };
        0 !== this.GetZElevation() && (c.ze = this.GetZElevation());
        0 !== this.GetAngle() && (c.a = this._GetAngleNoReflect());
        this.HasDefaultColor() || (c.c = this._color.toJSON());
        .5 !== this.GetOriginX() && (c.oX = this.GetOriginX());
        .5 !== this.GetOriginY() && (c.oY = this.GetOriginY());
        0 !== this.GetBlendMode() && (c.bm = this.GetBlendMode());
        this.IsVisible() || (c.v = this.IsVisible());
        this.IsCollisionEnabled() || (c.ce = this.IsCollisionEnabled());
        this.IsBboxChangeEventEnabled() && (c.be = this.IsBboxChangeEventEnabled());
        this._instanceEffectList && (c.fx = this._instanceEffectList._SaveToJson());
        const d = 0 !== (this._flags & FLAG_SOLID_FILTER_INCLUSIVE);
        d && (c.sfi = d);
        this._solidFilterTags && (c.sft = [...this._solidFilterTags].join(" "));
        this._sceneGraphInfo && "visual-state" !== a && (c.sgi = this._sceneGraphInfo._SaveToJson(a, b),
        sceneGraphExportDataMap.has(this) && (c.sgcd = sceneGraphExportDataMap.get(this).childrenData,
        c.sgzid = sceneGraphExportDataMap.get(this).zIndexData));
        this.HasMesh() && (c.mesh = this.GetSourceMesh().SaveToJson());
        return c
    }
    _SaveSceneGraphPropertiesToJson() {
        return {
            x: this._x,
            y: this._y,
            z: this._zElevation,
            w: this._w,
            h: this._h,
            a: this._a,
            sgi: this._GetSceneGraphInfo() ? this._GetSceneGraphInfo()._SaveToJsonProperties() : null
        }
    }
    _LoadSceneGraphPropertiesFromJson(a) {
        a && (this._x = a.x,
        this._y = a.y,
        this._zElevation = a.z,
        this._w = a.w,
        this._h = a.h,
        this._a = a.a,
        a.sgi && this._GetSceneGraphInfo() && this._GetSceneGraphInfo()._LoadFromJson(a.sgi),
        this._MarkSinCosAngleChanged(),
        this.SetBboxChanged())
    }
    _SetupSceneGraphConnectionsOnChangeOfLayout() {
        this._ReleaseTmpSceneGraphInfo();
        this._ResetAllSceneGraphState();
        this._CreateSceneGraphInfo(null);
        this._sceneGraphInfo && this._sceneGraphInfo._SetTmpSceneGraphChildren(this._tmpSceneGraphChildren, this._tmpSceneGraphChildrenIndexes)
    }
    _OnBeforeLoad(a) {
        "visual-state" !== a && this._ResetAllSceneGraphState()
    }
    _OnAfterLoad(a, b="full", c=null) {
        a.hasOwnProperty("sgi") && "visual-state" !== b && 0 === (this._flags & FLAG_DESTROYED$jscomp$1) && this._sceneGraphInfo._OnAfterLoad(a.sgi, c)
    }
    _OnAfterLoad2(a, b="full", c) {
        a.hasOwnProperty("sgi") && "visual-state" !== b && 0 === (this._flags & FLAG_DESTROYED$jscomp$1) && (this._sceneGraphInfo._SetTmpSceneGraphChildren(null, null),
        this._ReleaseTmpSceneGraphInfo(),
        this.SetBboxChanged())
    }
    _LoadFromJson(a, b) {
        enableUpdateRendererStateGroup = !1;
        this.SetX(a.x);
        this.SetY(a.y);
        this.SetWidth(a.w);
        this.SetHeight(a.h);
        this._SetZIndex(a.zi);
        this.SetZElevation(a.hasOwnProperty("ze") ? a.ze : 0);
        this.SetAngle(a.hasOwnProperty("a") ? a.a : 0);
        a.hasOwnProperty("c") ? tempColor$jscomp$6.setFromJSON(a.c) : a.hasOwnProperty("o") ? (tempColor$jscomp$6.copyRgb(this._color),
        tempColor$jscomp$6.a = a.o) : tempColor$jscomp$6.setRgba(1, 1, 1, 1);
        this._SetColor(tempColor$jscomp$6);
        this.SetOriginX(a.hasOwnProperty("oX") ? a.oX : .5);
        this.SetOriginY(a.hasOwnProperty("oY") ? a.oY : .5);
        this.SetBlendMode(a.hasOwnProperty("bm") ? a.bm : 0);
        this.SetVisible(a.hasOwnProperty("v") ? a.v : !0);
        this.SetCollisionEnabled(a.hasOwnProperty("ce") ? a.ce : !0);
        this.SetBboxChangeEventEnabled(a.hasOwnProperty("be") ? a.be : !1);
        this.SetSolidCollisionFilter(a.hasOwnProperty("sfi") ? a.sfi : !1, a.hasOwnProperty("sft") ? a.sft : "");
        this._instanceEffectList && a.hasOwnProperty("fx") && this._instanceEffectList._LoadFromJson(a.fx);
        if (!a.hasOwnProperty("sgi") && "visual-state" !== b && this._tmpSceneGraphChildren)
            for (var c of this._tmpSceneGraphChildren)
                c.IsDestroyed() || this._runtime.DestroyInstance(c);
        a.hasOwnProperty("sgi") && "visual-state" !== b && (this._CreateSceneGraphInfo(null),
        c = this._sceneGraphInfo,
        c._LoadFromJson(a.sgi),
        c._SetTmpSceneGraphChildren(this._tmpSceneGraphChildren, this._tmpSceneGraphChildrenIndexes),
        a.sgcd && C3$jscomp$190.IsFiniteNumber(a.sgzid) && sceneGraphExportDataMap.set(this, {
            childrenData: a.sgcd,
            zIndexData: a.sgzid
        }));
        a.hasOwnProperty("mesh") ? (c = a.mesh,
        this.CreateMesh(c.cols, c.rows),
        this.GetSourceMesh().LoadFromJson(c)) : this.ReleaseMesh();
        this.SetBboxChanged();
        enableUpdateRendererStateGroup = !0;
        this._UpdateRendererStateGroup();
        "visual-state" !== b && this._runtime.AddInstanceNeedingAfterLoad(this.GetInstance(), a)
    }
}
;
"use strict";
const C3$jscomp$191 = self.C3;
C3$jscomp$191.BehaviorType = class extends C3$jscomp$191.DefendedBase {
    constructor(a, b) {
        super();
        const c = a.GetRuntime()
          , d = c.GetObjectReference(b[1]);
        c.GetAddonManager()._DelayCreateBehavior(d);
        this._runtime = c;
        this._objectClass = a;
        this._behavior = C3$jscomp$191.AddonManager.GetBehaviorByConstructorFunction(d);
        this._iBehaviorType = this._sdkType = null;
        this._instSdkCtor = d.Instance;
        this._sid = b[2];
        this._name = b[0];
        this._jsPropName = this._runtime.GetJsPropName(b[3]);
        a = this._behavior.GetSdkVersion();
        if (2 > a && (this._sdkType = C3$jscomp$191.New(d.Type, this),
        !(this._sdkType instanceof C3$jscomp$191.SDKBehaviorTypeBase)))
            throw Error("v1 sdk type must derive from SDKBehaviorBase");
        C3$jscomp$191.AddonManager._PushInitObject(this, a);
        if (2 <= a) {
            if (this._iBehaviorType = new (d.Type ?? globalThis.ISDKBehaviorTypeBase),
            !(this._iBehaviorType instanceof globalThis.ISDKBehaviorTypeBase))
                throw Error("script interface class must derive from ISDKBehaviorTypeBase");
        } else
            this._iBehaviorType = new globalThis.IBehaviorType;
        C3$jscomp$191.AddonManager._PopInitObject(a);
        this.OnCreate()
    }
    static Create(a, b) {
        return C3$jscomp$191.New(C3$jscomp$191.BehaviorType, a, b)
    }
    Release() {
        this._behavior = this._runtime = null;
        this._sdkType && (this._sdkType.Release(),
        this._sdkType = null);
        this._instSdkCtor = null
    }
    GetSdkType() {
        return this._sdkType
    }
    OnCreate() {
        this._sdkType ? this._sdkType.OnCreate() : this._iBehaviorType && this._iBehaviorType._onCreate()
    }
    GetRuntime() {
        return this._runtime
    }
    GetObjectClass() {
        return this._objectClass
    }
    GetBehavior() {
        return this._behavior
    }
    GetInstanceSdkCtor() {
        return this._instSdkCtor
    }
    GetName() {
        return this._name
    }
    GetSID() {
        return this._sid
    }
    GetIBehaviorType() {
        return this._iBehaviorType
    }
    GetJsPropName() {
        return this._jsPropName
    }
}
;
"use strict";
const C3$jscomp$192 = self.C3
  , IBehaviorInstance$jscomp$1 = self.IBehaviorInstance;
C3$jscomp$192.BehaviorInstance = class extends C3$jscomp$192.DefendedBase {
    constructor(a) {
        super();
        this._runtime = a.runtime;
        this._behaviorType = a.behaviorType;
        this._behavior = this._behaviorType.GetBehavior();
        this._inst = a.instance;
        this._index = a.index;
        this._iScriptInterface = this._sdkInst = null;
        this._behavior._AddInstance(this._inst)
    }
    Release() {
        this._iScriptInterface && (this._iScriptInterface._release(),
        this._iScriptInterface = null);
        this._behavior._RemoveInstance(this._inst);
        this._sdkInst && (this._sdkInst.Release(),
        this._sdkInst = null);
        this._inst = this._behavior = this._behaviorType = this._runtime = null
    }
    _CreateSdkInstance(a) {
        if (this._sdkInst)
            throw Error("already got sdk instance");
        if (2 > this.GetBehavior().GetSdkVersion()) {
            if (this._sdkInst = C3$jscomp$192.New(this._behaviorType.GetInstanceSdkCtor(), this, a),
            !(this._sdkInst instanceof C3$jscomp$192.SDKBehaviorInstanceBase))
                throw Error("v1 sdk type must derive from SDKBehaviorInstanceBase");
        } else {
            const b = this.GetBehavior().GetScriptInterfaceClass();
            this._InitScriptInterface(b.Instance, a)
        }
    }
    GetSdkInstance() {
        return this._sdkInst ?? this._iScriptInterface
    }
    GetObjectInstance() {
        return this._inst
    }
    GetRuntime() {
        return this._runtime
    }
    GetBehaviorType() {
        return this._behaviorType
    }
    GetBehavior() {
        return this._behavior
    }
    _GetIndex() {
        return this._index
    }
    PostCreate() {
        this._sdkInst ? this._sdkInst.PostCreate() : this._iScriptInterface._postCreate()
    }
    OnSpriteFrameChanged(a, b) {
        this._sdkInst && this._sdkInst.OnSpriteFrameChanged(a, b)
    }
    _GetDebuggerProperties() {
        return this._sdkInst ? this._sdkInst.GetDebuggerProperties() : this._iScriptInterface._getDebuggerProperties()
    }
    SaveToJson(a="full") {
        return this._sdkInst ? this._sdkInst.SaveToJson(a) : this._iScriptInterface._saveToJson(a)
    }
    LoadFromJson(a, b="full") {
        if (this._sdkInst)
            return this._sdkInst.LoadFromJson(a, b);
        this._iScriptInterface._loadFromJson(a, b)
    }
    static SortByTickSequence(a, b, c) {
        var d = globalThis.ISDKBehaviorInstanceBase;
        b = b instanceof d ? a._UnwrapScriptInterface(b) : b.GetBehaviorInstance();
        a = c instanceof d ? a._UnwrapScriptInterface(c) : c.GetBehaviorInstance();
        d = b.GetObjectInstance();
        c = a.GetObjectInstance();
        const e = d.GetObjectClass().GetIndex()
          , f = c.GetObjectClass().GetIndex();
        if (e !== f)
            return e - f;
        d = d.GetPUID();
        c = c.GetPUID();
        return d !== c ? d - c : b._GetIndex() - a._GetIndex()
    }
    _InitScriptInterface(a, b) {
        const c = (a = a ?? this._sdkInst.GetScriptInterfaceClass()) || IBehaviorInstance$jscomp$1
          , d = this.GetBehavior().GetSdkVersion();
        C3$jscomp$192.AddonManager._PushInitObject(this, d);
        C3$jscomp$192.AddonManager._PushInitProperties(b);
        this._iScriptInterface = new c;
        C3$jscomp$192.AddonManager._PopInitProperties();
        C3$jscomp$192.AddonManager._PopInitObject(d);
        if (a && !(this._iScriptInterface instanceof IBehaviorInstance$jscomp$1))
            throw new TypeError(`script interface class '${a.name}' does not extend the right base class '${IBehaviorInstance$jscomp$1.name}'`);
        return this._iScriptInterface
    }
    GetScriptInterface() {
        return this._iScriptInterface || this._InitScriptInterface()
    }
    HasScriptInterface() {
        return !!this._iScriptInterface
    }
}
;
"use strict";
const C3$jscomp$193 = self.C3;
C3$jscomp$193.EffectList = class extends C3$jscomp$193.DefendedBase {
    constructor(a, b) {
        super();
        this._owner = a;
        this._allEffectTypes = [];
        this._activeEffectTypes = [];
        this._effectTypesByName = new Map;
        this._effectParams = [];
        this._effectParamBuffers = [];
        this._allInstanceEffectLists = new Set;
        this._preservesOpaqueness = !0;
        for (const c of b)
            a = C3$jscomp$193.New(C3$jscomp$193.EffectType, this, c, this._allEffectTypes.length),
            this._allEffectTypes.push(a),
            this._effectTypesByName.set(a.GetName().toLowerCase(), a),
            3 <= c.length && this._effectParams.push(this._LoadSingleEffectParameters(a, c[2]));
        this.GetRuntime()._AddEffectList(this)
    }
    Release() {
        this.GetRuntime()._RemoveEffectList(this);
        for (const a of this._effectParamBuffers)
            a.Release();
        C3$jscomp$193.clearArray(this._effectParamBuffers);
        C3$jscomp$193.clearArray(this._allEffectTypes);
        C3$jscomp$193.clearArray(this._activeEffectTypes);
        this._effectTypesByName.clear();
        C3$jscomp$193.clearArray(this._effectParams);
        this._owner = null
    }
    _AddInstanceEffectList(a) {
        this._allInstanceEffectLists.add(a)
    }
    _RemoveInstanceEffectList(a) {
        this._allInstanceEffectLists.delete(a)
    }
    _InitRenderer(a) {
        a.IsWebGPU() && (this._effectParamBuffers = this._allEffectTypes.map(b => {
            b = b.GetShaderProgram();
            return 0 < b.GetCustomParametersByteSize() ? C3$jscomp$193.New(C3$jscomp$193.Gfx.WebGPUEffectCustomParamsBuffer, b) : null
        }
        ),
        this._UpdateAllEffectParamBuffers());
        for (const b of this._allInstanceEffectLists)
            b._InitRenderer(a)
    }
    PrependEffectTypes(a) {
        if (a.length) {
            this._allEffectTypes = a.concat(this._allEffectTypes);
            for (const b of a)
                this._effectTypesByName.set(b.GetName().toLowerCase(), b);
            for (let b = 0, c = this._allEffectTypes.length; b < c; ++b)
                this._allEffectTypes[b]._SetIndex(b)
        }
    }
    _LoadSingleEffectParameters(a, b) {
        a.SetActive(b[0]);
        a = b.slice(1);
        for (let c = 0, d = a.length; c < d; ++c)
            if (b = a[c],
            Array.isArray(b)) {
                const e = C3$jscomp$193.New(C3$jscomp$193.Color);
                e.setFromJSON(b);
                a[c] = e
            }
        return a
    }
    GetOwner() {
        return this._owner
    }
    GetRuntime() {
        return this._owner.GetRuntime()
    }
    UpdateActiveEffects() {
        C3$jscomp$193.clearArray(this._activeEffectTypes);
        let a = !0;
        for (const b of this._allEffectTypes)
            b.IsActive() && (this._activeEffectTypes.push(b),
            b.GetShaderProgram().PreservesOpaqueness() || (a = !1));
        this._preservesOpaqueness = a
    }
    GetAllEffectTypes() {
        return this._allEffectTypes
    }
    HasAnyEffectType() {
        return 0 < this._allEffectTypes.length
    }
    GetEffectTypeByName(a) {
        return this._effectTypesByName.get(a.toLowerCase()) || null
    }
    GetEffectTypeByIndex(a) {
        a = Math.floor(+a);
        if (0 > a || a >= this._allEffectTypes.length)
            throw new RangeError("invalid effect type index");
        return this._allEffectTypes[a]
    }
    IsEffectIndexActive(a) {
        return this.GetEffectTypeByIndex(a).IsActive()
    }
    SetEffectIndexActive(a, b) {
        this.GetEffectTypeByIndex(a).SetActive(b)
    }
    GetActiveEffectTypes() {
        return this._activeEffectTypes
    }
    HasAnyActiveEffect() {
        return 0 < this._activeEffectTypes.length
    }
    PreservesOpaqueness() {
        return this._preservesOpaqueness
    }
    GetEffectParametersForIndex(a) {
        return this._effectParams[a]
    }
    _GetEffectChainShaderParametersForIndex(a) {
        return a < this._effectParamBuffers.length ? this._effectParamBuffers[a] : this._effectParams[a]
    }
    GetEffectParameter(a, b) {
        if (0 > a || a >= this._effectParams.length)
            return null;
        a = this._effectParams[a];
        return 0 > b || b >= a.length ? null : a[b]
    }
    SetEffectParameter(a, b, c) {
        if (0 > a || a >= this._effectParams.length)
            return !1;
        const d = this._effectParams[a];
        if (0 > b || b >= d.length)
            return !1;
        const e = d[b];
        if (e instanceof C3$jscomp$193.Color) {
            if (e.equalsIgnoringAlpha(c))
                return !1;
            e.copyRgb(c)
        } else {
            if (e === c)
                return !1;
            d[b] = c
        }
        a < this._effectParamBuffers.length && this._effectParamBuffers[a].SetParameterValue(b, c);
        return !0
    }
    _UpdateAllEffectParamBuffers() {
        const a = this._effectParams
          , b = this._effectParamBuffers;
        for (let c = 0, d = Math.min(a.length, b.length); c < d; ++c) {
            const e = b[c]
              , f = a[c];
            for (let h = 0, l = f.length; h < l; ++h)
                e.SetParameterValue(h, f[h])
        }
    }
    static SaveFxParamToJson(a) {
        return a && a instanceof C3$jscomp$193.Color ? {
            t: "color",
            v: a.toJSON()
        } : a
    }
    static LoadFxParamFromJson(a) {
        if (null === a)
            return NaN;
        if ("object" === typeof a) {
            if ("color" === a.t) {
                const b = C3$jscomp$193.New(C3$jscomp$193.Color);
                b.setFromJSON(a.v);
                return b
            }
            throw Error("invalid effect parameter type");
        }
        return a
    }
    static SaveFxParamsToJson(a) {
        return a.map(C3$jscomp$193.EffectList.SaveFxParamToJson)
    }
    static LoadFxParamsFromJson(a) {
        return a.map(C3$jscomp$193.EffectList.LoadFxParamFromJson)
    }
    SaveToJson() {
        return this._allEffectTypes.map(a => ({
            name: a.GetName(),
            active: a.IsActive(),
            params: C3$jscomp$193.EffectList.SaveFxParamsToJson(this._effectParams[a.GetIndex()])
        }))
    }
    LoadFromJson(a) {
        for (const b of a)
            if (a = this.GetEffectTypeByName(b.name))
                a.SetActive(b.active),
                this._effectParams[a.GetIndex()] = C3$jscomp$193.EffectList.LoadFxParamsFromJson(b.params);
        this.UpdateActiveEffects();
        this._UpdateAllEffectParamBuffers()
    }
}
;
"use strict";
const C3$jscomp$194 = self.C3;
C3$jscomp$194.EffectType = class extends C3$jscomp$194.DefendedBase {
    constructor(a, b, c) {
        super();
        this._effectList = a;
        this._id = b[0];
        this._name = b[1];
        this._index = c;
        this._shaderProgram = null;
        this._isActive = !0
    }
    Release() {
        this._shaderProgram = this._effectList = null
    }
    Clone(a) {
        a = C3$jscomp$194.New(C3$jscomp$194.EffectType, a, [this._id, this._name], -1);
        a._shaderProgram = this._shaderProgram;
        a._isActive = this._isActive;
        return a
    }
    _InitRenderer(a) {
        a = a.GetShaderProgramByName(this._id);
        if (!a)
            throw Error("failed to find shader program '" + this._id + "'");
        this._shaderProgram = a
    }
    GetEffectList() {
        return this._effectList
    }
    GetName() {
        return this._name
    }
    _SetIndex(a) {
        this._index = a
    }
    GetIndex() {
        return this._index
    }
    GetOwner() {
        return this._effectList.GetOwner()
    }
    GetRuntime() {
        return this._effectList.GetRuntime()
    }
    SetActive(a) {
        this._isActive = !!a
    }
    IsActive() {
        return this._isActive
    }
    GetShaderProgram() {
        return this._shaderProgram
    }
    GetDefaultParameterValues() {
        const a = [];
        for (let b = 0, c = this._shaderProgram.GetParameterCount(); b < c; ++b) {
            const d = this._shaderProgram.GetParameterType(b);
            if ("float" === d || "percent" === d)
                a.push(0);
            else if ("color" === d)
                a.push(C3$jscomp$194.New(C3$jscomp$194.Color, 1, 1, 1, 1));
            else
                throw new TypeError("unknown effect parameter type");
        }
        return a
    }
}
;
"use strict";
const C3$jscomp$195 = self.C3;
C3$jscomp$195.InstanceEffectList = class extends C3$jscomp$195.DefendedBase {
    constructor(a, b) {
        super();
        this._inst = a;
        this._wi = b;
        this._effectList = a.GetObjectClass().GetEffectList();
        this._wasDefaultColor = this._needsRebuildSteps = !0;
        this._wasMustPreDraw = this._wasTexRotated = this._wasRotatedOrNegativeSize = this._was3D = !1;
        this._effectChain = C3$jscomp$195.New(C3$jscomp$195.Gfx.EffectChain, a.GetRuntime().GetCanvasManager().GetEffectChainManager(), {
            drawContent: (c, d) => {
                d = d.GetContentObject();
                const e = d.GetWorldInfo();
                c.SetColor(e.GetPremultipliedColor());
                c.SetCurrentZ(e.GetTotalZElevation());
                d.Draw(c);
                c.SetCurrentZ(0)
            }
            ,
            getSourceTextureInfo: c => {
                const d = c.GetCurrentTexRect()
                  , [e,f] = c.GetCurrentSurfaceSize();
                return {
                    srcTexRect: d,
                    srcWidth: e,
                    srcHeight: f
                }
            }
            ,
            getShaderParameters: c => this._GetEffectChainShaderParametersForIndex(c)
        });
        this._activeEffectFlags = [];
        this._activeEffectTypes = [];
        this._preservesOpaqueness = !0;
        this._effectParams = [];
        this._effectParamBuffers = [];
        this._InitRenderer(a.GetRuntime().GetRenderer());
        for (let c = 0, d = this._effectList.GetAllEffectTypes().length; c < d; ++c)
            this._activeEffectFlags.push(!0);
        this.UpdateActiveEffects();
        this._effectList._AddInstanceEffectList(this)
    }
    Release() {
        this._effectList._RemoveInstanceEffectList(this);
        for (const a of this._effectParamBuffers)
            a && a.Release();
        C3$jscomp$195.clearArray(this._effectParamBuffers);
        this._effectChain.Release();
        this._effectChain = null;
        C3$jscomp$195.clearArray(this._activeEffectFlags);
        C3$jscomp$195.clearArray(this._activeEffectTypes);
        C3$jscomp$195.clearArray(this._effectParams);
        this._effectList = this._inst = null
    }
    _InitRenderer(a) {
        a.IsWebGPU() && (this._effectParamBuffers = this._effectList.GetAllEffectTypes().map(b => {
            b = b.GetShaderProgram();
            return 0 < b.GetCustomParametersByteSize() ? C3$jscomp$195.New(C3$jscomp$195.Gfx.WebGPUEffectCustomParamsBuffer, b) : null
        }
        ))
    }
    _LoadEffectParameters(a) {
        let b = 0;
        for (const c of a)
            this._effectParams.push(this._LoadSingleEffectParameters(b, c)),
            ++b;
        this._UpdateAllEffectParamBuffers();
        this.UpdateActiveEffects()
    }
    _LoadSingleEffectParameters(a, b) {
        this._activeEffectFlags[a] = b[0];
        a = b.slice(1);
        for (let c = 0, d = a.length; c < d; ++c)
            if (b = a[c],
            Array.isArray(b)) {
                const e = C3$jscomp$195.New(C3$jscomp$195.Color);
                e.setFromJSON(b);
                a[c] = e
            }
        return a
    }
    LoadDefaultEffectParameters() {
        for (const a of this._effectList.GetAllEffectTypes())
            this._effectParams.push(a.GetDefaultParameterValues());
        this._UpdateAllEffectParamBuffers()
    }
    GetOwner() {
        return this._owner
    }
    GetEffectList() {
        return this._effectList
    }
    GetEffectChain() {
        this._MaybeRebuildEffectChainSteps();
        return this._effectChain
    }
    GetRuntime() {
        return this._inst.GetRuntime()
    }
    UpdateActiveEffects() {
        C3$jscomp$195.clearArray(this._activeEffectTypes);
        const a = this._wi
          , b = this._effectList.GetAllEffectTypes()
          , c = this._activeEffectTypes
          , d = this._activeEffectFlags;
        let e = !0;
        for (let f = 0, h = b.length; f < h; ++f)
            if (d[f]) {
                const l = b[f];
                c.push(l);
                l.GetShaderProgram().PreservesOpaqueness() || (e = !1)
            }
        this._preservesOpaqueness = e;
        a._SetHasAnyActiveEffect(!!c.length);
        this._needsRebuildSteps = !0
    }
    _MaybeRebuildEffectChainSteps() {
        var a = this._inst
          , b = this._wi;
        const c = b.HasDefaultColor()
          , d = a.GetPlugin().Is3D();
        b = 0 !== b.GetAngle() || 0 !== b.GetLayer().GetAngle() || 0 > b.GetWidth() || 0 > b.GetHeight();
        const e = a.IsCurrentTexRotated();
        a = a.MustPreDraw();
        if (this._needsRebuildSteps || c !== this._wasDefaultColor || d !== this._was3D || b !== this._wasRotatedOrNegativeSize || e !== this._wasTexRotated || a !== this._wasMustPreDraw || this._effectChain.NeedsRebuild())
            this._effectChain.BuildSteps(this._activeEffectTypes.map(f => f.GetShaderProgram()), {
                indexMap: this._activeEffectTypes.map(f => f.GetIndex()),
                forcePreDraw: !c || a,
                is3D: d,
                isSourceTextureRotated: e,
                isRotatedOrNegativeSizeInstance: b
            }),
            this._needsRebuildSteps = !1,
            this._wasDefaultColor = c,
            this._was3D = d,
            this._wasRotatedOrNegativeSize = b,
            this._wasTexRotated = e,
            this._wasMustPreDraw = a
    }
    GetActiveEffectTypes() {
        return this._activeEffectTypes
    }
    GetEffectParametersForIndex(a) {
        return this._effectParams[a]
    }
    _GetEffectChainShaderParametersForIndex(a) {
        return a < this._effectParamBuffers.length ? this._effectParamBuffers[a] : this._effectParams[a]
    }
    GetEffectParameter(a, b) {
        if (0 > a || a >= this._effectParams.length)
            return null;
        a = this._effectParams[a];
        return 0 > b || b >= a.length ? null : a[b]
    }
    SetEffectParameter(a, b, c) {
        if (0 > a || a >= this._effectParams.length)
            return !1;
        const d = this._effectParams[a];
        if (0 > b || b >= d.length)
            return !1;
        const e = d[b];
        if (e instanceof C3$jscomp$195.Color) {
            if (e.equalsIgnoringAlpha(c))
                return !1;
            e.copyRgb(c)
        } else {
            if (e === c)
                return !1;
            d[b] = c
        }
        a < this._effectParamBuffers.length && this._effectParamBuffers[a].SetParameterValue(b, c);
        return !0
    }
    _UpdateAllEffectParamBuffers() {
        const a = this._effectParams
          , b = this._effectParamBuffers;
        for (let c = 0, d = b.length; c < d; ++c) {
            const e = b[c]
              , f = a[c];
            for (let h = 0, l = f.length; h < l; ++h)
                e.SetParameterValue(h, f[h])
        }
    }
    PreservesOpaqueness() {
        return this._preservesOpaqueness
    }
    HasAnyActiveBackgroundBlendingEffect() {
        return this._activeEffectTypes.some(a => a.GetShaderProgram().BlendsBackground())
    }
    IsEffectIndexActive(a) {
        return this._activeEffectFlags[a]
    }
    SetEffectIndexActive(a, b) {
        this._activeEffectFlags[a] = !!b
    }
    GetAllEffectTypes() {
        return this._effectList.GetAllEffectTypes()
    }
    _SaveToJson() {
        return this._effectList.GetAllEffectTypes().map(a => ({
            name: a.GetName(),
            active: this._activeEffectFlags[a.GetIndex()],
            params: C3$jscomp$195.EffectList.SaveFxParamsToJson(this._effectParams[a.GetIndex()])
        }))
    }
    _LoadFromJson(a) {
        for (const b of a)
            if (a = this._effectList.GetEffectTypeByName(b.name))
                this._activeEffectFlags[a.GetIndex()] = b.active,
                this._effectParams[a.GetIndex()] = C3$jscomp$195.EffectList.LoadFxParamsFromJson(b.params);
        this.UpdateActiveEffects();
        this._UpdateAllEffectParamBuffers()
    }
}
;
"use strict";
const C3$jscomp$196 = self.C3
  , tempCandidates = []
  , tileCollRectCandidates = []
  , tempJumpthruRet = []
  , tempPolyA = C3$jscomp$196.New(C3$jscomp$196.CollisionPoly)
  , tempPolyB = C3$jscomp$196.New(C3$jscomp$196.CollisionPoly)
  , tempQuad$jscomp$4 = C3$jscomp$196.New(C3$jscomp$196.Quad)
  , tempRect$jscomp$8 = C3$jscomp$196.New(C3$jscomp$196.Rect)
  , tempRect2$jscomp$1 = C3$jscomp$196.New(C3$jscomp$196.Rect);
let tempPolyC = null
  , tempRect3$jscomp$1 = null
  , tempQuadB = null;
C3$jscomp$196.CollisionEngine = class extends C3$jscomp$196.DefendedBase {
    constructor(a) {
        super();
        this._runtime = a;
        this._collisionCellHeight = this._collisionCellWidth = 0;
        this._registeredCollisions = [];
        this._polyCheckSec = this._polyCheckCount = this._collisionCheckSec = this._collisionCheckCount = 0;
        this._iCollisionEngine = new self.ICollisionEngine(this)
    }
    Release() {
        this._runtime = null
    }
    GetRuntime() {
        return this._runtime
    }
    GetICollisionEngine() {
        return this._iCollisionEngine
    }
    _Update1sStats() {
        this._collisionCheckSec = this._collisionCheckCount;
        this._collisionCheckCount = 0;
        this._polyCheckSec = this._polyCheckCount;
        this._polyCheckCount = 0
    }
    Get1secCollisionChecks() {
        return this._collisionCheckSec
    }
    Get1secPolyChecks() {
        return this._polyCheckSec
    }
    RegisterCollision(a, b) {
        const c = a.GetWorldInfo()
          , d = b.GetWorldInfo();
        c && d && c.IsCollisionEnabled() && d.IsCollisionEnabled() && this._registeredCollisions.push([a, b])
    }
    AddRegisteredCollisionCandidates(a, b, c) {
        for (const [d,e] of this._registeredCollisions) {
            let f;
            if (a === d)
                f = e;
            else if (a === e)
                f = d;
            else
                continue;
            f.BelongsToObjectClass(b) && (c.includes(f) || c.push(f))
        }
    }
    CheckRegisteredCollision(a, b) {
        if (!this._registeredCollisions.length)
            return !1;
        for (const [c,d] of this._registeredCollisions)
            if (a === c && b === d || a === d && b === c)
                return !0;
        return !1
    }
    ClearRegisteredCollisions() {
        C3$jscomp$196.clearArray(this._registeredCollisions)
    }
    TestOverlap(a, b) {
        if (!a || !b || a === b)
            return !1;
        a = a.GetWorldInfo();
        b = b.GetWorldInfo();
        if (!a.IsCollisionEnabled() || !b.IsCollisionEnabled())
            return !1;
        this._collisionCheckCount++;
        const c = a.GetLayer()
          , d = b.GetLayer();
        return c.IsTransformCompatibleWith(d) ? this._TestOverlap_SameLayers(a, b) : this._TestOverlap_DifferentLayers(a, b)
    }
    _TestOverlap_SameLayers(a, b) {
        if (!a.GetBoundingBox().intersectsRect(b.GetBoundingBox()))
            return !1;
        this._polyCheckCount++;
        if (!a.GetBoundingQuad().intersectsQuad(b.GetBoundingQuad()) || a.HasTilemap() && b.HasTilemap())
            return !1;
        if (a.HasTilemap())
            return this.TestTilemapOverlap(a, b);
        if (b.HasTilemap())
            return this.TestTilemapOverlap(b, a);
        if (!a.HasOwnCollisionPoly() && !b.HasOwnCollisionPoly())
            return !0;
        const c = a.GetTransformedCollisionPoly()
          , d = b.GetTransformedCollisionPoly();
        return c.intersectsPoly(d, b.GetX() - a.GetX(), b.GetY() - a.GetY())
    }
    _TestOverlap_DifferentLayers(a, b) {
        var c = a.HasTilemap()
          , d = b.HasTilemap();
        if (c && !d)
            return this.TestTilemapOverlapDifferentLayers(a, b);
        if (d && !c)
            return this.TestTilemapOverlapDifferentLayers(b, a);
        if (d || c)
            return !1;
        d = a.GetLayer();
        c = b.GetLayer();
        tempPolyA.copy(a.GetTransformedCollisionPoly());
        tempPolyB.copy(b.GetTransformedCollisionPoly());
        var e = tempPolyA.pointsArr();
        for (let f = 0, h = e.length; f < h; f += 2) {
            const l = f + 1
              , m = e[l]
              , [p,r] = d.LayerToCanvasCss(e[f] + a.GetX(), m + a.GetY());
            e[f] = p;
            e[l] = r
        }
        a = tempPolyB.pointsArr();
        for (let f = 0, h = a.length; f < h; f += 2) {
            d = f + 1;
            e = a[d];
            const [l,m] = c.LayerToCanvasCss(a[f] + b.GetX(), e + b.GetY());
            a[f] = l;
            a[d] = m
        }
        tempPolyA.setBboxChanged();
        tempPolyB.setBboxChanged();
        this._polyCheckCount++;
        return tempPolyA.intersectsPoly(tempPolyB, 0, 0)
    }
    TestTilemapOverlapDifferentLayers(a, b) {
        var c = a.GetLayer()
          , d = b.GetLayer();
        tempPolyC || (tempPolyC = C3$jscomp$196.New(C3$jscomp$196.CollisionPoly));
        tempRect3$jscomp$1 || (tempRect3$jscomp$1 = C3$jscomp$196.New(C3$jscomp$196.Rect));
        tempQuadB || (tempQuadB = C3$jscomp$196.New(C3$jscomp$196.Quad));
        var e = b.GetX()
          , f = b.GetY();
        const [h,l] = d.LayerToCanvasCss(e, f)
          , [m,p] = c.CanvasCssToLayer(h, l);
        c = m - e;
        f = p - f;
        tempRect3$jscomp$1.copy(b.GetBoundingBox());
        tempRect3$jscomp$1.offset(c, f);
        if (!a.GetBoundingBox().intersectsRect(tempRect3$jscomp$1))
            return !1;
        tempQuadB.copy(b.GetBoundingQuad());
        tempQuadB.offset(c, f);
        this._polyCheckCount++;
        if (!a.GetBoundingQuad().intersectsQuad(tempQuadB))
            return !1;
        tempPolyC.copy(b.GetTransformedCollisionPoly());
        d = tempPolyC.pointsArr();
        for (let r = 0, v = d.length; r < v; r += 2)
            e = r + 1,
            d[r] += c,
            d[e] += f;
        tempPolyC.setBboxChanged();
        return this.TestTilemapOverlap(a, b, m, p, tempPolyC, tempRect3$jscomp$1, tempQuadB)
    }
    TestTilemapOverlap(a, b, c, d, e, f, h) {
        f = void 0 !== f ? f : b.GetBoundingBox();
        const l = a.GetX()
          , m = a.GetY();
        var p = a.GetInstance().GetSdkInstance();
        c = void 0 !== c ? c : b.GetX();
        d = void 0 !== d ? d : b.GetY();
        a = b.HasOwnCollisionPoly();
        h = void 0 !== h ? h : b.GetBoundingQuad();
        p.GetCollisionRectCandidates(f, tileCollRectCandidates);
        for (let x = 0, B = tileCollRectCandidates.length; x < B; ++x) {
            var r = tileCollRectCandidates[x];
            p = r.GetRect();
            this._collisionCheckCount++;
            if (f.intersectsRectOffset(p, l, m) && (tempQuad$jscomp$4.setFromRect(p),
            tempQuad$jscomp$4.offset(l, m),
            tempQuad$jscomp$4.intersectsQuad(h)))
                if (a) {
                    var v = void 0 !== e ? e : b.GetTransformedCollisionPoly();
                    let A = c
                      , D = d;
                    void 0 !== e && (A = b.GetX(),
                    D = b.GetY());
                    if (r = r.GetPoly()) {
                        if (this._polyCheckCount++,
                        r.intersectsPoly(v, A - (l + p.getLeft()), D - (m + p.getTop())))
                            return C3$jscomp$196.clearArray(tileCollRectCandidates),
                            !0
                    } else if (tempPolyA.setFromQuad(tempQuad$jscomp$4, 0, 0),
                    tempPolyA.intersectsPoly(v, A, D))
                        return C3$jscomp$196.clearArray(tileCollRectCandidates),
                        !0
                } else if (v = r.GetPoly()) {
                    if (tempPolyA.setFromQuad(h, 0, 0),
                    v.intersectsPoly(tempPolyA, -(l + p.getLeft()), -(m + p.getTop())))
                        return C3$jscomp$196.clearArray(tileCollRectCandidates),
                        !0
                } else
                    return C3$jscomp$196.clearArray(tileCollRectCandidates),
                    !0
        }
        C3$jscomp$196.clearArray(tileCollRectCandidates);
        return !1
    }
    TestAndSelectCanvasPointOverlap(a, b, c) {
        const d = a.GetCurrentSol();
        var e = this._runtime.GetCurrentEvent();
        if (!e)
            throw Error("cannot call outside event");
        const f = e.IsOrBlock()
          , h = new Map
          , l = p => {
            let r = h.get(p);
            "undefined" === typeof r && (r = p.IsSelfAndParentsInteractive(),
            h.set(p, r));
            return r
        }
        ;
        if (d.IsSelectAll()) {
            c || (d._SetSelectAll(!1),
            C3$jscomp$196.clearArray(d._GetOwnInstances()));
            f && C3$jscomp$196.clearArray(d._GetOwnElseInstances());
            for (var m of a.GetInstances()) {
                const p = m.GetWorldInfo()
                  , r = p.GetLayer();
                e = !1;
                l(r) && p.IsInViewport2() && (e = b.some( ([v,x]) => {
                    const [B,A] = r.CanvasCssToLayer(v, x, p.GetTotalZElevation());
                    return p.ContainsPoint(B, A)
                }
                ));
                if (e) {
                    if (c)
                        return !1;
                    d._PushInstance(m)
                } else
                    f && d._PushElseInstance(m)
            }
        } else {
            m = !1;
            f && !e.IsFirstConditionOfType(this._runtime.GetCurrentCondition()) ? this._runtime.IsCurrentConditionFirst() && !d._GetOwnElseInstances().length && d._GetOwnInstances().length ? e = d._GetOwnInstances() : (e = d._GetOwnElseInstances(),
            m = !0) : e = d._GetOwnInstances();
            let p = 0;
            for (let r = 0, v = e.length; r < v; ++r) {
                const x = e[r]
                  , B = x.GetWorldInfo()
                  , A = B.GetLayer();
                let D = !1;
                l(A) && B.IsInViewport2() && (D = b.some( ([F,I]) => {
                    const [K,M] = A.CanvasCssToLayer(F, I, B.GetTotalZElevation());
                    return B.ContainsPoint(K, M)
                }
                ));
                if (D) {
                    if (c)
                        return !1;
                    m ? d._PushInstance(x) : e[p++] = x
                } else
                    m ? e[p++] = x : f && d._PushElseInstance(x)
            }
            c || (e.length = p)
        }
        a.ApplySolToContainer();
        h.clear();
        return c ? !0 : d.HasAnyInstances()
    }
    GetCollisionCandidates(a, b, c, d) {
        a = a ? 1 !== a.GetParallaxX() || 1 !== a.GetParallaxY() : !1;
        if (b.IsFamily())
            for (const e of b.GetFamilyMembers())
                a || e.IsAnyInstanceParallaxed() ? C3$jscomp$196.appendArray(d, e.GetInstances()) : (e._UpdateAllCollisionCells(),
                e._GetCollisionCellGrid().QueryRange(c, d));
        else
            a || b.IsAnyInstanceParallaxed() ? C3$jscomp$196.appendArray(d, b.GetInstances()) : (b._UpdateAllCollisionCells(),
            b._GetCollisionCellGrid().QueryRange(c, d))
    }
    GetObjectClassesCollisionCandidates(a, b, c, d) {
        for (const e of b)
            this.GetCollisionCandidates(a, e, c, d)
    }
    GetSolidCollisionCandidates(a, b, c) {
        const d = this._runtime.GetSolidBehavior();
        d && this.GetObjectClassesCollisionCandidates(a, d.GetObjectClasses(), b, c)
    }
    GetJumpthruCollisionCandidates(a, b, c) {
        const d = this._runtime.GetJumpthruBehavior();
        d && this.GetObjectClassesCollisionCandidates(a, d.GetObjectClasses(), b, c)
    }
    IsSolidCollisionAllowed(a, b) {
        return a._IsSolidEnabled() && (!b || b.GetWorldInfo().IsSolidCollisionAllowed(a.GetSavedDataMap().get("solidTags")))
    }
    TestOverlapSolid(a) {
        const b = a.GetWorldInfo();
        this.GetSolidCollisionCandidates(b.GetLayer(), b.GetBoundingBox(), tempCandidates);
        for (const c of tempCandidates)
            if (this.IsSolidCollisionAllowed(c, a) && this.TestOverlap(a, c))
                return C3$jscomp$196.clearArray(tempCandidates),
                c;
        C3$jscomp$196.clearArray(tempCandidates);
        return null
    }
    TestRectOverlapSolid(a, b) {
        this.GetSolidCollisionCandidates(null, a, tempCandidates);
        for (const c of tempCandidates)
            if (this.IsSolidCollisionAllowed(c, b) && this.TestRectOverlap(a, c))
                return C3$jscomp$196.clearArray(tempCandidates),
                c;
        C3$jscomp$196.clearArray(tempCandidates);
        return null
    }
    TestOverlapJumpthru(a, b) {
        let c = null;
        b && (c = tempJumpthruRet,
        C3$jscomp$196.clearArray(c));
        const d = a.GetWorldInfo();
        this.GetJumpthruCollisionCandidates(d.GetLayer(), d.GetBoundingBox(), tempCandidates);
        for (const e of tempCandidates)
            if (e._IsJumpthruEnabled() && this.TestOverlap(a, e))
                if (b)
                    c.push(e);
                else
                    return C3$jscomp$196.clearArray(tempCandidates),
                    e;
        C3$jscomp$196.clearArray(tempCandidates);
        return c
    }
    PushOut(a, b, c, d, e) {
        d = d || 50;
        const f = a.GetWorldInfo()
          , h = f.GetX()
          , l = f.GetY();
        for (let m = 0; m < d; ++m)
            if (f.SetXY(h + b * m, l + c * m),
            f.SetBboxChanged(),
            !this.TestOverlap(a, e))
                return !0;
        f.SetXY(h, l);
        f.SetBboxChanged();
        return !1
    }
    PushOutSolid(a, b, c, d, e, f) {
        d = d || 50;
        const h = a.GetWorldInfo()
          , l = h.GetX()
          , m = h.GetY();
        let p = null
          , r = null;
        for (let v = 0; v < d; ++v)
            if (h.SetXY(l + b * v, m + c * v),
            h.SetBboxChanged(),
            !this.TestOverlap(a, p))
                if (p = this.TestOverlapSolid(a))
                    r = p;
                else if (e && (p = f ? this.TestOverlap(a, f) ? f : null : this.TestOverlapJumpthru(a)) && (r = p),
                !p)
                    return r && this.PushInFractional(a, b, c, r, 16, !0),
                    !0;
        h.SetXY(l, m);
        h.SetBboxChanged();
        return !1
    }
    PushOutSolidAxis(a, b, c, d) {
        d = d || 50;
        const e = a.GetWorldInfo()
          , f = e.GetX()
          , h = e.GetY();
        let l = null
          , m = null;
        for (let p = 0; p < d; ++p)
            for (let r = 0; 2 > r; ++r) {
                const v = 2 * r - 1;
                e.SetXY(f + b * p * v, h + c * p * v);
                e.SetBboxChanged();
                if (!this.TestOverlap(a, l))
                    if (l = this.TestOverlapSolid(a))
                        m = l;
                    else
                        return m && this.PushInFractional(a, b * v, c * v, m, 16, !0),
                        !0
            }
        e.SetXY(f, h);
        e.SetBboxChanged();
        return !1
    }
    PushInFractional(a, b, c, d, e, f) {
        let h = 2
          , l = !1;
        var m = !1;
        const p = a.GetWorldInfo();
        let r = p.GetX()
          , v = p.GetY();
        for (; h <= e; )
            m = 1 / h,
            h *= 2,
            p.OffsetXY(b * m * (l ? 1 : -1), c * m * (l ? 1 : -1)),
            p.SetBboxChanged(),
            this.TestOverlap(a, d) || f && this.TestOverlapSolid(a) ? m = l = !0 : (m = l = !1,
            r = p.GetX(),
            v = p.GetY());
        m && (p.SetXY(r, v),
        p.SetBboxChanged())
    }
    PushOutSolidNearest(a, b=100) {
        let c = 0;
        const d = a.GetWorldInfo()
          , e = d.GetX()
          , f = d.GetY();
        let h = 0
          , l = this.TestOverlapSolid(a);
        if (!l)
            return !0;
        for (; c <= b; ) {
            let m = 0
              , p = 0;
            switch (h) {
            case 0:
                m = 0;
                p = -1;
                c++;
                break;
            case 1:
                m = 1;
                p = -1;
                break;
            case 2:
                m = 1;
                p = 0;
                break;
            case 3:
                p = m = 1;
                break;
            case 4:
                m = 0;
                p = 1;
                break;
            case 5:
                m = -1;
                p = 1;
                break;
            case 6:
                m = -1;
                p = 0;
                break;
            case 7:
                p = m = -1
            }
            h = (h + 1) % 8;
            d.SetXY(Math.floor(e + m * c), Math.floor(f + p * c));
            d.SetBboxChanged();
            if (!this.TestOverlap(a, l) && (l = this.TestOverlapSolid(a),
            !l))
                return !0
        }
        d.SetXY(e, f);
        d.SetBboxChanged();
        return !1
    }
    CalculateBounceAngle(a, b, c, d) {
        const e = a.GetWorldInfo()
          , f = e.GetX()
          , h = e.GetY()
          , l = Math.max(10, C3$jscomp$196.distanceTo(b, c, f, h));
        var m = C3$jscomp$196.angleTo(b, c, f, h)
          , p = d || this.TestOverlapSolid(a);
        if (!p)
            return C3$jscomp$196.clampAngle(m + Math.PI);
        let r = p;
        var v = 0
          , x = 0;
        const B = C3$jscomp$196.toRadians(5);
        let A;
        for (A = 1; 36 > A; ++A) {
            const D = m - A * B;
            e.SetXY(b + Math.cos(D) * l, c + Math.sin(D) * l);
            e.SetBboxChanged();
            if (!this.TestOverlap(a, r) && (r = d ? null : this.TestOverlapSolid(a),
            !r)) {
                v = D;
                break
            }
        }
        36 === A && (v = C3$jscomp$196.clampAngle(m + Math.PI));
        r = p;
        for (A = 1; 36 > A; ++A)
            if (p = m + A * B,
            e.SetXY(b + Math.cos(p) * l, c + Math.sin(p) * l),
            e.SetBboxChanged(),
            !this.TestOverlap(a, r) && (r = d ? null : this.TestOverlapSolid(a),
            !r)) {
                x = p;
                break
            }
        36 === A && (x = C3$jscomp$196.clampAngle(m + Math.PI));
        e.SetXY(f, h);
        e.SetBboxChanged();
        if (x === v)
            return x;
        a = C3$jscomp$196.angleDiff(x, v) / 2;
        a = C3$jscomp$196.angleClockwise(x, v) ? C3$jscomp$196.clampAngle(v + a + Math.PI) : C3$jscomp$196.clampAngle(x + a);
        v = Math.cos(m);
        m = Math.sin(m);
        x = Math.cos(a);
        a = Math.sin(a);
        b = v * x + m * a;
        return C3$jscomp$196.angleTo(0, 0, v - 2 * b * x, m - 2 * b * a)
    }
    TestSegmentOverlap(a, b, c, d, e) {
        if (!e)
            return !1;
        const f = e.GetWorldInfo();
        if (!f.IsCollisionEnabled())
            return !1;
        this._collisionCheckCount++;
        tempRect$jscomp$8.set(Math.min(a, c), Math.min(b, d), Math.max(a, c), Math.max(b, d));
        if (!f.GetBoundingBox().intersectsRect(tempRect$jscomp$8))
            return !1;
        if (e.HasTilemap())
            return this._TestSegmentOverlapTilemap(a, b, c, d, e, f);
        this._polyCheckCount++;
        return f.GetBoundingQuad().intersectsSegment(a, b, c, d) ? f.HasOwnCollisionPoly() ? f.GetTransformedCollisionPoly().intersectsSegment(f.GetX(), f.GetY(), a, b, c, d) : !0 : !1
    }
    _TestSegmentOverlapTilemap(a, b, c, d, e, f) {
        const h = f.GetX();
        f = f.GetY();
        e = e.GetSdkInstance();
        tempRect2$jscomp$1.set(a, b, c, d);
        tempRect2$jscomp$1.normalize();
        e.GetCollisionRectCandidates(tempRect2$jscomp$1, tileCollRectCandidates);
        for (let m = 0, p = tileCollRectCandidates.length; m < p; ++m) {
            var l = tileCollRectCandidates[m];
            e = l.GetRect();
            this._collisionCheckCount++;
            if (tempRect$jscomp$8.intersectsRectOffset(e, h, f) && (tempQuad$jscomp$4.setFromRect(e),
            tempQuad$jscomp$4.offset(h, f),
            tempQuad$jscomp$4.intersectsSegment(a, b, c, d)))
                if (l = l.GetPoly()) {
                    if (this._polyCheckCount++,
                    l.intersectsSegment(h + e.getLeft(), f + e.getTop(), a, b, c, d))
                        return C3$jscomp$196.clearArray(tileCollRectCandidates),
                        !0
                } else
                    return C3$jscomp$196.clearArray(tileCollRectCandidates),
                    !0
        }
        C3$jscomp$196.clearArray(tileCollRectCandidates);
        return !1
    }
    TestRectOverlap(a, b) {
        if (!b)
            return !1;
        const c = b.GetWorldInfo();
        if (!c.IsCollisionEnabled())
            return !1;
        this._collisionCheckCount++;
        if (!c.GetBoundingBox().intersectsRect(a))
            return !1;
        if (b.HasTilemap())
            return this._TestRectOverlapTilemap(a, b, c);
        this._polyCheckCount++;
        tempQuad$jscomp$4.setFromRect(a);
        if (!c.GetBoundingQuad().intersectsQuad(tempQuad$jscomp$4))
            return !1;
        if (!c.HasOwnCollisionPoly())
            return !0;
        tempPolyA.setFromRect(a, c.GetX(), c.GetY());
        a = c.GetTransformedCollisionPoly();
        return tempPolyA.intersectsPoly(a, 0, 0)
    }
    _TestRectOverlapTilemap(a, b, c) {
        const d = c.GetX();
        c = c.GetY();
        b.GetSdkInstance().GetCollisionRectCandidates(a, tileCollRectCandidates);
        for (let f = 0, h = tileCollRectCandidates.length; f < h; ++f) {
            var e = tileCollRectCandidates[f];
            b = e.GetRect();
            this._collisionCheckCount++;
            if (a.intersectsRectOffset(b, d, c))
                if (e = e.GetPoly()) {
                    if (this._polyCheckCount++,
                    tempPolyA.setFromRect(a, 0, 0),
                    e.intersectsPoly(tempPolyA, -(d + b.getLeft()), -(c + b.getTop())))
                        return C3$jscomp$196.clearArray(tileCollRectCandidates),
                        !0
                } else
                    return C3$jscomp$196.clearArray(tileCollRectCandidates),
                    !0
        }
        C3$jscomp$196.clearArray(tileCollRectCandidates);
        return !1
    }
    TestRayIntersectsInstance(a, b) {
        if (a) {
            var c = a.GetWorldInfo();
            c.IsCollisionEnabled() && (this._collisionCheckCount++,
            c.GetBoundingBox().intersectsRect(b.rect) && (a.HasTilemap() ? this._TestRayIntersectsTilemap(a, c, b) : (this._polyCheckCount++,
            c.HasOwnCollisionPoly() ? b.TestInstancePoly(a, c.GetX(), c.GetY(), c.GetTransformedCollisionPoly()) : b.TestInstanceQuad(a, c.GetBoundingQuad()))))
        }
    }
    _TestRayIntersectsTilemap(a, b, c) {
        const d = b.GetX()
          , e = b.GetY();
        a.GetSdkInstance().GetCollisionRectCandidates(c.rect, tileCollRectCandidates);
        for (let h = 0, l = tileCollRectCandidates.length; h < l; h++) {
            var f = tileCollRectCandidates[h];
            const m = f.GetRect();
            this._collisionCheckCount++;
            c.rect.intersectsRectOffset(m, d, e) && (f = f.GetPoly(),
            this._polyCheckCount++,
            f ? c.TestInstancePoly(a, d + m.getLeft(), e + m.getTop(), f) : c.TestInstanceRect(a, b.GetX(), b.GetY(), m))
        }
        C3$jscomp$196.clearArray(tileCollRectCandidates)
    }
    SetCollisionCellSize(a, b) {
        if (a !== this._collisionCellWidth || b !== this._collisionCellHeight) {
            this._collisionCellWidth = a;
            this._collisionCellHeight = b;
            var c = this._runtime.GetAllObjectClasses();
            for (const d of c)
                if (d.IsWorldType()) {
                    for (const e of d.instancesIncludingPendingCreate())
                        e.GetWorldInfo()._RemoveFromCollisionCells();
                    d._GetCollisionCellGrid().SetCellSize(a, b);
                    d._SetAnyCollisionCellChanged();
                    for (const e of d.instancesIncludingPendingCreate())
                        c = e.GetWorldInfo(),
                        c._SetCollisionCellChanged(),
                        c._UpdateCollisionCell()
                }
        }
    }
    GetCollisionCellSize() {
        return [this._collisionCellWidth, this._collisionCellHeight]
    }
    _InitCollisionCellSize(a, b) {
        this._collisionCellWidth = a;
        this._collisionCellHeight = b
    }
}
;
"use strict";
const C3$jscomp$197 = self.C3;
C3$jscomp$197.SparseGrid = class extends C3$jscomp$197.DefendedBase {
    constructor(a, b) {
        super();
        this._cellWidth = a;
        this._cellHeight = b;
        this._cells = C3$jscomp$197.New(C3$jscomp$197.PairMap)
    }
    Release() {
        this._cells.Release();
        this._cells = null
    }
    SetCellSize(a, b) {
        if (!this._cells.IsEmpty())
            throw Error("grid not empty");
        this._cellWidth = a;
        this._cellHeight = b
    }
    GetCell(a, b, c) {
        let d = this._cells.Get(a, b);
        return d ? d : c ? (d = C3$jscomp$197.New(C3$jscomp$197.GridCell, this, a, b),
        this._cells.Set(a, b, d),
        d) : null
    }
    XToCell(a) {
        a = Math.floor(a / this._cellWidth);
        return isFinite(a) ? a : 0
    }
    YToCell(a) {
        a = Math.floor(a / this._cellHeight);
        return isFinite(a) ? a : 0
    }
    Update(a, b, c) {
        if (b)
            for (let d = b.getLeft(), e = b.getRight(); d <= e; ++d)
                for (let f = b.getTop(), h = b.getBottom(); f <= h; ++f) {
                    if (c && c.containsPoint(d, f))
                        continue;
                    const l = this.GetCell(d, f, !1);
                    l && (l.Remove(a),
                    l.IsEmpty() && this._cells.Delete(d, f))
                }
        if (c)
            for (let d = c.getLeft(), e = c.getRight(); d <= e; ++d)
                for (let f = c.getTop(), h = c.getBottom(); f <= h; ++f)
                    b && b.containsPoint(d, f) || this.GetCell(d, f, !0).Insert(a)
    }
    QueryRange(a, b) {
        let c = this.XToCell(a.getLeft());
        const d = this.YToCell(a.getTop())
          , e = this.XToCell(a.getRight());
        a = this.YToCell(a.getBottom());
        if (isFinite(e) && isFinite(a))
            for (; c <= e; ++c)
                for (let f = d; f <= a; ++f) {
                    const h = this.GetCell(c, f, !1);
                    h && h.Dump(b)
                }
    }
}
;
"use strict";
const C3$jscomp$198 = self.C3;
C3$jscomp$198.GridCell = class extends C3$jscomp$198.DefendedBase {
    constructor(a, b, c) {
        super();
        this._grid = a;
        this._x = b;
        this._y = c;
        this._instances = C3$jscomp$198.New(C3$jscomp$198.ArraySet)
    }
    Release() {
        this._instances.Release();
        this._grid = this._instances = null
    }
    IsEmpty() {
        return this._instances.IsEmpty()
    }
    Insert(a) {
        this._instances.Add(a)
    }
    Remove(a) {
        this._instances.Delete(a)
    }
    Dump(a) {
        C3$jscomp$198.appendArray(a, this._instances.GetArray())
    }
}
;
"use strict";
const C3$jscomp$199 = self.C3;
C3$jscomp$199.Ray = class {
    constructor() {
        this.dy = this.dx = this.y2 = this.x2 = this.y1 = this.x1 = 0;
        this.rect = new C3$jscomp$199.Rect;
        this.hitFraction = 2;
        this.hitUid = null;
        this.distance = this.hitY = this.hitX = this.hitNormalDy = this.hitNormalDx = this.hitNormal = 0;
        this.normalX = 1;
        this.normalY = 0;
        this.reflectionX = 1;
        this.reflectionY = 0
    }
    DidCollide() {
        return 1.000001 > this.hitFraction
    }
    Reset() {
        this.hitFraction = 2
    }
    Set(a, b, c, d) {
        this.x1 = a;
        this.y1 = b;
        this.x2 = c;
        this.y2 = d;
        this.dx = c - a;
        this.dy = d - b;
        this.rect.set(a, b, c, d);
        this.rect.normalize();
        this.hitFraction = 2;
        this.hitUid = null;
        this.distance = this.hitY = this.hitX = this.hitNormalDy = this.hitNormalDx = this.hitNormal = 0;
        this.normalX = 1;
        this.normalY = 0;
        this.reflectionX = 1;
        this.reflectionY = 0;
        return this
    }
    Complete() {
        if (!1 !== this.DidCollide()) {
            var a = this.dx * this.hitFraction
              , b = this.dy * this.hitFraction
              , c = Math.hypot(a, b);
            a /= c;
            b /= c;
            this.distance = c - 1E-6;
            this.hitX = this.x1 + a * this.distance;
            this.hitY = this.y1 + b * this.distance;
            this.hitNormal = Math.atan2(this.hitNormalDy, this.hitNormalDx) + Math.PI / 2;
            this.normalX = Math.cos(this.hitNormal);
            this.normalY = Math.sin(this.hitNormal);
            c = a * this.normalX + b * this.normalY;
            this.reflectionX = a - 2 * this.normalX * c;
            this.reflectionY = b - 2 * this.normalY * c;
            0 < c && (this.hitNormal = C3$jscomp$199.clampAngle(this.hitNormal + Math.PI),
            this.normalX = -this.normalX,
            this.normalY = -this.normalY)
        }
    }
    TestInstanceSegment(a, b, c, d, e) {
        const f = C3$jscomp$199.rayIntersect(this.x1, this.y1, this.x2, this.y2, b, c, d, e);
        0 <= f && f < this.hitFraction && (this.hitFraction = f,
        this.hitUid = a.GetUID(),
        this.hitNormalDx = b - d,
        this.hitNormalDy = c - e)
    }
    TestInstanceRect(a, b, c, d) {
        const e = b + d.getLeft();
        b += d.getRight();
        const f = c + d.getTop();
        c += d.getBottom();
        this.TestInstanceSegment(a, e, f, b, f);
        this.TestInstanceSegment(a, b, f, b, c);
        this.TestInstanceSegment(a, b, c, e, c);
        this.TestInstanceSegment(a, e, c, e, f)
    }
    TestInstanceQuad(a, b) {
        const c = b.getTlx()
          , d = b.getTly()
          , e = b.getTrx()
          , f = b.getTry()
          , h = b.getBrx()
          , l = b.getBry()
          , m = b.getBlx();
        b = b.getBly();
        this.TestInstanceSegment(a, c, d, e, f);
        this.TestInstanceSegment(a, e, f, h, l);
        this.TestInstanceSegment(a, h, l, m, b);
        this.TestInstanceSegment(a, m, b, c, d)
    }
    TestInstancePoly(a, b, c, d) {
        d = d.pointsArr();
        for (let e = 0, f = d.length; e < f; e += 2) {
            const h = (e + 2) % f;
            this.TestInstanceSegment(a, d[e] + b, d[e + 1] + c, d[h] + b, d[h + 1] + c)
        }
    }
}
;
"use strict";
const C3$jscomp$200 = self.C3
  , VALID_FULLSCREEN_MODES = new Set("off crop scale-inner scale-outer letterbox-scale letterbox-integer-scale".split(" "))
  , VALID_FULLSCREEN_SCALING_QUALITIES = new Set(["high", "low"])
  , glMatrix$jscomp$11 = self.glMatrix
  , mat4$jscomp$10 = glMatrix$jscomp$11.mat4
  , tempProjection = mat4$jscomp$10.create()
  , tempQuad$jscomp$5 = C3$jscomp$200.New(C3$jscomp$200.Quad)
  , tempRect$jscomp$9 = C3$jscomp$200.New(C3$jscomp$200.Rect);
C3$jscomp$200.CanvasManager = class extends C3$jscomp$200.DefendedBase {
    constructor(a) {
        super();
        this._runtime = a;
        this._canvasLayers = [];
        this._isWebGPUEnabled = !1;
        this._iRenderer = this._webgpuRenderer = this._webglRenderer = null;
        this._gpuPreference = "high-performance";
        this._isLimitedToWebGL1 = !1;
        this._windowInnerHeight = this._windowInnerWidth = 0;
        this._cssDisplayMode = "";
        this._canvasCssOffsetY = this._canvasCssOffsetX = this._canvasDeviceHeight = this._canvasDeviceWidth = this._canvasCssHeight = this._canvasCssWidth = 0;
        this._zAxisScale = "normalized";
        this._initFieldOfView = 0;
        this._zNear = 1;
        this._zFar = 1E4;
        this._enableMipmaps = !0;
        this._drawHeight = this._drawWidth = this._textureAnisotropy = 0;
        this._documentFullscreenMode = this._fullscreenMode = "letterbox-scale";
        this._deviceTransformOffY = this._deviceTransformOffX = 0;
        this._defaultProjectionMatrix = mat4$jscomp$10.create();
        this._fullscreenScalingQuality = this._wantFullscreenScalingQuality = "high";
        this._isDocumentFullscreen = !1;
        this._availableAdditionalRenderTargets = [];
        this._usedAdditionalRenderTargets = new Set;
        this._shaderData = self.C3_Shaders;
        this._effectChainManager = C3$jscomp$200.New(C3$jscomp$200.Gfx.EffectChainManager, {
            getDrawSize: () => [this.GetDrawWidth(), this.GetDrawHeight()],
            getRenderTarget: () => this.GetEffectCompositorRenderTarget(),
            releaseRenderTarget: b => this.ReleaseEffectCompositorRenderTarget(b),
            getTime: () => this.GetRuntime().GetGameTime(),
            redraw: () => this.GetRuntime().UpdateRender()
        });
        this._gpuTimeEndFrame = this._gpuTimeStartFrame = 0;
        this._gpuLastUtilisation = NaN;
        this._gpuFrameTimingsBuffer = null;
        this._layersGpuProfile = new Map;
        this._gpuCurUtilisation = NaN;
        this._webgpuFrameTimings = new Map;
        this._snapshotFormat = "";
        this._snapshotQuality = 1;
        this._snapshotArea = C3$jscomp$200.New(C3$jscomp$200.Rect);
        this._snapshotUrl = "";
        this._snapshotResolve = this._snapshotPromise = null;
        this._loaderStartTime = this._isPastingToDrawingCanvas = 0;
        this._rafId = -1;
        this._loadingProgress = 0;
        this._loadingprogress_handler = b => this._loadingProgress = b.progress;
        this._percentText = null;
        this._splashTextures = {
            logo: null,
            powered: null,
            website: null
        };
        this._splashFadeOutStartTime = this._splashFadeInFinishTime = this._splashFrameNumber = 0;
        this._splashState = "fade-in";
        this._splashDoneResolve = null;
        this._splashDonePromise = new Promise(b => this._splashDoneResolve = b)
    }
    _SetGPUPowerPreference(a) {
        this._gpuPreference = a
    }
    _SetWebGPUEnabled(a) {
        this._isWebGPUEnabled = !!a
    }
    _SetZAxisScale(a) {
        this._zAxisScale = a
    }
    GetZAxisScale() {
        return this._zAxisScale
    }
    _SetInitFieldOfView(a) {
        this._initFieldOfView = a
    }
    _SetZDistances(a, b) {
        this._zNear = a;
        this._zFar = b
    }
    _SetLimitedToWebGL1(a) {
        this._isLimitedToWebGL1 = !!a
    }
    async CreateCanvas(a) {
        var b = a.canvas;
        this._canvasLayers.push({
            canvas: b,
            ctx: null
        });
        this._runtime.AddDOMComponentMessageHandler("runtime", "window-resize", d => this._OnWindowResize(d));
        this._runtime.AddDOMComponentMessageHandler("runtime", "fullscreenchange", d => this._OnFullscreenChange(d));
        this._runtime.AddDOMComponentMessageHandler("runtime", "fullscreenerror", d => this._OnFullscreenError(d));
        b.addEventListener("webglcontextlost", d => this._OnWebGLContextLost(d));
        b.addEventListener("webglcontextrestored", d => this._OnWebGLContextRestored(d));
        this._isDocumentFullscreen = !!a.isFullscreen;
        this._cssDisplayMode = a.cssDisplayMode;
        var c = navigator.gpu && this._isWebGPUEnabled;
        b = !1;
        if (c)
            try {
                await this._InitWebGPUContext(!0)
            } catch (d) {
                this._MaybeLogRendererError("WebGPU", d),
                this._webgpuRenderer = null
            }
        if (!this.GetRenderer())
            try {
                await this._InitWebGLContext(!0)
            } catch (d) {
                this._MaybeLogRendererError("WebGL", d),
                this._webglRenderer = null
            }
        this.GetRenderer() || (b = !0);
        if (!this.GetRenderer() && c)
            try {
                await this._InitWebGPUContext(!1)
            } catch (d) {
                this._MaybeLogRendererError("WebGPU", d),
                this._webgpuRenderer = null
            }
        if (!this.GetRenderer())
            try {
                await this._InitWebGLContext(!1)
            } catch (d) {
                this._MaybeLogRendererError("WebGL", d),
                this._webglRenderer = null
            }
        c = this.GetRenderer();
        if (!c)
            throw Error("failed to acquire a renderer - check WebGL or WebGPU is supported");
        c.SetHasMajorPerformanceCaveat(b);
        this._webgpuRenderer && (this._webgpuRenderer.ondevicelost = () => this._OnWebGPUDeviceLost(),
        this._webgpuRenderer.ondevicerestored = () => this._OnWebGPUDeviceRestored());
        "normalized" === this._zAxisScale ? c.SetZAxisScaleNormalized() : (c.SetZAxisScaleRegular(),
        c.SetFovY(this._initFieldOfView));
        this.SetSize(a.windowInnerWidth, a.windowInnerHeight, !0);
        await this._InitRenderer()
    }
    _MaybeLogRendererError(a, b) {
        b && "string" === typeof b.message && b.message.startsWith("renderer-unavailable") || console.error(`Error creating ${a} renderer: `, b)
    }
    async _InitWebGPUContext(a) {
        const b = {
            nearZ: this._zNear,
            farZ: this._zFar
        };
        a = {
            powerPreference: this._gpuPreference,
            depth: this._runtime.Uses3DFeatures(),
            failIfMajorPerformanceCaveat: a,
            usesBackgroundBlending: this._runtime.UsesAnyBackgroundBlending(),
            canSampleBackbuffer: this._runtime.UsesAnyCrossSampling(),
            canSampleDepth: this._runtime.UsesAnyDepthSampling()
        };
        this._webgpuRenderer = C3$jscomp$200.New(C3$jscomp$200.Gfx.WebGPURenderer, b);
        await this._webgpuRenderer.Create(this._canvasLayers[0].canvas, a)
    }
    async _InitWebGLContext(a) {
        a = {
            alpha: !0,
            powerPreference: this._gpuPreference,
            enableGpuProfiling: "xbox-uwp-webview2" !== this._runtime.GetExportType(),
            depth: this._runtime.Uses3DFeatures(),
            canSampleDepth: this._runtime.UsesAnyDepthSampling(),
            failIfMajorPerformanceCaveat: a,
            nearZ: this._zNear,
            farZ: this._zFar
        };
        this._isLimitedToWebGL1 && (a.maxWebGLVersion = 1);
        this._webglRenderer = C3$jscomp$200.New(C3$jscomp$200.Gfx.WebGLRenderer, this._canvasLayers[0].canvas, a);
        await this._webglRenderer.InitState()
    }
    async _InitWebGPU() {
        if (this._shaderData) {
            const a = [];
            for (const [b,c] of Object.entries(this._shaderData)) {
                c.src = c.wgsl;
                const d = C3$jscomp$200.Gfx.WebGPUShaderProgram.GetDefaultVertexShaderSource();
                a.push(this._webgpuRenderer.CreateShaderProgram(Object.assign({
                    vertexSrc: d,
                    name: b
                }, c)))
            }
            await Promise.all(a)
        }
    }
    async _InitWebGL() {
        if (this._shaderData) {
            const a = [];
            for (const [b,c] of Object.entries(this._shaderData)) {
                let d;
                if (c.glslWebGL2 && 2 <= this._webglRenderer.GetWebGLVersionNumber())
                    c.src = c.glslWebGL2,
                    d = C3$jscomp$200.Gfx.WebGLShaderProgram.GetDefaultVertexShaderSource_WebGL2();
                else {
                    if (!c.glsl)
                        throw Error(`shader '${b}' does not support WebGL 1`);
                    c.src = c.glsl;
                    d = C3$jscomp$200.Gfx.WebGLShaderProgram.GetDefaultVertexShaderSource()
                }
                a.push(this._webglRenderer.CreateShaderProgram(Object.assign({
                    vertexSrc: d,
                    name: b
                }, c)))
            }
            await Promise.all(a);
            this._webglRenderer.ResetLastProgram();
            this._webglRenderer.SetTextureFillMode()
        }
        this._webglRenderer.SupportsGPUProfiling() && (this._gpuFrameTimingsBuffer = C3$jscomp$200.New(C3$jscomp$200.Gfx.WebGLQueryResultBuffer, this._webglRenderer))
    }
    async _InitRenderer() {
        this._webgpuRenderer ? await this._InitWebGPU() : this._webglRenderer && await this._InitWebGL();
        const a = this.GetRenderer();
        a.SetMipmapsEnabled(this._enableMipmaps);
        a.SupportsGPUProfiling() && (this._gpuLastUtilisation = 0);
        for (const b of this._runtime._GetAllEffectLists()) {
            for (const c of b.GetAllEffectTypes())
                c._InitRenderer(a);
            b._InitRenderer(a);
            b.UpdateActiveEffects()
        }
        this._iRenderer = new self.IRenderer(this._runtime,a)
    }
    Release() {
        this._webglRenderer = this._runtime = null;
        this._canvasLayers.length = 0
    }
    IsInWorker() {
        return this._runtime.IsInWorker()
    }
    _OnWindowResize(a) {
        const b = this._runtime;
        if (!b.IsExportToVideo()) {
            var c = a.devicePixelRatio;
            this.IsInWorker() && (self.devicePixelRatio = c);
            b._SetDevicePixelRatio(c);
            this._isDocumentFullscreen = !!a.isFullscreen;
            this._cssDisplayMode = a.cssDisplayMode;
            this.SetSize(a.innerWidth, a.innerHeight);
            b.UpdateRender();
            c = new C3$jscomp$200.Event("window-resize");
            c.data = a;
            b.Dispatcher().dispatchEventAndWaitAsyncSequential(c);
            a = new C3$jscomp$200.Event("resize");
            a.cssWidth = this.GetCssWidth();
            a.cssHeight = this.GetCssHeight();
            a.deviceWidth = this.GetDeviceWidth();
            a.deviceHeight = this.GetDeviceHeight();
            b.DispatchUserScriptEvent(a);
            b.IsDebug() && (b.HitBreakpoint() || self.C3Debugger.IsDebuggerPaused()) && b.Render()
        }
    }
    _OnFullscreenChange(a) {
        this._isDocumentFullscreen = !!a.isFullscreen;
        this.SetSize(a.innerWidth, a.innerHeight, !0);
        this._runtime.UpdateRender()
    }
    _OnFullscreenError(a) {
        this._isDocumentFullscreen = !!a.isFullscreen;
        this.SetSize(a.innerWidth, a.innerHeight, !0);
        this._runtime.UpdateRender()
    }
    SetSize(a, b, c=!1) {
        a = Math.floor(a);
        b = Math.floor(b);
        if (0 >= a || 0 >= b)
            throw Error("invalid size");
        if (this._windowInnerWidth !== a || this._windowInnerHeight !== b || c) {
            this._windowInnerWidth = a;
            this._windowInnerHeight = b;
            c = this.GetCurrentFullscreenMode();
            "letterbox-scale" === c ? this._CalculateLetterboxScale(a, b) : "letterbox-integer-scale" === c ? this._CalculateLetterboxIntegerScale(a, b) : "off" === c ? this._CalculateFixedSizeCanvas(a, b) : this._CalculateFullsizeCanvas(a, b);
            this._UpdateFullscreenScalingQuality(c);
            for (const {canvas: e} of this._canvasLayers)
                e.width = this._canvasDeviceWidth,
                e.height = this._canvasDeviceHeight;
            this._runtime.PostComponentMessageToDOM("canvas", "update-size", {
                marginLeft: this._canvasCssOffsetX,
                marginTop: this._canvasCssOffsetY,
                styleWidth: this._canvasCssWidth,
                styleHeight: this._canvasCssHeight,
                displayScale: this.GetDisplayScale()
            });
            a = this.GetRenderer();
            a.SetSize(this._canvasDeviceWidth, this._canvasDeviceHeight, !0);
            for (var d of this._availableAdditionalRenderTargets)
                a.DeleteRenderTarget(d);
            C3$jscomp$200.clearArray(this._availableAdditionalRenderTargets);
            this.UpdateDefaultProjectionMatrix();
            d = this._runtime.GetLayoutManager();
            d.SetAllLayerProjectionChanged();
            d.SetAllLayerMVChanged()
        }
    }
    UpdateDefaultProjectionMatrix() {
        this.GetRenderer().CalculatePerspectiveMatrix(this._defaultProjectionMatrix, this.GetDrawWidth() / this.GetDrawHeight())
    }
    GetDefaultProjectionMatrix() {
        return this._defaultProjectionMatrix
    }
    _CalculateLetterboxScale(a, b) {
        const c = this._runtime.GetDevicePixelRatio()
          , d = this._runtime.GetOriginalViewportWidth()
          , e = this._runtime.GetOriginalViewportHeight()
          , f = d / e;
        a / b > f ? (this._canvasCssWidth = Math.round(b * f),
        this._canvasCssHeight = b,
        this._canvasCssOffsetX = Math.floor((a - this._canvasCssWidth) / 2),
        this._canvasCssOffsetY = 0) : (this._canvasCssWidth = a,
        this._canvasCssHeight = Math.round(a / f),
        this._canvasCssOffsetX = 0,
        this._canvasCssOffsetY = Math.floor((b - this._canvasCssHeight) / 2));
        this._canvasDeviceWidth = Math.round(this._canvasCssWidth * c);
        this._canvasDeviceHeight = Math.round(this._canvasCssHeight * c);
        this._runtime.SetViewportSize(d, e)
    }
    _CalculateLetterboxIntegerScale(a, b) {
        const c = this._runtime.GetDevicePixelRatio();
        1 !== c && (a += 1,
        b += 1);
        const d = this._runtime.GetOriginalViewportWidth()
          , e = this._runtime.GetOriginalViewportHeight();
        var f = d / e;
        f = a / b > f ? b * f * c / d : a / f * c / e;
        1 < f ? f = Math.floor(f) : 1 > f && (f = 1 / Math.ceil(1 / f));
        this._canvasDeviceWidth = Math.round(d * f);
        this._canvasDeviceHeight = Math.round(e * f);
        this._canvasCssWidth = this._canvasDeviceWidth / c;
        this._canvasCssHeight = this._canvasDeviceHeight / c;
        this._canvasCssOffsetX = Math.max(Math.floor((a - this._canvasCssWidth) / 2), 0);
        this._canvasCssOffsetY = Math.max(Math.floor((b - this._canvasCssHeight) / 2), 0);
        this._runtime.SetViewportSize(d, e)
    }
    _CalculateFullsizeCanvas(a, b) {
        const c = this._runtime.GetDevicePixelRatio();
        this._canvasCssWidth = a;
        this._canvasCssHeight = b;
        this._canvasDeviceWidth = Math.round(this._canvasCssWidth * c);
        this._canvasDeviceHeight = Math.round(this._canvasCssHeight * c);
        this._canvasCssOffsetY = this._canvasCssOffsetX = 0;
        a = this.GetDisplayScale();
        this._runtime.SetViewportSize(this._canvasCssWidth / a, this._canvasCssHeight / a)
    }
    _CalculateFixedSizeCanvas(a, b) {
        const c = this._runtime.GetDevicePixelRatio();
        this._canvasCssWidth = this._runtime.GetViewportWidth();
        this._canvasCssHeight = this._runtime.GetViewportHeight();
        this._canvasDeviceWidth = Math.round(this._canvasCssWidth * c);
        this._canvasDeviceHeight = Math.round(this._canvasCssHeight * c);
        this.IsDocumentFullscreen() ? (this._canvasCssOffsetX = Math.floor((a - this._canvasCssWidth) / 2),
        this._canvasCssOffsetY = Math.floor((b - this._canvasCssHeight) / 2)) : this._canvasCssOffsetY = this._canvasCssOffsetX = 0;
        this._runtime.SetViewportSize(this._runtime.GetViewportWidth(), this._runtime.GetViewportHeight())
    }
    _UpdateFullscreenScalingQuality(a) {
        if ("high" === this._wantFullscreenScalingQuality)
            this._drawWidth = this._canvasDeviceWidth,
            this._drawHeight = this._canvasDeviceHeight,
            this._fullscreenScalingQuality = "high";
        else {
            let c;
            if ("off" === this.GetCurrentFullscreenMode()) {
                var b = this._runtime.GetViewportWidth();
                c = this._runtime.GetViewportHeight()
            } else
                b = this._runtime.GetOriginalViewportWidth(),
                c = this._runtime.GetOriginalViewportHeight();
            this._canvasDeviceWidth < b || this._canvasDeviceHeight < c ? (this._drawWidth = this._canvasDeviceWidth,
            this._drawHeight = this._canvasDeviceHeight,
            this._fullscreenScalingQuality = "high") : (this._drawWidth = b,
            this._drawHeight = c,
            this._fullscreenScalingQuality = "low",
            "scale-inner" === a ? (a = b / c,
            b = this._windowInnerWidth / this._windowInnerHeight,
            b < a ? this._drawWidth = this._drawHeight * b : b > a && (this._drawHeight = this._drawWidth / b)) : "scale-outer" === a && (a = b / c,
            b = this._windowInnerWidth / this._windowInnerHeight,
            b > a ? this._drawWidth = this._drawHeight * b : b < a && (this._drawHeight = this._drawWidth / b)))
        }
    }
    GetRuntime() {
        return this._runtime
    }
    GetMainCanvas() {
        return this._canvasLayers[0].canvas
    }
    GetEffectChainManager() {
        return this._effectChainManager
    }
    IsDocumentFullscreen() {
        return this._isDocumentFullscreen
    }
    GetCssDisplayMode() {
        return this._cssDisplayMode
    }
    SetFullscreenMode(a) {
        if (!VALID_FULLSCREEN_MODES.has(a))
            throw Error("invalid fullscreen mode");
        this._fullscreenMode = a;
        a = this._runtime.GetLayoutManager();
        a.SetAllLayerProjectionChanged();
        a.SetAllLayerMVChanged()
    }
    GetFullscreenMode() {
        return this._fullscreenMode
    }
    SetDocumentFullscreenMode(a) {
        if (!VALID_FULLSCREEN_MODES.has(a))
            throw Error("invalid fullscreen mode");
        this._documentFullscreenMode = a;
        a = this._runtime.GetLayoutManager();
        a.SetAllLayerProjectionChanged();
        a.SetAllLayerMVChanged()
    }
    GetDocumentFullscreenMode() {
        return this._documentFullscreenMode
    }
    GetCurrentFullscreenMode() {
        return this.IsDocumentFullscreen() ? this.GetDocumentFullscreenMode() : this.GetFullscreenMode()
    }
    SetFullscreenScalingQuality(a) {
        if (!VALID_FULLSCREEN_SCALING_QUALITIES.has(a))
            throw Error("invalid fullscreen scaling quality");
        this._wantFullscreenScalingQuality = a;
        this._runtime.GetLayoutManager().SetAllLayerProjectionChanged()
    }
    GetSetFullscreenScalingQuality() {
        return this._wantFullscreenScalingQuality
    }
    GetCurrentFullscreenScalingQuality() {
        return this._fullscreenScalingQuality
    }
    static _FullscreenModeNumberToString(a) {
        switch (a) {
        case 0:
            return "off";
        case 1:
            return "crop";
        case 2:
            return "scale-inner";
        case 3:
            return "scale-outer";
        case 4:
            return "letterbox-scale";
        case 5:
            return "letterbox-integer-scale";
        default:
            throw Error("invalid fullscreen mode");
        }
    }
    GetLastWidth() {
        return this._windowInnerWidth
    }
    GetLastHeight() {
        return this._windowInnerHeight
    }
    GetDrawWidth() {
        return this._drawWidth
    }
    GetDrawHeight() {
        return this._drawHeight
    }
    SetMipmapsEnabled(a) {
        this._enableMipmaps = !!a
    }
    _SetTextureAnisotropy(a) {
        this._textureAnisotropy = a
    }
    GetTextureAnisotropy() {
        return this._textureAnisotropy
    }
    IsRendererContextLost() {
        return this.GetRenderer().IsContextLost()
    }
    _OnWebGLContextLost(a) {
        console.log("[Construct] WebGL context lost");
        a.preventDefault();
        this._availableAdditionalRenderTargets = [];
        this._usedAdditionalRenderTargets.clear();
        this._effectChainManager.OnContextLost();
        this._webglRenderer.OnContextLost();
        this._runtime._OnRendererContextLost()
    }
    _OnWebGPUDeviceLost() {
        console.log("[Construct] WebGPU device lost");
        this._availableAdditionalRenderTargets = [];
        this._usedAdditionalRenderTargets.clear();
        this._effectChainManager.OnContextLost();
        this._runtime._OnRendererContextLost()
    }
    async _OnWebGLContextRestored(a) {
        await this._webglRenderer.OnContextRestored();
        await this._InitRenderer();
        await this._runtime._OnRendererContextRestored();
        console.log("[Construct] WebGL context restored")
    }
    async _OnWebGPUDeviceRestored() {
        await this._InitRenderer();
        await this._runtime._OnRendererContextRestored();
        console.log("[Construct] WebGPU device restored")
    }
    GetWebGLRenderer() {
        return this._webglRenderer
    }
    GetWebGPURenderer() {
        return this._webgpuRenderer
    }
    GetRenderer() {
        return this._webgpuRenderer || this._webglRenderer
    }
    GetIRenderer() {
        return this._iRenderer
    }
    GetRenderScale() {
        return "low" === this._fullscreenScalingQuality ? 1 / this._runtime.GetDevicePixelRatio() : this.GetDisplayScale()
    }
    GetDisplayScale() {
        const a = this.GetCurrentFullscreenMode();
        if ("off" === a || "crop" === a)
            return 1;
        const b = this._runtime.GetOriginalViewportWidth()
          , c = this._runtime.GetOriginalViewportHeight()
          , d = b / c
          , e = this._canvasDeviceWidth / this._canvasDeviceHeight;
        return "scale-inner" !== a && e > d || "scale-inner" === a && e < d ? this._canvasCssHeight / c : this._canvasCssWidth / b
    }
    GetEffectLayerScaleParam() {
        return "low" === this.GetCurrentFullscreenScalingQuality() ? 1 : this.GetDisplayScale()
    }
    GetEffectDevicePixelRatioParam() {
        return "low" === this.GetCurrentFullscreenScalingQuality() ? 1 : this._runtime.GetDevicePixelRatio()
    }
    SetDeviceTransformOffset(a, b) {
        this._deviceTransformOffX = a;
        this._deviceTransformOffY = b
    }
    SetDeviceTransform(a, b, c, d=!0) {
        b = b || this._drawWidth;
        c = c || this._drawHeight;
        const e = b / 2 + this._deviceTransformOffX
          , f = c / 2 + this._deviceTransformOffY;
        if (d) {
            d = this.GetDefaultProjectionMatrix();
            if (b !== this._drawWidth || c !== this._drawHeight)
                a.CalculatePerspectiveMatrix(tempProjection, b / c),
                d = tempProjection;
            a.SetProjectionMatrix(d)
        }
        b = a.CalculateLookAtModelView2(e, f, a.GetDefaultCameraZ(c), e, f, 0, c);
        a.SetModelViewMatrix(b)
    }
    SetCssTransform(a, b=!0) {
        var c = this.GetCssWidth();
        const d = this.GetCssHeight();
        c /= 2;
        const e = d / 2;
        b && a.SetProjectionMatrix(this.GetDefaultProjectionMatrix());
        b = a.CalculateLookAtModelView2(c, e, a.GetDefaultCameraZ(d), c, e, 0, d);
        a.SetModelViewMatrix(b)
    }
    GetDeviceWidth() {
        return this._canvasDeviceWidth
    }
    GetDeviceHeight() {
        return this._canvasDeviceHeight
    }
    GetCssWidth() {
        return this._canvasCssWidth
    }
    GetCssHeight() {
        return this._canvasCssHeight
    }
    GetCanvasClientX() {
        return this._canvasCssOffsetX
    }
    GetCanvasClientY() {
        return this._canvasCssOffsetY
    }
    GetHTMLLayerCount() {
        return this._canvasLayers.length
    }
    _CanUseImageBitmapRenderingContext() {
        return "undefined" !== typeof OffscreenCanvas && this.GetMainCanvas()instanceof OffscreenCanvas && ("Chromium" !== C3$jscomp$200.Platform.BrowserEngine || 124 <= C3$jscomp$200.Platform.BrowserVersionNumber)
    }
    async SetHTMLLayerCount(a, b=!1) {
        if (1 > a)
            throw Error("invalid HTML layer count");
        if (this._canvasLayers.length !== a) {
            b = {
                count: a,
                immediate: b,
                marginLeft: this._canvasCssOffsetX,
                marginTop: this._canvasCssOffsetY,
                styleWidth: this._canvasCssWidth,
                styleHeight: this._canvasCssHeight
            };
            b = this.IsInWorker() ? await this._runtime.PostComponentMessageToDOMAsync("canvas", "set-html-layer-count", b) : self.c3_runtimeInterface._OnSetHTMLLayerCount(b);
            if (a < this._canvasLayers.length)
                this._canvasLayers.length = a;
            else
                for (const c of b.addedCanvases) {
                    c.width = this._canvasDeviceWidth;
                    c.height = this._canvasDeviceHeight;
                    a = this._CanUseImageBitmapRenderingContext() ? "bitmaprenderer" : "2d";
                    b = c.getContext(a);
                    if (!b)
                        throw Error(`failed to acquire '${a}' canvas context`);
                    this._canvasLayers.push({
                        canvas: c,
                        ctx: b
                    })
                }
            this._runtime.UpdateRender()
        }
    }
    BlitMainCanvasToHTMLLayerCanvas(a) {
        if (!(a >= this._canvasLayers.length)) {
            var b = this.GetMainCanvas();
            a = this._canvasLayers[a].ctx;
            this._CanUseImageBitmapRenderingContext() ? a.transferFromImageBitmap(b.transferToImageBitmap()) : (a.globalCompositeOperation = "copy",
            a.drawImage(b, 0, 0))
        }
    }
    GetAdditionalRenderTarget(a) {
        a.depth = this._runtime.Uses3DFeatures();
        const b = this._availableAdditionalRenderTargets
          , c = b.findIndex(e => e.IsCompatibleWithOptions(a));
        let d;
        -1 !== c ? (d = b[c],
        b.splice(c, 1)) : d = this.GetRenderer().CreateRenderTarget(a);
        this._usedAdditionalRenderTargets.add(d);
        return d
    }
    ReleaseAdditionalRenderTarget(a) {
        if (!this._usedAdditionalRenderTargets.has(a))
            throw Error("render target not in use");
        this._usedAdditionalRenderTargets.delete(a);
        this._availableAdditionalRenderTargets.push(a)
    }
    GetEffectCompositorRenderTarget() {
        const a = {
            sampling: this._runtime.GetSampling()
        };
        "low" === this.GetCurrentFullscreenScalingQuality() && (a.width = this.GetDrawWidth(),
        a.height = this.GetDrawHeight());
        return this.GetAdditionalRenderTarget(a)
    }
    ReleaseEffectCompositorRenderTarget(a) {
        this.ReleaseAdditionalRenderTarget(a)
    }
    *activeLayersGpuProfiles() {
        for (const a of this._runtime.GetLayoutManager().runningLayouts())
            for (const b of a.GetLayers()) {
                const c = this._layersGpuProfile.get(b);
                c && (yield c)
            }
    }
    GetLayerTimingsBuffer(a) {
        if (!this.GetRenderer().SupportsGPUProfiling())
            return null;
        let b = this._layersGpuProfile.get(a);
        b || (b = {
            layer: a,
            name: a.GetName(),
            timingsBuffer: C3$jscomp$200.New(C3$jscomp$200.Gfx.WebGLQueryResultBuffer, this._webglRenderer),
            curUtilisation: 0,
            lastTotalUtilisation: 0,
            lastSelfUtilisation: 0
        },
        this._layersGpuProfile.set(a, b));
        return b.timingsBuffer
    }
    _Update1sFrameRange() {
        const a = this.GetRenderer();
        if (a.SupportsGPUProfiling() && 0 === this._gpuTimeEndFrame) {
            this._gpuTimeEndFrame = a.GetFrameNumber();
            this._gpuCurUtilisation = NaN;
            for (const b of this.activeLayersGpuProfiles())
                b.curUtilisation = NaN
        }
    }
    _UpdateTick() {
        this._webglRenderer && this._webglRenderer.SupportsGPUProfiling() && this._UpdateTick_WebGL();
        this._webgpuRenderer && this._webgpuRenderer.SupportsGPUProfiling() && this._UpdateTick_WebGPU()
    }
    _UpdateTick_WebGL() {
        if (isNaN(this._gpuCurUtilisation) && (this._gpuCurUtilisation = this._gpuFrameTimingsBuffer.GetFrameRangeResultSum(this._gpuTimeStartFrame, this._gpuTimeEndFrame),
        !isNaN(this._gpuCurUtilisation))) {
            if (this._runtime.IsDebug())
                for (var a of this.activeLayersGpuProfiles())
                    if (a.curUtilisation = a.timingsBuffer.GetFrameRangeResultSum(this._gpuTimeStartFrame, this._gpuTimeEndFrame),
                    isNaN(a.curUtilisation))
                        return;
            this._gpuFrameTimingsBuffer.DeleteAllBeforeFrameNumber(this._gpuTimeEndFrame);
            this._gpuLastUtilisation = Math.min(this._gpuCurUtilisation, 1);
            if (this._runtime.IsDebug()) {
                const c = new Map;
                for (const d of this.activeLayersGpuProfiles())
                    d.timingsBuffer.DeleteAllBeforeFrameNumber(this._gpuTimeEndFrame),
                    d.lastTotalUtilisation = Math.min(d.curUtilisation, 1),
                    c.set(d.layer, d.lastTotalUtilisation);
                for (var b of this.activeLayersGpuProfiles())
                    a = b.layer,
                    a = (c.get(a) || 0) - a.GetSubLayers().reduce( (d, e) => d + (c.get(e) || 0), 0),
                    b.lastSelfUtilisation = C3$jscomp$200.clamp(a, 0, 1);
                b = this._runtime.GetMainRunningLayout();
                b = this._gpuLastUtilisation - b._GetRootLayers().reduce( (d, e) => d + (c.get(e) || 0), 0);
                self.C3Debugger.UpdateGPUProfile(C3$jscomp$200.clamp(b, 0, 1), this._gpuLastUtilisation, [...this.activeLayersGpuProfiles()])
            }
            this._gpuTimeStartFrame = this._gpuTimeEndFrame;
            this._gpuTimeEndFrame = 0
        }
    }
    GetGPUFrameTimingsBuffer() {
        return this._gpuFrameTimingsBuffer
    }
    _UpdateTick_WebGPU() {
        if (0 !== this._gpuTimeEndFrame) {
            for (var a = this._gpuTimeStartFrame; a < this._gpuTimeEndFrame; ++a) {
                var b = this._webgpuFrameTimings.get(a);
                if (b && !b.HasResult())
                    return
            }
            a = this._runtime.GetMainRunningLayout();
            b = C3$jscomp$200.MakeFilledArray(a.GetLayerCount() + 1, 0);
            var c = 0;
            for (let e = this._gpuTimeStartFrame; e < this._gpuTimeEndFrame; ++e) {
                var d = this._webgpuFrameTimings.get(e);
                if (!d)
                    continue;
                d = d.GetResult();
                let f = BigInt(0)
                  , h = BigInt(0);
                const l = BigInt(0);
                for (let m = 0, p = Math.min(b.length, d.length / 2); m < p; ++m) {
                    const r = d[2 * m]
                      , v = d[2 * m + 1];
                    r !== l && (f === l || r < f) && (f = r);
                    v > h && (h = v);
                    b[m] += Number(v - r) / 1E9
                }
                c += Number(h - f) / 1E9
            }
            this._gpuLastUtilisation = C3$jscomp$200.clamp(c, 0, 1);
            if (this._runtime.IsDebug()) {
                c = a.GetLayers();
                const e = new Map;
                for (let h = 0, l = Math.min(c.length, b.length - 1); h < l; ++h)
                    e.set(c[h], b[h + 1]);
                b = [];
                const f = new Map;
                for (const [h,l] of e)
                    c = [...h.selfAndAllSubLayers()].reduce( (m, p) => m + (e.get(p) || 0), 0),
                    f.set(h, c),
                    b.push({
                        name: h.GetName(),
                        lastSelfUtilisation: C3$jscomp$200.clamp(l, 0, 1),
                        lastTotalUtilisation: C3$jscomp$200.clamp(c, 0, 1)
                    });
                a = this._gpuLastUtilisation - a._GetRootLayers().reduce( (h, l) => h + (f.get(l) || 0), 0);
                self.C3Debugger.UpdateGPUProfile(C3$jscomp$200.clamp(a, 0, 1), this._gpuLastUtilisation, b)
            }
            for (a = this._gpuTimeStartFrame; a < this._gpuTimeEndFrame; ++a)
                this._webgpuFrameTimings.delete(a);
            this._gpuTimeStartFrame = this._gpuTimeEndFrame;
            this._gpuTimeEndFrame = 0
        }
    }
    _AddWebGPUFrameTiming(a) {
        this._webgpuFrameTimings.set(this._webgpuRenderer.GetFrameNumber(), a)
    }
    GetGPUUtilisation() {
        return this._gpuLastUtilisation
    }
    SnapshotCanvas(a, b, c, d, e, f) {
        this._snapshotFormat = a;
        this._snapshotQuality = b;
        this._snapshotArea.setWH(c, d, e, f);
        return this._snapshotPromise ? this._snapshotPromise : this._snapshotPromise = new Promise(h => {
            this._snapshotResolve = h
        }
        )
    }
    _MaybeTakeSnapshot() {
        if (this._snapshotFormat) {
            var a = this.GetMainCanvas()
              , b = this._snapshotArea
              , c = C3$jscomp$200.clamp(Math.floor(b.getLeft()), 0, a.width)
              , d = C3$jscomp$200.clamp(Math.floor(b.getTop()), 0, a.height)
              , e = b.width();
            e = 0 === e ? a.width - c : C3$jscomp$200.clamp(Math.floor(e), 0, a.width - c);
            b = b.height();
            b = 0 === b ? a.height - d : C3$jscomp$200.clamp(Math.floor(b), 0, a.height - d);
            if ((0 !== c || 0 !== d || e !== a.width || b !== a.height) && 0 < e && 0 < b) {
                const f = C3$jscomp$200.CreateCanvas(e, b);
                f.getContext("2d").drawImage(a, c, d, e, b, 0, 0, e, b);
                a = f
            }
            C3$jscomp$200.CanvasToBlob(a, this._snapshotFormat, this._snapshotQuality).then(f => {
                this._snapshotUrl && URL.revokeObjectURL(this._snapshotUrl);
                this._snapshotUrl = URL.createObjectURL(f);
                this._snapshotPromise = null;
                this._snapshotResolve(this._snapshotUrl)
            }
            );
            this._snapshotFormat = "";
            this._snapshotQuality = 1
        }
    }
    GetCanvasSnapshotUrl() {
        return this._snapshotUrl
    }
    SetIsPastingToDrawingCanvas(a) {
        a ? this._isPastingToDrawingCanvas++ : this._isPastingToDrawingCanvas--
    }
    IsPastingToDrawingCanvas() {
        return 0 < this._isPastingToDrawingCanvas
    }
    InitLoadingScreen(a) {
        const b = this.GetRenderer();
        2 === a ? (this._percentText = C3$jscomp$200.New(C3$jscomp$200.Gfx.RendererText, this.GetRenderer()),
        this._percentText.SetFontName("Arial"),
        this._percentText.SetFontSize(16),
        this._percentText.SetHorizontalAlignment("center"),
        this._percentText.SetVerticalAlignment("center"),
        this._percentText.SetSize(300, 200)) : 0 === a ? (a = this._runtime.GetLoadingLogoAsset()) && a.LoadStaticTexture(b).catch(c => console.warn("[C3 runtime] Failed to create texture for loading logo: ", c)) : 4 === a && (this._LoadSvgSplashImage("splash-images/splash-logo.svg").then(c => {
            "done" === this._splashState ? b.DeleteTexture(c) : this._splashTextures.logo = c
        }
        ).catch(c => console.warn("Failed to load splash image: ", c)),
        this._LoadBitmapSplashImage("splash-images/splash-poweredby-512.png").then(c => {
            "done" === this._splashState ? b.DeleteTexture(c) : this._splashTextures.powered = c
        }
        ).catch(c => console.warn("Failed to load splash image: ", c)),
        this._LoadBitmapSplashImage("splash-images/splash-website-512.png").then(c => {
            "done" === this._splashState ? b.DeleteTexture(c) : this._splashTextures.website = c
        }
        ).catch(c => console.warn("Failed to load splash image: ", c)))
    }
    async _LoadSvgSplashImage(a) {
        a = (new URL(a,this._runtime.GetRuntimeBaseURL())).toString();
        a = await C3$jscomp$200.FetchBlob(a);
        a = await this._runtime.RasterSvgImage(a, 2048, 2048);
        return await this.GetRenderer().CreateStaticTextureAsync(a, {
            mipMapQuality: "high"
        })
    }
    async _LoadBitmapSplashImage(a) {
        a = (new URL(a,this._runtime.GetRuntimeBaseURL())).toString();
        a = await C3$jscomp$200.FetchBlob(a);
        return await this.GetRenderer().CreateStaticTextureAsync(a, {
            mipMapQuality: "high"
        })
    }
    HideCordovaSplashScreen() {
        this._runtime.PostComponentMessageToDOM("runtime", "hide-cordova-splash")
    }
    StartLoadingScreen() {
        this._loaderStartTime = Date.now();
        this._runtime.Dispatcher().addEventListener("loadingprogress", this._loadingprogress_handler);
        this._rafId = requestAnimationFrame( () => this._DrawLoadingScreen());
        3 !== this._runtime.GetLoaderStyle() && this.HideCordovaSplashScreen()
    }
    async EndLoadingScreen() {
        const a = this.GetRenderer();
        this._loadingProgress = 1;
        const b = this._runtime.GetLoaderStyle();
        4 === b && await this._splashDonePromise;
        this._splashDonePromise = this._splashDoneResolve = null;
        -1 !== this._rafId && (cancelAnimationFrame(this._rafId),
        this._rafId = -1);
        this._runtime.Dispatcher().removeEventListener("loadingprogress", this._loadingprogress_handler);
        this._loadingprogress_handler = null;
        this._percentText && (this._percentText.Release(),
        this._percentText = null);
        this._runtime.ReleaseLoadingLogoAsset();
        a.Start();
        this._splashTextures.logo && (a.DeleteTexture(this._splashTextures.logo),
        this._splashTextures.logo = null);
        this._splashTextures.powered && (a.DeleteTexture(this._splashTextures.powered),
        this._splashTextures.powered = null);
        this._splashTextures.website && (a.DeleteTexture(this._splashTextures.website),
        this._splashTextures.website = null);
        a.ClearRgba(0, 0, 0, 0);
        a.Finish();
        this._splashState = "done";
        this._gpuTimeStartFrame = a.GetFrameNumber();
        3 === b && this.HideCordovaSplashScreen()
    }
    _DrawLoadingScreen() {
        if (-1 !== this._rafId) {
            var a = this.GetRenderer();
            a.Start();
            this._rafId = -1;
            var b = this._runtime.GetAssetManager().HasHadErrorLoading()
              , c = this._runtime.GetLoaderStyle();
            3 !== c && (this.SetCssTransform(a),
            a.ClearRgba(0, 0, 0, 0),
            a.ResetColor(),
            a.SetTextureFillMode(),
            a.SetTexture(null));
            if (0 === c)
                this._DrawProgressBarAndLogoLoadingScreen(b);
            else if (1 === c)
                this._DrawProgressBarLoadingScreen(b, 120, 0);
            else if (2 === c)
                this._DrawPercentTextLoadingScreen(b);
            else if (3 === c)
                C3$jscomp$200.noop();
            else if (4 === c)
                this._DrawSplashLoadingScreen(b);
            else
                throw Error("invalid loader style");
            a.Finish();
            this._rafId = requestAnimationFrame( () => this._DrawLoadingScreen())
        }
    }
    _DrawPercentTextLoadingScreen(a) {
        a ? this._percentText.SetColorRgb(1, 0, 0) : this._percentText.SetColorRgb(.6, .6, .6);
        this._percentText.SetText(Math.round(100 * this._loadingProgress) + "%");
        a = this._canvasCssWidth / 2;
        const b = this._canvasCssHeight / 2;
        tempQuad$jscomp$5.setRect(a - 150, b - 100, a + 150, b + 100);
        a = this.GetRenderer();
        a.SetTexture(this._percentText.GetTexture());
        a.Quad3(tempQuad$jscomp$5, this._percentText.GetTexRect())
    }
    _DrawProgressBarLoadingScreen(a, b, c) {
        const d = this.GetRenderer();
        d.SetColorFillMode();
        a ? d.SetColorRgba(1, 0, 0, 1) : d.SetColorRgba(.118, .565, 1, 1);
        a = this._canvasCssWidth / 2;
        const e = this._canvasCssHeight / 2
          , f = b / 2;
        tempRect$jscomp$9.setWH(a - f, e - 4 + c, Math.floor(b * this._loadingProgress), 8);
        d.Rect(tempRect$jscomp$9);
        tempRect$jscomp$9.setWH(a - f, e - 4 + c, b, 8);
        tempRect$jscomp$9.offset(-.5, -.5);
        tempRect$jscomp$9.inflate(.5, .5);
        d.SetColorRgba(0, 0, 0, 1);
        d.LineRect2(tempRect$jscomp$9);
        tempRect$jscomp$9.inflate(1, 1);
        d.SetColorRgba(1, 1, 1, 1);
        d.LineRect2(tempRect$jscomp$9)
    }
    _DrawProgressBarAndLogoLoadingScreen(a) {
        const b = this.GetRenderer();
        var c = this._runtime.GetLoadingLogoAsset();
        if (c)
            if (c = c.GetTexture()) {
                var d = c.GetWidth()
                  , e = c.GetHeight()
                  , f = this._canvasCssWidth / 2
                  , h = this._canvasCssHeight / 2
                  , l = d / 2;
                e /= 2;
                tempQuad$jscomp$5.setRect(f - l, h - e, f + l, h + e);
                b.SetTexture(c);
                b.Quad(tempQuad$jscomp$5);
                this._DrawProgressBarLoadingScreen(a, d, e + 16)
            } else
                this._DrawProgressBarLoadingScreen(a, 120, 0);
        else
            this._DrawProgressBarLoadingScreen(a, 120, 0)
    }
    _DrawSplashLoadingScreen(a) {
        const b = this.GetRenderer()
          , c = this._splashTextures.logo
          , d = this._splashTextures.powered
          , e = this._splashTextures.website
          , f = Date.now();
        0 === this._splashFrameNumber && (this._loaderStartTime = f);
        const h = this._runtime.IsPreview() || this._runtime.IsFBInstantAvailable() && !this._runtime.IsCordova()
          , l = h ? 0 : 200
          , m = h ? 0 : 3E3;
        let p = 1;
        "fade-in" === this._splashState ? p = Math.min((f - this._loaderStartTime) / 300, 1) : "fade-out" === this._splashState && (p = Math.max(1 - (f - this._splashFadeOutStartTime) / 300, 0));
        b.SetColorFillMode();
        b.SetColorRgba(.231 * p, .251 * p, .271 * p, p);
        tempRect$jscomp$9.set(0, 0, this._canvasCssWidth, this._canvasCssHeight);
        b.Rect(tempRect$jscomp$9);
        const r = Math.ceil(this._canvasCssWidth)
          , v = Math.ceil(this._canvasCssHeight);
        let x;
        256 < this._canvasCssHeight ? (b.SetColorRgba(.302 * p, .334 * p, .365 * p, p),
        x = Math.max(.005 * v, 2),
        tempRect$jscomp$9.setWH(0, .8 * v - x / 2, r, x),
        b.Rect(tempRect$jscomp$9),
        a ? b.SetColorRgba(p, 0, 0, p) : b.SetColorRgba(.161 * p, .953 * p, .816 * p, p),
        a = r * this._loadingProgress,
        tempRect$jscomp$9.setWH(.5 * r - a / 2, .8 * v - x / 2, a, x),
        b.Rect(tempRect$jscomp$9),
        b.SetColorRgba(p, p, p, p),
        b.SetTextureFillMode(),
        d && (a = 1.5 * C3$jscomp$200.clamp(.22 * v, 105, .6 * r),
        x = a / 8,
        tempRect$jscomp$9.setWH(.5 * r - a / 2, .2 * v - x / 2, a, x),
        b.SetTexture(d),
        b.Rect(tempRect$jscomp$9)),
        c && (x = a = Math.min(.395 * v, .95 * r),
        tempRect$jscomp$9.setWH(.5 * r - a / 2, .485 * v - x / 2, a, x),
        b.SetTexture(c),
        b.Rect(tempRect$jscomp$9)),
        e && (a = 1.5 * C3$jscomp$200.clamp(.22 * v, 105, .6 * r),
        x = a / 8,
        tempRect$jscomp$9.setWH(.5 * r - a / 2, .868 * v - x / 2, a, x),
        b.SetTexture(e),
        b.Rect(tempRect$jscomp$9))) : (b.SetColorRgba(.302 * p, .334 * p, .365 * p, p),
        x = Math.max(.005 * v, 2),
        tempRect$jscomp$9.setWH(0, .85 * v - x / 2, r, x),
        b.Rect(tempRect$jscomp$9),
        a ? b.SetColorRgba(p, 0, 0, p) : b.SetColorRgba(.161 * p, .953 * p, .816 * p, p),
        a = r * this._loadingProgress,
        tempRect$jscomp$9.setWH(.5 * r - a / 2, .85 * v - x / 2, a, x),
        b.Rect(tempRect$jscomp$9),
        b.SetColorRgba(p, p, p, p),
        b.SetTextureFillMode(),
        c && (x = a = .55 * v,
        tempRect$jscomp$9.setWH(.5 * r - a / 2, .45 * v - x / 2, a, x),
        b.SetTexture(c),
        b.Rect(tempRect$jscomp$9)));
        this._splashFrameNumber++;
        "fade-in" === this._splashState && 300 <= f - this._loaderStartTime && 2 <= this._splashFrameNumber && (this._splashState = "wait",
        this._splashFadeInFinishTime = f);
        "wait" === this._splashState && f - this._splashFadeInFinishTime >= m && 1 <= this._loadingProgress && (this._splashState = "fade-out",
        this._splashFadeOutStartTime = f);
        ("fade-out" === this._splashState && f - this._splashFadeOutStartTime >= 300 + l || h && 1 <= this._loadingProgress && 500 > f - this._loaderStartTime) && this._splashDoneResolve()
    }
}
;
"use strict";
const C3$jscomp$201 = self.C3
  , C3Debugger$jscomp$3 = self.C3Debugger
  , DEFAULT_RUNTIME_OPTS = {
    messagePort: null,
    runtimeBaseUrl: "",
    headless: !1,
    hasDom: !0,
    isInWorker: !1,
    useAudio: !0,
    projectData: "",
    exportType: ""
};
let ife = !0;
C3$jscomp$201.Runtime = class extends C3$jscomp$201.DefendedBase {
    constructor(a) {
        a = Object.assign({}, DEFAULT_RUNTIME_OPTS, a);
        super();
        this._messagePort = a.messagePort;
        this._runtimeBaseUrl = a.runtimeBaseUrl;
        this._previewUrl = a.previewUrl;
        this._isHeadless = !!a.headless;
        this._hasDom = !!a.hasDom;
        this._isInWorker = !!a.isInWorker;
        ife = a.ife;
        this._useAudio = !!a.useAudio;
        this._exportType = a.exportType;
        this._isiOSCordova = !!a.isiOSCordova;
        this._isiOSWebView = !!a.isiOSWebView;
        this._isWindowsWebView2 = !!a.isWindowsWebView2;
        this._isAnyWebView2Wrapper = !!a.isAnyWebView2Wrapper;
        this._isFBInstantAvailable = !!a.isFBInstantAvailable;
        this._opusWasmScriptUrl = a.opusWasmScriptUrl;
        this._opusWasmBinaryUrl = a.opusWasmBinaryUrl;
        this._isDebugging = this._breakpointsEnabled = this._isDebug = !("preview" !== this._exportType || !a.isDebug);
        this._debuggingDisabled = 0;
        this._additionalLoadPromises = [];
        this._additionalCreatePromises = [];
        this._isUsingCreatePromises = !1;
        this._appId = this._projectUniqueId = this._projectVersion = this._projectName = "";
        this._originalViewportHeight = this._originalViewportWidth = 0;
        this._devicePixelRatio = self.devicePixelRatio;
        this._loaderStyle = this._viewportHeight = this._viewportWidth = this._parallaxYorigin = this._parallaxXorigin = 0;
        this._usesLoaderLayout = !1;
        this._isLoading = !0;
        this._usesAnyDepthSampling = this._usesAnyCrossSampling = this._usesAnyBackgroundBlending = !1;
        this._loadingLogoAsset = null;
        this._assetManager = C3$jscomp$201.New(C3$jscomp$201.AssetManager, this, a);
        this._layoutManager = C3$jscomp$201.New(C3$jscomp$201.LayoutManager, this);
        this._eventSheetManager = C3$jscomp$201.New(C3$jscomp$201.EventSheetManager, this);
        this._addonManager = C3$jscomp$201.New(C3$jscomp$201.AddonManager, this, a.wrapperComponentIds);
        this._collisionEngine = C3$jscomp$201.New(C3$jscomp$201.CollisionEngine, this);
        this._timelineManager = C3$jscomp$201.New(C3$jscomp$201.TimelineManager, this);
        this._transitionManager = C3$jscomp$201.New(C3$jscomp$201.TransitionManager, this);
        this._templateManager = C3$jscomp$201.New(C3$jscomp$201.TemplateManager, this);
        this._flowchartManager = C3$jscomp$201.New(C3$jscomp$201.FlowchartManager, this);
        this._textIconManager = C3$jscomp$201.New(C3$jscomp$201.TextIconManager, {
            getIconSetMeta: c => this._GetTextIconSetMeta(c),
            getIconSetContent: c => this._GetTextIconSetContent(c)
        });
        this._iconChangeHandlers = new Map;
        this._allObjectClasses = [];
        this._objectClassesByName = new Map;
        this._objectClassesBySid = new Map;
        this._familyCount = 0;
        this._allContainers = [];
        this._allEffectLists = new Set;
        this._currentLayoutStack = [];
        this._instancesPendingCreate = [];
        this._instancesPendingDestroy = new Map;
        this._isFlushingPendingInstances = this._hasPendingInstances = !1;
        this._nextUid = this._objectCount = 0;
        this._instancesByUid = new Map;
        this._instancesPendingRelease = new Set;
        this._instancesPendingReleaseAffectedObjectClasses = new Set;
        this._objectReferenceTable = [];
        this._jsPropNameTable = [];
        this._canvasManager = null;
        this._uses3dFeatures = !1;
        this._framerateMode = "vsync";
        this._sampling = "trilinear";
        this._isPixelRoundingEnabled = !1;
        this._needRender = !0;
        this._isPausedOnBlur = this._pauseOnBlur = !1;
        this._exportToVideo = null;
        this._tickCallbacks = {
            normal: c => {
                this._ruafId = this._rafId = -1;
                this.Tick(c)
            }
            ,
            tickOnly: c => {
                this._ruafId = -1;
                this.Tick(c, !1, "skip-render")
            }
            ,
            renderOnly: () => {
                this._rafId = -1;
                this.Render()
            }
        };
        this._ruafId = this._rafId = -1;
        this._tickCountNoSave = this._tickCount = 0;
        this._hasStartedTicking = this._isInTick = this._hasStarted = !1;
        this._isLayoutFirstTick = !0;
        this._suspendCount = 0;
        this._scheduleTriggersThrottle = new C3$jscomp$201.PromiseThrottle(1);
        this._randomNumberCallback = () => Math.random();
        this._dt = this._dt1 = this._dtRaw = this._lastTickTime = this._startTime = 0;
        this._timeScale = 1;
        this._maxDt = 1 / 30;
        this._minDt = 0;
        this._gameTime = C3$jscomp$201.New(C3$jscomp$201.KahanSum);
        this._gameTimeRaw = C3$jscomp$201.New(C3$jscomp$201.KahanSum);
        this._wallTime = C3$jscomp$201.New(C3$jscomp$201.KahanSum);
        this._instanceTimes = new Map;
        this._fpsFrameCount = -1;
        this._fps = this._fpsLastTime = 0;
        this._tpsTickCount = -1;
        this._mainThreadTime = this._mainThreadTimeCounter = this._tps = 0;
        this._isLoadingState = !1;
        this._loadFromSlotName = this._saveToSlotName = "";
        this._loadFromJson = null;
        this._lastSaveJson = "";
        this._savegamesStorage = this._projectStorage = null;
        this._dispatcher = C3$jscomp$201.New(C3$jscomp$201.Event.Dispatcher);
        this._domEventHandlers = new Map;
        this._pendingResponsePromises = new Map;
        this._nextDomResponseId = 0;
        this._isReadyToHandleEvents = this._didRequestDeviceMotionEvent = this._didRequestDeviceOrientationEvent = !1;
        this._waitingToHandleEvents = [];
        this._eventObjects = {
            pretick: C3$jscomp$201.New(C3$jscomp$201.Event, "pretick", !1),
            tick: C3$jscomp$201.New(C3$jscomp$201.Event, "tick", !1),
            tick2: C3$jscomp$201.New(C3$jscomp$201.Event, "tick2", !1),
            instancedestroy: C3$jscomp$201.New(C3$jscomp$201.Event, "instancedestroy", !1),
            beforelayoutchange: C3$jscomp$201.New(C3$jscomp$201.Event, "beforelayoutchange", !1),
            layoutchange: C3$jscomp$201.New(C3$jscomp$201.Event, "layoutchange", !1)
        };
        this._eventObjects.instancedestroy.instance = null;
        this._userScriptDispatcher = C3$jscomp$201.New(C3$jscomp$201.Event.Dispatcher);
        this._userScriptEventObjects = null;
        const b = (c, d) => C3$jscomp$201.BehaviorInstance.SortByTickSequence(this, c, d);
        this._behInstsToTick = C3$jscomp$201.New(C3$jscomp$201.RedBlackSet, b);
        this._behInstsToPostTick = C3$jscomp$201.New(C3$jscomp$201.RedBlackSet, b);
        this._behInstsToTick2 = C3$jscomp$201.New(C3$jscomp$201.RedBlackSet, b);
        this._jobScheduler = C3$jscomp$201.New(C3$jscomp$201.JobSchedulerRuntime, this, a.jobScheduler);
        a.canvas && (this._canvasManager = C3$jscomp$201.New(C3$jscomp$201.CanvasManager, this));
        this._messagePort.onmessage = c => this._OnMessageFromDOM(c.data);
        this.AddDOMComponentMessageHandler("runtime", "visibilitychange", c => this._OnVisibilityChange(c));
        this.AddDOMComponentMessageHandler("runtime", "wrapper-extension-message", c => this._OnWrapperExtensionMessage(c));
        this.AddDOMComponentMessageHandler("runtime", "opus-decode", c => this._WasmDecodeWebMOpus(c.arrayBuffer));
        this.AddDOMComponentMessageHandler("runtime", "get-remote-preview-status-info", () => this._GetRemotePreviewStatusInfo());
        this.AddDOMComponentMessageHandler("runtime", "js-invoke-function", c => this._InvokeFunctionFromJS(c));
        this.AddDOMComponentMessageHandler("runtime", "go-to-last-error-script", self.goToLastErrorScript);
        this.AddDOMComponentMessageHandler("runtime", "offline-audio-render-completed", c => this._OnOfflineAudioRenderCompleted(c));
        this._dispatcher.addEventListener("window-blur", c => this._OnWindowBlur(c));
        this._dispatcher.addEventListener("window-focus", () => this._OnWindowFocus());
        this._timelineManager.AddRuntimeListeners();
        this._templateManager.AddRuntimeListeners();
        this._iRuntime = null;
        this._interfaceMap = new WeakMap;
        this._commonScriptInterfaces = {
            keyboard: null,
            mouse: null,
            touch: null,
            timelineController: null,
            platformInfo: null
        };
        this._instancesNeedingAfterLoadMap = new WeakMap;
        this._instancesNeedingAfterLoadArray = []
    }
    static Create(a) {
        return C3$jscomp$201.New(C3$jscomp$201.Runtime, a)
    }
    Release() {
        C3$jscomp$201.clearArray(this._allObjectClasses);
        this._objectClassesByName.clear();
        this._objectClassesBySid.clear();
        this._layoutManager.Release();
        this._layoutManager = null;
        this._eventSheetManager.Release();
        this._eventSheetManager = null;
        this._addonManager.Release();
        this._addonManager = null;
        this._assetManager.Release();
        this._assetManager = null;
        this._collisionEngine.Release();
        this._collisionEngine = null;
        this._timelineManager.Release();
        this._timelineManager = null;
        this._transitionManager.Release();
        this._transitionManager = null;
        this._templateManager.Release();
        this._templateManager = null;
        this._flowchartManager.Release();
        this._flowchartManager = null;
        this._textIconManager.Release();
        this._textIconManager = null;
        this._canvasManager && (this._canvasManager.Release(),
        this._canvasManager = null);
        this._dispatcher.Release();
        this._tickEvent = this._dispatcher = null
    }
    _OnMessageFromDOM(a) {
        const b = a.type;
        if ("event" === b)
            this._OnEventFromDOM(a);
        else if ("result" === b)
            this._OnResultFromDOM(a);
        else
            throw Error(`unknown message '${b}'`);
    }
    _OnEventFromDOM(a) {
        if (this._isReadyToHandleEvents) {
            var b = a.component
              , c = a.handler
              , d = a.data
              , e = a.dispatchOpts
              , f = !(!e || !e.dispatchRuntimeEvent);
            e = !(!e || !e.dispatchUserScriptEvent);
            var h = a.responseId;
            if ("runtime" === b && (f && (a = new C3$jscomp$201.Event(c),
            a.data = d,
            this._dispatcher.dispatchEventAndWaitAsyncSequential(a)),
            e)) {
                a = new C3$jscomp$201.Event(c,!0);
                for (const [l,m] of Object.entries(d))
                    a[l] = m;
                this.DispatchUserScriptEvent(a)
            }
            if (a = this._domEventHandlers.get(b))
                if (a = a.get(c)) {
                    f = null;
                    try {
                        f = a(d)
                    } catch (l) {
                        console.error(`Exception in '${b}' handler '${c}':`, l);
                        null !== h && this._PostResultToDOM(h, !1, "" + l);
                        return
                    }
                    null !== h && (f && f.then ? f.then(l => this._PostResultToDOM(h, !0, l)).catch(l => {
                        console.error(`Rejection from '${b}' handler '${c}':`, l);
                        this._PostResultToDOM(h, !1, "" + l)
                    }
                    ) : this._PostResultToDOM(h, !0, f))
                } else
                    f || e || console.warn(`[Runtime] No DOM handler '${c}' for component '${b}'`);
            else
                f || e || console.warn(`[Runtime] No DOM event handlers for component '${b}'`)
        } else
            this._waitingToHandleEvents.push(a)
    }
    _PostResultToDOM(a, b, c) {
        this._messagePort.postMessage({
            type: "result",
            responseId: a,
            isOk: b,
            result: c
        })
    }
    _OnResultFromDOM(a) {
        const b = a.responseId
          , c = a.isOk;
        a = a.result;
        const d = this._pendingResponsePromises.get(b);
        c ? d.resolve(a) : d.reject(a);
        this._pendingResponsePromises.delete(b)
    }
    AddDOMComponentMessageHandler(a, b, c) {
        let d = this._domEventHandlers.get(a);
        d || (d = new Map,
        this._domEventHandlers.set(a, d));
        if (d.has(b))
            throw Error(`[Runtime] Component '${a}' already has handler '${b}'`);
        d.set(b, c)
    }
    PostComponentMessageToDOM(a, b, c, d) {
        this._messagePort.postMessage({
            type: "event",
            component: a,
            handler: b,
            data: c,
            responseId: null
        }, d)
    }
    PostComponentMessageToDOMAsync(a, b, c, d) {
        const e = this._nextDomResponseId++
          , f = new Promise( (h, l) => {
            this._pendingResponsePromises.set(e, {
                resolve: h,
                reject: l
            })
        }
        );
        this._messagePort.postMessage({
            type: "event",
            component: a,
            handler: b,
            data: c,
            responseId: e
        }, d);
        return f
    }
    SendWrapperExtensionMessage(a, b, c, d=-1) {
        this.PostComponentMessageToDOM("runtime", "send-wrapper-extension-message", {
            componentId: a,
            messageId: b,
            params: c,
            asyncId: d
        })
    }
    SendWrapperExtensionMessageAsync(a, b, c) {
        const d = this._nextDomResponseId++
          , e = new Promise( (f, h) => {
            this._pendingResponsePromises.set(d, {
                resolve: f,
                reject: h
            })
        }
        );
        this.SendWrapperExtensionMessage(a, b, c, d);
        return e
    }
    _OnWrapperExtensionMessage(a) {
        if (-1 !== a.asyncId) {
            const b = a.asyncId;
            this._pendingResponsePromises.get(b).resolve(a.params);
            this._pendingResponsePromises.delete(b)
        } else
            this._OnEventFromDOM({
                component: "wrapper-extension:" + a.componentId,
                handler: a.messageId,
                data: a.params,
                responseId: null
            })
    }
    AddWrapperExtensionMessageHandler(a, b, c) {
        this.AddDOMComponentMessageHandler("wrapper-extension:" + a, b, c)
    }
    HasWrapperComponentId(a) {
        return this._addonManager.HasWrapperComponentId(a)
    }
    PostToDebugger(a) {
        if (!this.IsDebug())
            throw Error("not in debug mode");
        this.PostComponentMessageToDOM("runtime", "post-to-debugger", a)
    }
    async Init(a) {
        C3$jscomp$201.CommonACES_SetRuntime(this);
        this.IsDebug() ? await C3Debugger$jscomp$3.Init(this) : self.C3Debugger && self.C3Debugger.InitPreview(this);
        var [b] = await Promise.all([this._assetManager.FetchJson("data.json"), this._MaybeLoadOpusDecoder(), this._jobScheduler.Init()]);
        await this._LoadDataJson(b);
        await this._InitialiseCanvas(a);
        this.IsPreview() || console.info("Made with Construct, the game and app creator :: https://www.construct.net");
        this.GetWebGLRenderer() ? (b = this.GetWebGLRenderer(),
        console.info(`[C3 runtime] Hosted in ${this.IsInWorker() ? "worker" : "DOM"}, rendering with WebGL ${b.GetWebGLVersionNumber()} [${b.GetUnmaskedRenderer()}]`)) : this.GetWebGPURenderer() && console.info(`[C3 runtime] Hosted in ${this.IsInWorker() ? "worker" : "DOM"}, rendering with WebGPU [${this.GetWebGPURenderer().GetAdapterInfoString()}]`);
        this.GetRenderer().HasMajorPerformanceCaveat() && console.warn("[C3 runtime] The renderer indicates a major performance caveat. Software rendering may be in use. This can result in significantly degraded performance.");
        this._isReadyToHandleEvents = !0;
        for (const c of this._waitingToHandleEvents)
            this._OnEventFromDOM(c);
        C3$jscomp$201.clearArray(this._waitingToHandleEvents);
        this._canvasManager && this._canvasManager.StartLoadingScreen();
        for (const c of a.runOnStartupFunctions)
            this._additionalLoadPromises.push(this._RunOnStartupFunction(c));
        await Promise.all([this._assetManager.WaitForAllToLoad(), ...this._additionalLoadPromises]);
        C3$jscomp$201.clearArray(this._additionalLoadPromises);
        if (this._assetManager.HasHadErrorLoading())
            this._canvasManager && this._canvasManager.HideCordovaSplashScreen();
        else
            return this._canvasManager && await this._canvasManager.EndLoadingScreen(),
            await this._dispatcher.dispatchEventAndWaitAsync(new C3$jscomp$201.Event("beforeruntimestart")),
            await this.Start(),
            this._messagePort.postMessage({
                type: "runtime-ready"
            }),
            this
    }
    async _RunOnStartupFunction(a) {
        try {
            await a(this._iRuntime)
        } catch (b) {
            console.error("[C3 runtime] Error in runOnStartup function: ", b)
        }
    }
    async _LoadDataJson(a) {
        a = a.project;
        this._projectName = a[0];
        this._projectVersion = a[16];
        this._projectUniqueId = a[31];
        this._appId = a[38];
        var b = a[39] || "loading-logo.png";
        this._isPixelRoundingEnabled = !!a[9];
        this._originalViewportWidth = this._viewportWidth = a[10];
        this._originalViewportHeight = this._viewportHeight = a[11];
        this._collisionEngine._InitCollisionCellSize(this._originalViewportWidth, this._originalViewportHeight);
        this._parallaxXorigin = this._originalViewportWidth / 2;
        this._parallaxYorigin = this._originalViewportHeight / 2;
        this._framerateMode = a[37];
        this._uses3dFeatures = !!a[40];
        this._sampling = a[14];
        this._usesAnyBackgroundBlending = a[15];
        this._usesAnyCrossSampling = a[42];
        this._usesAnyDepthSampling = a[17];
        this._usesLoaderLayout = !!a[18];
        this._loaderStyle = a[19];
        this._nextUid = a[21];
        this._pauseOnBlur = a[22];
        const c = this._assetManager;
        c._SetFileStructure(a[45]);
        c._SetAudioFiles(a[7], a[25]);
        c._SetMediaSubfolder(a[8]);
        c._SetFontsSubfolder(a[32]);
        c._SetIconsSubfolder(a[28]);
        c._SetWebFonts(a[29]);
        if (0 === this._loaderStyle) {
            let l = "";
            this.IsPreview() ? c._HasLocalUrlBlob(b) && (l = c.GetLocalUrlAsBlobUrl(b)) : l = "flat" === c.GetFileStructure() ? c.GetIconsSubfolder() + b : b;
            l && (this._loadingLogoAsset = c.LoadImage({
                url: l
            }))
        }
        this._canvasManager && (this._canvasManager.SetFullscreenMode(C3$jscomp$201.CanvasManager._FullscreenModeNumberToString(a[12])),
        this._canvasManager.SetFullscreenScalingQuality(a[23] ? "high" : "low"),
        this._canvasManager.SetMipmapsEnabled(0 !== a[24]),
        this._canvasManager._SetGPUPowerPreference(a[34]),
        this._canvasManager._SetTextureAnisotropy(a[41]),
        this._canvasManager._SetWebGPUEnabled(a[13]),
        this._canvasManager._SetZAxisScale(a[30]),
        this._canvasManager._SetZDistances(a[46], a[47]),
        this._canvasManager._SetInitFieldOfView(a[26]),
        this._canvasManager._SetLimitedToWebGL1(a[48]));
        (b = a[43]) && await this._LoadExportToVideoData(b);
        this._InitScriptInterfaces();
        this._addonManager.CreateSystemPlugin();
        this._objectReferenceTable = self.C3_GetObjectRefTable();
        b = a[2];
        for (var d of b[1])
            this._addonManager.CreateBehavior(d);
        for (const l of b[0])
            this._addonManager.CreatePlugin(l);
        this._objectReferenceTable = self.C3_GetObjectRefTable();
        this._LoadJsPropNameTable();
        this._addonManager._InitAddonScriptInterfaces();
        for (var e of a[3])
            d = C3$jscomp$201.ObjectClass.Create(this, this._allObjectClasses.length, e),
            this._allObjectClasses.push(d),
            this._objectClassesByName.set(d.GetName().toLowerCase(), d),
            this._objectClassesBySid.set(d.GetSID(), d);
        for (const l of a[4])
            this._allObjectClasses[l[0]]._LoadFamily(l);
        for (var f of a[27])
            e = f.map(l => this._allObjectClasses[l]),
            this._allContainers.push(C3$jscomp$201.New(C3$jscomp$201.Container, this, e));
        this._InitObjectsScriptInterface();
        for (const l of this._allObjectClasses)
            l._OnAfterCreate();
        for (const l of a[5])
            this._layoutManager.Create(l);
        (f = a[1]) && (f = this._layoutManager.GetLayoutByName(f)) && this._layoutManager.SetFirstLayout(f);
        for (var h of a[35])
            this._transitionManager.Create(h);
        for (const l of a[33])
            this._timelineManager.Create(l);
        for (const l of a[44])
            this._templateManager.Create(l);
        this._templateManager.HasTemplates() || (this._templateManager.Release(),
        this._templateManager = null);
        for (const l of a[49])
            this._flowchartManager.Create(l);
        this._flowchartManager.HasFlowcharts() || (this._flowchartManager.Release(),
        this._flowchartManager = null);
        for (const l of a[6])
            this._eventSheetManager.Create(l);
        this._eventSheetManager._PostInit();
        this._InitGlobalVariableScriptInterface();
        C3$jscomp$201.clearArray(this._objectReferenceTable);
        this.FlushPendingInstances();
        h = "any";
        a = a[20];
        1 === a ? h = "portrait" : 2 === a && (h = "landscape");
        this.PostComponentMessageToDOM("runtime", "set-target-orientation", {
            targetOrientation: h
        })
    }
    async _LoadExportToVideoData(a) {
        const b = a.format;
        "image-sequence" === b ? this._exportToVideo = new self.C3ExportToImageSequence(this,a) : "image-sequence-gif" === b ? this._exportToVideo = new self.C3ExportToGIF(this,a) : "webm" === b ? this._exportToVideo = new self.C3ExportToWebMVideo(this,a) : "mp4" === b && (this._exportToVideo = new self.C3ExportToMP4Video(this,a));
        this._framerateMode = "unlimited-frame";
        this._canvasManager.SetFullscreenMode("off");
        this._devicePixelRatio = 1;
        self.devicePixelRatio = 1;
        await this.PostComponentMessageToDOMAsync("runtime", "set-exporting-to-video", {
            message: this._exportToVideo.GetExportingMessageForPercent(0),
            duration: this._exportToVideo.GetDuration()
        })
    }
    GetLoaderStyle() {
        return this._loaderStyle
    }
    IsExportToVideo() {
        return null !== this._exportToVideo
    }
    GetExportVideoDuration() {
        return this._exportToVideo.GetDuration()
    }
    GetExportVideoFramerate() {
        return this._exportToVideo.GetFramerate()
    }
    _InitExportToVideo() {
        return this._exportToVideo.Init({
            width: this._canvasManager.GetDeviceWidth(),
            height: this._canvasManager.GetDeviceHeight()
        })
    }
    _ExportToVideoAddFrame() {
        const a = this._tickCount / this.GetExportVideoFramerate();
        return this._exportToVideo.AddFrame(this._canvasManager.GetMainCanvas(), a)
    }
    _ExportToVideoAddKeyframe() {
        this._exportToVideo && this._exportToVideo.AddKeyframe()
    }
    _OnOfflineAudioRenderCompleted(a) {
        this._exportToVideo.OnOfflineAudioRenderCompleted(a)
    }
    _ExportToVideoFinish() {
        return this._exportToVideo.Finish()
    }
    IsFBInstantAvailable() {
        return this._isFBInstantAvailable
    }
    IsLoading() {
        return this._isLoading
    }
    AddLoadPromise(a) {
        this._additionalLoadPromises.push(a)
    }
    SetUsingCreatePromises(a) {
        this._isUsingCreatePromises = !!a
    }
    AddCreatePromise(a) {
        this._isUsingCreatePromises && this._additionalCreatePromises.push(a)
    }
    GetCreatePromises() {
        return this._additionalCreatePromises
    }
    _GetNextFamilyIndex() {
        return this._familyCount++
    }
    GetFamilyCount() {
        return this._familyCount
    }
    _AddEffectList(a) {
        this._allEffectLists.add(a)
    }
    _RemoveEffectList(a) {
        this._allEffectLists.delete(a)
    }
    _GetAllEffectLists() {
        return this._allEffectLists
    }
    async _InitialiseCanvas(a) {
        this._canvasManager && (await this._canvasManager.CreateCanvas(a),
        this._canvasManager.InitLoadingScreen(this._loaderStyle))
    }
    async _MaybeLoadOpusDecoder() {
        if (!this._assetManager.IsAudioFormatSupported("audio/webm; codecs=opus")) {
            var a = null;
            try {
                a = this.IsiOSCordova() && this._assetManager.IsFileProtocol() ? await this._assetManager.CordovaFetchLocalFileAsArrayBuffer(this._opusWasmBinaryUrl) : await this._assetManager.FetchArrayBuffer(this._opusWasmBinaryUrl)
            } catch (b) {
                console.info("Failed to fetch Opus decoder WASM; assuming project has no Opus audio.", b);
                return
            }
            a ? this.AddJobWorkerBuffer(a, "opus-decoder-wasm") : this.AddJobWorkerBlob(null, "opus-decoder-wasm");
            await this.AddJobWorkerScripts([this._opusWasmScriptUrl])
        }
    }
    async _WasmDecodeWebMOpus(a) {
        return await this.AddJob("OpusDecode", {
            arrayBuffer: a
        }, [a])
    }
    async Start() {
        this._hasStarted = !0;
        this._startTime = Date.now();
        let a = null;
        const b = new Promise(d => a = d);
        if (this._usesLoaderLayout) {
            for (var c of this._allObjectClasses)
                c.IsFamily() || c.IsOnLoaderLayout() || !c.IsWorldType() || c.OnCreate();
            (async () => {
                await this._assetManager.WaitForAllToLoad();
                await b;
                this._isLoading = !1;
                this._OnLoadFinished()
            }
            )()
        } else
            this._isLoading = !1;
        this._assetManager.SetInitialLoadFinished();
        this.IsDebug() && C3Debugger$jscomp$3.RuntimeInit(ife);
        for (const d of this._layoutManager.GetAllLayouts())
            d._CreateGlobalNonWorlds();
        this.IsExportToVideo() && await this._InitExportToVideo();
        c = this._layoutManager.GetFirstLayout();
        await c._Load(null, this.GetRenderer());
        await c._StartRunning(!0);
        this._fpsLastTime = performance.now();
        a();
        this._usesLoaderLayout || this._OnLoadFinished();
        (await this.PostComponentMessageToDOMAsync("runtime", "before-start-ticking")).isSuspended && !this.IsExportToVideo() ? this._suspendCount++ : this.Tick()
    }
    _OnLoadFinished() {
        this.Trigger(C3$jscomp$201.Plugins.System.Cnds.OnLoadFinished, null, null);
        this.PostComponentMessageToDOM("runtime", "register-sw")
    }
    GetObjectReference(a) {
        a = Math.floor(a);
        const b = this._objectReferenceTable;
        if (0 > a || a >= b.length)
            throw Error("invalid object reference");
        return b[a]
    }
    _LoadJsPropNameTable() {
        for (const a of self.C3_JsPropNameTable) {
            const b = C3$jscomp$201.first(Object.keys(a));
            this._jsPropNameTable.push(b)
        }
    }
    GetJsPropName(a) {
        a = Math.floor(a);
        const b = this._jsPropNameTable;
        if (0 > a || a >= b.length)
            throw Error("invalid prop reference");
        return b[a]
    }
    HasDOM() {
        return this._hasDom
    }
    IsHeadless() {
        return this._isHeadless
    }
    IsInWorker() {
        return this._isInWorker
    }
    GetRuntimeBaseURL() {
        return this._runtimeBaseUrl
    }
    GetPreviewURL() {
        return this._previewUrl
    }
    GetEventSheetManager() {
        return this._eventSheetManager
    }
    GetEventStack() {
        return this._eventSheetManager.GetEventStack()
    }
    GetCurrentEventStackFrame() {
        return this._eventSheetManager.GetCurrentEventStackFrame()
    }
    GetCurrentEvent() {
        return this._eventSheetManager.GetCurrentEvent()
    }
    GetCurrentCondition() {
        return this._eventSheetManager.GetCurrentCondition()
    }
    IsCurrentConditionFirst() {
        return 0 === this.GetCurrentEventStackFrame().GetConditionIndex()
    }
    GetCurrentAction() {
        return this._eventSheetManager.GetCurrentAction()
    }
    GetAddonManager() {
        return this._addonManager
    }
    GetSystemPlugin() {
        return this._addonManager.GetSystemPlugin()
    }
    GetObjectClassByIndex(a) {
        a = Math.floor(a);
        if (0 > a || a >= this._allObjectClasses.length)
            throw new RangeError("invalid index");
        return this._allObjectClasses[a]
    }
    GetObjectClassByName(a) {
        return this._objectClassesByName.get(a.toLowerCase()) || null
    }
    GetObjectClassBySID(a) {
        return this._objectClassesBySid.get(a) || null
    }
    GetSingleGlobalObjectClassByCtor(a) {
        return (a = C3$jscomp$201.AddonManager.GetPluginByConstructorFunction(a)) ? a.GetSingleGlobalObjectClass() : null
    }
    GetAllObjectClasses() {
        return this._allObjectClasses
    }
    *allInstances() {
        for (const a of this._allObjectClasses)
            a.IsFamily() || (yield*a.instances())
    }
    Dispatcher() {
        return this._dispatcher
    }
    UserScriptDispatcher() {
        return this._userScriptDispatcher
    }
    DispatchUserScriptEvent(a) {
        a.runtime = this.GetIRuntime();
        const b = this.IsDebug() && !this._eventSheetManager.IsInEventEngine();
        b && C3Debugger$jscomp$3.StartMeasuringScriptTime();
        this._userScriptDispatcher.dispatchEvent(a);
        b && C3Debugger$jscomp$3.AddScriptTime()
    }
    DispatchUserScriptEventAsyncWait(a) {
        a.runtime = this.GetIRuntime();
        return this._userScriptDispatcher.dispatchEventAndWaitAsync(a)
    }
    GetOriginalViewportWidth() {
        return this._originalViewportWidth
    }
    GetOriginalViewportHeight() {
        return this._originalViewportHeight
    }
    SetOriginalViewportSize(a, b) {
        if (this._originalViewportWidth !== a || this._originalViewportHeight !== b)
            this._originalViewportWidth = a,
            this._originalViewportHeight = b,
            a = this.GetLayoutManager(),
            a.SetAllLayerProjectionChanged(),
            a.SetAllLayerMVChanged()
    }
    GetViewportWidth() {
        return this._viewportWidth
    }
    GetViewportHeight() {
        return this._viewportHeight
    }
    SetViewportSize(a, b) {
        if (this._viewportWidth !== a || this._viewportHeight !== b)
            this._viewportWidth = a,
            this._viewportHeight = b,
            a = this.GetLayoutManager(),
            a.SetAllLayerProjectionChanged(),
            a.SetAllLayerMVChanged()
    }
    _SetDevicePixelRatio(a) {
        this.IsExportToVideo() || (this._devicePixelRatio = a)
    }
    GetDevicePixelRatio() {
        return this._devicePixelRatio
    }
    GetParallaxXOrigin() {
        return this._parallaxXorigin
    }
    GetParallaxYOrigin() {
        return this._parallaxYorigin
    }
    GetCanvasManager() {
        return this._canvasManager
    }
    GetDrawWidth() {
        return this._canvasManager ? this._canvasManager.GetDrawWidth() : this._viewportWidth
    }
    GetDrawHeight() {
        return this._canvasManager ? this._canvasManager.GetDrawHeight() : this._viewportHeight
    }
    GetRenderScale() {
        return this._canvasManager ? this._canvasManager.GetRenderScale() : 1
    }
    GetDisplayScale() {
        return this._canvasManager ? this._canvasManager.GetDisplayScale() : 1
    }
    GetEffectLayerScaleParam() {
        return this._canvasManager ? this._canvasManager.GetEffectLayerScaleParam() : 1
    }
    GetEffectDevicePixelRatioParam() {
        return this._canvasManager ? this._canvasManager.GetEffectDevicePixelRatioParam() : 1
    }
    GetCanvasClientX() {
        return this._canvasManager ? this._canvasManager.GetCanvasClientX() : 0
    }
    GetCanvasClientY() {
        return this._canvasManager ? this._canvasManager.GetCanvasClientY() : 0
    }
    GetCanvasCssWidth() {
        return this._canvasManager ? this._canvasManager.GetCssWidth() : 0
    }
    GetCanvasCssHeight() {
        return this._canvasManager ? this._canvasManager.GetCssHeight() : 0
    }
    GetFullscreenMode() {
        return this._canvasManager ? this._canvasManager.GetFullscreenMode() : "off"
    }
    GetAdditionalRenderTarget(a) {
        return this._canvasManager ? this._canvasManager.GetAdditionalRenderTarget(a) : null
    }
    ReleaseAdditionalRenderTarget(a) {
        this._canvasManager && this._canvasManager.ReleaseAdditionalRenderTarget(a)
    }
    UsesAnyBackgroundBlending() {
        return this._usesAnyBackgroundBlending
    }
    UsesAnyCrossSampling() {
        return this._usesAnyCrossSampling
    }
    UsesAnyDepthSampling() {
        return this._usesAnyDepthSampling
    }
    GetGPUUtilisation() {
        return this._canvasManager ? this._canvasManager.GetGPUUtilisation() : NaN
    }
    IsLinearSampling() {
        return "nearest" !== this.GetSampling()
    }
    GetFramerateMode() {
        return this._framerateMode
    }
    _SetFramerateMode(a) {
        this._framerateMode !== a && (this._framerateMode = a,
        -1 !== this._rafId || -1 !== this._ruafId) && (this._CancelAnimationFrame(),
        this._RequestAnimationFrame())
    }
    GetSampling() {
        return this._sampling
    }
    UsesLoaderLayout() {
        return this._usesLoaderLayout
    }
    GetLoadingLogoAsset() {
        return this._loadingLogoAsset
    }
    ReleaseLoadingLogoAsset() {
        this._loadingLogoAsset && (this._loadingLogoAsset.ReleaseTexture(),
        this._loadingLogoAsset.Release(),
        this._loadingLogoAsset = null)
    }
    GetLayoutManager() {
        return this._layoutManager
    }
    GetMainRunningLayout() {
        return this._layoutManager.GetMainRunningLayout()
    }
    GetTimelineManager() {
        return this._timelineManager
    }
    GetTransitionManager() {
        return this._transitionManager
    }
    GetTemplateManager() {
        return this._templateManager
    }
    GetFlowchartManager() {
        return this._flowchartManager
    }
    GetAssetManager() {
        return this._assetManager
    }
    LoadImage(a) {
        return this._assetManager.LoadImage(a)
    }
    CreateInstance(a, b, c, d, e, f) {
        if (f && this._templateManager) {
            const h = this._templateManager.GetTemplateData(a, f);
            if (h)
                return a = this.CreateInstanceFromData(h, b, !1, c, d, !1, e, void 0, e),
                this._templateManager.MapInstanceToTemplateName(a, f),
                a
        }
        return this.CreateInstanceFromData(a, b, !1, c, d, !1, e, void 0, e)
    }
    CreateInstanceFromData(a, b, c, d, e, f, h, l, m) {
        var p = null;
        let r = null;
        if (a instanceof C3$jscomp$201.ObjectClass) {
            r = a;
            if (r.IsFamily()) {
                a = r.GetFamilyMembers();
                var v = Math.floor(this.Random() * a.length);
                r = a[v]
            }
            p = r.GetDefaultInstanceData()
        } else
            p = a,
            r = this.GetObjectClassByIndex(p[1]);
        var x = r.GetPlugin().IsWorldType();
        if (this._isLoading && x && !r.IsOnLoaderLayout())
            return null;
        const B = b;
        x || (b = null);
        var A = c && !f && p && !this._instancesByUid.has(p[2]) ? p[2] : this._nextUid++;
        v = p ? p[0] : null;
        a = C3$jscomp$201.New(C3$jscomp$201.Instance, {
            runtime: this,
            objectType: r,
            layer: b,
            worldData: v,
            instVarData: p ? p[3] : null,
            uid: A
        });
        this._instancesByUid.set(A, a);
        A = null;
        x && (A = a.GetWorldInfo(),
        "undefined" !== typeof d && "undefined" !== typeof e && (A.SetX(d),
        A.SetY(e)),
        r._SetAnyCollisionCellChanged(!0));
        b && (m || b._AddInstance(a, !0),
        1 === b.GetParallaxX() && 1 === b.GetParallaxY() || r._SetAnyInstanceParallaxed(!0),
        b.GetLayout().MaybeLoadTexturesFor(r));
        this._objectCount++;
        let D = !0;
        if (l) {
            var F = l.GetObjectClass();
            F.IsInContainer() && r.IsInContainer() && (l = r.GetContainer(),
            F = F.GetContainer(),
            l === F && (D = !1))
        }
        if (r.IsInContainer() && !c && !f && D) {
            for (var I of r.GetContainer().objectTypes())
                I !== r && (l = this.CreateInstanceFromData(I, B, !1, A ? A.GetX() : d, A ? A.GetY() : e, !0, !1, void 0, m),
                a._AddSibling(l));
            for (var K of a.siblings()) {
                K._AddSibling(a);
                for (const M of a.siblings())
                    K !== M && K._AddSibling(M)
            }
        }
        x && !c && h && this._CreateChildInstancesFromData(a, v, A, b, d, e, m);
        if (r.IsInContainer() && !c && !f && h)
            for (const M of a.siblings())
                if (c = M.GetWorldInfo())
                    I = M.GetPlugin(),
                    K = M.GetObjectClass().GetDefaultInstanceData()[0],
                    I.IsWorldType() ? this._CreateChildInstancesFromData(M, K, c, b, c.GetX(), c.GetY(), m) : this._CreateChildInstancesFromData(M, K, c, b, void 0, void 0, m);
        !f && h && ("undefined" === typeof d && (d = v[0]),
        "undefined" === typeof e && (e = v[1]),
        b = A.GetTopParent(),
        d = d - A.GetX() + b.GetX(),
        e = e - A.GetY() + b.GetY(),
        b.SetXY(d, e));
        r._SetIIDsStale();
        e = p ? C3$jscomp$201.cloneArray(p[5]) : null;
        p = p ? p[4].map(M => C3$jscomp$201.cloneArray(M)) : null;
        (x = x && v && v[13]) && a._SetHasTilemap();
        a._CreateSdkInstance(e, p);
        x && (v = v[13],
        a.GetSdkInstance().LoadTilemapData(v[2], v[0], v[1]));
        this._instancesPendingCreate.push(a);
        this._hasPendingInstances = !0;
        this.IsDebug() && C3Debugger$jscomp$3.InstanceCreated(a);
        return a
    }
    _CreateChildInstancesFromData(a, b, c, d, e, f, h) {
        var l = c.GetSceneGraphZIndexExportData()
          , m = c.GetSceneGraphChildrenExportData();
        a.GetWorldInfo().SetSceneGraphZIndex(l);
        if (m) {
            "undefined" === typeof e && (e = b[0]);
            "undefined" === typeof f && (f = b[1]);
            l = new Set;
            c = b[0];
            b = b[1];
            for (const A of m) {
                var p = A[0]
                  , r = A[1]
                  , v = A[2];
                m = A[3];
                var x = !!A[4];
                const D = A[5];
                var B = A[6];
                r = B ? B : this._layoutManager.GetLayoutBySID(p).GetLayer(r).GetInitialInstanceData(v);
                p = this.GetObjectClassByIndex(r[1]);
                v = a.HasSibling(p);
                B = l.has(p);
                v && !B && x ? (x = a.GetSibling(p),
                x.GetWorldInfo().Init(r[0]),
                v = e + r[0][0] - c,
                r = f + r[0][1] - b,
                x.GetWorldInfo().SetXY(v, r),
                x.GetWorldInfo().SetSceneGraphZIndex(D),
                a.AddChild(x, {
                    transformX: !!(m >> 0 & 1),
                    transformY: !!(m >> 1 & 1),
                    transformWidth: !!(m >> 2 & 1),
                    transformHeight: !!(m >> 3 & 1),
                    transformAngle: !!(m >> 4 & 1),
                    destroyWithParent: !!(m >> 5 & 1),
                    transformZElevation: !!(m >> 6 & 1),
                    transformOpacity: !!(m >> 7 & 1),
                    transformVisibility: !!(m >> 8 & 1)
                }),
                l.add(p)) : (x = this.CreateInstanceFromData(r, d, !1, e + r[0][0] - c, f + r[0][1] - b, !1, !0, a, h),
                x.GetWorldInfo().SetSceneGraphZIndex(D),
                a.AddChild(x, {
                    transformX: !!(m >> 0 & 1),
                    transformY: !!(m >> 1 & 1),
                    transformWidth: !!(m >> 2 & 1),
                    transformHeight: !!(m >> 3 & 1),
                    transformAngle: !!(m >> 4 & 1),
                    destroyWithParent: !!(m >> 5 & 1),
                    transformZElevation: !!(m >> 6 & 1),
                    transformOpacity: !!(m >> 7 & 1),
                    transformVisibility: !!(m >> 8 & 1)
                }))
            }
        }
    }
    DestroyInstance(a) {
        if (!this._instancesPendingRelease.has(a)) {
            var b = a.GetObjectClass()
              , c = this._instancesPendingDestroy.get(b);
            if (c) {
                if (c.has(a))
                    return;
                c.add(a)
            } else
                c = new Set,
                c.add(a),
                this._instancesPendingDestroy.set(b, c);
            this.IsDebug() && C3Debugger$jscomp$3.InstanceDestroyed(a);
            a._MarkDestroyed();
            this._hasPendingInstances = !0;
            if (a.IsInContainer())
                for (const d of a.siblings())
                    this.DestroyInstance(d);
            for (const d of a.children())
                d.GetDestroyWithParent() && this.DestroyInstance(d);
            this._layoutManager.IsEndingLayout() || this._isLoadingState || (b = this.GetEventSheetManager(),
            b.BlockFlushingInstances(!0),
            a._TriggerOnDestroyed(),
            b.BlockFlushingInstances(!1));
            a._FireDestroyedScriptEvents(this._layoutManager.IsEndingLayout())
        }
    }
    FlushPendingInstances() {
        this._hasPendingInstances && (this._isFlushingPendingInstances = !0,
        this._FlushInstancesPendingCreate(),
        this._FlushInstancesPendingDestroy(),
        this._hasPendingInstances = this._isFlushingPendingInstances = !1,
        this.UpdateRender())
    }
    _FlushInstancesPendingCreate() {
        for (const a of this._instancesPendingCreate) {
            const b = a.GetObjectClass();
            b._AddInstance(a);
            for (const c of b.GetFamilies())
                c._AddInstance(a),
                c._SetIIDsStale()
        }
        C3$jscomp$201.clearArray(this._instancesPendingCreate)
    }
    _FlushInstancesPendingDestroy() {
        this._dispatcher.SetDelayRemoveEventsEnabled(!0);
        for (const [a,b] of this._instancesPendingDestroy.entries())
            this._FlushInstancesPendingDestroyForObjectClass(a, b),
            b.clear();
        this._instancesPendingDestroy.clear();
        this._dispatcher.SetDelayRemoveEventsEnabled(!1)
    }
    _FlushInstancesPendingDestroyForObjectClass(a, b) {
        for (const d of b) {
            var c = this._eventObjects.instancedestroy;
            c.instance = d;
            this._dispatcher.dispatchEvent(c);
            this._instancesByUid.delete(d.GetUID());
            this._instanceTimes.delete(d);
            if (c = d.GetWorldInfo())
                c._RemoveFromCollisionCells(),
                c._RemoveFromRenderCells(),
                c._MarkDestroyed();
            this._instancesPendingRelease.add(d);
            this._objectCount--
        }
        C3$jscomp$201.arrayRemoveAllInSet(a.GetInstances(), b);
        a._SetIIDsStale();
        this._instancesPendingReleaseAffectedObjectClasses.add(a);
        0 === a.GetInstances().length && a._SetAnyInstanceParallaxed(!1);
        for (const d of a.GetFamilies())
            C3$jscomp$201.arrayRemoveAllInSet(d.GetInstances(), b),
            d._SetIIDsStale(),
            this._instancesPendingReleaseAffectedObjectClasses.add(d);
        if (a.GetPlugin().IsWorldType()) {
            a = new Set([...b].map(d => d.GetWorldInfo().GetLayer()));
            for (const d of a)
                d._RemoveAllInstancesInSet(b)
        }
    }
    _GetInstancesPendingCreate() {
        return this._instancesPendingCreate
    }
    *instancesPendingCreateForObjectClass(a) {
        for (const b of this._GetInstancesPendingCreate())
            a.IsFamily() ? b.GetObjectClass().BelongsToFamily(a) && (yield b) : b.GetObjectClass() === a && (yield b)
    }
    _GetNewUID() {
        return this._nextUid++
    }
    _MapInstanceByUID(a, b) {
        this._instancesByUid.set(a, b)
    }
    _OnRendererContextLost() {
        this._dispatcher.dispatchEvent(C3$jscomp$201.New(C3$jscomp$201.Event, "renderercontextlost"));
        this.SetSuspended(!0);
        for (var a of this._allObjectClasses)
            !a.IsFamily() && a.HasLoadedTextures() && a.ReleaseTextures();
        (a = this.GetMainRunningLayout()) && a._OnRendererContextLost();
        C3$jscomp$201.ImageInfo.OnRendererContextLost();
        C3$jscomp$201.ImageAsset.OnRendererContextLost()
    }
    async _OnRendererContextRestored() {
        await this.GetMainRunningLayout()._Load(null, this.GetRenderer());
        this._dispatcher.dispatchEvent(C3$jscomp$201.New(C3$jscomp$201.Event, "renderercontextrestored"));
        this.SetSuspended(!1);
        this.UpdateRender()
    }
    _OnVisibilityChange(a) {
        a = a.hidden;
        this.SetSuspended(a);
        a || this.UpdateRender()
    }
    _OnWindowBlur(a) {
        this.IsPreview() && this._pauseOnBlur && !C3$jscomp$201.Platform.IsMobile && !a.data.parentHasFocus && (this.SetSuspended(!0),
        this._isPausedOnBlur = !0)
    }
    _OnWindowFocus() {
        this._isPausedOnBlur && (this.SetSuspended(!1),
        this._isPausedOnBlur = !1)
    }
    _RequestAnimationFrame() {
        const a = this._tickCallbacks;
        "vsync" === this._framerateMode ? -1 === this._rafId && (this._rafId = self.requestAnimationFrame(a.normal)) : "unlimited-tick" === this._framerateMode ? (-1 === this._ruafId && (this._ruafId = C3$jscomp$201.RequestUnlimitedAnimationFrame(a.tickOnly)),
        -1 === this._rafId && (this._rafId = self.requestAnimationFrame(a.renderOnly))) : -1 === this._ruafId && (this._ruafId = C3$jscomp$201.RequestUnlimitedAnimationFrame(a.normal))
    }
    _CancelAnimationFrame() {
        -1 !== this._rafId && (self.cancelAnimationFrame(this._rafId),
        this._rafId = -1);
        -1 !== this._ruafId && (C3$jscomp$201.CancelUnlimitedAnimationFrame(this._ruafId),
        this._ruafId = -1)
    }
    IsSuspended() {
        return 0 < this._suspendCount
    }
    SetSuspended(a) {
        if (!this.IsExportToVideo()) {
            var b = this.IsSuspended();
            this._suspendCount += a ? 1 : -1;
            0 > this._suspendCount && (this._suspendCount = 0);
            a = this.IsSuspended();
            !b && a ? (console.log("[Construct] Suspending"),
            this._CancelAnimationFrame(),
            this._dispatcher.dispatchEvent(C3$jscomp$201.New(C3$jscomp$201.Event, "suspend")),
            this.Trigger(C3$jscomp$201.Plugins.System.Cnds.OnSuspend, null, null)) : b && !a && (console.log("[Construct] Resuming"),
            this._fpsLastTime = this._lastTickTime = b = performance.now(),
            this._mainThreadTimeCounter = this._mainThreadTime = this._tps = this._tpsTickCount = this._fps = this._fpsFrameCount = 0,
            this._dispatcher.dispatchEvent(C3$jscomp$201.New(C3$jscomp$201.Event, "resume")),
            this.Trigger(C3$jscomp$201.Plugins.System.Cnds.OnResume, null, null),
            this.HitBreakpoint() || this.Tick(b))
        }
    }
    _AddBehInstToTick(a) {
        this._behInstsToTick.Add(a)
    }
    _AddBehInstToPostTick(a) {
        this._behInstsToPostTick.Add(a)
    }
    _AddBehInstToTick2(a) {
        this._behInstsToTick2.Add(a)
    }
    _RemoveBehInstToTick(a) {
        this._behInstsToTick.Remove(a)
    }
    _RemoveBehInstToPostTick(a) {
        this._behInstsToPostTick.Remove(a)
    }
    _RemoveBehInstToTick2(a) {
        this._behInstsToTick2.Remove(a)
    }
    _BehaviorTick() {
        const a = globalThis.ISDKBehaviorInstanceBase;
        this._behInstsToTick.SetQueueingEnabled(!0);
        for (const b of this._behInstsToTick)
            b instanceof a ? b._tick() : b.Tick();
        this._behInstsToTick.SetQueueingEnabled(!1)
    }
    _BehaviorPostTick() {
        const a = globalThis.ISDKBehaviorInstanceBase;
        this._behInstsToPostTick.SetQueueingEnabled(!0);
        for (const b of this._behInstsToPostTick)
            b instanceof a ? b._postTick() : b.PostTick();
        this._behInstsToPostTick.SetQueueingEnabled(!1)
    }
    _BehaviorTick2() {
        const a = globalThis.ISDKBehaviorInstanceBase;
        this._behInstsToTick2.SetQueueingEnabled(!0);
        for (const b of this._behInstsToTick2)
            b instanceof a ? b._tick2() : b.Tick2();
        this._behInstsToTick2.SetQueueingEnabled(!1)
    }
    *_DebugBehaviorTick() {
        const a = globalThis.ISDKBehaviorInstanceBase;
        this._behInstsToTick.SetQueueingEnabled(!0);
        for (const b of this._behInstsToTick) {
            let c;
            c = b instanceof a ? b._tick() : b.Tick();
            C3$jscomp$201.IsIterator(c) && (yield*c)
        }
        this._behInstsToTick.SetQueueingEnabled(!1)
    }
    *_DebugBehaviorPostTick() {
        const a = globalThis.ISDKBehaviorInstanceBase;
        this._behInstsToPostTick.SetQueueingEnabled(!0);
        for (const b of this._behInstsToPostTick) {
            let c;
            c = b instanceof a ? b._postTick() : b.PostTick();
            C3$jscomp$201.IsIterator(c) && (yield*c)
        }
        this._behInstsToPostTick.SetQueueingEnabled(!1)
    }
    *_DebugBehaviorTick2() {
        const a = globalThis.ISDKBehaviorInstanceBase;
        this._behInstsToTick2.SetQueueingEnabled(!0);
        for (const b of this._behInstsToTick2) {
            let c;
            c = b instanceof a ? b._tick2() : b.Tick2();
            C3$jscomp$201.IsIterator(c) && (yield*c)
        }
        this._behInstsToTick2.SetQueueingEnabled(!1)
    }
    async Tick(a, b, c) {
        this._hasStartedTicking = !0;
        const d = "background-wake" === c;
        c = "background-wake" !== c && "skip-render" !== c;
        var e = this.GetLayoutManager()
          , f = this.GetCanvasManager();
        if (this._hasStarted && (!this.IsSuspended() || b || d)) {
            b = performance.now();
            this._isInTick = !0;
            this._MeasureDt(a || 0);
            this._tpsTickCount++;
            this._ReleasePendingInstances();
            a = this.Step_BeforePreTick();
            this.IsDebugging() && await a;
            a = this._dispatcher.dispatchEventAndWait_AsyncOptional(this._eventObjects.pretick);
            a instanceof Promise && await a;
            a = this.Step_AfterPreTick();
            this.IsDebugging() && await a;
            this._NeedsHandleSaveOrLoad() && await this._HandleSaveOrLoad();
            e.IsPendingChangeMainLayout() && await this._MaybeChangeLayout();
            a = this.Step_RunEventsEtc();
            this.IsDebugging() && await a;
            a = e.GetMainRunningLayout();
            var h = a._GetPendingSetHTMLLayerCount();
            e = !1;
            -1 !== h && (a._ResetPendingHTMLLayerCount(),
            f.GetHTMLLayerCount() !== h && (f = this.GetCanvasManager().SetHTMLLayerCount(h),
            this.IsInWorker() && (e = !0,
            await f)));
            c && this.Render();
            e && this.PostComponentMessageToDOM("canvas", "cleanup-html-layers");
            if (this.IsExportToVideo() && (await this._ExportToVideoAddFrame(),
            this.GetGameTime() >= this.GetExportVideoDuration())) {
                this._ExportToVideoFinish();
                return
            }
            this.IsSuspended() || d || this._RequestAnimationFrame();
            this._tickCount++;
            this._tickCountNoSave++;
            this._isInTick = !1;
            this._mainThreadTimeCounter += performance.now() - b
        }
    }
    async Step_BeforePreTick() {
        const a = this._eventSheetManager
          , b = this.IsDebug();
        this.FlushPendingInstances();
        a.BlockFlushingInstances(!0);
        this.PushCurrentLayout(this.GetMainRunningLayout());
        b && C3Debugger$jscomp$3.StartMeasuringTime();
        this.IsDebugging() ? await a.DebugRunScheduledWaits() : a.RunScheduledWaits();
        b && C3Debugger$jscomp$3.AddEventsTime();
        this.PopCurrentLayout();
        a.BlockFlushingInstances(!1);
        this.FlushPendingInstances();
        a.BlockFlushingInstances(!0)
    }
    async Step_AfterPreTick() {
        const a = this.IsDebug()
          , b = this.IsDebugging()
          , c = this._dispatcher
          , d = this._eventObjects
          , e = this._userScriptEventObjects;
        a && C3Debugger$jscomp$3.StartMeasuringTime();
        b ? await this.DebugIterateAndBreak(this._DebugBehaviorTick()) : this._BehaviorTick();
        b ? await this.DebugIterateAndBreak(this._DebugBehaviorPostTick()) : this._BehaviorPostTick();
        a && C3Debugger$jscomp$3.AddBehaviorTickTime();
        a && C3Debugger$jscomp$3.StartMeasuringTime();
        b ? await this.DebugFireGeneratorEventAndBreak(d.tick) : c.dispatchEvent(d.tick);
        a && C3Debugger$jscomp$3.AddPluginTickTime();
        this._eventSheetManager.BlockFlushingInstances(!1);
        this.DispatchUserScriptEvent(e.tick)
    }
    async Step_RunEventsEtc() {
        const a = this._eventSheetManager
          , b = this._dispatcher
          , c = this._eventObjects
          , d = this.IsDebug()
          , e = this.IsDebugging();
        d && C3Debugger$jscomp$3.StartMeasuringTime();
        e ? await a.DebugRunEvents(this._layoutManager) : a.RunEvents(this._layoutManager);
        d && C3Debugger$jscomp$3.AddEventsTime();
        this._collisionEngine.ClearRegisteredCollisions();
        this._ReleasePendingInstances();
        this._isLayoutFirstTick = !1;
        a.BlockFlushingInstances(!0);
        d && C3Debugger$jscomp$3.StartMeasuringTime();
        e ? await this.DebugIterateAndBreak(this._DebugBehaviorTick2()) : this._BehaviorTick2();
        d && C3Debugger$jscomp$3.AddBehaviorTickTime();
        d && C3Debugger$jscomp$3.StartMeasuringTime();
        e ? await this.DebugFireGeneratorEventAndBreak(c.tick2) : b.dispatchEvent(c.tick2);
        d && C3Debugger$jscomp$3.AddPluginTickTime();
        a.BlockFlushingInstances(!1);
        e && await a.RunQueuedDebugTriggersAsync()
    }
    _ReleasePendingInstances() {
        if (0 !== this._instancesPendingRelease.size) {
            var a = this._dispatcher;
            a.SetDelayRemoveEventsEnabled(!0);
            for (const b of this._instancesPendingReleaseAffectedObjectClasses)
                b.GetSolStack().RemoveInstances(this._instancesPendingRelease);
            this._instancesPendingReleaseAffectedObjectClasses.clear();
            this._eventSheetManager.RemoveInstancesFromScheduledWaits(this._instancesPendingRelease);
            for (const b of this._instancesPendingRelease)
                b.Release();
            this._instancesPendingRelease.clear();
            a.SetDelayRemoveEventsEnabled(!1)
        }
    }
    async _MaybeChangeLayout() {
        const a = this.GetLayoutManager();
        let b = 0;
        for (; a.IsPendingChangeMainLayout() && 10 > b++; )
            await this._DoChangeLayout(a.GetPendingChangeMainLayout())
    }
    _MeasureDt(a) {
        let b = 0;
        this.IsExportToVideo() ? this._dt1 = this._dtRaw = b = 1 / this.GetExportVideoFramerate() : 0 !== this._lastTickTime && (b = Math.max(a - this._lastTickTime, 0) / 1E3,
        .5 < b && (b = 0),
        this._dtRaw = b,
        this._dt1 = C3$jscomp$201.clamp(b, this._minDt, this._maxDt));
        this._lastTickTime = a;
        this._dt = this._dt1 * this._timeScale;
        this._gameTime.Add(this._dt);
        this._gameTimeRaw.Add(b * this._timeScale);
        this._wallTime.Add(this._dt1);
        for (const [c,d] of this._instanceTimes)
            d.Add(this._dt1 * c.GetTimeScale());
        this._canvasManager && this._canvasManager._UpdateTick();
        1E3 <= a - this._fpsLastTime && (this._fpsLastTime += 1E3,
        1E3 <= a - this._fpsLastTime && (this._fpsLastTime = a),
        this._fps = this._fpsFrameCount,
        this._fpsFrameCount = 0,
        this._tps = this._tpsTickCount,
        this._tpsTickCount = 0,
        this._mainThreadTime = Math.min(this._mainThreadTimeCounter / 1E3, 1),
        this._mainThreadTimeCounter = 0,
        this._canvasManager && this._canvasManager._Update1sFrameRange(),
        this._collisionEngine._Update1sStats(),
        this.IsDebug() && C3Debugger$jscomp$3.Update1sPerfStats())
    }
    _SetTrackingInstanceTime(a, b) {
        b ? this._instanceTimes.has(a) || (b = C3$jscomp$201.New(C3$jscomp$201.KahanSum),
        b.Copy(this._gameTime),
        this._instanceTimes.set(a, b)) : this._instanceTimes.delete(a)
    }
    _GetInstanceGameTime(a) {
        return (a = this._instanceTimes.get(a)) ? a.Get() : this.GetGameTime()
    }
    async _DoChangeLayout(a) {
        const b = this._dispatcher
          , c = this.GetLayoutManager().GetMainRunningLayout();
        await c._StopRunning();
        c._Unload(a, this.GetRenderer());
        c === a && this._eventSheetManager.ClearAllScheduledWaits();
        this._collisionEngine.ClearRegisteredCollisions();
        this._ReleasePendingInstances();
        b.dispatchEvent(this._eventObjects.beforelayoutchange);
        C3$jscomp$201.Asyncify.SetHighThroughputMode(!0);
        await a._Load(c, this.GetRenderer());
        C3$jscomp$201.Asyncify.SetHighThroughputMode(!1);
        await a._StartRunning(!1);
        b.dispatchEvent(this._eventObjects.layoutchange);
        this.UpdateRender();
        this._isLayoutFirstTick = !0;
        this.FlushPendingInstances();
        this._ExportToVideoAddKeyframe()
    }
    UpdateRender() {
        this._needRender = !0
    }
    GetWebGLRenderer() {
        return this._canvasManager ? this._canvasManager.GetWebGLRenderer() : null
    }
    GetWebGPURenderer() {
        return this._canvasManager ? this._canvasManager.GetWebGPURenderer() : null
    }
    GetRenderer() {
        return this._canvasManager ? this._canvasManager.GetRenderer() : null
    }
    Render() {
        const a = this._canvasManager;
        if (a && !a.IsRendererContextLost()) {
            var b = this.GetRenderer()
              , c = b.SupportsGPUProfiling()
              , d = c && b.IsWebGL();
            c = c && b.IsWebGPU();
            d && b.CheckForQueryResults();
            if (this._needRender || this.IsExportToVideo()) {
                var e = this._layoutManager.GetMainRunningLayout();
                this._fpsFrameCount++;
                b.Start();
                var f = this.IsDebug();
                f && C3Debugger$jscomp$3.StartMeasuringTime();
                this._needRender = !1;
                var h = null;
                d && (h = a.GetGPUFrameTimingsBuffer().AddTimeElapsedQuery(),
                b.StartQuery(h));
                d = null;
                c && (d = b.StartFrameTiming(2 * (1 + e.GetLayerCount())),
                b.StartMeasuringRenderPassTime(0, 1));
                this.Uses3DFeatures() && "low" === a.GetCurrentFullscreenScalingQuality() ? b.SetFixedSizeDepthBuffer(a.GetDrawWidth(), a.GetDrawHeight()) : b.SetAutoSizeDepthBuffer();
                this._Render(this.GetRenderer(), e);
                h && b.EndQuery(h);
                c && (b.StopMeasuringRenderPassTime(),
                this._canvasManager._AddWebGPUFrameTiming(d));
                b.Finish();
                f && (C3Debugger$jscomp$3.AddDrawCallsTime(),
                C3Debugger$jscomp$3.UpdateInspectHighlight());
                a && a._MaybeTakeSnapshot()
            } else
                b.IncrementFrameNumber()
        }
    }
    _NeedsHTMLLayerCompositing(a) {
        return "low" === this.GetCanvasManager().GetCurrentFullscreenScalingQuality() || a.IsWebGL() && (this.UsesAnyBackgroundBlending() || this.Uses3DFeatures())
    }
    _Render(a, b) {
        a.SetTextureFillMode();
        a.SetAlphaBlend();
        a.SetColorRgba(1, 1, 1, 1);
        a.SetRenderTarget(null);
        a.SetTexture(null);
        a.SetDepthEnabled(this.Uses3DFeatures());
        this._NeedsHTMLLayerCompositing(a) && b._MaybeStartDrawToOwnTexture(a);
        const c = b.GetHTMLLayerCount();
        for (let d = 1; d < c; ++d)
            b.DrawForHTMLLayerIndex(a, d),
            a.IsWebGPU() && a.Restart();
        this._NeedsHTMLLayerCompositing(a) || b._MaybeStartDrawToOwnTexture(a);
        b.DrawMain(a)
    }
    Trigger(a, b, c) {
        if (!this._hasStarted)
            return !1;
        var d = !this._isInTick && !this._eventSheetManager.IsInTrigger();
        let e = 0;
        d && (e = performance.now());
        const f = this.IsDebug();
        f && this.SetDebuggingEnabled(!1);
        a = this._eventSheetManager._Trigger(this._layoutManager, a, b, c);
        d && (d = performance.now() - e,
        this._mainThreadTimeCounter += d,
        f && C3Debugger$jscomp$3.AddTriggersTime(d));
        f && this.SetDebuggingEnabled(!0);
        return a
    }
    DebugTrigger(a, b, c) {
        if (!this.IsDebugging())
            return this.Trigger(a, b, c);
        if (this.HitBreakpoint())
            throw Error("called DebugTrigger() while stopped on breakpoint");
        if (!this._isInTick && !this._eventSheetManager.IsInTrigger())
            throw Error("called DebugTrigger() outside of event code - use TriggerAsync() instead");
        return this._eventSheetManager._DebugTrigger(this._layoutManager, a, b, c)
    }
    async TriggerAsync(a, b, c) {
        if (!this.IsDebugging())
            return this.Trigger(a, b, c);
        if (!this._hasStarted)
            return !1;
        if (this.HitBreakpoint())
            return this._eventSheetManager.QueueDebugTrigger(a, b, c);
        if (!this.GetMainRunningLayout())
            return this._eventSheetManager.QueueTrigger(a, b, c);
        const d = performance.now();
        a = this._eventSheetManager._DebugTrigger(this._layoutManager, a, b, c);
        for (b = a.next(); !b.done; )
            await this.DebugBreak(b.value),
            b = a.next();
        this.IsSuspended() || this._eventSheetManager.IsInTrigger() || (await this._eventSheetManager.RunQueuedDebugTriggersAsync(),
        this._hasStartedTicking && !this._isInTick && this._RequestAnimationFrame());
        this._mainThreadTimeCounter += performance.now() - d;
        return b.value
    }
    FastTrigger(a, b, c) {
        const d = this.IsDebug();
        d && this.SetDebuggingEnabled(!1);
        a = this._eventSheetManager._FastTrigger(this._layoutManager, a, b, c);
        d && this.SetDebuggingEnabled(!0);
        return a
    }
    DebugFastTrigger(a, b, c) {
        return this._eventSheetManager._DebugFastTrigger(this._layoutManager, a, b, c)
    }
    ScheduleTriggers(a) {
        return this._scheduleTriggersThrottle.Add(a)
    }
    PushCurrentLayout(a) {
        this._currentLayoutStack.push(a)
    }
    PopCurrentLayout() {
        if (!this._currentLayoutStack.length)
            throw Error("layout stack empty");
        this._currentLayoutStack.pop()
    }
    GetCurrentLayout() {
        return this._currentLayoutStack.length ? this._currentLayoutStack.at(-1) : this.GetMainRunningLayout()
    }
    GetDt(a) {
        return a && -1 !== a.GetTimeScale() ? this._dt1 * a.GetTimeScale() : this._dt
    }
    _GetDtFast() {
        return this._dt
    }
    GetDt1() {
        return this._dt1
    }
    GetDtRaw() {
        return this._dtRaw
    }
    GetTimeScale() {
        return this._timeScale
    }
    SetTimeScale(a) {
        if (isNaN(a) || 0 > a)
            a = 0;
        this._timeScale = a
    }
    SetMinDt(a) {
        this._minDt = Math.max(a, 0)
    }
    GetMinDt() {
        return this._minDt
    }
    SetMaxDt(a) {
        this._maxDt = Math.max(a, 0)
    }
    GetMaxDt() {
        return this._maxDt
    }
    GetFramesPerSecond() {
        return this._fps
    }
    GetTicksPerSecond() {
        return this._tps
    }
    GetMainThreadTime() {
        return this._mainThreadTime
    }
    GetStartTime() {
        return this._startTime
    }
    GetGameTime() {
        return this._gameTime.Get()
    }
    GetGameTimeRaw() {
        return this._gameTimeRaw.Get()
    }
    GetWallTime() {
        return this._wallTime.Get()
    }
    GetTickCount() {
        return this._tickCount
    }
    GetTickCountNoSave() {
        return this._tickCountNoSave
    }
    GetObjectCount() {
        return this._objectCount
    }
    GetProjectName() {
        return this._projectName
    }
    GetProjectVersion() {
        return this._projectVersion
    }
    GetProjectUniqueId() {
        return this._projectUniqueId
    }
    GetAppId() {
        return this._appId
    }
    GetInstanceByUID(a) {
        if (this._isLoadingState)
            throw Error("cannot call while loading state - wait until afterload event");
        return this._instancesByUid.get(a) || null
    }
    _RefreshUidMap() {
        this._instancesByUid.clear();
        for (const a of this._allObjectClasses)
            if (!a.IsFamily())
                for (const b of a.GetInstances())
                    this._instancesByUid.set(b.GetUID(), b)
    }
    IsPreview() {
        return "preview" === this._exportType
    }
    IsDebug() {
        return this._isDebug
    }
    GetExportType() {
        return this._exportType
    }
    IsCordova() {
        return "cordova" === this._exportType
    }
    IsAndroidWebView() {
        return "Android" === C3$jscomp$201.Platform.OS && ("cordova" === this._exportType || "playable-ad" === this._exportType || "instant-games" === this._exportType)
    }
    IsiOSCordova() {
        return this._isiOSCordova
    }
    IsiOSWebView() {
        return this._isiOSWebView
    }
    IsWindowsWebView2() {
        return this._isWindowsWebView2
    }
    IsAnyWebView2Wrapper() {
        return this._isAnyWebView2Wrapper
    }
    GetCollisionEngine() {
        return this._collisionEngine
    }
    GetSolidBehavior() {
        return this._addonManager.GetSolidBehavior()
    }
    GetJumpthruBehavior() {
        return this._addonManager.GetJumpthruBehavior()
    }
    Uses3DFeatures() {
        return this._uses3dFeatures
    }
    GetZScaleFactor() {
        return this.GetRenderer().GetZAxisScaleFactor(this.GetViewportHeight())
    }
    GetDefaultCameraZ(a) {
        return this.GetRenderer().GetDefaultCameraZ(a || this.GetViewportHeight())
    }
    IsLayoutFirstTick() {
        return this._isLayoutFirstTick
    }
    SetPixelRoundingEnabled(a) {
        a = !!a;
        this._isPixelRoundingEnabled !== a && (this._isPixelRoundingEnabled = a,
        this.GetLayoutManager().SetAllLayerMVChanged(),
        this.UpdateRender())
    }
    IsPixelRoundingEnabled() {
        return this._isPixelRoundingEnabled
    }
    GetTextIconSet(a) {
        if (!this._iconChangeHandlers.has(a)) {
            var b = () => this.DeleteTextIconSet(a);
            this._iconChangeHandlers.set(a, b);
            a.Dispatcher().addEventListener("animationframeimagechange", b)
        }
        b = this._textIconManager.GetIconSet(a);
        b.HasLoaded() || b.LoadContent().then( () => this.UpdateRender());
        return b
    }
    DeleteTextIconSet(a) {
        this._textIconManager.DeleteIconSet(a)
    }
    _GetTextIconSetMeta(a) {
        const b = [];
        for (const c of a.GetAnimations())
            for (const d of c.GetFrames())
                a = d.GetImageInfo(),
                b.push({
                    source: d,
                    width: a.GetWidth(),
                    height: a.GetHeight(),
                    tag: d.GetTag()
                });
        return {
            icons: b
        }
    }
    async _GetTextIconSetContent(a) {
        const b = C3$jscomp$201.New(C3$jscomp$201.PromiseThrottle);
        var c = [];
        const d = new Map;
        for (const e of a.GetAnimations())
            for (const f of e.GetFrames()) {
                const h = f.GetImageInfo().GetImageAsset();
                d.has(h) || (d.set(h, null),
                c.push(b.Add(async () => {
                    const l = await h.LoadToDrawable();
                    d.set(h, l)
                }
                )))
            }
        await Promise.all(c);
        c = [];
        for (const e of a.GetAnimations())
            for (const f of e.GetFrames())
                c.push(b.Add(async () => {
                    var h = f.GetImageInfo();
                    const l = d.get(h.GetImageAsset());
                    h = await h.ExtractImageToCanvas(l);
                    return {
                        drawable: await createImageBitmap(h)
                    }
                }
                ));
        a = await Promise.all(c);
        for (const e of d.values())
            e instanceof ImageBitmap && e.close && e.close();
        return {
            icons: a
        }
    }
    SaveToSlot(a) {
        this._saveToSlotName = a
    }
    LoadFromSlot(a) {
        this._loadFromSlotName = a
    }
    LoadFromJsonString(a) {
        this._loadFromJson = a
    }
    GetLastSaveJsonString() {
        return this._lastSaveJson
    }
    _NeedsHandleSaveOrLoad() {
        return !(!this._saveToSlotName && !this._loadFromSlotName && null === this._loadFromJson)
    }
    async _HandleSaveOrLoad() {
        this._saveToSlotName && (this.FlushPendingInstances(),
        await this._DoSaveToSlot(this._saveToSlotName),
        this._ClearSaveOrLoad());
        this._loadFromSlotName && (await this._DoLoadFromSlot(this._loadFromSlotName),
        this._ClearSaveOrLoad(),
        this.IsDebug() && C3Debugger$jscomp$3.StepIfPausedInDebugger());
        if (null !== this._loadFromJson) {
            this.FlushPendingInstances();
            try {
                await this._DoLoadFromJsonString(this._loadFromJson),
                this._lastSaveJson = this._loadFromJson,
                await this.TriggerAsync(C3$jscomp$201.Plugins.System.Cnds.OnLoadComplete, null),
                this._lastSaveJson = ""
            } catch (a) {
                console.error("[Construct] Failed to load state from JSON string: ", a),
                await this.TriggerAsync(C3$jscomp$201.Plugins.System.Cnds.OnLoadFailed, null)
            }
            this._ClearSaveOrLoad()
        }
    }
    _ClearSaveOrLoad() {
        this._loadFromSlotName = this._saveToSlotName = "";
        this._loadFromJson = null
    }
    _GetProjectStorage() {
        this._projectStorage || (this._projectStorage = localforage.createInstance({
            name: "c3-localstorage-" + this.GetProjectUniqueId(),
            description: this.GetProjectName()
        }));
        return this._projectStorage
    }
    _GetSavegamesStorage() {
        this._savegamesStorage || (this._savegamesStorage = localforage.createInstance({
            name: "c3-savegames-" + this.GetProjectUniqueId(),
            description: this.GetProjectName()
        }));
        return this._savegamesStorage
    }
    async _DoSaveToSlot(a) {
        const b = await this._SaveToJsonString();
        try {
            await this._GetSavegamesStorage().setItem(a, b),
            console.log("[Construct] Saved state to storage (" + b.length + " chars)"),
            this._lastSaveJson = b,
            await this.TriggerAsync(C3$jscomp$201.Plugins.System.Cnds.OnSaveComplete, null),
            this._lastSaveJson = ""
        } catch (c) {
            console.error("[Construct] Failed to save state to storage: ", c),
            await this.TriggerAsync(C3$jscomp$201.Plugins.System.Cnds.OnSaveFailed, null)
        }
    }
    async _DoLoadFromSlot(a) {
        try {
            const b = await this._GetSavegamesStorage().getItem(a);
            if (!b)
                throw Error("empty slot");
            console.log("[Construct] Loaded state from storage (" + b.length + " chars)");
            await this._DoLoadFromJsonString(b);
            this._lastSaveJson = b;
            await this.TriggerAsync(C3$jscomp$201.Plugins.System.Cnds.OnLoadComplete, null);
            this._lastSaveJson = ""
        } catch (b) {
            console.error("[Construct] Failed to load state from storage: ", b),
            await this.TriggerAsync(C3$jscomp$201.Plugins.System.Cnds.OnLoadFailed, null)
        }
    }
    async _SaveToJsonString() {
        const a = {
            c3save: !0,
            version: 1,
            rt: {
                time: this.GetGameTime(),
                timeRaw: this.GetGameTimeRaw(),
                walltime: this.GetWallTime(),
                timescale: this.GetTimeScale(),
                tickcount: this.GetTickCount(),
                next_uid: this._nextUid,
                running_layout: this.GetMainRunningLayout().GetSID(),
                start_time_offset: Date.now() - this._startTime
            },
            types: {},
            layouts: {},
            events: this._eventSheetManager._SaveToJson(),
            timelines: this._timelineManager._SaveToJson(),
            user_script_data: null
        };
        for (var b of this._allObjectClasses)
            b.IsFamily() || b.HasNoSaveBehavior() || (a.types[b.GetSID().toString()] = b._SaveToJson());
        for (const c of this._layoutManager.GetAllLayouts())
            a.layouts[c.GetSID().toString()] = c._SaveToJson();
        b = this._CreateUserScriptEvent("save");
        b.saveData = null;
        await this.DispatchUserScriptEventAsyncWait(b);
        a.user_script_data = b.saveData;
        return JSON.stringify(a)
    }
    IsLoadingState() {
        return this._isLoadingState
    }
    async _DoLoadFromJsonString(a) {
        var b = this.GetLayoutManager();
        a = JSON.parse(a);
        if (a.c2save)
            throw Error("C2 saves are incompatible with C3 runtime");
        if (!a.c3save)
            throw Error("not valid C3 save data");
        if (1 < a.version)
            throw Error("C3 save data from future version");
        this.ClearIntancesNeedingAfterLoad();
        this._dispatcher.dispatchEvent(C3$jscomp$201.New(C3$jscomp$201.Event, "beforeload"));
        for (var c of this.allInstances())
            c.GetObjectClass().HasNoSaveBehavior() || c._OnBeforeLoad();
        c = a.rt;
        this._gameTime.Set(c.time);
        c.hasOwnProperty("timeRaw") && this._gameTimeRaw.Set(c.timeRaw);
        this._wallTime.Set(c.walltime);
        this._timeScale = c.timescale;
        this._tickCount = c.tickcount;
        this._startTime = Date.now() - c.start_time_offset;
        var d = c.running_layout;
        this._isLoadingState = !0;
        var e = !1;
        if (d !== this.GetMainRunningLayout().GetSID())
            if (e = b.GetLayoutBySID(d))
                await this._DoChangeLayout(e),
                e = !0;
            else
                return;
        for (const [l,m] of Object.entries(a.layouts))
            d = parseInt(l, 10),
            (d = b.GetLayoutBySID(d)) && d._LoadFromJson(m);
        for (const [l,m] of Object.entries(a.types))
            d = parseInt(l, 10),
            d = this.GetObjectClassBySID(d),
            !d || d.IsFamily() || d.HasNoSaveBehavior() || d._LoadFromJson(m);
        for (var f of this._layoutManager.GetAllLayouts())
            for (const l of f.allLayers())
                l._LoadFromJsonAfterInstances();
        this.FlushPendingInstances();
        this._RefreshUidMap();
        this._isLoadingState = !1;
        if (e) {
            for (const l of this.allInstances())
                l.SetupInitialSceneGraphConnections();
            for (const [l,m] of Object.entries(a.types))
                f = parseInt(l, 10),
                f = this.GetObjectClassBySID(f),
                !f || f.IsFamily() || f.HasNoSaveBehavior() || f._SetupSceneGraphConnectionsOnChangeOfLayout(m)
        }
        this._nextUid = c.next_uid;
        this._eventSheetManager._LoadFromJson(a.events);
        for (const l of this._allObjectClasses)
            if (!l.IsFamily() && l.IsInContainer())
                for (const m of l.GetInstances()) {
                    c = m.GetIID();
                    for (const p of l.GetContainer().objectTypes())
                        if (p !== l) {
                            f = p.GetInstances();
                            if (0 > c || c >= f.length)
                                throw Error("missing sibling instance");
                            m._AddSibling(f[c])
                        }
                }
        this._timelineManager._LoadFromJson(a.timelines);
        b.SetAllLayerProjectionChanged();
        b.SetAllLayerMVChanged();
        this._dispatcher.dispatchEvent(C3$jscomp$201.New(C3$jscomp$201.Event, "afterload"));
        this.DispatchUserScriptEvent(this._CreateUserScriptEvent("afterload"));
        this.DoAfterLoad();
        for (var [h] of Object.entries(a.types))
            b = parseInt(h, 10),
            (b = this.GetObjectClassBySID(b)) && b._ClearLoadInstancesJson();
        h = this._CreateUserScriptEvent("load");
        h.saveData = a.user_script_data;
        await this.DispatchUserScriptEventAsyncWait(h);
        this.UpdateRender()
    }
    SortOnTmpHierarchyPosition(a, b) {
        return a.GetWorldInfo().GetTmpHierarchyPosition() - b.GetWorldInfo().GetTmpHierarchyPosition()
    }
    AddInstanceNeedingAfterLoad(a, b) {
        a.GetWorldInfo() && (this._instancesNeedingAfterLoadMap.set(a, b),
        this._instancesNeedingAfterLoadArray.push(a))
    }
    ClearIntancesNeedingAfterLoad() {
        this._instancesNeedingAfterLoadMap = new WeakMap;
        C3$jscomp$201.clearArray(this._instancesNeedingAfterLoadArray)
    }
    DoAfterLoad(a="full", b=null) {
        this._instancesNeedingAfterLoadArray.sort(this.SortOnTmpHierarchyPosition);
        for (const c of this._instancesNeedingAfterLoadArray)
            c._OnAfterLoad(this._instancesNeedingAfterLoadMap.get(c), a, b);
        for (const c of this._instancesNeedingAfterLoadArray)
            c._OnAfterLoad2(this._instancesNeedingAfterLoadMap.get(c), a, b);
        this.ClearIntancesNeedingAfterLoad()
    }
    async AddJobWorkerScripts(a) {
        a = await Promise.all(a.map(async b => {
            const c = C3$jscomp$201.IsAbsoluteURL(b) && (new URL(b)).origin !== location.origin
              , d = this.IsCordova() && this._assetManager.IsFileProtocol();
            return c || d || this.IsPreview() || "playable-ad" === this.GetExportType() ? (b = await this._assetManager.FetchBlob(b),
            URL.createObjectURL(b)) : C3$jscomp$201.IsRelativeURL(b) ? (new URL(b,this._runtimeBaseUrl)).toString() : b
        }
        ));
        this._jobScheduler.ImportScriptsToJobWorkers(a)
    }
    AddJobWorkerBlob(a, b) {
        this._jobScheduler.SendBlobToJobWorkers(a, b)
    }
    AddJobWorkerBuffer(a, b) {
        this._jobScheduler.SendBufferToJobWorkers(a, b)
    }
    AddJob(a, b, c, d) {
        return this._jobScheduler.AddJob(a, b, c, null, null, d)
    }
    BroadcastJob(a, b, c, d) {
        return this._jobScheduler.BroadcastJob(a, b, c, d)
    }
    GetMaxNumJobWorkers() {
        return this._jobScheduler.GetMaxNumWorkers()
    }
    InvokeDownload(a, b) {
        this.PostComponentMessageToDOM("runtime", "invoke-download", {
            url: a,
            filename: b
        })
    }
    async RasterSvgImage(a, b, c, d, e, f) {
        d = d || b;
        e = e || c;
        if (this.IsInWorker())
            return (await this.PostComponentMessageToDOMAsync("runtime", "raster-svg-image", {
                blob: a,
                imageWidth: b,
                imageHeight: c,
                surfaceWidth: d,
                surfaceHeight: e,
                imageBitmapOpts: f
            })).imageBitmap;
        a = await self.C3_RasterSvgImageBlob(a, b, c, d, e);
        return f ? await self.createImageBitmap(a, f) : a
    }
    async GetSvgImageSize(a) {
        return this.IsInWorker() ? await this.PostComponentMessageToDOMAsync("runtime", "get-svg-image-size", {
            blob: a
        }) : await self.C3_GetSvgImageSize(a)
    }
    RequestDeviceOrientationEvent() {
        this._didRequestDeviceOrientationEvent || (this._didRequestDeviceOrientationEvent = !0,
        this.PostComponentMessageToDOM("runtime", "enable-device-orientation"))
    }
    RequestDeviceMotionEvent() {
        this._didRequestDeviceMotionEvent || (this._didRequestDeviceMotionEvent = !0,
        this.PostComponentMessageToDOM("runtime", "enable-device-motion"))
    }
    Random() {
        return this._randomNumberCallback()
    }
    SetRandomNumberGeneratorCallback(a) {
        this._randomNumberCallback = a
    }
    _GetRemotePreviewStatusInfo() {
        const a = this.GetRenderer();
        return {
            fps: this.GetFramesPerSecond(),
            tps: this.GetTicksPerSecond(),
            cpu: this.GetMainThreadTime(),
            gpu: this.GetGPUUtilisation(),
            layout: this.GetMainRunningLayout() ? this.GetMainRunningLayout().GetName() : "",
            renderer: a.IsWebGL() ? a.GetUnmaskedRenderer() : a.GetAdapterInfoString()
        }
    }
    HitBreakpoint() {
        return this.IsDebug() ? C3Debugger$jscomp$3.HitBreakpoint() : !1
    }
    DebugBreak(a) {
        return this.IsDebugging() ? C3Debugger$jscomp$3.DebugBreak(a) : Promise.resolve()
    }
    DebugBreakNext() {
        return this.IsDebugging() ? C3Debugger$jscomp$3.BreakNext() : !1
    }
    SetDebugBreakpointsEnabled(a) {
        this._breakpointsEnabled = !!a;
        this._UpdateDebuggingFlag()
    }
    AreDebugBreakpointsEnabled() {
        return this._breakpointsEnabled
    }
    IsDebugging() {
        return this._isDebugging
    }
    SetDebuggingEnabled(a) {
        a ? this._debuggingDisabled-- : this._debuggingDisabled++;
        this._UpdateDebuggingFlag()
    }
    _UpdateDebuggingFlag() {
        this._isDebugging = this.IsDebug() && this._breakpointsEnabled && 0 === this._debuggingDisabled
    }
    IsCPUProfiling() {
        return this.IsDebug() && C3Debugger$jscomp$3.IsCPUProfiling()
    }
    IsGPUProfiling() {
        return this.IsDebug() && this.GetRenderer().SupportsGPUProfiling() && C3Debugger$jscomp$3.IsGPUProfiling()
    }
    async DebugIterateAndBreak(a) {
        if (a)
            for (const b of a)
                await this.DebugBreak(b)
    }
    DebugFireGeneratorEventAndBreak(a) {
        return this.DebugIterateAndBreak(this._dispatcher.dispatchGeneratorEvent(a))
    }
    _InvokeFunctionFromJS(a) {
        return this._eventSheetManager._InvokeFunctionFromJS(a.name, a.params)
    }
    _GetHTMLLayerWrapElement(a) {
        if (this.IsInWorker())
            throw Error("not supported in worker mode");
        return self.c3_runtimeInterface._GetHTMLWrapElement(a)
    }
    GetIRuntime() {
        return this._iRuntime
    }
    _CreateUserScriptEvent(a) {
        a = C3$jscomp$201.New(C3$jscomp$201.Event, a, !1);
        a.runtime = this._iRuntime;
        return a
    }
    _InitScriptInterfaces() {
        this._iRuntime = new self.IRuntime(this);
        this._userScriptEventObjects = {
            tick: this._CreateUserScriptEvent("tick")
        }
    }
    _InitObjectsScriptInterface() {
        const a = {};
        for (const b of this._allObjectClasses)
            a[b.GetJsPropName()] = {
                value: b.GetIObjectClass(),
                enumerable: !0,
                writable: !1
            };
        this._iRuntime._InitObjects(a)
    }
    _InitGlobalVariableScriptInterface() {
        const a = {};
        for (const b of this.GetEventSheetManager().GetAllGlobalVariables())
            a[b.GetJsPropName()] = b._GetScriptInterfaceDescriptor();
        this._iRuntime._InitGlobalVars(a)
    }
    _GetCommonScriptInterfaces() {
        return this._commonScriptInterfaces
    }
    _MapScriptInterface(a, b) {
        this._interfaceMap.set(a, b)
    }
    _UnwrapScriptInterface(a) {
        return this._interfaceMap.get(a)
    }
    _UnwrapIObjectClass(a) {
        if (!(a instanceof self.IObjectClass))
            throw new TypeError("expected IObjectClass");
        a = this._UnwrapScriptInterface(a);
        if (!(a && a instanceof C3$jscomp$201.ObjectClass))
            throw Error("invalid IObjectClass");
        return a
    }
    _UnwrapIInstance(a) {
        if (!(a instanceof self.IInstance))
            throw new TypeError("expected IInstance");
        a = this._UnwrapScriptInterface(a);
        if (!(a && a instanceof C3$jscomp$201.Instance))
            throw Error("invalid IInstance");
        return a
    }
    _UnwrapIWorldInstance(a) {
        if (!(a instanceof self.IWorldInstance))
            throw new TypeError("expected IWorldInstance");
        a = this._UnwrapScriptInterface(a);
        if (!(a && a instanceof C3$jscomp$201.Instance))
            throw Error("invalid IInstance");
        return a
    }
}
;
self.C3_CreateRuntime = C3$jscomp$201.Runtime.Create;
self.C3_InitRuntime = (a, b) => a.Init(b);
"use strict";
const C3$jscomp$202 = self.C3;
C3$jscomp$202.JobSchedulerRuntime = class extends C3$jscomp$202.DefendedBase {
    constructor(a, b) {
        super();
        this._runtime = a;
        this._jobPromises = new Map;
        this._nextJobId = 0;
        this._inputPort = b.inputPort;
        b.outputPort.onmessage = c => this._OnJobWorkerMessage(c);
        this._maxNumWorkers = b.maxNumWorkers;
        this._jobWorkerCount = 1;
        this._hadErrorCreatingWorker = this._isCreatingWorker = !1
    }
    async Init() {}
    GetMaxNumWorkers() {
        return this._maxNumWorkers
    }
    ImportScriptsToJobWorkers(a) {
        this._inputPort.postMessage({
            type: "_import_scripts",
            scripts: a
        })
    }
    SendBlobToJobWorkers(a, b) {
        this._inputPort.postMessage({
            type: "_send_blob",
            blob: a,
            id: b
        })
    }
    SendBufferToJobWorkers(a, b) {
        this._inputPort.postMessage({
            type: "_send_buffer",
            buffer: a,
            id: b
        }, [a])
    }
    AddJob(a, b, c, d, e, f) {
        c || (c = []);
        if ("number" === typeof f && (f = Math.floor(f),
        0 >= f))
            throw Error("invalid maxWorkerNum");
        const h = this._nextJobId++;
        a = {
            type: a,
            isBroadcast: !1,
            maxWorkerNum: f,
            jobId: h,
            params: b,
            transferables: c
        };
        b = new Promise( (l, m) => {
            this._jobPromises.set(h, {
                resolve: l,
                progress: d,
                reject: m,
                cancelled: !1,
                maxWorkerNum: f
            })
        }
        );
        e && e.SetAction( () => this._CancelJob(h));
        this._inputPort.postMessage(a, c);
        this._MaybeCreateExtraWorker();
        return b
    }
    BroadcastJob(a, b, c, d) {
        c || (c = []);
        if ("number" === typeof d && (d = Math.floor(d),
        0 >= d))
            throw Error("invalid maxWorkerNum");
        const e = this._nextJobId++;
        this._inputPort.postMessage({
            type: a,
            isBroadcast: !0,
            maxWorkerNum: d,
            jobId: e,
            params: b,
            transferables: c
        }, c)
    }
    _CancelJob(a) {
        const b = this._jobPromises.get(a);
        b && (b.cancelled = !0,
        b.resolve = null,
        b.progress = null,
        b.reject = null,
        this._inputPort.postMessage({
            type: "_cancel",
            jobId: a
        }))
    }
    _OnJobWorkerMessage(a) {
        a = a.data;
        const b = a.type
          , c = a.jobId;
        switch (b) {
        case "result":
            this._OnJobResult(c, a.result);
            break;
        case "progress":
            this._OnJobProgress(c, a.progress);
            break;
        case "error":
            this._OnJobError(c, a.error);
            break;
        case "ready":
            this._OnJobWorkerReady();
            break;
        default:
            throw Error(`unknown message from worker '${b}'`);
        }
    }
    _OnJobResult(a, b) {
        const c = this._jobPromises.get(a);
        if (!c)
            throw Error("invalid job ID");
        c.cancelled || c.resolve(b);
        this._jobPromises.delete(a)
    }
    _OnJobProgress(a, b) {
        a = this._jobPromises.get(a);
        if (!a)
            throw Error("invalid job ID");
        !a.cancelled && a.progress && a.progress(b)
    }
    _OnJobError(a, b) {
        const c = this._jobPromises.get(a);
        if (!c)
            throw Error("invalid job ID");
        c.cancelled || c.reject(b);
        this._jobPromises.delete(a)
    }
    _OnJobWorkerReady() {
        this._isCreatingWorker && (this._isCreatingWorker = !1,
        this._jobWorkerCount++,
        this._jobWorkerCount < this._maxNumWorkers ? this._MaybeCreateExtraWorker() : this._inputPort.postMessage({
            type: "_no_more_workers"
        }))
    }
    _GetWorkerCountNeededForPendingJobs() {
        let a = 0;
        const b = [...this._jobPromises.values()].sort( (c, d) => (c.maxWorkerNum || Infinity) - (d.maxWorkerNum || Infinity));
        for (const c of b)
            a < (c.maxWorkerNum || Infinity) && a++;
        return a
    }
    async _MaybeCreateExtraWorker() {
        if (!(this._jobWorkerCount >= this._maxNumWorkers || this._isCreatingWorker || this._hadErrorCreatingWorker || this._GetWorkerCountNeededForPendingJobs() <= this._jobWorkerCount))
            try {
                this._isCreatingWorker = !0,
                (await this._runtime.PostComponentMessageToDOMAsync("runtime", "create-job-worker")).outputPort.onmessage = a => this._OnJobWorkerMessage(a)
            } catch (a) {
                this._hadErrorCreatingWorker = !0,
                this._isCreatingWorker = !1,
                console.error(`[Construct] Failed to create job worker; stopping creating any more (created ${this._jobWorkerCount} so far)`, a)
            }
    }
}
;
self.C3_Shaders = {};
self.C3_Shaders.setcolor = {
    glsl: "varying mediump vec2 vTex;\nuniform lowp sampler2D samplerFront;\nuniform lowp vec3 setColor;\nvoid main(void)\n{\nlowp float a = texture2D(samplerFront, vTex).a;\ngl_FragColor = vec4(setColor.r * a, setColor.g * a, setColor.b * a, a);\n}",
    glslWebGL2: "",
    wgsl: "%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\nstruct ShaderParams {\nsetColor : vec3<f32>\n};\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\n%%FRAGMENTINPUT_STRUCT%%\n%%FRAGMENTOUTPUT_STRUCT%%\n@fragment\nfn main(input : FragmentInput) -> FragmentOutput\n{\nvar a : f32 = textureSample(textureFront, samplerFront, input.fragUV).a;\nvar output : FragmentOutput;\noutput.color = vec4<f32>(shaderParams.setColor * a, a);\nreturn output;\n}",
    blendsBackground: !1,
    usesDepth: !1,
    extendBoxHorizontal: 0,
    extendBoxVertical: 0,
    crossSampling: !1,
    mustPreDraw: !1,
    preservesOpaqueness: !0,
    supports3dDirectRendering: !1,
    animated: !1,
    parameters: [["setColor", 0, "color"]]
};
self.C3_Shaders.grayscale = {
    glsl: "varying mediump vec2 vTex;\nuniform lowp sampler2D samplerFront;\nuniform lowp float intensity;\nvoid main(void)\n{\nlowp vec4 front = texture2D(samplerFront, vTex);\nlowp float gray = front.r * 0.299 + front.g * 0.587 + front.b * 0.114;\ngl_FragColor = mix(front, vec4(gray, gray, gray, front.a), intensity);\n}",
    glslWebGL2: "",
    wgsl: "%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\nstruct ShaderParams {\nintensity : f32\n};\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\n%%C3_UTILITY_FUNCTIONS%%\n%%FRAGMENTINPUT_STRUCT%%\n%%FRAGMENTOUTPUT_STRUCT%%\n@fragment\nfn main(input : FragmentInput) -> FragmentOutput\n{\nvar front : vec4<f32> = textureSample(textureFront, samplerFront, input.fragUV);\nvar gray : f32 = c3_grayscale(front.rgb);\nvar output : FragmentOutput;\noutput.color = mix(front, vec4<f32>(gray, gray, gray, front.a), shaderParams.intensity);\nreturn output;\n}",
    blendsBackground: !1,
    usesDepth: !1,
    extendBoxHorizontal: 0,
    extendBoxVertical: 0,
    crossSampling: !1,
    mustPreDraw: !1,
    preservesOpaqueness: !0,
    supports3dDirectRendering: !1,
    animated: !1,
    parameters: [["intensity", 0, "percent"]]
};
self.C3_Shaders.federicoCalchera_Gradient = {
    glsl: "uniform mediump float uAngle;\nuniform mediump float uStartOpacity;\nuniform mediump float uEndOpacity;\nuniform mediump float uSmoothness;\nuniform lowp vec3 color0;\nuniform lowp vec3 color1;\nuniform mediump vec2 srcOriginStart;\nuniform mediump vec2 srcOriginEnd;\nvarying mediump vec2 vTex;\nuniform lowp sampler2D samplerFront;\nprecision mediump float;\nvoid main() {\nvec4 front = texture2D(samplerFront, vTex);\nvec4 startColor = vec4(color0, 1.);\nvec4 endColor = vec4(color1, 1.);\nfloat currentAngle = -uAngle;\nmediump vec2 srcOriginSize = srcOriginEnd - srcOriginStart;\nmediump vec2 uv = ((vTex - srcOriginStart) / srcOriginSize);\nvec2 origin = vec2(0.5, 0.5);\nuv -= origin;\nfloat angle = radians(90.0) - radians(currentAngle) + atan(uv.y, uv.x);\nfloat len = length(uv);\nuv = vec2(cos(angle) * len, sin(angle) * len) + origin;\nfloat t = smoothstep(.5 + uSmoothness , .5 - uSmoothness, uv.x);\nstartColor = mix(front, startColor, uStartOpacity);\nendColor = mix(front, endColor, uEndOpacity);\ngl_FragColor = mix(startColor, endColor, t) * front.a;\n}",
    glslWebGL2: "",
    wgsl: "%%FRAGMENTINPUT_STRUCT%%\n%%FRAGMENTOUTPUT_STRUCT%%\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\nstruct ShaderParams {\ncolor0 : vec3<f32>,\nuStartOpacity : f32,\ncolor1 : vec3<f32>,\nuEndOpacity : f32,\nuAngle : f32,\nuSmoothness : f32\n};\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\n%%C3PARAMS_STRUCT%%\n%%C3_UTILITY_FUNCTIONS%%\n@fragment\nfn main(input : FragmentInput) -> FragmentOutput\n{\nlet front: vec4<f32> = textureSample(textureFront, samplerFront, input.fragUV);\nvar startColor: vec4<f32> = vec4<f32>(shaderParams.color0, 1.);\nvar endColor: vec4<f32> = vec4<f32>(shaderParams.color1, 1.);\nlet currentAngle: f32 = -shaderParams.uAngle;\nvar uv: vec2<f32> = c3_srcOriginToNorm(input.fragUV);\nlet origin: vec2<f32> = vec2<f32>(0.5, 0.5);\nuv = uv - (origin);\nlet angle: f32 = radians(90.) - radians(currentAngle) + atan2(uv.y, uv.x);\nlet len: f32 = length(uv);\nuv = vec2<f32>(cos(angle) * len, sin(angle) * len) + origin;\nlet t: f32 = smoothstep(.5 + shaderParams.uSmoothness, .5 -shaderParams.uSmoothness, uv.x);\nstartColor = mix(front, startColor, shaderParams.uStartOpacity);\nendColor = mix(front, endColor, shaderParams.uEndOpacity);\nvar output : FragmentOutput;\noutput.color = mix(startColor, endColor, t) * front.a;\nreturn output;\n}",
    blendsBackground: !1,
    usesDepth: !1,
    extendBoxHorizontal: 0,
    extendBoxVertical: 0,
    crossSampling: !1,
    mustPreDraw: !1,
    preservesOpaqueness: !0,
    supports3dDirectRendering: !1,
    animated: !1,
    parameters: [["color0", 0, "color"], ["uStartOpacity", 0, "percent"], ["color1", 0, "color"], ["uEndOpacity", 0, "percent"], ["uAngle", 0, "float"], ["uSmoothness", 0, "percent"]]
};
self.C3_Shaders.brightness = {
    glsl: "varying mediump vec2 vTex;\nuniform lowp sampler2D samplerFront;\nuniform lowp float brightness;\nvoid main(void)\n{\nlowp vec4 front = texture2D(samplerFront, vTex);\nlowp float a = front.a;\nif (a != 0.0)\nfront.rgb /= front.a;\nfront.rgb += (brightness - 1.0);\nfront.rgb *= a;\ngl_FragColor = front;\n}",
    glslWebGL2: "",
    wgsl: "%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\nstruct ShaderParams {\nbrightness : f32\n};\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\n%%C3_UTILITY_FUNCTIONS%%\n%%FRAGMENTINPUT_STRUCT%%\n%%FRAGMENTOUTPUT_STRUCT%%\n@fragment\nfn main(input : FragmentInput) -> FragmentOutput\n{\nvar front : vec4<f32> = c3_unpremultiply(textureSample(textureFront, samplerFront, input.fragUV));\nvar output : FragmentOutput;\noutput.color = vec4<f32>((front.rgb + (shaderParams.brightness - 1.0)) * front.a, front.a);\nreturn output;\n}",
    blendsBackground: !1,
    usesDepth: !1,
    extendBoxHorizontal: 0,
    extendBoxVertical: 0,
    crossSampling: !1,
    mustPreDraw: !1,
    preservesOpaqueness: !0,
    supports3dDirectRendering: !1,
    animated: !1,
    parameters: [["brightness", 0, "percent"]]
};
self.C3_Shaders.addColor = {
    glsl: "varying mediump vec2 vTex;\nuniform lowp sampler2D samplerFront;\nuniform lowp vec3 setColor;\nuniform mediump float blend;\nvoid main(void)\n{\nlowp vec4 front = texture2D(samplerFront, vTex);\ngl_FragColor = vec4(front.rgb + setColor * front.a, front.a);\n}",
    glslWebGL2: "#version 300 es\nin mediump vec2 vTex;\nuniform lowp sampler2D samplerFront;\nuniform lowp vec3 setColor;\nuniform mediump float blend;\nout lowp vec4 outColor;\nvoid main(void)\n{\nlowp vec4 front = texture(samplerFront, vTex);\noutColor = vec4(front.rgb + setColor * front.a, front.a);\n}",
    wgsl: "%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\nstruct ShaderParams {\nsetColor : vec3<f32>,\n};\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\n%%FRAGMENTINPUT_STRUCT%%\n%%FRAGMENTOUTPUT_STRUCT%%\n@fragment\nfn main(input : FragmentInput) -> FragmentOutput\n{\nvar front : vec4<f32> = textureSample(textureFront, samplerFront, input.fragUV);\nvar output : FragmentOutput;\noutput.color = vec4<f32>(front.rgb + shaderParams.setColor * front.a, front.a);\nreturn output;\n}",
    blendsBackground: !1,
    usesDepth: !1,
    extendBoxHorizontal: 0,
    extendBoxVertical: 0,
    crossSampling: !1,
    mustPreDraw: !1,
    preservesOpaqueness: !0,
    supports3dDirectRendering: !1,
    animated: !1,
    parameters: [["setColor", 0, "color"]]
};
self.C3_Shaders.skymen_BetterOutline = {
    glsl: "uniform lowp vec3 outlinecolor;\nuniform lowp float width;\nuniform lowp float precisionStep;\nuniform lowp float samples;\nuniform lowp float outlineOpacity;\nvarying mediump vec2 vTex;\nuniform lowp sampler2D samplerFront;\nuniform mediump vec2 srcStart;\nuniform mediump vec2 srcEnd;\nuniform mediump vec2 srcOriginStart;\nuniform mediump vec2 srcOriginEnd;\nuniform mediump vec2 layoutStart;\nuniform mediump vec2 layoutEnd;\nuniform lowp sampler2D samplerBack;\nuniform mediump vec2 destStart;\nuniform mediump vec2 destEnd;\nuniform mediump float seconds;\nuniform mediump vec2 pixelSize;\nuniform mediump float layerScale;\nuniform mediump float layerAngle;\n#define PI 3.14159265359\n#define SAMPLES 96\n#define PASSES 64\nvoid main(void)\n{\nif (width <= 0.0 || outlineOpacity <= 0.0) {\ngl_FragColor = texture2D( samplerFront, vTex );\nreturn;\n}\nmediump float outlineAlpha = 0.0;\nmediump vec2 actualWidth;\nmediump float widthCopy = width;\nmediump vec4 color = vec4(outlinecolor.x, outlinecolor.y, outlinecolor.z, 1.0);\nmediump float angle;\nmediump vec2 layoutSize = abs(vec2(layoutEnd.x-layoutStart.x,(layoutEnd.y-layoutStart.y)));\nmediump vec2 texelSize = abs(srcOriginEnd-srcOriginStart)/layoutSize;\nmediump vec4 fragColor;\nmediump vec2 testPoint;\nmediump float sampledAlpha;\nint passes = int(clamp(width / precisionStep, 1.0, float(PASSES)));\nfor (int j=0; j<PASSES; j++) {\nif (j >= passes ) break;\nwidthCopy = mix(0.0, width, float(j)/float(passes));\nactualWidth = widthCopy * texelSize;\nangle = 0.0;\nfor( int i=0; i<SAMPLES; i++ ){\nif (i >= int(samples)) break;\nangle += 1.0/(clamp(samples, 0.0, float(SAMPLES))/2.0) * PI;\ntestPoint = vTex + actualWidth * vec2(cos(angle), sin(angle));\nsampledAlpha = texture2D( samplerFront,  testPoint ).a;\noutlineAlpha = max( outlineAlpha, sampledAlpha );\n}\n}\nfragColor = color * outlineAlpha * outlineOpacity;\nmediump vec4 tex0 = texture2D( samplerFront, vTex );\ngl_FragColor = fragColor * (1. - tex0.a) + tex0;\n}",
    glslWebGL2: "#version 300 es\nin mediump vec2 vTex;\nout lowp vec4 outColor;\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n#define highmedp highp\n#else\n#define highmedp mediump\n#endif\nprecision lowp float;\nuniform lowp sampler2D samplerFront;\nuniform mediump vec2 srcStart;\nuniform mediump vec2 srcEnd;\nuniform mediump vec2 srcOriginStart;\nuniform mediump vec2 srcOriginEnd;\nuniform mediump vec2 layoutStart;\nuniform mediump vec2 layoutEnd;\nuniform lowp sampler2D samplerBack;\nuniform lowp sampler2D samplerDepth;\nuniform mediump vec2 destStart;\nuniform mediump vec2 destEnd;\nuniform highmedp float seconds;\nuniform mediump vec2 pixelSize;\nuniform mediump float layerScale;\nuniform mediump float layerAngle;\nuniform mediump float devicePixelRatio;\nuniform mediump float zNear;\nuniform mediump float zFar;\nuniform lowp vec3 outlinecolor;\nuniform lowp float width;\nuniform lowp float precisionStep;\nuniform lowp float samples;\nuniform lowp float outlineOpacity;\n#define PI 3.14159265359\n#define SAMPLES 96\n#define PASSES 64\nvoid main(void)\n{\nif (width <= 0.0 || outlineOpacity <= 0.0) {\noutColor = texture( samplerFront, vTex );\nreturn;\n}\nmediump float outlineAlpha = 0.0;\nmediump vec2 actualWidth;\nmediump float widthCopy = width;\nmediump vec4 color = vec4(outlinecolor.x, outlinecolor.y, outlinecolor.z, 1.0);\nmediump float angle;\nmediump vec2 layoutSize = abs(vec2(layoutEnd.x-layoutStart.x,(layoutEnd.y-layoutStart.y)));\nmediump vec2 texelSize = abs(srcOriginEnd-srcOriginStart)/layoutSize;\nmediump vec4 fragColor;\nmediump vec2 testPoint;\nmediump float sampledAlpha;\nint passes = int(clamp(width / precisionStep, 1.0, float(PASSES)));\nint sampleCount = int(clamp(samples, 0.0, float(SAMPLES)));\nfor (int j = 0; j <= passes; j++) {\nwidthCopy = mix(0.0, width, float(j)/float(passes));\nactualWidth = widthCopy * texelSize;\nangle = 0.0;\nfor( int i = 0; i < sampleCount; i++ ) {\nangle += 1.0/(float(sampleCount)/2.0) * PI;\ntestPoint = vTex + actualWidth * vec2(cos(angle), sin(angle));\nsampledAlpha = texture( samplerFront,  testPoint ).a;\noutlineAlpha = max( outlineAlpha, sampledAlpha );\n}\n}\nfragColor = color * outlineAlpha * outlineOpacity;\nmediump vec4 tex0 = texture( samplerFront, vTex );\noutColor = fragColor * (1. - tex0.a) + tex0;\n}",
    wgsl: "%%FRAGMENTINPUT_STRUCT%%\n/* input struct contains the following fields:\nfragUV : vec2<f32>\nfragPos : vec4<f32>\nfn c3_getBackUV(fragPos : vec2<f32>, texBack : texture_2d<f32>) -> vec2<f32>\nfn c3_getDepthUV(fragPos : vec2<f32>, texDepth : texture_depth_2d) -> vec2<f32>\n*/\n%%FRAGMENTOUTPUT_STRUCT%%\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\nstruct ShaderParams {\noutlinecolor : vec3<f32>,\nwidth : f32,\nprecisionStep : f32,\nsamples : f32,\noutlineOpacity : f32\n};\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\n%%C3PARAMS_STRUCT%%\n/* c3Params struct contains the following fields:\nsrcStart : vec2<f32>,\nsrcEnd : vec2<f32>,\nsrcOriginStart : vec2<f32>,\nsrcOriginEnd : vec2<f32>,\nlayoutStart : vec2<f32>,\nlayoutEnd : vec2<f32>,\ndestStart : vec2<f32>,\ndestEnd : vec2<f32>,\ndevicePixelRatio : f32,\nlayerScale : f32,\nlayerAngle : f32,\nseconds : f32,\nzNear : f32,\nzFar : f32,\nisSrcTexRotated : u32\nfn c3_srcToNorm(p : vec2<f32>) -> vec2<f32>\nfn c3_normToSrc(p : vec2<f32>) -> vec2<f32>\nfn c3_srcOriginToNorm(p : vec2<f32>) -> vec2<f32>\nfn c3_normToSrcOrigin(p : vec2<f32>) -> vec2<f32>\nfn c3_clampToSrc(p : vec2<f32>) -> vec2<f32>\nfn c3_clampToSrcOrigin(p : vec2<f32>) -> vec2<f32>\nfn c3_getLayoutPos(p : vec2<f32>) -> vec2<f32>\nfn c3_srcToDest(p : vec2<f32>) -> vec2<f32>\nfn c3_clampToDest(p : vec2<f32>) -> vec2<f32>\nfn c3_linearizeDepth(depthSample : f32) -> f32\n*/\n/*\nfn c3_premultiply(c : vec4<f32>) -> vec4<f32>\nfn c3_unpremultiply(c : vec4<f32>) -> vec4<f32>\nfn c3_grayscale(rgb : vec3<f32>) -> f32\nfn c3_getPixelSize(t : texture_2d<f32>) -> vec2<f32>\nfn c3_RGBtoHSL(color : vec3<f32>) -> vec3<f32>\nfn c3_HSLtoRGB(hsl : vec3<f32>) -> vec3<f32>\n*/\nconst PI:f32 = 3.14159265359;\nconst SAMPLES:i32 = 96;\nconst PASSES:i32 = 64;\n@fragment\nfn main(input : FragmentInput) -> FragmentOutput\n{\nvar output : FragmentOutput;\nif (shaderParams.width <= 0.0 || shaderParams.outlineOpacity <= 0.0) {\noutput.color = textureSample(textureFront, samplerFront, input.fragUV );\nreturn output;\n}\nvar outlineAlpha: f32 = 0.0;\nvar actualWidth: vec2<f32>;\nvar widthCopy: f32 = shaderParams.width;\nvar color: vec4<f32> = vec4<f32>(shaderParams.outlinecolor.x, shaderParams.outlinecolor.y, shaderParams.outlinecolor.z, 1.0);\nvar angle: f32;\nlet layoutSize: vec2<f32> = abs(vec2<f32>(c3Params.layoutEnd.x - c3Params.layoutStart.x, c3Params.layoutEnd.y - c3Params.layoutStart.y));\nlet texelSize: vec2<f32> = abs(c3Params.srcOriginEnd - c3Params.srcOriginStart) / layoutSize;\nvar fragColor: vec4<f32>;\nvar testPoint: vec2<f32>;\nvar sampledAlpha: f32;\nlet passes: u32 = u32(clamp(shaderParams.width / shaderParams.precisionStep, 1.0, f32(SAMPLES)));\nlet sampleCount: u32 = u32(clamp(shaderParams.samples, 0.0, f32(SAMPLES)));\nfor (var j: u32 = 0u; j <= passes; j = j + 1u) {\nwidthCopy = mix(0.0, shaderParams.width, f32(j) / f32(passes));\nactualWidth = widthCopy * texelSize;\nangle = 0.0;\nfor (var i: u32 = 0u; i < sampleCount; i = i + 1u) {\nangle = angle + 1.0 / (f32(sampleCount) / 2.0) * PI;\ntestPoint = input.fragUV + actualWidth * vec2<f32>(cos(angle), sin(angle));\nsampledAlpha = textureSample(textureFront, samplerFront, testPoint).a; // Assuming 'samplerFrontSampler' is the sampler associated with 'samplerFront'\noutlineAlpha = max(outlineAlpha, sampledAlpha);\n}\n}\nfragColor = color * outlineAlpha * shaderParams.outlineOpacity;\nvar tex0 : vec4<f32> = textureSample(textureFront, samplerFront, input.fragUV );\noutput.color = fragColor * (1. - tex0.a) + tex0;\nreturn output;\n}",
    blendsBackground: !1,
    usesDepth: !1,
    extendBoxHorizontal: 50,
    extendBoxVertical: 50,
    crossSampling: !0,
    mustPreDraw: !0,
    preservesOpaqueness: !1,
    supports3dDirectRendering: !1,
    animated: !1,
    parameters: [["outlinecolor", 0, "color"], ["width", 0, "float"], ["precisionStep", 0, "float"], ["samples", 0, "float"], ["outlineOpacity", 0, "percent"]]
};
"use strict";
const C3$jscomp$203 = self.C3;
let cacheRegex = null
  , lastRegex = ""
  , lastFlags = ""
  , regexMatches = []
  , lastMatchesStr = ""
  , lastMatchesRegex = ""
  , lastMatchesFlags = "";
const forEachStack = C3$jscomp$203.New(C3$jscomp$203.ArrayStack);
function ForEachOrdered_SortInstances(a, b) {
    a = a[1];
    b = b[1];
    if ("number" === typeof a && "number" === typeof b)
        return a - b;
    a = "" + a;
    b = "" + b;
    return a < b ? -1 : a > b ? 1 : 0
}
C3$jscomp$203.Plugins.System = class extends C3$jscomp$203.SDKPluginBase {
    constructor(a) {
        super(a);
        this._loopStack = this._runtime.GetEventSheetManager().GetLoopStack();
        this._eventStack = this._runtime.GetEventSheetManager().GetEventStack();
        this._imagesLoadingComplete = this._imagesLoadingTotal = 0;
        this._functionMaps = new Map;
        this._signalTags = []
    }
    Release() {
        super.Release()
    }
    UpdateRender() {
        this._runtime.UpdateRender()
    }
    Trigger(a) {
        this._runtime.Trigger(a, null, null)
    }
    GetRegex(a, b) {
        cacheRegex && a === lastRegex && b === lastFlags || (cacheRegex = new RegExp(a,b),
        lastRegex = a,
        lastFlags = b);
        cacheRegex.lastIndex = 0;
        return cacheRegex
    }
    GetRegexMatches(a, b, c) {
        if (a === lastMatchesStr && b === lastMatchesRegex && c === lastMatchesFlags)
            return regexMatches;
        const d = this.GetRegex(b, c);
        regexMatches = a.match(d);
        lastMatchesStr = a;
        lastMatchesRegex = b;
        lastMatchesFlags = c;
        return regexMatches
    }
    async _LoadTexturesForObjectClasses(a, b) {
        if (b.length) {
            this._imagesLoadingTotal += b.length;
            var c = [];
            for (const d of b)
                c.push(a.MaybeLoadTexturesFor(d));
            await C3$jscomp$203.PromiseAllWithProgress(c, () => {
                this._imagesLoadingComplete++
            }
            );
            this._imagesLoadingComplete++;
            this._imagesLoadingComplete === this._imagesLoadingTotal && (this._imagesLoadingTotal = this._imagesLoadingComplete = 0,
            this._runtime.Trigger(C3$jscomp$203.Plugins.System.Cnds.OnImageLoadingComplete, null, null))
        }
    }
    _UnloadTexturesForObjectClasses(a, b) {
        for (const c of b)
            0 === c.GetInstanceCount() && a.MaybeUnloadTexturesFor(c)
    }
    _GetForEachStack() {
        return forEachStack
    }
    _Repeat(a) {
        var b = this._runtime.GetEventSheetManager();
        const c = b.GetEventStack()
          , d = c.GetCurrentStackFrame()
          , e = d.GetCurrentEvent()
          , f = e.GetSolModifiers();
        var h = d.IsSolModifierAfterCnds();
        const l = c.Push(e)
          , m = b.GetLoopStack()
          , p = m.Push();
        p.SetEnd(a);
        if (h)
            for (h = 0; h < a && !p.IsStopped(); ++h)
                b.PushCopySol(f),
                p.SetIndex(h),
                e.Retrigger(d, l),
                b.PopSol(f);
        else
            for (b = 0; b < a && !p.IsStopped(); ++b)
                p.SetIndex(b),
                e.Retrigger(d, l);
        c.Pop();
        m.Pop();
        return !1
    }
    *_DebugRepeat(a) {
        var b = this._runtime.GetEventSheetManager();
        const c = b.GetEventStack()
          , d = c.GetCurrentStackFrame()
          , e = d.GetCurrentEvent()
          , f = e.GetSolModifiers();
        var h = d.IsSolModifierAfterCnds();
        const l = c.Push(e)
          , m = b.GetLoopStack()
          , p = m.Push();
        p.SetEnd(a);
        if (h)
            for (h = 0; h < a && !p.IsStopped(); ++h)
                b.PushCopySol(f),
                p.SetIndex(h),
                yield*e.DebugRetrigger(d, l),
                b.PopSol(f);
        else
            for (b = 0; b < a && !p.IsStopped(); ++b)
                p.SetIndex(b),
                yield*e.DebugRetrigger(d, l);
        c.Pop();
        m.Pop();
        return !1
    }
    _While() {
        var a = this._runtime.GetEventSheetManager();
        const b = a.GetEventStack()
          , c = b.GetCurrentStackFrame()
          , d = c.GetCurrentEvent()
          , e = d.GetSolModifiers();
        var f = c.IsSolModifierAfterCnds();
        const h = b.Push(d)
          , l = a.GetLoopStack()
          , m = l.Push();
        if (f)
            for (f = 0; !m.IsStopped(); ++f)
                a.PushCopySol(e),
                m.SetIndex(f),
                d.Retrigger(c, h) || m.Stop(),
                a.PopSol(e);
        else
            for (a = 0; !m.IsStopped(); ++a)
                m.SetIndex(a),
                d.Retrigger(c, h) || m.Stop();
        b.Pop();
        l.Pop();
        return !1
    }
    *_DebugWhile() {
        var a = this._runtime.GetEventSheetManager();
        const b = a.GetEventStack()
          , c = b.GetCurrentStackFrame()
          , d = c.GetCurrentEvent()
          , e = d.GetSolModifiers();
        var f = c.IsSolModifierAfterCnds();
        const h = b.Push(d)
          , l = a.GetLoopStack()
          , m = l.Push();
        if (f)
            for (f = 0; !m.IsStopped(); ++f)
                a.PushCopySol(e),
                m.SetIndex(f),
                (yield*d.DebugRetrigger(c, h)) || m.Stop(),
                a.PopSol(e);
        else
            for (a = 0; !m.IsStopped(); ++a)
                m.SetIndex(a),
                (yield*d.DebugRetrigger(c, h)) || m.Stop();
        b.Pop();
        l.Pop();
        return !1
    }
    _For(a, b, c) {
        var d = this._runtime.GetEventSheetManager();
        const e = d.GetEventStack()
          , f = e.GetCurrentStackFrame()
          , h = f.GetCurrentEvent()
          , l = h.GetSolModifiers()
          , m = f.IsSolModifierAfterCnds()
          , p = e.Push(h)
          , r = d.GetLoopStack()
          , v = r.Push();
        v.SetName(a);
        v.SetEnd(c);
        if (c < b)
            if (m)
                for (a = b; a >= c && !v.IsStopped(); --a)
                    d.PushCopySol(l),
                    v.SetIndex(a),
                    h.Retrigger(f, p),
                    d.PopSol(l);
            else
                for (d = b; d >= c && !v.IsStopped(); --d)
                    v.SetIndex(d),
                    h.Retrigger(f, p);
        else if (m)
            for (a = b; a <= c && !v.IsStopped(); ++a)
                d.PushCopySol(l),
                v.SetIndex(a),
                h.Retrigger(f, p),
                d.PopSol(l);
        else
            for (d = b; d <= c && !v.IsStopped(); ++d)
                v.SetIndex(d),
                h.Retrigger(f, p);
        e.Pop();
        r.Pop();
        return !1
    }
    *_DebugFor(a, b, c) {
        var d = this._runtime.GetEventSheetManager();
        const e = d.GetEventStack()
          , f = e.GetCurrentStackFrame()
          , h = f.GetCurrentEvent()
          , l = h.GetSolModifiers()
          , m = f.IsSolModifierAfterCnds()
          , p = e.Push(h)
          , r = d.GetLoopStack()
          , v = r.Push();
        v.SetName(a);
        v.SetEnd(c);
        if (c < b)
            if (m)
                for (a = b; a >= c && !v.IsStopped(); --a)
                    d.PushCopySol(l),
                    v.SetIndex(a),
                    yield*h.DebugRetrigger(f, p),
                    d.PopSol(l);
            else
                for (d = b; d >= c && !v.IsStopped(); --d)
                    v.SetIndex(d),
                    yield*h.DebugRetrigger(f, p);
        else if (m)
            for (a = b; a <= c && !v.IsStopped(); ++a)
                d.PushCopySol(l),
                v.SetIndex(a),
                yield*h.DebugRetrigger(f, p),
                d.PopSol(l);
        else
            for (d = b; d <= c && !v.IsStopped(); ++d)
                v.SetIndex(d),
                yield*h.DebugRetrigger(f, p);
        e.Pop();
        r.Pop();
        return !1
    }
    _ForEach(a) {
        var b = a.GetCurrentSol();
        const c = b.GetInstances();
        if (0 === c.length)
            return !1;
        var d = this._runtime.GetEventSheetManager();
        const e = d.GetEventStack()
          , f = e.GetCurrentStackFrame()
          , h = f.GetCurrentEvent()
          , l = h.GetSolModifiers()
          , m = f.IsSolModifierAfterCnds()
          , p = e.Push(h)
          , r = d.GetLoopStack()
          , v = r.Push()
          , x = a.IsInContainer()
          , B = forEachStack.Push();
        C3$jscomp$203.shallowAssignArray(B, c);
        v.SetEnd(B.length);
        if (m)
            for (let A = 0, D = B.length; A < D && !v.IsStopped(); ++A)
                d.PushCopySol(l),
                b = B[A],
                a.GetCurrentSol().SetSinglePicked(b),
                x && b.SetSiblingsSinglePicked(),
                v.SetIndex(A),
                h.Retrigger(f, p),
                d.PopSol(l);
        else {
            b._SetSelectAll(!1);
            a = b._GetOwnInstances();
            C3$jscomp$203.clearArray(a);
            a.push(null);
            for (let A = 0, D = B.length; A < D && !v.IsStopped(); ++A)
                d = B[A],
                a[0] = d,
                x && d.SetSiblingsSinglePicked(),
                v.SetIndex(A),
                h.Retrigger(f, p)
        }
        e.Pop();
        r.Pop();
        C3$jscomp$203.clearArray(B);
        forEachStack.Pop();
        return !1
    }
    *_DebugForEach(a) {
        var b = a.GetCurrentSol();
        const c = b.GetInstances();
        if (0 === c.length)
            return !1;
        var d = this._runtime.GetEventSheetManager();
        const e = d.GetEventStack()
          , f = e.GetCurrentStackFrame()
          , h = f.GetCurrentEvent()
          , l = h.GetSolModifiers()
          , m = f.IsSolModifierAfterCnds()
          , p = e.Push(h)
          , r = d.GetLoopStack()
          , v = r.Push()
          , x = a.IsInContainer()
          , B = forEachStack.Push();
        C3$jscomp$203.shallowAssignArray(B, c);
        v.SetEnd(B.length);
        if (m)
            for (let A = 0, D = B.length; A < D && !v.IsStopped(); ++A)
                d.PushCopySol(l),
                b = B[A],
                a.GetCurrentSol().SetSinglePicked(b),
                x && b.SetSiblingsSinglePicked(),
                v.SetIndex(A),
                yield*h.DebugRetrigger(f, p),
                d.PopSol(l);
        else {
            b._SetSelectAll(!1);
            a = b._GetOwnInstances();
            C3$jscomp$203.clearArray(a);
            a.push(null);
            for (let A = 0, D = B.length; A < D && !v.IsStopped(); ++A)
                d = B[A],
                a[0] = d,
                x && d.SetSiblingsSinglePicked(),
                v.SetIndex(A),
                yield*h.DebugRetrigger(f, p)
        }
        e.Pop();
        r.Pop();
        C3$jscomp$203.clearArray(B);
        forEachStack.Pop();
        return !1
    }
    _ForEachOrdered(a, b) {
        const c = a.GetCurrentSol()
          , d = c.GetInstances();
        if (0 === d.length)
            return !1;
        var e = this._runtime.GetEventSheetManager();
        const f = e.GetEventStack()
          , h = e.GetCurrentCondition()
          , l = f.GetCurrentStackFrame()
          , m = l.GetCurrentEvent()
          , p = m.GetSolModifiers()
          , r = l.IsSolModifierAfterCnds()
          , v = f.Push(m)
          , x = e.GetLoopStack()
          , B = x.Push()
          , A = a.IsInContainer()
          , D = forEachStack.Push();
        C3$jscomp$203.clearArray(D);
        B.SetEnd(d.length);
        for (let F = 0, I = d.length; F < I; ++F)
            D.push([d[F], h.ReevaluateParameter(1, F)]);
        D.sort(ForEachOrdered_SortInstances);
        1 === b && D.reverse();
        if (r)
            for (let F = 0, I = D.length; F < I && !B.IsStopped(); ++F)
                e.PushCopySol(p),
                b = D[F][0],
                a.GetCurrentSol().SetSinglePicked(b),
                A && b.SetSiblingsSinglePicked(),
                B.SetIndex(F),
                m.Retrigger(l, v),
                e.PopSol(p);
        else {
            c._SetSelectAll(!1);
            a = c._GetOwnInstances();
            C3$jscomp$203.clearArray(a);
            a.push(null);
            for (let F = 0, I = D.length; F < I && !B.IsStopped(); ++F)
                e = D[F][0],
                a[0] = e,
                A && e.SetSiblingsSinglePicked(),
                B.SetIndex(F),
                m.Retrigger(l, v)
        }
        f.Pop();
        x.Pop();
        C3$jscomp$203.clearArray(D);
        forEachStack.Pop();
        return !1
    }
    *_DebugForEachOrdered(a, b) {
        const c = a.GetCurrentSol()
          , d = c.GetInstances();
        if (0 === d.length)
            return !1;
        var e = this._runtime.GetEventSheetManager();
        const f = e.GetEventStack()
          , h = e.GetCurrentCondition()
          , l = f.GetCurrentStackFrame()
          , m = l.GetCurrentEvent()
          , p = m.GetSolModifiers()
          , r = l.IsSolModifierAfterCnds()
          , v = f.Push(m)
          , x = e.GetLoopStack()
          , B = x.Push()
          , A = a.IsInContainer()
          , D = forEachStack.Push();
        C3$jscomp$203.clearArray(D);
        B.SetEnd(d.length);
        for (let F = 0, I = d.length; F < I; ++F)
            D.push([d[F], h.ReevaluateParameter(1, F)]);
        D.sort(ForEachOrdered_SortInstances);
        1 === b && D.reverse();
        if (r)
            for (let F = 0, I = D.length; F < I && !B.IsStopped(); ++F)
                e.PushCopySol(p),
                b = D[F][0],
                a.GetCurrentSol().SetSinglePicked(b),
                A && b.SetSiblingsSinglePicked(),
                B.SetIndex(F),
                yield*m.DebugRetrigger(l, v),
                e.PopSol(p);
        else {
            c._SetSelectAll(!1);
            a = c._GetOwnInstances();
            C3$jscomp$203.clearArray(a);
            a.push(null);
            for (let F = 0, I = D.length; F < I && !B.IsStopped(); ++F)
                e = D[F][0],
                a[0] = e,
                A && e.SetSiblingsSinglePicked(),
                B.SetIndex(F),
                yield*m.DebugRetrigger(l, v)
        }
        f.Pop();
        x.Pop();
        C3$jscomp$203.clearArray(D);
        forEachStack.Pop();
        return !1
    }
    _GetFunctionMap(a, b) {
        let c = this._functionMaps.get(a);
        if (c)
            return c;
        if (!b)
            return null;
        c = {
            defaultFunc: null,
            strMap: new Map
        };
        this._functionMaps.set(a, c);
        return c
    }
    _DoCallMappedFunction(a, b, c, d, e) {
        b.GetEventBlock().RunAsMappedFunctionCall(c, b.IsCopyPicked());
        d && a.PopSol(e)
    }
    *_DebugDoCallMappedFunction(a, b, c, d, e) {
        yield*b.GetEventBlock().DebugRunAsMappedFunctionCall(c, b.IsCopyPicked());
        d && a.PopSol(e)
    }
}
;
const C3$jscomp$204 = self.C3;
C3$jscomp$204.Plugins.System.Type = class extends C3$jscomp$204.DefendedBase {
    constructor(a) {
        super();
        this._objectClass = a;
        this._runtime = a.GetRuntime();
        this._plugin = a.GetPlugin()
    }
    OnCreate() {}
    Release() {
        this._plugin = this._runtime = this._objectClass = null
    }
}
;
const C3$jscomp$205 = self.C3;
C3$jscomp$205.Plugins.System.Instance = class extends C3$jscomp$205.DefendedBase {
    constructor(a, b) {
        super();
        this._inst = a;
        this._objectClass = this._inst.GetObjectClass();
        this._sdkType = this._objectClass.GetSdkType();
        this._runtime = this._inst.GetRuntime()
    }
    Release() {
        this._runtime = this._sdkType = this._objectClass = this._inst = null
    }
}
;
const C3$jscomp$206 = self.C3
  , tmpPickArray = [];
C3$jscomp$206.Plugins.System.Cnds = {
    EveryTick() {
        return !0
    },
    OnLayoutStart() {
        return !0
    },
    OnLayoutEnd() {
        return !0
    },
    OnSuspend() {
        return !0
    },
    OnResume() {
        return !0
    },
    IsSuspended() {
        return this._runtime.IsSuspended()
    },
    Else() {
        const a = this._runtime.GetCurrentEventStackFrame();
        return a.GetElseBranchRan() ? !1 : !a.GetLastEventTrue()
    },
    TriggerOnce() {
        const a = this._runtime.GetCurrentCondition().GetSavedDataMap();
        let b = a.get("TriggerOnce_lastTick");
        "undefined" === typeof b && (b = -1,
        a.set("TriggerOnce_lastTick", -1));
        const c = this._runtime.GetTickCount();
        a.set("TriggerOnce_lastTick", c);
        return this._runtime.IsLayoutFirstTick() || b !== c - 1
    },
    Every(a) {
        const b = this._runtime.GetCurrentCondition().GetSavedDataMap()
          , c = b.get("Every_lastTime") || 0
          , d = this._runtime.GetGameTime();
        b.has("Every_seconds") || b.set("Every_seconds", a);
        const e = b.get("Every_seconds");
        if (d >= c + e)
            return b.set("Every_lastTime", c + e),
            d >= b.get("Every_lastTime") + .04 && b.set("Every_lastTime", d),
            b.set("Every_seconds", a),
            !0;
        d < c - .1 && b.set("Every_lastTime", d);
        return !1
    },
    IsGroupActive(a) {
        return (a = this._runtime.GetEventSheetManager().GetEventGroupByName(a)) && a.IsGroupActive()
    },
    IsPreview() {
        return this._runtime.IsPreview()
    },
    IsMobile() {
        return C3$jscomp$206.Platform.IsMobile
    },
    OnLoadFinished() {
        return !0
    },
    OnCanvasSnapshot() {
        return !0
    },
    EffectsSupported() {
        return !0
    },
    OnSaveComplete() {
        return !0
    },
    OnSaveFailed() {
        return !0
    },
    OnLoadComplete() {
        return !0
    },
    OnLoadFailed() {
        return !0
    },
    ObjectUIDExists(a) {
        return !!this._runtime.GetInstanceByUID(a)
    },
    IsOnPlatform(a) {
        switch (a) {
        case 0:
            return "browser" === C3$jscomp$206.Platform.Context;
        case 1:
            return "iOS" === C3$jscomp$206.Platform.OS;
        case 2:
            return "Android" === C3$jscomp$206.Platform.OS;
        case 8:
            return "cordova" === C3$jscomp$206.Platform.Context;
        case 9:
            return "scirra-arcade" === this._runtime.GetExportType();
        case 10:
            return "nwjs" === C3$jscomp$206.Platform.Context;
        case 13:
            return "windows-uwp" === this._runtime.GetExportType();
        default:
            return !1
        }
    },
    RegexTest(a, b, c) {
        return this.GetRegex(b, c).test(a)
    },
    Compare(a, b, c) {
        return C3$jscomp$206.compare(a, b, c)
    },
    CompareBetween(a, b, c) {
        return a >= b && a <= c
    },
    CompareVar(a, b, c) {
        return C3$jscomp$206.compare(a.GetValue(), b, c)
    },
    CompareBoolVar(a) {
        return !!a.GetValue()
    },
    CompareTime(a, b) {
        const c = this._runtime.GetGameTime();
        return 0 === a ? (a = this._runtime.GetCurrentCondition().GetSavedDataMap(),
        !a.get("CompareTime_executed") && c >= b ? (a.set("CompareTime_executed", !0),
        !0) : !1) : C3$jscomp$206.compare(c, a, b)
    },
    IsNaN(a) {
        return isNaN(a)
    },
    AngleWithin(a, b, c) {
        return C3$jscomp$206.angleDiff(C3$jscomp$206.toRadians(a), C3$jscomp$206.toRadians(c)) <= C3$jscomp$206.toRadians(b)
    },
    IsClockwiseFrom(a, b) {
        return C3$jscomp$206.angleClockwise(C3$jscomp$206.toRadians(a), C3$jscomp$206.toRadians(b))
    },
    IsBetweenAngles(a, b, c) {
        a = C3$jscomp$206.toRadians(a);
        b = C3$jscomp$206.toRadians(b);
        c = C3$jscomp$206.toRadians(c);
        return C3$jscomp$206.angleClockwise(c, b) ? C3$jscomp$206.angleClockwise(a, b) && !C3$jscomp$206.angleClockwise(a, c) : !(!C3$jscomp$206.angleClockwise(a, b) && C3$jscomp$206.angleClockwise(a, c))
    },
    IsValueType(a, b) {
        return "number" === typeof a ? 0 === b : 1 === b
    },
    EvaluateExpression(a) {
        return !!a
    },
    OnSignal(a) {
        return a.toLowerCase() === this._signalTags.at(-1)
    },
    PickByComparison(a, b, c, d) {
        if (!a)
            return !1;
        const e = this._GetForEachStack()
          , f = e.Push()
          , h = a.GetCurrentSol();
        C3$jscomp$206.shallowAssignArray(f, h.GetInstances());
        h.IsSelectAll() && C3$jscomp$206.clearArray(h._GetOwnElseInstances());
        const l = this._runtime.GetCurrentCondition();
        let m = 0;
        for (let p = 0, r = f.length; p < r; ++p) {
            const v = f[p];
            f[m] = v;
            b = l.ReevaluateParameter(1, p);
            d = l.ReevaluateParameter(3, p);
            C3$jscomp$206.compare(b, c, d) ? ++m : h._PushElseInstance(v)
        }
        C3$jscomp$206.truncateArray(f, m);
        h.SetArrayPicked(f);
        b = !!f.length;
        C3$jscomp$206.clearArray(f);
        e.Pop();
        a.ApplySolToContainer();
        return b
    },
    PickByEvaluate(a, b) {
        if (!a)
            return !1;
        const c = this._GetForEachStack()
          , d = c.Push()
          , e = a.GetCurrentSol();
        C3$jscomp$206.shallowAssignArray(d, e.GetInstances());
        e.IsSelectAll() && C3$jscomp$206.clearArray(e._GetOwnElseInstances());
        const f = this._runtime.GetCurrentCondition();
        let h = 0;
        for (let l = 0, m = d.length; l < m; ++l) {
            const p = d[l];
            d[h] = p;
            (b = f.ReevaluateParameter(1, l)) ? ++h : e._PushElseInstance(p)
        }
        C3$jscomp$206.truncateArray(d, h);
        e.SetArrayPicked(d);
        b = !!d.length;
        C3$jscomp$206.clearArray(d);
        c.Pop();
        a.ApplySolToContainer();
        return b
    },
    PickByHighestLowestValue(a, b, c) {
        if (!a)
            return !1;
        const d = a.GetCurrentSol()
          , e = d.GetInstances();
        if (0 === e.length)
            return !1;
        const f = this._runtime.GetCurrentCondition();
        let h = null
          , l = 0;
        for (let m = 0, p = e.length; m < p; ++m) {
            const r = e[m];
            c = f.ReevaluateParameter(2, m);
            if (null === h || 0 === b && c < l || 1 === b && c > l)
                l = c,
                h = r
        }
        d.PickOne(h);
        a.ApplySolToContainer();
        return !0
    },
    PickNth(a, b) {
        if (!a)
            return !1;
        const c = a.GetCurrentSol()
          , d = c.GetInstances();
        b = Math.floor(b);
        if (b >= d.length)
            return !1;
        c.PickOne(d[b]);
        a.ApplySolToContainer();
        return !0
    },
    PickRandom(a) {
        if (!a)
            return !1;
        const b = a.GetCurrentSol()
          , c = b.GetInstances()
          , d = Math.floor(this._runtime.Random() * c.length);
        if (d >= c.length)
            return !1;
        b.PickOne(c[d]);
        a.ApplySolToContainer();
        return !0
    },
    PickAll(a) {
        if (!a || !a.GetInstanceCount())
            return !1;
        a.GetCurrentSol()._SetSelectAll(!0);
        a.ApplySolToContainer();
        return !0
    },
    PickOverlappingPoint(a, b, c) {
        if (!a)
            return !1;
        const d = a.GetCurrentSol();
        var e = d.GetInstances();
        const f = this._runtime.GetCurrentEvent().IsOrBlock()
          , h = this._runtime.GetCurrentCondition().IsInverted();
        d.IsSelectAll() ? (C3$jscomp$206.shallowAssignArray(tmpPickArray, e),
        d.ClearArrays(),
        d._SetSelectAll(!1)) : f ? (C3$jscomp$206.shallowAssignArray(tmpPickArray, d._GetOwnElseInstances()),
        C3$jscomp$206.clearArray(d._GetOwnElseInstances())) : (C3$jscomp$206.shallowAssignArray(tmpPickArray, d._GetOwnInstances()),
        C3$jscomp$206.clearArray(d._GetOwnInstances()));
        for (let l = 0, m = tmpPickArray.length; l < m; ++l)
            e = tmpPickArray[l],
            C3$jscomp$206.xor(e.GetWorldInfo().ContainsPoint(b, c), h) ? d._PushInstance(e) : d._PushElseInstance(e);
        a.ApplySolToContainer();
        return C3$jscomp$206.xor(!!d._GetOwnInstances().length, h)
    },
    PickLastCreated(a) {
        if (!a)
            return !1;
        var b = a.IsFamily();
        let c = null;
        const d = this._runtime._GetInstancesPendingCreate();
        for (let e = d.length - 1; 0 <= e; --e) {
            const f = d[e];
            if (b) {
                if (f.GetObjectClass().BelongsToFamily(a)) {
                    c = f;
                    break
                }
            } else if (f.GetObjectClass() === a) {
                c = f;
                break
            }
        }
        c || (b = a.GetInstances(),
        b.length && (c = b.at(-1)));
        if (!c)
            return !1;
        a.GetCurrentSol().PickOne(c);
        a.ApplySolToContainer();
        return !0
    },
    Repeat(a) {
        return this._runtime.IsDebugging() ? this._DebugRepeat(a) : this._Repeat(a)
    },
    While() {
        return this._runtime.IsDebugging() ? this._DebugWhile() : this._While()
    },
    For(a, b, c) {
        return this._runtime.IsDebugging() ? this._DebugFor(a, b, c) : this._For(a, b, c)
    },
    ForEach(a) {
        return this._runtime.IsDebugging() ? this._DebugForEach(a) : this._ForEach(a)
    },
    ForEachOrdered(a, b, c) {
        return this._runtime.IsDebugging() ? this._DebugForEachOrdered(a, c) : this._ForEachOrdered(a, c)
    },
    LayerVisible(a) {
        return a ? a.IsVisible() : !1
    },
    LayerInteractive(a) {
        return a ? a.IsSelfAndParentsInteractive() : !1
    },
    LayerIsHTML(a) {
        return a ? a.IsHTMLElementsLayer() : !1
    },
    LayerEmpty(a) {
        return a ? !a.GetInstanceCount() : !1
    },
    LayerCmpOpacity(a, b, c) {
        return a ? C3$jscomp$206.compare(100 * a.GetOpacity(), b, c) : !1
    },
    LayerNameExists(a) {
        const b = this._runtime.GetMainRunningLayout();
        return b ? b.HasLayerByName(a) : !1
    },
    OnImageLoadingComplete() {
        return !0
    },
    IsLoadingImages() {
        return 0 < this._imagesLoadingTotal
    },
    TemplateExists(a, b) {
        const c = this._runtime.GetTemplateManager();
        return c && b ? !!c.GetTemplateData(a, b) : !1
    }
};
const C3$jscomp$207 = self.C3;
function SortZOrderList$jscomp$1(a, b) {
    const c = a[0] - b[0];
    return 0 !== c ? c : a[1] - b[1]
}
function SortInstancesByValue(a, b) {
    return a[1] - b[1]
}
const tempZOrderList$jscomp$1 = []
  , tempInstValues = []
  , tempRect$jscomp$10 = C3$jscomp$207.New(C3$jscomp$207.Rect)
  , tempColor$jscomp$7 = C3$jscomp$207.New(C3$jscomp$207.Color);
C3$jscomp$207.Plugins.System.Acts = {
    SetVar(a, b) {
        a.SetValue(b)
    },
    AddVar(a, b) {
        a.IsNumber() && "number" !== typeof b && (b = parseFloat(b));
        a.SetValue(a.GetValue() + b)
    },
    SubVar(a, b) {
        a.IsNumber() && a.SetValue(a.GetValue() - b)
    },
    SetBoolVar(a, b) {
        a.SetValue(!!b)
    },
    ToggleBoolVar(a) {
        a.SetValue(!a.GetValue())
    },
    ResetEventVar(a) {
        a.SetValue(a.GetInitialValue())
    },
    ResetGlobals(a) {
        this._runtime.GetEventSheetManager().ResetAllGlobalsToInitialValue(a)
    },
    CreateObject(a, b, c, d, e, f) {
        if (a && b && (c = this._runtime.CreateInstance(a, b, c, d, e, f))) {
            e && b.SortAndAddInstancesByZIndex(c);
            b = this._runtime.GetEventSheetManager();
            b.BlockFlushingInstances(!0);
            c._TriggerOnCreatedOnSelfAndRelated();
            b.BlockFlushingInstances(!1);
            b = new Map;
            c.CollectInstancesToPick(b, a, e);
            for (const [h,l] of b)
                h.GetCurrentSol().SetSetPicked(l)
        }
    },
    CreateObjectByName(a, b, c, d, e, f) {
        a && b && (a = this._runtime.GetObjectClassByName(a)) && C3$jscomp$207.Plugins.System.Acts.CreateObject.call(this, a, b, c, d, e, f)
    },
    RecreateInitialObjects(a, b, c, d, e, f, h, l, m, p) {
        if (a) {
            var r = this._runtime.GetCurrentLayout();
            if (f && (r = this._runtime.GetLayoutManager().GetLayoutByName(f),
            !r))
                return;
            f = null;
            if ("number" !== typeof h || 0 <= h)
                if (f = r.GetLayer(h),
                !f)
                    return;
            tempRect$jscomp$10.set(b, c, d, e);
            b = r.RecreateInitialObjects(a, tempRect$jscomp$10, f, l, m, p);
            a.GetCurrentSol().SetArrayPicked(b);
            a.ApplySolToContainer()
        }
    },
    StopLoop() {
        const a = this._loopStack;
        a.IsInLoop() && a.GetCurrent().Stop()
    },
    SetGroupActive(a, b) {
        (a = this._runtime.GetEventSheetManager().GetEventGroupByName(a)) && (0 === b ? a.SetGroupActive(!1) : 1 === b ? a.SetGroupActive(!0) : a.SetGroupActive(!a.IsGroupActive()))
    },
    SetTimescale(a) {
        this._runtime.SetTimeScale(a)
    },
    SetObjectTimescale(a, b) {
        0 > b && (b = 0);
        if (a) {
            a = a.GetCurrentSol().GetInstances();
            for (const c of a)
                c.SetTimeScale(b)
        }
    },
    RestoreObjectTimescale(a) {
        if (a) {
            a = a.GetCurrentSol().GetInstances();
            for (const b of a)
                b.RestoreTimeScale()
        }
    },
    Wait(a) {
        if (!(0 > a))
            return this._runtime.GetEventSheetManager().AddScheduledWait().InitTimer(a),
            !0
    },
    WaitForSignal(a) {
        this._runtime.GetEventSheetManager().AddScheduledWait().InitSignal(a);
        return !0
    },
    WaitForPreviousActions() {
        const a = this._runtime.GetEventSheetManager();
        a.AddScheduledWait().InitPromise(a.GetPromiseForAllAsyncActions());
        return !0
    },
    Signal(a) {
        a = a.toLowerCase();
        this._signalTags.push(a);
        this._runtime.Trigger(C3$jscomp$207.Plugins.System.Cnds.OnSignal, null);
        this._signalTags.pop();
        for (const b of this._runtime.GetEventSheetManager().scheduledWaits())
            b.IsSignal() && b.GetSignalTag() === a && b.SetSignalled()
    },
    async SnapshotCanvas(a, b, c, d, e, f) {
        const h = this._runtime.GetCanvasManager();
        h && (this.UpdateRender(),
        await h.SnapshotCanvas(0 === a ? "image/png" : "image/jpeg", b / 100, c, d, e, f),
        await this._runtime.TriggerAsync(C3$jscomp$207.Plugins.System.Cnds.OnCanvasSnapshot, null))
    },
    SetCanvasSize(a, b) {
        if (!(0 >= a || 0 >= b)) {
            this._runtime.SetViewportSize(a, b);
            this._runtime.GetCurrentLayout().BoundScrolling();
            var c = this._runtime.GetCanvasManager();
            c && ("off" !== c.GetCurrentFullscreenMode() && this._runtime.SetOriginalViewportSize(a, b),
            c.SetSize(c.GetLastWidth(), c.GetLastHeight(), !0),
            this._runtime.UpdateRender())
        }
    },
    SetFullscreenQuality(a) {
        const b = this._runtime.GetCanvasManager();
        b && "off" !== b.GetCurrentFullscreenMode() && (b.SetFullscreenScalingQuality(0 !== a ? "high" : "low"),
        b.SetSize(b.GetLastWidth(), b.GetLastHeight(), !0))
    },
    SaveState(a) {
        this._runtime.SaveToSlot(a)
    },
    LoadState(a) {
        this._runtime.LoadFromSlot(a)
    },
    LoadStateJSON(a) {
        this._runtime.LoadFromJsonString(a)
    },
    SetHalfFramerateMode(a) {},
    ResetPersisted() {
        for (const a of this._runtime.GetLayoutManager().GetAllLayouts())
            a.ResetPersistData()
    },
    SetPixelRounding(a) {
        this._runtime.SetPixelRoundingEnabled(0 !== a)
    },
    SetFramerateMinMax(a, b) {
        this._runtime.SetMaxDt(1 / a);
        this._runtime.SetMinDt(1 / b)
    },
    SetDeltaTimeMinMax(a, b) {
        this._runtime.SetMinDt(a);
        this._runtime.SetMaxDt(b)
    },
    SetFramerateMode(a) {
        this._runtime._SetFramerateMode(["vsync", "unlimited-tick", "unlimited-frame"][a])
    },
    SortZOrderByInstVar(a, b) {
        if (a) {
            var c = a.GetCurrentSol().GetInstances()
              , d = this._runtime.GetCurrentLayout()
              , e = a.IsFamily();
            a = a.GetFamilyIndex();
            for (let h = 0, l = c.length; h < l; ++h) {
                var f = c[h];
                const m = f.GetWorldInfo();
                if (!m)
                    continue;
                let p;
                p = e ? f.GetInstanceVariableValue(b + f.GetObjectClass().GetFamilyInstanceVariableOffset(a)) : f.GetInstanceVariableValue(b);
                tempZOrderList$jscomp$1.push([m.GetLayer().GetIndex(), m.GetZIndex()]);
                tempInstValues.push([f, p])
            }
            if (tempZOrderList$jscomp$1.length) {
                tempZOrderList$jscomp$1.sort(SortZOrderList$jscomp$1);
                tempInstValues.sort(SortInstancesByValue);
                b = !1;
                for (let h = 0, l = tempZOrderList$jscomp$1.length; h < l; ++h)
                    c = tempInstValues[h][0],
                    e = d.GetLayerByIndex(tempZOrderList$jscomp$1[h][0]),
                    a = tempZOrderList$jscomp$1[h][1],
                    f = e._GetInstances(),
                    f[a] !== c && (f[a] = c,
                    c.GetWorldInfo()._SetLayer(e, !0),
                    e.SetZIndicesChanged(c),
                    b = !0);
                b && this._runtime.UpdateRender();
                C3$jscomp$207.clearArray(tempZOrderList$jscomp$1);
                C3$jscomp$207.clearArray(tempInstValues)
            }
        }
    },
    SetCollisionCellSize(a, b) {
        a = Math.floor(a);
        b = Math.floor(b);
        0 >= a || 0 >= b || !Number.isFinite(a) || !Number.isFinite(b) || this._runtime.GetCollisionEngine().SetCollisionCellSize(a, b)
    },
    GoToLayout(a) {
        if (!this._runtime.IsLoading()) {
            var b = this._runtime.GetLayoutManager();
            b.IsPendingChangeMainLayout() || b.ChangeMainLayout(a)
        }
    },
    GoToLayoutByName(a) {
        if (!this._runtime.IsLoading()) {
            var b = this._runtime.GetLayoutManager();
            b.IsPendingChangeMainLayout() || (a = b.GetLayoutByName(a)) && b.ChangeMainLayout(a)
        }
    },
    NextPrevLayout(a) {
        if (!this._runtime.IsLoading()) {
            var b = this._runtime.GetLayoutManager();
            if (!b.IsPendingChangeMainLayout()) {
                var c = b.GetAllLayouts()
                  , d = c.indexOf(b.GetMainRunningLayout());
                a && 0 === d || (a || d !== c.length - 1) && b.ChangeMainLayout(c[d + (a ? -1 : 1)])
            }
        }
    },
    RestartLayout() {
        if (!this._runtime.IsLoading()) {
            var a = this._runtime.GetLayoutManager();
            a.IsPendingChangeMainLayout() || (a.ChangeMainLayout(a.GetMainRunningLayout()),
            this._runtime.GetEventSheetManager().ResetAllGroupsInitialActivation())
        }
    },
    SetLayerVisible(a, b) {
        a && a.SetVisible(b)
    },
    SetLayerInteractive(a, b) {
        a && a.SetInteractive(b)
    },
    SetLayerHTML(a, b) {
        a && a.SetIsHTMLElementsLayer(b)
    },
    SetLayerOpacity(a, b) {
        a && a.SetOpacity(b / 100)
    },
    SetLayerScale(a, b) {
        a && a.SetOwnScale(b)
    },
    SetLayerScaleRate(a, b) {
        a && a.SetScaleRate(b)
    },
    SetLayerAngle(a, b) {
        a && a.SetAngle(C3$jscomp$207.toRadians(+b))
    },
    SetLayerScroll(a, b, c) {
        a && (a.SetOwnScrollPositionEnabled(!0),
        a.SetScrollX(b),
        a.SetScrollY(c))
    },
    RestoreLayerScroll(a) {
        a && a.SetOwnScrollPositionEnabled(!1)
    },
    SetLayerParallax(a, b, c) {
        a && a.SetParallax(b / 100, c / 100)
    },
    SetLayerZElevation(a, b) {
        a && a.SetZElevation(+b)
    },
    SetLayerBackground(a, b) {
        a && (tempColor$jscomp$7.setFromRgbValue(b),
        tempColor$jscomp$7.clamp(),
        a = a.GetBackgroundColor(),
        a.equalsIgnoringAlpha(tempColor$jscomp$7) || (a.copyRgb(tempColor$jscomp$7),
        this.UpdateRender()))
    },
    SetLayerTransparent(a, b) {
        a && a.SetTransparent(b)
    },
    SetLayerBlendMode(a, b) {
        a && a.SetBlendMode(b)
    },
    SetLayerEffectEnabled(a, b, c) {
        a && (c = a.GetEffectList().GetEffectTypeByName(c)) && (b = 1 === b,
        c.IsActive() !== b && (c.SetActive(b),
        a.UpdateActiveEffects(),
        this._runtime.UpdateRender()))
    },
    SetLayerEffectParam(a, b, c, d) {
        if (a && (a = a.GetEffectList(),
        b = a.GetEffectTypeByName(b))) {
            c = Math.floor(c);
            var e = b.GetShaderProgram().GetParameterType(c);
            e && ("color" === e ? (tempColor$jscomp$7.setFromRgbValue(d),
            d = tempColor$jscomp$7) : "percent" === e && (d /= 100),
            a.SetEffectParameter(b.GetIndex(), c, d) && b.IsActive() && this._runtime.UpdateRender())
        }
    },
    SetLayerForceOwnTexture(a, b) {
        a && a.SetForceOwnTexture(b)
    },
    SetLayoutScale(a) {
        this._runtime.GetCurrentLayout().SetScale(+a)
    },
    SetLayoutAngle(a) {
        this._runtime.GetCurrentLayout().SetAngle(C3$jscomp$207.toRadians(+a))
    },
    SetLayoutEffectEnabled(a, b) {
        const c = this._runtime.GetCurrentLayout();
        if (b = c.GetEffectList().GetEffectTypeByName(b))
            a = 1 === a,
            b.IsActive() !== a && (b.SetActive(a),
            c.UpdateActiveEffects(),
            this._runtime.UpdateRender())
    },
    SetLayoutEffectParam(a, b, c) {
        const d = this._runtime.GetCurrentLayout().GetEffectList();
        if (a = d.GetEffectTypeByName(a)) {
            b = Math.floor(b);
            var e = a.GetShaderProgram().GetParameterType(b);
            e && ("color" === e ? (tempColor$jscomp$7.setFromRgbValue(c),
            c = tempColor$jscomp$7) : "percent" === e && (c /= 100),
            d.SetEffectParameter(a.GetIndex(), b, c) && a.IsActive() && this._runtime.UpdateRender())
        }
    },
    SetLayoutVanishingPoint(a, b) {
        this._runtime.GetCurrentLayout().SetVanishingPointXY(a / 100, b / 100)
    },
    SetLayoutProjection(a) {
        const b = this._runtime.GetCurrentLayout();
        0 === a ? b.SetPerspectiveProjection() : b.SetOrthographicProjection()
    },
    ScrollX(a) {
        this._runtime.GetCurrentLayout().SetScrollX(a)
    },
    ScrollY(a) {
        this._runtime.GetCurrentLayout().SetScrollY(a)
    },
    Scroll(a, b) {
        const c = this._runtime.GetCurrentLayout();
        c.SetScrollX(a);
        c.SetScrollY(b)
    },
    ScrollToObject(a) {
        if (a && (a = a.GetFirstPicked()) && (a = a.GetWorldInfo())) {
            var b = this._runtime.GetCurrentLayout();
            b.SetScrollX(a.GetX());
            b.SetScrollY(a.GetY())
        }
    },
    AddLayer(a, b, c) {
        const d = this._runtime.GetCurrentLayout();
        try {
            d.AddLayer(a, b, c)
        } catch (e) {
            console.warn("[Construct] Cannot add layer: ", e)
        }
    },
    MoveLayer(a, b, c) {
        if (a) {
            var d = this._runtime.GetCurrentLayout();
            try {
                d.MoveLayer(a, b, c)
            } catch (e) {
                console.warn("[Construct] Cannot move layer: ", e)
            }
        }
    },
    RemoveLayer(a) {
        a && this._runtime.GetCurrentLayout().RemoveLayer(a)
    },
    RemoveAllDynamicLayers() {
        this._runtime.GetCurrentLayout().RemoveAllDynamicLayers()
    },
    async LoadObjectTextures(a) {
        const b = this._runtime.GetMainRunningLayout();
        b && a && !this._runtime.IsLoading() && (a = a.IsFamily() ? a.GetFamilyMembers() : [a],
        await this._LoadTexturesForObjectClasses(b, a))
    },
    async LoadObjectTexturesByName(a) {
        await C3$jscomp$207.Plugins.System.Acts.LoadObjectTextures.call(this, this._runtime.GetObjectClassByName(a))
    },
    UnloadObjectTextures(a) {
        const b = this._runtime.GetMainRunningLayout();
        b && a && (a = a.IsFamily() ? a.GetFamilyMembers() : [a],
        this._UnloadTexturesForObjectClasses(b, a))
    },
    UnloadObjectTexturesByName(a) {
        C3$jscomp$207.Plugins.System.Acts.UnloadObjectTextures.call(this, this._runtime.GetObjectClassByName(a))
    },
    UnloadUnusedTextures() {
        const a = this._runtime.GetMainRunningLayout();
        if (a) {
            var b = a._GetTextureLoadedObjectTypes();
            this._UnloadTexturesForObjectClasses(a, b)
        }
    },
    async LoadLayoutTextures(a) {
        const b = this._runtime.GetMainRunningLayout();
        a && b && !this._runtime.IsLoading() && await this._LoadTexturesForObjectClasses(b, a._GetInitialObjectClasses())
    },
    async LoadLayoutTexturesByName(a) {
        const b = this._runtime.GetMainRunningLayout();
        (a = this._runtime.GetLayoutManager().GetLayoutByName(a)) && b && !this._runtime.IsLoading() && await this._LoadTexturesForObjectClasses(b, a._GetInitialObjectClasses())
    },
    SetFunctionReturnValue(a) {
        const b = this._eventStack.GetCurrentExpFuncStackFrame();
        if (b)
            switch (b.GetFunctionReturnType()) {
            case 1:
                "number" === typeof a && b.SetFunctionReturnValue(a);
                break;
            case 2:
                "string" === typeof a && b.SetFunctionReturnValue(a);
                break;
            case 3:
                b.SetFunctionReturnValue(a)
            }
    },
    MapFunction(a, b, c) {
        var d = this._GetFunctionMap(a.toLowerCase(), !0);
        const e = d.strMap
          , f = b.toLowerCase();
        e.has(f) && console.warn(`[Construct] Function map '${a}' string '${b}' already in map; overwriting entry`);
        if (d = C3$jscomp$207.first(e.values()) || d.defaultFunc) {
            d = 0 !== d.GetReturnType();
            const h = 0 !== c.GetReturnType();
            if (d !== h) {
                console.error(`[Construct] Function map '${a}' string '${b}' function return type not compatible with other functions in the map; entry ignored`);
                return
            }
        }
        e.set(f, c)
    },
    MapFunctionDefault(a, b) {
        const c = this._GetFunctionMap(a.toLowerCase(), !0);
        c.defaultFunc && console.warn(`[Construct] Function map '${a}' already has a default; overwriting entry`);
        var d = C3$jscomp$207.first(c.strMap.values()) || c.defaultFunc;
        if (d) {
            d = 0 !== d.GetReturnType();
            const e = 0 !== b.GetReturnType();
            if (d !== e) {
                console.error(`[Construct] Function map '${a}' default: function return type not compatible with other functions in the map; entry ignored`);
                return
            }
        }
        c.defaultFunc = b
    },
    CallMappedFunction(a, b, c) {
        c = Math.floor(c);
        var d = this._GetFunctionMap(a.toLowerCase(), !1);
        if (d) {
            var e = d.strMap.get(b.toLowerCase());
            if (!e)
                if (d.defaultFunc)
                    e = d.defaultFunc,
                    c = 0;
                else {
                    console.warn(`[Construct] Call mapped function: no function associated with map '${a}' string '${b}'; call ignored (consider setting a default)`);
                    return
                }
            if (e.IsEnabled())
                if (0 !== e.GetReturnType())
                    console.warn(`[Construct] Call mapped function: map '${a}' string '${b}' has a return type so cannot be called`);
                else {
                    a = this._runtime;
                    b = a.GetEventSheetManager();
                    var f = b.GetCurrentEvent();
                    d = f.GetSolModifiersIncludingParents();
                    var h = 0 < d.length;
                    h && (e.IsCopyPicked() ? b.PushCopySol(d) : b.PushCleanSol(d));
                    var l = [];
                    if (f = b.FindFirstFunctionBlockParent(f)) {
                        f = f.GetFunctionParameters();
                        for (let m = c, p = f.length; m < p; ++m)
                            l.push(f[m].GetValue())
                    }
                    c = e.GetFunctionParameters();
                    for (let m = l.length, p = c.length; m < p; ++m)
                        l.push(c[m].GetInitialValue());
                    return a.IsDebugging() ? this._DebugDoCallMappedFunction(b, e, l, h, d) : this._DoCallMappedFunction(b, e, l, h, d)
                }
        } else
            console.warn(`[Construct] Call mapped function: map name '${a}' not found; call ignored`)
    }
};
const C3$jscomp$208 = self.C3;
C3$jscomp$208.Plugins.System.Exps = {
    int: function(a) {
        "string" === typeof a && (a = parseInt(a, 10),
        isNaN(a) && (a = 0));
        return Math.floor(a)
    },
    float: function(a) {
        "string" === typeof a && (a = parseFloat(a),
        isNaN(a) && (a = 0));
        return a
    },
    str(a) {
        return a.toString()
    },
    len(a) {
        return "string" === typeof a ? a.length : 0
    },
    random(a, b) {
        return "undefined" === typeof b ? this._runtime.Random() * a : this._runtime.Random() * (b - a) + a
    },
    choose(...a) {
        const b = Math.floor(this._runtime.Random() * a.length);
        return a[b]
    },
    chooseindex(a, ...b) {
        "number" !== typeof a && (a = 0);
        a = C3$jscomp$208.clamp(Math.floor(a), 0, b.length - 1);
        return b[a]
    },
    pi() {
        return Math.PI
    },
    infinity() {
        return Infinity
    },
    sqrt(a) {
        return Math.sqrt(a)
    },
    abs(a) {
        return Math.abs(a)
    },
    round(a) {
        return Math.round(a)
    },
    roundtodp(a, b) {
        b = Math.max(Math.floor(b), 0);
        b = Math.pow(10, b);
        return Math.round((a + Number.EPSILON) * b) / b
    },
    floor(a) {
        return Math.floor(a)
    },
    ceil(a) {
        return Math.ceil(a)
    },
    sign(a) {
        return Math.sign(a)
    },
    sin(a) {
        return Math.sin(C3$jscomp$208.toRadians(a))
    },
    cos(a) {
        return Math.cos(C3$jscomp$208.toRadians(a))
    },
    tan(a) {
        return Math.tan(C3$jscomp$208.toRadians(a))
    },
    asin(a) {
        return C3$jscomp$208.toDegrees(Math.asin(a))
    },
    acos(a) {
        return C3$jscomp$208.toDegrees(Math.acos(a))
    },
    atan(a) {
        return C3$jscomp$208.toDegrees(Math.atan(a))
    },
    exp(a) {
        return Math.exp(a)
    },
    ln(a) {
        return Math.log(a)
    },
    log10(a) {
        return Math.log10(a)
    },
    max(...a) {
        let b = a[0];
        "number" !== typeof b && (b = 0);
        for (let c = 1, d = a.length; c < d; ++c) {
            let e = a[c];
            "number" === typeof e && b < e && (b = e)
        }
        return b
    },
    min(...a) {
        let b = a[0];
        "number" !== typeof b && (b = 0);
        for (let c = 1, d = a.length; c < d; ++c) {
            let e = a[c];
            "number" === typeof e && b > e && (b = e)
        }
        return b
    },
    clamp(a, b, c) {
        return C3$jscomp$208.clamp(a, b, c)
    },
    distance(a, b, c, d) {
        return C3$jscomp$208.distanceTo(a, b, c, d)
    },
    angle(a, b, c, d) {
        return C3$jscomp$208.toDegrees(C3$jscomp$208.angleTo(a, b, c, d))
    },
    lerp(a, b, c) {
        return C3$jscomp$208.lerp(a, b, c)
    },
    unlerp(a, b, c) {
        return C3$jscomp$208.unlerp(a, b, c)
    },
    qarp(a, b, c, d) {
        return C3$jscomp$208.qarp(a, b, c, d)
    },
    cubic(a, b, c, d, e) {
        return C3$jscomp$208.cubic(a, b, c, d, e)
    },
    cosp(a, b, c) {
        return C3$jscomp$208.cosp(a, b, c)
    },
    anglediff(a, b) {
        return C3$jscomp$208.toDegrees(C3$jscomp$208.angleDiff(C3$jscomp$208.toRadians(a), C3$jscomp$208.toRadians(b)))
    },
    anglelerp(a, b, c) {
        return C3$jscomp$208.toDegrees(C3$jscomp$208.angleLerp(C3$jscomp$208.toRadians(a), C3$jscomp$208.toRadians(b), c))
    },
    anglerotate(a, b, c) {
        return C3$jscomp$208.toDegrees(C3$jscomp$208.angleRotate(C3$jscomp$208.toRadians(a), C3$jscomp$208.toRadians(b), C3$jscomp$208.toRadians(c)))
    },
    setbit(a, b, c) {
        b |= 0;
        return (a | 0) & ~(1 << b) | (0 !== c ? 1 : 0) << b
    },
    togglebit(a, b) {
        return (a | 0) ^ 1 << (b | 0)
    },
    getbit(a, b) {
        return (a | 0) & 1 << (b | 0) ? 1 : 0
    },
    newline() {
        return "\n"
    },
    uppercase(a) {
        return "string" === typeof a ? a.toUpperCase() : ""
    },
    lowercase(a) {
        return "string" === typeof a ? a.toLowerCase() : ""
    },
    left(a, b) {
        return "string" === typeof a ? a.substr(0, b) : ""
    },
    mid(a, b, c) {
        return "string" !== typeof a ? "" : 0 > c ? a.substr(b) : a.substr(b, c)
    },
    right(a, b) {
        return "string" === typeof a ? a.substr(Math.max(a.length - b, 0)) : ""
    },
    trim(a) {
        return "string" === typeof a ? a.trim() : ""
    },
    tokenat(a, b, c) {
        if ("string" !== typeof a || "string" !== typeof c)
            return "";
        a = a.split(c);
        b = Math.floor(b);
        return 0 > b || b >= a.length ? "" : a[b]
    },
    tokencount(a, b) {
        return "string" === typeof a && "string" === typeof b && a.length ? a.split(b).length : 0
    },
    find(a, b) {
        return "string" === typeof a && "string" === typeof b ? a.search(new RegExp(C3$jscomp$208.EscapeRegex(b),"i")) : -1
    },
    findcase(a, b) {
        return "string" === typeof a && "string" === typeof b ? a.search(new RegExp(C3$jscomp$208.EscapeRegex(b),"")) : -1
    },
    replace(a, b, c) {
        return "string" === typeof a && "string" === typeof b && "string" === typeof c ? a.replace(new RegExp(C3$jscomp$208.EscapeRegex(b),"gi"), c) : "string" === typeof a ? a : ""
    },
    stringsub(a, ...b) {
        for (let c = 0, d = b.length; c < d; ++c)
            a = a.replaceAll(`{${c}}`, b[c].toString());
        return a
    },
    regexsearch(a, b, c) {
        b = this.GetRegex(b, c);
        return a ? a.search(b) : -1
    },
    regexreplace(a, b, c, d) {
        b = this.GetRegex(b, c);
        return a ? a.replace(b, d) : ""
    },
    regexmatchcount(a, b, c) {
        return (a = this.GetRegexMatches(a.toString(), b, c)) ? a.length : 0
    },
    regexmatchat(a, b, c, d) {
        d = Math.floor(d);
        a = this.GetRegexMatches(a.toString(), b, c);
        return !a || 0 > d || d >= a.length ? "" : a[d]
    },
    zeropad(a, b) {
        let c = 0 > a ? "-" : "";
        0 > a && (a = -a);
        c += "0".repeat(Math.max(b - a.toString().length, 0));
        return c + a.toString()
    },
    urlencode(a) {
        return encodeURIComponent(a)
    },
    urldecode(a) {
        return decodeURIComponent(a)
    },
    dt() {
        return this._runtime._GetDtFast()
    },
    timescale() {
        return this._runtime.GetTimeScale()
    },
    wallclocktime() {
        return (Date.now() - this._runtime.GetStartTime()) / 1E3
    },
    unixtime() {
        return Date.now()
    },
    time() {
        return this._runtime.GetGameTime()
    },
    tickcount() {
        return this._runtime.GetTickCount()
    },
    objectcount() {
        return this._runtime.GetObjectCount()
    },
    fps() {
        return this._runtime.GetFramesPerSecond()
    },
    cpuutilisation() {
        return this._runtime.GetMainThreadTime()
    },
    gpuutilisation() {
        return this._runtime.GetGPUUtilisation()
    },
    windowwidth() {
        return this._runtime.GetCanvasManager().GetDeviceWidth()
    },
    windowheight() {
        return this._runtime.GetCanvasManager().GetDeviceHeight()
    },
    originalwindowwidth() {
        return this._runtime.GetOriginalViewportWidth()
    },
    originalwindowheight() {
        return this._runtime.GetOriginalViewportHeight()
    },
    originalviewportwidth() {
        return this._runtime.GetOriginalViewportWidth()
    },
    originalviewportheight() {
        return this._runtime.GetOriginalViewportHeight()
    },
    scrollx() {
        return this._runtime.GetCurrentLayout().GetScrollX()
    },
    scrolly() {
        return this._runtime.GetCurrentLayout().GetScrollY()
    },
    layoutname() {
        return this._runtime.GetCurrentLayout().GetName()
    },
    layoutscale() {
        return this._runtime.GetCurrentLayout().GetScale()
    },
    layoutangle() {
        return C3$jscomp$208.toDegrees(this._runtime.GetCurrentLayout().GetAngle())
    },
    layoutwidth() {
        return this._runtime.GetCurrentLayout().GetWidth()
    },
    layoutheight() {
        return this._runtime.GetCurrentLayout().GetHeight()
    },
    vanishingpointx() {
        return 100 * this._runtime.GetCurrentLayout().GetVanishingPointX()
    },
    vanishingpointy() {
        return 100 * this._runtime.GetCurrentLayout().GetVanishingPointY()
    },
    viewportleft(a) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.GetViewport3D().getLeft() : 0
    },
    viewporttop(a) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.GetViewport3D().getTop() : 0
    },
    viewportright(a) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.GetViewport3D().getRight() : 0
    },
    viewportbottom(a) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.GetViewport3D().getBottom() : 0
    },
    viewportwidth(a) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.GetViewport3D().width() : 0
    },
    viewportheight(a) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.GetViewport3D().height() : 0
    },
    viewportmidx(a) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? (a = a.GetViewport3D(),
        (a.getLeft() + a.getRight()) / 2) : 0
    },
    viewportmidy(a) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? (a = a.GetViewport3D(),
        (a.getTop() + a.getBottom()) / 2) : 0
    },
    canvastolayerx(a, b, c) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.CanvasCssToLayer(b, c)[0] : 0
    },
    canvastolayery(a, b, c) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.CanvasCssToLayer(b, c)[1] : 0
    },
    layertocanvasx(a, b, c) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.LayerToCanvasCss(b, c)[0] : 0
    },
    layertocanvasy(a, b, c) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.LayerToCanvasCss(b, c)[1] : 0
    },
    layertolayerx(a, b, c, d) {
        const e = this._runtime.GetCurrentLayout();
        a = e.GetLayer(a);
        b = e.GetLayer(b);
        if (!a || !b || a === b)
            return c;
        const [f,h] = a.LayerToCanvasCss(c, d);
        return b.CanvasCssToLayer(f, h)[0]
    },
    layertolayery(a, b, c, d) {
        const e = this._runtime.GetCurrentLayout();
        a = e.GetLayer(a);
        b = e.GetLayer(b);
        if (!a || !b || a === b)
            return d;
        const [f,h] = a.LayerToCanvasCss(c, d);
        return b.CanvasCssToLayer(f, h)[1]
    },
    layerscale(a) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.GetOwnScale() : 0
    },
    layerangle(a) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? C3$jscomp$208.toDegrees(a.GetOwnAngle()) : 0
    },
    layeropacity(a) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? 100 * a.GetOpacity() : 0
    },
    layerscalerate(a) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.GetScaleRate() : 0
    },
    layerscrollx(a) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.GetScrollX() : 0
    },
    layerscrolly(a) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.GetScrollY() : 0
    },
    layerparallaxx(a) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? 100 * a.GetParallaxX() : 0
    },
    layerparallaxy(a) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? 100 * a.GetParallaxY() : 0
    },
    layerzelevation(a) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.GetZElevation() : 0
    },
    layerindex(a) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.GetIndex() : -1
    },
    canvassnapshot() {
        const a = this._runtime.GetCanvasManager();
        return a ? a.GetCanvasSnapshotUrl() : ""
    },
    loopindex(a) {
        const b = this._loopStack;
        return b.IsInLoop() ? a ? (a = b.FindByName(a)) ? a.GetIndex() : 0 : b.GetCurrent().GetIndex() : 0
    },
    savestatejson() {
        return this._runtime.GetLastSaveJsonString()
    },
    callmapped(a, b, ...c) {
        var d = this._GetFunctionMap(a.toLowerCase(), !1);
        if (!d)
            return console.warn(`[Construct] Call mapped function: map name '${a}' not found; returning 0`),
            0;
        let e = d.strMap.get(b.toLowerCase());
        if (!e)
            if (d.defaultFunc)
                e = d.defaultFunc;
            else
                return console.warn(`[Construct] Call mapped function: no function associated with map '${a}' string '${b}'; returning 0 (consider setting a default)`),
                0;
        d = e.GetReturnType();
        const f = e.GetDefaultReturnValue();
        if (0 === d)
            return console.warn(`[Construct] Call mapped function: map '${a}' string '${b}' has no return type so cannot be called from an expression; returning 0`),
            0;
        if (!e.IsEnabled())
            return f;
        a = this._runtime.GetEventSheetManager();
        b = a.GetCurrentEvent().GetSolModifiersIncludingParents();
        const h = 0 < b.length;
        h && (e.IsCopyPicked() ? a.PushCopySol(b) : a.PushCleanSol(b));
        var l = e.GetFunctionParameters();
        for (let m = c.length, p = l.length; m < p; ++m)
            c.push(l[m].GetInitialValue());
        l = e.GetEventBlock();
        c = l.RunAsExpressionFunctionCall(l.GetSolModifiersIncludingParents(), e.IsCopyPicked(), d, f, ...c);
        h && a.PopSol(b);
        return c
    },
    loadingprogress() {
        return this._runtime.GetAssetManager().GetLoadProgress()
    },
    imageloadingprogress() {
        return 0 === this._imagesLoadingTotal ? 1 : this._imagesLoadingComplete / this._imagesLoadingTotal
    },
    renderer() {
        return this._runtime.GetWebGPURenderer() ? "webgpu" : "webgl"
    },
    rendererdetail() {
        return this._runtime.GetWebGPURenderer() ? this._runtime.GetWebGPURenderer().GetAdapterInfoString() : this._runtime.GetWebGLRenderer().GetUnmaskedRenderer()
    },
    imagememoryusage() {
        let a = this._runtime.GetRenderer().GetEstimatedTextureMemoryUsage();
        return Math.round(100 * a / 1048576) / 100
    },
    rgb(a, b, c) {
        return C3$jscomp$208.PackRGB(a, b, c)
    },
    rgbex(a, b, c) {
        return C3$jscomp$208.PackRGBEx(a / 100, b / 100, c / 100)
    },
    rgba(a, b, c, d) {
        return C3$jscomp$208.PackRGBAEx(a / 100, b / 100, c / 100, d / 100)
    },
    rgbex255(a, b, c) {
        return C3$jscomp$208.PackRGBEx(a / 255, b / 255, c / 255)
    },
    rgba255(a, b, c, d) {
        return C3$jscomp$208.PackRGBAEx(a / 255, b / 255, c / 255, d / 255)
    },
    projectname() {
        return this._runtime.GetProjectName()
    },
    projectversion() {
        return this._runtime.GetProjectVersion()
    },
    currenteventsheetname() {
        return this._runtime.GetCurrentEvent().GetEventSheet().GetName()
    },
    currenteventnumber() {
        return this._runtime.GetCurrentEvent().GetDisplayNumber()
    }
};
"use strict";
const C3$jscomp$209 = self.C3;
C3$jscomp$209.Plugins.Keyboard = class extends C3$jscomp$209.SDKPluginBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
}
;
const C3$jscomp$210 = self.C3;
C3$jscomp$210.Plugins.Keyboard.Type = class extends C3$jscomp$210.SDKTypeBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
    GetScriptInterfaceClass() {
        return self.IKeyboardObjectType
    }
}
;
let keyboardObjectType = null;
function GetKeyboardSdkInstance() {
    return keyboardObjectType.GetSingleGlobalInstance().GetSdkInstance()
}
self.IKeyboardObjectType = class extends self.IObjectClass {
    constructor(a) {
        super(a);
        keyboardObjectType = a;
        a.GetRuntime()._GetCommonScriptInterfaces().keyboard = this
    }
    isKeyDown(a) {
        const b = GetKeyboardSdkInstance();
        if ("string" === typeof a)
            return b.IsKeyDown(a);
        if ("number" === typeof a)
            return b.IsKeyCodeDown(a);
        throw new TypeError("expected string or number");
    }
}
;
const C3$jscomp$211 = self.C3;
C3$jscomp$211.Plugins.Keyboard.Instance = class extends C3$jscomp$211.SDKInstanceBase {
    constructor(a, b) {
        super(a);
        this._keysDownByString = new Set;
        this._keysDownByWhich = new Set;
        this._triggerWhich = 0;
        this._triggerTypedKey = this._triggerString = "";
        a = this.GetRuntime().Dispatcher();
        this._disposables = new C3$jscomp$211.CompositeDisposable(C3$jscomp$211.Disposable.From(a, "keydown", c => this._OnKeyDown(c.data)),C3$jscomp$211.Disposable.From(a, "keyup", c => this._OnKeyUp(c.data)),C3$jscomp$211.Disposable.From(a, "window-blur", () => this._OnWindowOrKeyboardBlur()),C3$jscomp$211.Disposable.From(a, "keyboard-blur", () => this._OnWindowOrKeyboardBlur()))
    }
    Release() {
        super.Release()
    }
    _OnKeyDown(a) {
        const b = a.which
          , c = a.code || b.toString();
        a = a.key;
        this._keysDownByString.has(c) || (this._keysDownByString.add(c),
        this._keysDownByWhich.add(b),
        this._triggerString = c,
        this._triggerWhich = b,
        this._triggerTypedKey = a,
        this.Trigger(C3$jscomp$211.Plugins.Keyboard.Cnds.OnAnyKey),
        this.Trigger(C3$jscomp$211.Plugins.Keyboard.Cnds.OnKey),
        this.Trigger(C3$jscomp$211.Plugins.Keyboard.Cnds.OnLeftRightKeyPressed),
        this.Trigger(C3$jscomp$211.Plugins.Keyboard.Cnds.OnKeyCode))
    }
    _OnKeyUp(a) {
        const b = a.which
          , c = a.code || b.toString();
        a = a.key;
        this._keysDownByString.delete(c);
        this._keysDownByWhich.delete(b);
        this._triggerString = c;
        this._triggerWhich = b;
        this._triggerTypedKey = a;
        this.Trigger(C3$jscomp$211.Plugins.Keyboard.Cnds.OnAnyKeyReleased);
        this.Trigger(C3$jscomp$211.Plugins.Keyboard.Cnds.OnKeyReleased);
        this.Trigger(C3$jscomp$211.Plugins.Keyboard.Cnds.OnLeftRightKeyReleased);
        this.Trigger(C3$jscomp$211.Plugins.Keyboard.Cnds.OnKeyCodeReleased)
    }
    _OnWindowOrKeyboardBlur() {
        for (const a of this._keysDownByWhich)
            this._keysDownByWhich.delete(a),
            this._triggerWhich = a,
            this.Trigger(C3$jscomp$211.Plugins.Keyboard.Cnds.OnAnyKeyReleased),
            this.Trigger(C3$jscomp$211.Plugins.Keyboard.Cnds.OnKeyReleased),
            this.Trigger(C3$jscomp$211.Plugins.Keyboard.Cnds.OnKeyCodeReleased);
        this._keysDownByString.clear()
    }
    IsKeyDown(a) {
        return this._keysDownByString.has(a)
    }
    IsKeyCodeDown(a) {
        return this._keysDownByWhich.has(a)
    }
    SaveToJson() {
        return {
            tk: this._triggerWhich,
            tkk: this._triggerTypedKey
        }
    }
    LoadFromJson(a) {
        this._triggerWhich = a.tk;
        a.hasOwnProperty("tkk") && (this._triggerTypedKey = a.tkk)
    }
    GetDebuggerProperties() {
        return [{
            title: "plugins.keyboard.name",
            properties: [{
                name: "plugins.keyboard.debugger.last-key-code",
                value: this._triggerWhich
            }, {
                name: "plugins.keyboard.debugger.last-key-string",
                value: C3$jscomp$211.Plugins.Keyboard.Exps.StringFromKeyCode(this._triggerWhich)
            }, {
                name: "plugins.keyboard.debugger.last-typed-key",
                value: this._triggerTypedKey
            }]
        }]
    }
}
;
const LEFTRIGHT_KEY_STRINGS = "ShiftLeft ShiftRight ControlLeft ControlRight AltLeft AltRight MetaLeft MetaRight".split(" ");
self.C3.Plugins.Keyboard.Cnds = {
    IsKeyDown(a) {
        return this._keysDownByWhich.has(a)
    },
    OnKey(a) {
        return this._triggerWhich === a
    },
    OnAnyKey() {
        return !0
    },
    OnAnyKeyReleased() {
        return !0
    },
    OnKeyReleased(a) {
        return this._triggerWhich === a
    },
    IsKeyCodeDown(a) {
        a = Math.floor(a);
        return this._keysDownByWhich.has(a)
    },
    OnKeyCode(a) {
        return this._triggerWhich === a
    },
    OnKeyCodeReleased(a) {
        return this._triggerWhich === a
    },
    OnLeftRightKeyPressed(a) {
        return this._triggerString === LEFTRIGHT_KEY_STRINGS[a]
    },
    OnLeftRightKeyReleased(a) {
        return this._triggerString === LEFTRIGHT_KEY_STRINGS[a]
    },
    IsLeftRightKeyDown(a) {
        return this._keysDownByString.has(LEFTRIGHT_KEY_STRINGS[a])
    }
};
self.C3.Plugins.Keyboard.Acts = {};
function StringFromCharCode(a) {
    a = Math.floor(a);
    switch (a) {
    case 8:
        return "backspace";
    case 9:
        return "tab";
    case 13:
        return "enter";
    case 16:
        return "shift";
    case 17:
        return "control";
    case 18:
        return "alt";
    case 19:
        return "pause";
    case 20:
        return "capslock";
    case 27:
        return "esc";
    case 33:
        return "pageup";
    case 34:
        return "pagedown";
    case 35:
        return "end";
    case 36:
        return "home";
    case 37:
        return "\u2190";
    case 38:
        return "\u2191";
    case 39:
        return "\u2192";
    case 40:
        return "\u2193";
    case 45:
        return "insert";
    case 46:
        return "del";
    case 91:
        return "left window key";
    case 92:
        return "right window key";
    case 93:
        return "select";
    case 96:
        return "numpad 0";
    case 97:
        return "numpad 1";
    case 98:
        return "numpad 2";
    case 99:
        return "numpad 3";
    case 100:
        return "numpad 4";
    case 101:
        return "numpad 5";
    case 102:
        return "numpad 6";
    case 103:
        return "numpad 7";
    case 104:
        return "numpad 8";
    case 105:
        return "numpad 9";
    case 106:
        return "numpad *";
    case 107:
        return "numpad +";
    case 109:
        return "numpad -";
    case 110:
        return "numpad .";
    case 111:
        return "numpad /";
    case 112:
        return "F1";
    case 113:
        return "F2";
    case 114:
        return "F3";
    case 115:
        return "F4";
    case 116:
        return "F5";
    case 117:
        return "F6";
    case 118:
        return "F7";
    case 119:
        return "F8";
    case 120:
        return "F9";
    case 121:
        return "F10";
    case 122:
        return "F11";
    case 123:
        return "F12";
    case 144:
        return "numlock";
    case 145:
        return "scroll lock";
    case 186:
        return ";";
    case 187:
        return "=";
    case 188:
        return ",";
    case 189:
        return "-";
    case 190:
        return ".";
    case 191:
        return "/";
    case 192:
        return "'";
    case 219:
        return "[";
    case 220:
        return "\\";
    case 221:
        return "]";
    case 222:
        return "#";
    case 223:
        return "`";
    default:
        return String.fromCharCode(a)
    }
}
self.C3.Plugins.Keyboard.Exps = {
    LastKeyCode() {
        return this._triggerWhich
    },
    StringFromKeyCode(a) {
        return StringFromCharCode(a)
    },
    TypedKey() {
        return this._triggerTypedKey
    }
};
"use strict";
const C3$jscomp$215 = self.C3;
C3$jscomp$215.Plugins.Touch = class extends C3$jscomp$215.SDKPluginBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
}
;
const C3$jscomp$216 = self.C3
  , C3X$jscomp$35 = self.C3X;
C3$jscomp$216.Plugins.Touch.Type = class extends C3$jscomp$216.SDKTypeBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
    GetScriptInterfaceClass() {
        return self.ITouchObjectType
    }
}
;
let touchObjectType = null;
function GetTouchSdkInstance() {
    return touchObjectType.GetSingleGlobalInstance().GetSdkInstance()
}
self.ITouchObjectType = class extends self.IObjectClass {
    constructor(a) {
        super(a);
        touchObjectType = a;
        a.GetRuntime()._GetCommonScriptInterfaces().touch = this
    }
    requestPermission(a) {
        C3X$jscomp$35.RequireString(a);
        const b = GetTouchSdkInstance();
        if ("orientation" === a)
            return b._RequestPermission(0);
        if ("motion" === a)
            return b._RequestPermission(1);
        throw Error("invalid type");
    }
}
;
const C3$jscomp$217 = self.C3;
C3$jscomp$217.Plugins.Touch.Instance = class extends C3$jscomp$217.SDKInstanceBase {
    constructor(a, b) {
        super(a, "touch");
        this._touches = new Map;
        this._isMouseDown = this._useMouseInput = !1;
        this._triggerType = this._getTouchIndex = this._curTouchY = this._curTouchX = this._triggerPermission = this._triggerId = this._triggerIndex = this._accWithGZ = this._accWithGY = this._accWithGX = this._accZ = this._accY = this._accX = this._orientGamma = this._orientBeta = this._orientAlpha = this._orientCompassHeading = 0;
        this._permissionPromises = [];
        b && (this._useMouseInput = b[0]);
        this.AddDOMMessageHandler("permission-result", c => this._OnPermissionResult(c));
        a = this.GetRuntime().Dispatcher();
        this._disposables = new C3$jscomp$217.CompositeDisposable(C3$jscomp$217.Disposable.From(a, "pointerdown", c => this._OnPointerDown(c.data)),C3$jscomp$217.Disposable.From(a, "pointermove", c => this._OnPointerMove(c.data)),C3$jscomp$217.Disposable.From(a, "pointerup", c => this._OnPointerUp(c.data, !1)),C3$jscomp$217.Disposable.From(a, "pointercancel", c => this._OnPointerUp(c.data, !0)),C3$jscomp$217.Disposable.From(a, "deviceorientation", c => this._OnDeviceOrientation(c.data)),C3$jscomp$217.Disposable.From(a, "deviceorientationabsolute", c => this._OnDeviceOrientationAbsolute(c.data)),C3$jscomp$217.Disposable.From(a, "devicemotion", c => this._OnDeviceMotion(c.data)),C3$jscomp$217.Disposable.From(a, "tick2", c => this._OnTick2()))
    }
    Release() {
        this._touches.clear();
        super.Release()
    }
    _OnPointerDown(a) {
        if ("mouse" === a.pointerType)
            if (this._useMouseInput)
                this._isMouseDown = !0;
            else
                return;
        const b = a.pointerId;
        if (!this._touches.has(b)) {
            var c = a.pageX - this._runtime.GetCanvasClientX();
            a = a.pageY - this._runtime.GetCanvasClientY();
            var d = performance.now()
              , e = this._touches.size;
            this._triggerIndex = e;
            this._triggerId = b;
            var f = C3$jscomp$217.New(C3$jscomp$217.Plugins.Touch.TouchInfo);
            f.Init(d, c, a, b, e);
            this._touches.set(b, f);
            this.Trigger(C3$jscomp$217.Plugins.Touch.Cnds.OnNthTouchStart);
            this.Trigger(C3$jscomp$217.Plugins.Touch.Cnds.OnTouchStart);
            this._curTouchX = c;
            this._curTouchY = a;
            this._triggerType = 0;
            this.Trigger(C3$jscomp$217.Plugins.Touch.Cnds.OnTouchObject)
        }
    }
    _OnPointerMove(a) {
        if ("mouse" !== a.pointerType || this._isMouseDown) {
            var b = this._touches.get(a.pointerId);
            if (b) {
                var c = performance.now();
                if (!(2 > c - b.GetTime())) {
                    var d = a.pageX - this._runtime.GetCanvasClientX()
                      , e = a.pageY - this._runtime.GetCanvasClientY();
                    b.Update(c, d, e, a.width, a.height, a.pressure)
                }
            }
        }
    }
    _OnPointerUp(a, b) {
        if ("mouse" === a.pointerType)
            if (this._isMouseDown)
                this._isMouseDown = !1;
            else
                return;
        const c = performance.now()
          , d = a.pointerId
          , e = this._touches.get(d);
        if (e) {
            this._triggerIndex = e.GetStartIndex();
            this._triggerId = e.GetId();
            if (!b) {
                const f = a.pageX - this._runtime.GetCanvasClientX();
                a = a.pageY - this._runtime.GetCanvasClientY();
                this._curTouchX = f;
                this._curTouchY = a;
                this._triggerType = 1;
                this.Trigger(C3$jscomp$217.Plugins.Touch.Cnds.OnTouchObject)
            }
            this.Trigger(C3$jscomp$217.Plugins.Touch.Cnds.OnNthTouchEnd);
            this.Trigger(C3$jscomp$217.Plugins.Touch.Cnds.OnTouchEnd);
            b || (b = e.ShouldTriggerTap(c),
            "single-tap" === b ? (this.Trigger(C3$jscomp$217.Plugins.Touch.Cnds.OnTapGesture),
            this._curTouchX = e.GetX(),
            this._curTouchY = e.GetY(),
            this.Trigger(C3$jscomp$217.Plugins.Touch.Cnds.OnTapGestureObject)) : "double-tap" === b && (this.Trigger(C3$jscomp$217.Plugins.Touch.Cnds.OnDoubleTapGesture),
            this._curTouchX = e.GetX(),
            this._curTouchY = e.GetY(),
            this.Trigger(C3$jscomp$217.Plugins.Touch.Cnds.OnDoubleTapGestureObject)));
            e.Release();
            this._touches.delete(d)
        }
    }
    _RequestPermission(a) {
        this._PostToDOMMaybeSync("request-permission", {
            type: a
        });
        return new Promise( (b, c) => {
            this._permissionPromises.push({
                type: a,
                resolve: b,
                reject: c
            })
        }
        )
    }
    _OnPermissionResult(a) {
        const b = a.result
          , c = a.type;
        this._triggerPermission = c;
        a = this._permissionPromises.filter(d => d.type === c);
        for (const d of a)
            d.resolve(b ? "granted" : "denied");
        this._permissionPromises = this._permissionPromises.filter(d => d.type !== c);
        b ? (this.Trigger(C3$jscomp$217.Plugins.Touch.Cnds.OnPermissionGranted),
        0 === c ? this._runtime.RequestDeviceOrientationEvent() : this._runtime.RequestDeviceMotionEvent()) : this.Trigger(C3$jscomp$217.Plugins.Touch.Cnds.OnPermissionDenied)
    }
    _OnDeviceOrientation(a) {
        "number" === typeof a.webkitCompassHeading ? this._orientCompassHeading = a.webkitCompassHeading : a.absolute && (this._orientCompassHeading = a.alpha);
        this._orientAlpha = a.alpha;
        this._orientBeta = a.beta;
        this._orientGamma = a.gamma
    }
    _OnDeviceOrientationAbsolute(a) {
        this._orientCompassHeading = a.alpha
    }
    _OnDeviceMotion(a) {
        const b = a.acceleration;
        b && (this._accX = b.x,
        this._accY = b.y,
        this._accZ = b.z);
        if (a = a.accelerationIncludingGravity)
            this._accWithGX = a.x,
            this._accWithGY = a.y,
            this._accWithGZ = a.z
    }
    _OnTick2() {
        const a = performance.now();
        let b = 0;
        for (const c of this._touches.values())
            c.GetTime() <= a - 50 && c._SetLastTime(a),
            c.ShouldTriggerHold(a) && (this._triggerIndex = c.GetStartIndex(),
            this._triggerId = c.GetId(),
            this._getTouchIndex = b,
            this.Trigger(C3$jscomp$217.Plugins.Touch.Cnds.OnHoldGesture),
            this._curTouchX = c.GetX(),
            this._curTouchY = c.GetY(),
            this.Trigger(C3$jscomp$217.Plugins.Touch.Cnds.OnHoldGestureObject),
            this._getTouchIndex = 0),
            ++b
    }
    _GetTouchByIndex(a) {
        a = Math.floor(a);
        for (const b of this._touches.values()) {
            if (0 === a)
                return b;
            --a
        }
        return null
    }
    _IsClientPosOnCanvas(a, b) {
        return 0 <= a && 0 <= b && a < this._runtime.GetCanvasCssWidth() && b < this._runtime.GetCanvasCssHeight()
    }
    GetDebuggerProperties() {
        return [{
            title: "plugins.touch.debugger.touches",
            properties: [...this._touches.values()].map(a => ({
                name: "$" + a.GetId(),
                value: a.GetX() + ", " + a.GetY()
            }))
        }]
    }
}
;
const C3$jscomp$218 = self.C3;
C3$jscomp$218.Plugins.Touch.Cnds = {
    OnTouchStart() {
        return !0
    },
    OnTouchEnd() {
        return !0
    },
    IsInTouch() {
        return 0 < this._touches.size
    },
    OnTouchObject(a, b) {
        return a && b === this._triggerType && this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY) ? this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(a, [[this._curTouchX, this._curTouchY]], !1) : !1
    },
    IsTouchingObject(a) {
        if (!a)
            return !1;
        const b = this._runtime.GetCurrentCondition().IsInverted()
          , c = [...this._touches.values()].filter(d => this._IsClientPosOnCanvas(d.GetX(), d.GetY())).map(d => [d.GetX(), d.GetY()]);
        return C3$jscomp$218.xor(this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(a, c, b), b)
    },
    CompareTouchSpeed(a, b, c) {
        return (a = this._GetTouchByIndex(a)) ? C3$jscomp$218.compare(a.GetSpeed(), b, c) : !1
    },
    OrientationSupported() {
        return !0
    },
    MotionSupported() {
        return !0
    },
    CompareOrientation(a, b, c) {
        this._runtime.RequestDeviceOrientationEvent();
        return C3$jscomp$218.compare(0 === a ? this._orientAlpha : 1 === a ? this._orientBeta : this._orientGamma, b, c)
    },
    CompareAcceleration(a, b, c) {
        this._runtime.RequestDeviceMotionEvent();
        return C3$jscomp$218.compare(0 === a ? this._accWithGX : 1 === a ? this._accWithGY : 2 === a ? this._accWithGZ : 3 === a ? this._accX : 4 === a ? this._accY : this._accZ, b, c)
    },
    OnNthTouchStart(a) {
        a = Math.floor(a);
        return a === this._triggerIndex
    },
    OnNthTouchEnd(a) {
        a = Math.floor(a);
        return a === this._triggerIndex
    },
    HasNthTouch(a) {
        a = Math.floor(a);
        return this._touches.size >= a + 1
    },
    OnHoldGesture() {
        return !0
    },
    OnTapGesture() {
        return !0
    },
    OnDoubleTapGesture() {
        return !0
    },
    OnHoldGestureObject(a) {
        return a && this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY) ? this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(a, [[this._curTouchX, this._curTouchY]], !1) : !1
    },
    OnTapGestureObject(a) {
        return a && this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY) ? this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(a, [[this._curTouchX, this._curTouchY]], !1) : !1
    },
    OnDoubleTapGestureObject(a) {
        return a && this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY) ? this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(a, [[this._curTouchX, this._curTouchY]], !1) : !1
    },
    OnPermissionGranted(a) {
        return this._triggerPermission === a
    },
    OnPermissionDenied(a) {
        return this._triggerPermission === a
    }
};
self.C3.Plugins.Touch.Acts = {
    RequestPermission(a) {
        this._RequestPermission(a)
    }
};
const C3$jscomp$220 = self.C3;
C3$jscomp$220.Plugins.Touch.Exps = {
    TouchCount() {
        return this._touches.size
    },
    X(a) {
        const b = this._GetTouchByIndex(this._getTouchIndex);
        return b ? b.GetPositionForLayer(this._runtime.GetCurrentLayout(), a, !0) : 0
    },
    Y(a) {
        const b = this._GetTouchByIndex(this._getTouchIndex);
        return b ? b.GetPositionForLayer(this._runtime.GetCurrentLayout(), a, !1) : 0
    },
    XAt(a, b) {
        return (a = this._GetTouchByIndex(a)) ? a.GetPositionForLayer(this._runtime.GetCurrentLayout(), b, !0) : 0
    },
    YAt(a, b) {
        return (a = this._GetTouchByIndex(a)) ? a.GetPositionForLayer(this._runtime.GetCurrentLayout(), b, !1) : 0
    },
    XForID(a, b) {
        return (a = this._touches.get(a)) ? a.GetPositionForLayer(this._runtime.GetCurrentLayout(), b, !0) : 0
    },
    YForID(a, b) {
        return (a = this._touches.get(a)) ? a.GetPositionForLayer(this._runtime.GetCurrentLayout(), b, !1) : 0
    },
    AbsoluteX() {
        const a = this._GetTouchByIndex(0);
        return a ? a.GetX() : 0
    },
    AbsoluteY() {
        const a = this._GetTouchByIndex(0);
        return a ? a.GetY() : 0
    },
    AbsoluteXAt(a) {
        return (a = this._GetTouchByIndex(a)) ? a.GetX() : 0
    },
    AbsoluteYAt(a) {
        return (a = this._GetTouchByIndex(a)) ? a.GetY() : 0
    },
    AbsoluteXForID(a) {
        return (a = this._touches.get(a)) ? a.GetX() : 0
    },
    AbsoluteYForID(a) {
        return (a = this._touches.get(a)) ? a.GetY() : 0
    },
    SpeedAt(a) {
        return (a = this._GetTouchByIndex(a)) ? a.GetSpeed() : 0
    },
    SpeedForID(a) {
        return (a = this._touches.get(a)) ? a.GetSpeed() : 0
    },
    AngleAt(a) {
        return (a = this._GetTouchByIndex(a)) ? C3$jscomp$220.toDegrees(a.GetAngle()) : 0
    },
    AngleForID(a) {
        return (a = this._touches.get(a)) ? C3$jscomp$220.toDegrees(a.GetAngle()) : 0
    },
    CompassHeading() {
        this._runtime.RequestDeviceOrientationEvent();
        return this._orientCompassHeading
    },
    Alpha() {
        this._runtime.RequestDeviceOrientationEvent();
        return this._orientAlpha
    },
    Beta() {
        this._runtime.RequestDeviceOrientationEvent();
        return this._orientBeta
    },
    Gamma() {
        this._runtime.RequestDeviceOrientationEvent();
        return this._orientGamma
    },
    AccelerationXWithG() {
        this._runtime.RequestDeviceMotionEvent();
        return this._accWithGX
    },
    AccelerationYWithG() {
        this._runtime.RequestDeviceMotionEvent();
        return this._accWithGY
    },
    AccelerationZWithG() {
        this._runtime.RequestDeviceMotionEvent();
        return this._accWithGZ
    },
    AccelerationX() {
        this._runtime.RequestDeviceMotionEvent();
        return this._accX
    },
    AccelerationY() {
        this._runtime.RequestDeviceMotionEvent();
        return this._accY
    },
    AccelerationZ() {
        this._runtime.RequestDeviceMotionEvent();
        return this._accZ
    },
    TouchIndex() {
        return this._triggerIndex
    },
    TouchID() {
        return this._triggerId
    },
    WidthForID(a) {
        return (a = this._touches.get(a)) ? a.GetWidth() : 0
    },
    HeightForID(a) {
        return (a = this._touches.get(a)) ? a.GetHeight() : 0
    },
    PressureForID(a) {
        return (a = this._touches.get(a)) ? a.GetPressure() : 0
    }
};
"use strict";
const C3$jscomp$221 = self.C3;
let lastTapX = -1E3
  , lastTapY = -1E3
  , lastTapTime = -1E4;
C3$jscomp$221.Plugins.Touch.TouchInfo = class extends C3$jscomp$221.DefendedBase {
    constructor() {
        super();
        this._pressure = this._height = this._width = this._lastY = this._lastX = this._y = this._x = this._startY = this._startX = this._lastTime = this._time = this._startTime = this._startIndex = this._pointerId = 0;
        this._isTooFarForHold = this._hasTriggeredHold = !1
    }
    Release() {}
    Init(a, b, c, d, e) {
        this._pointerId = d;
        this._startIndex = e;
        this._startTime = this._lastTime = this._time = a;
        this._startX = b;
        this._startY = c;
        this._x = b;
        this._y = c;
        this._lastX = b;
        this._lastY = c
    }
    Update(a, b, c, d, e, f) {
        this._lastTime = this._time;
        this._time = a;
        this._lastX = this._x;
        this._lastY = this._y;
        this._x = b;
        this._y = c;
        this._width = d;
        this._height = e;
        this._pressure = f;
        !this._isTooFarForHold && 15 <= C3$jscomp$221.distanceTo(this._startX, this._startY, this._x, this._y) && (this._isTooFarForHold = !0)
    }
    GetId() {
        return this._pointerId
    }
    GetStartIndex() {
        return this._startIndex
    }
    GetTime() {
        return this._time
    }
    _SetLastTime(a) {
        this._lastTime = a
    }
    GetX() {
        return this._x
    }
    GetY() {
        return this._y
    }
    GetSpeed() {
        const a = C3$jscomp$221.distanceTo(this._x, this._y, this._lastX, this._lastY)
          , b = (this._time - this._lastTime) / 1E3;
        return 0 < b ? a / b : 0
    }
    GetAngle() {
        return C3$jscomp$221.angleTo(this._lastX, this._lastY, this._x, this._y)
    }
    GetWidth() {
        return this._width
    }
    GetHeight() {
        return this._height
    }
    GetPressure() {
        return this._pressure
    }
    ShouldTriggerHold(a) {
        return this._hasTriggeredHold ? !1 : 500 <= a - this._startTime && !this._isTooFarForHold && 15 > C3$jscomp$221.distanceTo(this._startX, this._startY, this._x, this._y) ? this._hasTriggeredHold = !0 : !1
    }
    ShouldTriggerTap(a) {
        if (this._hasTriggeredHold)
            return "";
        if (333 >= a - this._startTime && !this._isTooFarForHold && 15 > C3$jscomp$221.distanceTo(this._startX, this._startY, this._x, this._y)) {
            if (666 >= a - lastTapTime && 25 > C3$jscomp$221.distanceTo(lastTapX, lastTapY, this._x, this._y))
                return lastTapY = lastTapX = -1E3,
                lastTapTime = -1E4,
                "double-tap";
            lastTapX = this._x;
            lastTapY = this._y;
            lastTapTime = a;
            return "single-tap"
        }
        return ""
    }
    GetPositionForLayer(a, b, c) {
        return "undefined" === typeof b ? a.GetLayerByIndex(0).CanvasCssToLayer_DefaultTransform(this._x, this._y)[c ? 0 : 1] : (a = a.GetLayer(b)) ? a.CanvasCssToLayer(this._x, this._y)[c ? 0 : 1] : 0
    }
}
;
"use strict";
const C3$jscomp$222 = self.C3;
C3$jscomp$222.Plugins.Mouse = class extends C3$jscomp$222.SDKPluginBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
}
;
const C3$jscomp$223 = self.C3
  , C3X$jscomp$36 = self.C3X;
C3$jscomp$223.Plugins.Mouse.Type = class extends C3$jscomp$223.SDKTypeBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
    GetScriptInterfaceClass() {
        return self.IMouseObjectType
    }
}
;
let mouseObjectType = null;
function GetMouseSdkInstance() {
    return mouseObjectType.GetSingleGlobalInstance().GetSdkInstance()
}
self.IMouseObjectType = class extends self.IObjectClass {
    constructor(a) {
        super(a);
        mouseObjectType = a;
        a.GetRuntime()._GetCommonScriptInterfaces().mouse = this
    }
    getMouseX(a) {
        return GetMouseSdkInstance().GetMousePositionForLayer(a)[0]
    }
    getMouseY(a) {
        return GetMouseSdkInstance().GetMousePositionForLayer(a)[1]
    }
    getMousePosition(a) {
        return GetMouseSdkInstance().GetMousePositionForLayer(a)
    }
    isMouseButtonDown(a) {
        return GetMouseSdkInstance().IsMouseButtonDown(a)
    }
    setCursorStyle(a) {
        C3X$jscomp$36.RequireString(a);
        GetMouseSdkInstance().SetCursorStyle(a)
    }
    setCursorObjectClass(a) {
        const b = GetMouseSdkInstance();
        a = b.GetRuntime()._UnwrapIObjectClass(a);
        b.SetCursorObjectClass(a)
    }
}
;
const C3$jscomp$224 = self.C3;
let lastSetCursor = null;
C3$jscomp$224.Plugins.Mouse.Instance = class extends C3$jscomp$224.SDKInstanceBase {
    constructor(a, b) {
        super(a, "mouse");
        this._buttonMap = [!1, !1, !1, !1, !1];
        this._wheelDeltaZ = this._wheelDeltaY = this._wheelDeltaX = this._triggerDir = this._triggerType = this._triggerButton = this._mouseYcanvas = this._mouseXcanvas = 0;
        this._hasPointerLock = !1;
        this._movementY = this._movementX = 0;
        this.AddDOMMessageHandlers([["pointer-lock-change", c => this._OnPointerLockChange(c)], ["pointer-lock-error", c => this._OnPointerLockError(c)]]);
        a = this.GetRuntime().Dispatcher();
        this._disposables = new C3$jscomp$224.CompositeDisposable(C3$jscomp$224.Disposable.From(a, "pointermove", c => this._OnPointerMove(c.data)),C3$jscomp$224.Disposable.From(a, "pointerdown", c => this._OnPointerDown(c.data)),C3$jscomp$224.Disposable.From(a, "pointerup", c => this._OnPointerUp(c.data)),C3$jscomp$224.Disposable.From(a, "dblclick", c => this._OnDoubleClick(c.data)),C3$jscomp$224.Disposable.From(a, "wheel", c => this._OnMouseWheel(c.data)),C3$jscomp$224.Disposable.From(a, "window-blur", () => this._OnWindowBlur()))
    }
    Release() {
        super.Release()
    }
    _OnPointerDown(a) {
        "mouse" === a.pointerType && (this._mouseXcanvas = a.pageX - this._runtime.GetCanvasClientX(),
        this._mouseYcanvas = a.pageY - this._runtime.GetCanvasClientY(),
        this._CheckButtonChanges(a.lastButtons, a.buttons))
    }
    _OnPointerMove(a) {
        this._movementX = a.movementX;
        this._movementY = a.movementY;
        this.Trigger(C3$jscomp$224.Plugins.Mouse.Cnds.OnMovement);
        this._movementY = this._movementX = 0;
        "mouse" === a.pointerType && (this._mouseXcanvas = a.pageX - this._runtime.GetCanvasClientX(),
        this._mouseYcanvas = a.pageY - this._runtime.GetCanvasClientY(),
        this._CheckButtonChanges(a.lastButtons, a.buttons))
    }
    _OnPointerUp(a) {
        "mouse" === a.pointerType && this._CheckButtonChanges(a.lastButtons, a.buttons)
    }
    _CheckButtonChanges(a, b) {
        this._CheckButtonChange(a, b, 1, 0);
        this._CheckButtonChange(a, b, 4, 1);
        this._CheckButtonChange(a, b, 2, 2);
        this._CheckButtonChange(a, b, 8, 3);
        this._CheckButtonChange(a, b, 16, 4)
    }
    _CheckButtonChange(a, b, c, d) {
        !(a & c) && b & c ? this._OnMouseDown(d) : a & c && !(b & c) && this._OnMouseUp(d)
    }
    _OnMouseDown(a) {
        this._buttonMap[a] = !0;
        this.Trigger(C3$jscomp$224.Plugins.Mouse.Cnds.OnAnyClick);
        this._triggerButton = a;
        this._triggerType = 0;
        this.Trigger(C3$jscomp$224.Plugins.Mouse.Cnds.OnClick);
        this.Trigger(C3$jscomp$224.Plugins.Mouse.Cnds.OnObjectClicked)
    }
    _OnMouseUp(a) {
        this._buttonMap[a] && (this._buttonMap[a] = !1,
        this._triggerButton = a,
        this.Trigger(C3$jscomp$224.Plugins.Mouse.Cnds.OnRelease))
    }
    _OnDoubleClick(a) {
        this._triggerButton = a.button;
        this._triggerType = 1;
        this.Trigger(C3$jscomp$224.Plugins.Mouse.Cnds.OnClick);
        this.Trigger(C3$jscomp$224.Plugins.Mouse.Cnds.OnObjectClicked)
    }
    _OnMouseWheel(a) {
        this._triggerDir = 0 > a.deltaY ? 1 : 0;
        this._wheelDeltaX = a.deltaX;
        this._wheelDeltaY = a.deltaY;
        this._wheelDeltaZ = a.deltaZ;
        this.Trigger(C3$jscomp$224.Plugins.Mouse.Cnds.OnWheel)
    }
    _OnWindowBlur() {
        for (let a = 0, b = this._buttonMap.length; a < b && this._buttonMap[a]; ++a)
            this._buttonMap[a] = !1,
            this._triggerButton = a,
            this.Trigger(C3$jscomp$224.Plugins.Mouse.Cnds.OnRelease)
    }
    GetMousePositionForLayer(a) {
        const b = this._runtime.GetMainRunningLayout()
          , c = this._mouseXcanvas
          , d = this._mouseYcanvas;
        return "undefined" === typeof a ? b.GetLayerByIndex(0).CanvasCssToLayer_DefaultTransform(c, d) : (a = b.GetLayer(a)) ? a.CanvasCssToLayer(c, d) : [0, 0]
    }
    IsMouseButtonDown(a) {
        a = Math.floor(a);
        return !!this._buttonMap[a]
    }
    _IsMouseOverCanvas() {
        return 0 <= this._mouseXcanvas && 0 <= this._mouseYcanvas && this._mouseXcanvas < this._runtime.GetCanvasCssWidth() && this._mouseYcanvas < this._runtime.GetCanvasCssHeight()
    }
    SetCursorStyle(a) {
        lastSetCursor !== a && (lastSetCursor = a,
        this.PostToDOM("cursor", a))
    }
    async SetCursorObjectClass(a) {
        if (!C3$jscomp$224.Platform.IsMobile && a) {
            var b = a.GetFirstPicked();
            b && (a = b.GetWorldInfo(),
            b = b.GetCurrentImageInfo(),
            a && b && lastSetCursor !== b && (lastSetCursor = b,
            a = `url(${await b.ExtractImageToBlobURL()}) ${Math.round(a.GetOriginX() * b.GetWidth())} ${Math.round(a.GetOriginY() * b.GetHeight())}, auto`,
            this.PostToDOM("cursor", a)))
        }
    }
    _OnPointerLockChange(a) {
        this._UpdatePointerLockState(a["has-pointer-lock"])
    }
    _OnPointerLockError(a) {
        this._UpdatePointerLockState(a["has-pointer-lock"]);
        this.Trigger(C3$jscomp$224.Plugins.Mouse.Cnds.OnPointerLockError)
    }
    _UpdatePointerLockState(a) {
        this._hasPointerLock !== a && ((this._hasPointerLock = a) ? this.Trigger(C3$jscomp$224.Plugins.Mouse.Cnds.OnPointerLocked) : this.Trigger(C3$jscomp$224.Plugins.Mouse.Cnds.OnPointerUnlocked))
    }
    GetDebuggerProperties() {
        return [{
            title: "plugins.mouse.name",
            properties: [{
                name: "plugins.mouse.debugger.absolute-position",
                value: this._mouseXcanvas + "," + this._mouseYcanvas
            }, {
                name: "plugins.mouse.debugger.left-button",
                value: this._buttonMap[0]
            }, {
                name: "plugins.mouse.debugger.middle-button",
                value: this._buttonMap[1]
            }, {
                name: "plugins.mouse.debugger.right-button",
                value: this._buttonMap[2]
            }, {
                name: "plugins.mouse.debugger.button-4",
                value: this._buttonMap[3]
            }, {
                name: "plugins.mouse.debugger.button-5",
                value: this._buttonMap[4]
            }]
        }, {
            title: "plugins.mouse.debugger.position-on-each-layer",
            properties: this._runtime.GetMainRunningLayout().GetLayers().map(a => ({
                name: "$" + a.GetName(),
                value: a.CanvasCssToLayer(this._mouseXcanvas, this._mouseYcanvas).join(", ")
            }))
        }]
    }
}
;
const C3$jscomp$225 = self.C3;
C3$jscomp$225.Plugins.Mouse.Cnds = {
    OnClick(a, b) {
        return this._triggerButton === a && this._triggerType === b
    },
    OnAnyClick() {
        return !0
    },
    IsButtonDown(a) {
        return this._buttonMap[a]
    },
    OnRelease(a) {
        return this._triggerButton === a
    },
    IsOverObject(a) {
        const b = this._runtime.GetCurrentCondition().IsInverted()
          , c = [];
        this._IsMouseOverCanvas() && c.push([this._mouseXcanvas, this._mouseYcanvas]);
        return C3$jscomp$225.xor(this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(a, c, b), b)
    },
    OnObjectClicked(a, b, c) {
        if (a !== this._triggerButton || b !== this._triggerType || !this._IsMouseOverCanvas())
            return !1;
        a = this._mouseXcanvas;
        b = this._mouseYcanvas;
        return this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(c, [[a, b]], !1)
    },
    OnWheel(a) {
        return 2 === a || this._triggerDir === a
    },
    OnPointerLocked() {
        return !0
    },
    OnPointerUnlocked() {
        return !0
    },
    OnPointerLockError() {
        return !0
    },
    HasPointerLock() {
        return this._hasPointerLock
    },
    OnMovement() {
        return !0
    }
};
const CURSOR_STYLES = "auto pointer text crosshair move help wait none".split(" ");
self.C3.Plugins.Mouse.Acts = {
    SetCursor(a) {
        this.SetCursorStyle(CURSOR_STYLES[a])
    },
    SetCursorSprite(a) {
        this.SetCursorObjectClass(a)
    },
    RequestPointerLock() {
        this._PostToDOMMaybeSync("request-pointer-lock")
    },
    ReleasePointerLock() {
        this.PostToDOM("release-pointer-lock")
    }
};
self.C3.Plugins.Mouse.Exps = {
    X(a) {
        return this.GetMousePositionForLayer(a)[0]
    },
    Y(a) {
        return this.GetMousePositionForLayer(a)[1]
    },
    AbsoluteX() {
        return this._mouseXcanvas
    },
    AbsoluteY() {
        return this._mouseYcanvas
    },
    MovementX() {
        return this._movementX
    },
    MovementY() {
        return this._movementY
    },
    WheelDeltaX() {
        return this._wheelDeltaX
    },
    WheelDeltaY() {
        return this._wheelDeltaY
    },
    WheelDeltaZ() {
        return this._wheelDeltaZ
    }
};
"use strict";
const C3$jscomp$228 = self.C3
  , actionPromises = [];
C3$jscomp$228.Plugins.Audio = class extends C3$jscomp$228.SDKPluginBase {
    constructor(a) {
        super(a)
    }
    _AddActionPromise(a) {
        actionPromises.push(a)
    }
    static async WaitForAllActionPromises() {
        await Promise.all(actionPromises);
        C3$jscomp$228.clearArray(actionPromises)
    }
    Release() {
        super.Release()
    }
}
;
const C3$jscomp$229 = self.C3;
C3$jscomp$229.Plugins.Audio.Type = class extends C3$jscomp$229.SDKTypeBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
    GetScriptInterfaceClass() {
        return self.IAudioObjectType
    }
}
;
function GetAudioDOMInterface() {
    if (self.C3Audio_DOMInterface)
        return self.C3Audio_DOMInterface;
    throw Error("audio scripting API cannot be used here - make sure the project is using DOM mode, not worker mode");
}
self.IAudioObjectType = class extends self.IObjectClass {
    constructor(a) {
        super(a)
    }
    get audioContext() {
        return GetAudioDOMInterface().GetAudioContextExtern()
    }
    get destinationNode() {
        return GetAudioDOMInterface().GetDestinationNodeExtern()
    }
}
;
const C3$jscomp$230 = self.C3
  , LATENCY_HINTS = ["interactive", "balanced", "playback"];
C3$jscomp$230.Plugins.Audio.Instance = class extends C3$jscomp$230.SDKInstanceBase {
    constructor(a, b) {
        super(a, "audio");
        this._nextPlayTime = 0;
        this._triggerTags = [];
        this._enableMultiTags = !0;
        this._saveLoadMode = this._timeScaleMode = 0;
        this._playInBackground = !1;
        this._distanceModel = this._panningModel = 1;
        this._listenerPos = [this._runtime.GetViewportWidth() / 2, this._runtime.GetViewportHeight() / 2, 600];
        this._listenerForwardVec = [0, 0, -1];
        this._listenerUpVec = [0, 1, 0];
        this._referenceDistance = 600;
        this._maxDistance = 1E4;
        this._rolloffFactor = 1;
        this._listenerInst = null;
        this._loadListenerUid = -1;
        this._masterVolume = 1;
        this._isSilent = !1;
        this._sampleRate = 0;
        this._audioContextState = "suspended";
        this._outputLatency = 0;
        this._effectCount = new Map;
        this._preloadCount = this._preloadTotal = 0;
        this._bufferMetadata = new Map;
        this._remoteUrls = new Map;
        a = "interactive";
        b && (this._timeScaleMode = b[0],
        this._saveLoadMode = b[1],
        this._playInBackground = b[2],
        a = LATENCY_HINTS[b[3]],
        this._enableMultiTags = b[4],
        this._panningModel = b[5],
        this._distanceModel = b[6],
        this._listenerPos[2] = b[7],
        this._referenceDistance = b[8],
        this._maxDistance = b[9],
        this._rolloffFactor = b[10]);
        this._lastAIState = [];
        this._lastFxState = [];
        this._lastAnalysersData = [];
        this.AddDOMMessageHandlers([["state", e => this._OnUpdateState(e)], ["audiocontext-state", e => this._OnAudioContextStateChanged(e)], ["fxstate", e => this._OnUpdateFxState(e)], ["trigger", e => this._OnTrigger(e)], ["buffer-metadata", e => this._OnBufferMetadata(e)]]);
        b = this.GetRuntime().Dispatcher();
        this._disposables = new C3$jscomp$230.CompositeDisposable(C3$jscomp$230.Disposable.From(b, "instancedestroy", e => this._OnInstanceDestroyed(e.instance)),C3$jscomp$230.Disposable.From(b, "afterload", () => this._OnAfterLoad()),C3$jscomp$230.Disposable.From(b, "suspend", () => this._OnSuspend()),C3$jscomp$230.Disposable.From(b, "resume", () => this._OnResume()));
        b = "Safari" === C3$jscomp$230.Platform.Browser;
        const c = this._runtime.IsiOSWebView()
          , d = this._runtime.GetAssetManager().IsFileProtocol();
        b = b || c || d;
        this._runtime.AddLoadPromise(this.PostToDOMAsync("create-audio-context", {
            preloadList: this._runtime.GetAssetManager().GetAudioToPreload().map(e => ({
                originalUrl: e.originalUrl,
                url: e.url,
                type: e.type,
                fileSize: e.fileSize
            })),
            timeScaleMode: this._timeScaleMode,
            latencyHint: a,
            panningModel: this._panningModel,
            distanceModel: this._distanceModel,
            refDistance: this._referenceDistance,
            maxDistance: this._maxDistance,
            rolloffFactor: this._rolloffFactor,
            listenerPos: this._listenerPos,
            usePlayMusicAsSoundWorkaround: b
        }).then(e => {
            this._sampleRate = e.sampleRate;
            this._audioContextState = e.audioContextState;
            this._outputLatency = e.outputLatency
        }
        ));
        this._StartTicking()
    }
    Release() {
        this._listenerInst = null;
        super.Release()
    }
    _SplitTags(a) {
        return this._enableMultiTags ? a.split(" ").filter(b => !!b) : a ? [a] : []
    }
    _MatchTagLists(a, b) {
        for (const c of b) {
            b = !1;
            for (const d of a)
                if (C3$jscomp$230.equalsNoCase(d, c)) {
                    b = !0;
                    break
                }
            if (!b)
                return !1
        }
        return !0
    }
    _MatchTagListToStr(a, b) {
        return this._MatchTagLists(a, this._SplitTags(b))
    }
    _AddActionPromise(a) {
        this.GetPlugin()._AddActionPromise(a)
    }
    _OnInstanceDestroyed(a) {
        this._listenerInst === a && (this._listenerInst = null)
    }
    DbToLinearNoCap(a) {
        return Math.pow(10, a / 20)
    }
    DbToLinear(a) {
        a = this.DbToLinearNoCap(a);
        return isFinite(a) ? Math.max(Math.min(a, 1), 0) : 0
    }
    LinearToDbNoCap(a) {
        return Math.log(a) / Math.log(10) * 20
    }
    LinearToDb(a) {
        return this.LinearToDbNoCap(Math.max(Math.min(a, 1), 0))
    }
    _OnSuspend() {
        this._playInBackground || this.PostToDOM("set-suspended", {
            isSuspended: !0
        })
    }
    _OnResume() {
        this._playInBackground || this.PostToDOM("set-suspended", {
            isSuspended: !1
        })
    }
    _OnUpdateState(a) {
        const b = a.tickCount;
        this._outputLatency = a.outputLatency;
        const c = this._lastAIState.filter(d => d.hasOwnProperty("placeholder") && (d.placeholder > b || -1 === d.placeholder));
        this._lastAIState = a.audioInstances;
        this._lastAnalysersData = a.analysers;
        0 < c.length && C3$jscomp$230.appendArray(this._lastAIState, c)
    }
    _OnBufferMetadata(a) {
        this._bufferMetadata.set(a.originalUrl, {
            duration: a.duration
        })
    }
    _OnAudioContextStateChanged(a) {
        this._audioContextState = a.audioContextState
    }
    GetAudioContextState() {
        return this._runtime.IsExportToVideo() ? "running" : this._audioContextState
    }
    _OnUpdateFxState(a) {
        this._lastFxState = a.fxstate
    }
    _GetFirstAudioStateByTags(a) {
        a = this._SplitTags(a);
        for (const b of this._lastAIState)
            if (this._MatchTagLists(b.tags, a))
                return b;
        return null
    }
    _IsTagPlaying(a) {
        const b = this._SplitTags(a);
        return this._lastAIState.some(c => this._MatchTagLists(c.tags, b) && c.isPlaying)
    }
    _MaybeMarkAsPlaying(a, b, c, d, e) {
        if (this._IsTagPlaying(b))
            return null;
        const f = this._bufferMetadata.get(a);
        a = {
            tags: this._SplitTags(b),
            duration: f ? f.duration : 0,
            volume: e,
            isPlaying: !0,
            playbackTime: 0,
            playbackRate: 1,
            uid: -1,
            bufferOriginalUrl: a,
            bufferUrl: "",
            bufferType: "",
            isMusic: c,
            isLooping: d,
            isMuted: !1,
            resumePosition: 0,
            pan: null,
            placeholder: -1
        };
        this._lastAIState.push(a);
        return a
    }
    async _OnTrigger(a) {
        const b = a.type;
        this._triggerTags = a.tags;
        a = a.aiid;
        if ("ended" === b) {
            for (const c of this._lastAIState)
                if (c.aiid === a) {
                    c.isPlaying = !1;
                    break
                }
            await this.TriggerAsync(C3$jscomp$230.Plugins.Audio.Cnds.OnEnded)
        } else
            "fade-ended" === b && await this.TriggerAsync(C3$jscomp$230.Plugins.Audio.Cnds.OnFadeEnded)
    }
    _MatchTriggerTag(a) {
        return this._MatchTagListToStr(this._triggerTags, a)
    }
    Tick() {
        const a = {
            timeScale: this._runtime.GetTimeScale(),
            gameTime: this._runtime.GetGameTimeRaw(),
            instPans: this.GetInstancePans(),
            tickCount: this._runtime.GetTickCountNoSave()
        };
        if (this._listenerInst) {
            const b = this._listenerInst.GetWorldInfo();
            this._listenerPos[0] = b.GetX();
            this._listenerPos[1] = b.GetY();
            a.listenerPos = this._listenerPos;
            a.listenerOrientation = [...this._listenerForwardVec, ...this._listenerUpVec]
        }
        this.PostToDOM("tick", a)
    }
    rotatePtAround(a, b, c, d, e) {
        if (0 === c)
            return [a, b];
        const f = Math.sin(c);
        c = Math.cos(c);
        a -= d;
        b -= e;
        const h = a * f;
        a = a * c - b * f;
        b = b * c + h;
        return [a + d, b + e]
    }
    GetInstancePans() {
        return this._lastAIState.filter(a => -1 !== a.uid).map(a => this._runtime.GetInstanceByUID(a.uid)).filter(a => a).map(a => {
            const b = a.GetWorldInfo()
              , c = b.GetLayer().GetAngle()
              , [d,e] = this.rotatePtAround(b.GetX(), b.GetY(), -c, this._listenerPos[0], this._listenerPos[1]);
            return {
                uid: a.GetUID(),
                x: d,
                y: e,
                z: b.GetTotalZElevation(),
                angle: b.GetAngle() - c
            }
        }
        )
    }
    GetAnalyserData(a, b) {
        for (const c of this._lastAnalysersData)
            if (c.index === b && C3$jscomp$230.equalsNoCase(c.tag, a))
                return c;
        return null
    }
    _IncrementEffectCount(a) {
        for (const b of this._SplitTags(a))
            a = b.toLowerCase(),
            this._effectCount.set(a, (this._effectCount.get(a) || 0) + 1)
    }
    _ShouldSave(a) {
        return a.hasOwnProperty("placeholder") || 3 === this._saveLoadMode ? !1 : a.isMusic && 1 === this._saveLoadMode ? !1 : a.isMusic || 2 !== this._saveLoadMode ? !0 : !1
    }
    SaveToJson() {
        return {
            isSilent: this._isSilent,
            masterVolume: this._masterVolume,
            listenerZ: this._listenerPos[2],
            listenerForwardVec: this._listenerForwardVec,
            listenerUpVec: this._listenerUpVec,
            listenerUid: this._listenerInst ? this._listenerInst.GetUID() : -1,
            remoteUrls: [...this._remoteUrls.entries()],
            playing: this._lastAIState.filter(a => this._ShouldSave(a)),
            effects: this._lastFxState,
            analysers: this._lastAnalysersData
        }
    }
    LoadFromJson(a) {
        this._isSilent = a.isSilent;
        this._masterVolume = a.masterVolume;
        this._listenerPos[2] = a.listenerZ;
        this._listenerInst = null;
        this._loadListenerUid = a.listenerUid;
        a.hasOwnProperty("listenerForwardVec") ? this._listenerForwardVec = a.listenerForwardVec : this._listenerForwardVec = [0, 0, -1];
        a.hasOwnProperty("listenerUpVec") ? this._listenerUpVec = a.listenerUpVec : this._listenerUpVec = [0, 1, 0];
        this._remoteUrls.clear();
        if (a.remoteUrls)
            for (const [b,c] of a.remoteUrls)
                this._remoteUrls.set(b, c);
        this._lastAIState = a.playing;
        for (const b of this._lastAIState)
            b.hasOwnProperty("tag") && !b.hasOwnProperty("tags") && (b.tags = [b.tag].filter(c => !!c));
        this._lastFxState = a.effects;
        this._lastAnalysersData = a.analysers
    }
    _OnAfterLoad() {
        if (-1 !== this._loadListenerUid && (this._listenerInst = this._runtime.GetInstanceByUID(this._loadListenerUid),
        this._loadListenerUid = -1,
        this._listenerInst)) {
            var a = this._listenerInst.GetWorldInfo();
            this._listenerPos[0] = a.GetX();
            this._listenerPos[1] = a.GetY()
        }
        for (var b of this._lastAIState)
            (a = this._runtime.GetAssetManager().GetProjectAudioFileUrl(b.bufferOriginalUrl)) ? (b.bufferUrl = a.url,
            b.bufferType = a.type) : b.bufferUrl = null;
        for (const c of Object.values(this._lastFxState))
            for (const d of c)
                d.hasOwnProperty("bufferOriginalUrl") && (b = this._runtime.GetAssetManager().GetProjectAudioFileUrl(d.bufferOriginalUrl)) && (d.bufferUrl = b.url,
                d.bufferType = b.type);
        this.PostToDOM("load-state", {
            saveLoadMode: this._saveLoadMode,
            timeScale: this._runtime.GetTimeScale(),
            gameTime: this._runtime.GetGameTimeRaw(),
            listenerPos: this._listenerPos,
            listenerOrientation: [...this._listenerForwardVec, ...this._listenerUpVec],
            isSilent: this._isSilent,
            masterVolume: this._masterVolume,
            playing: this._lastAIState.filter(c => null !== c.bufferUrl),
            effects: this._lastFxState
        })
    }
    GetDebuggerProperties() {
        const a = [];
        for (const [b,c] of Object.entries(this._lastFxState))
            a.push({
                name: "$" + b,
                value: c.map(d => d.type).join(", ")
            });
        return [{
            title: "plugins.audio.debugger.tag-effects",
            properties: a
        }, {
            title: "plugins.audio.debugger.currently-playing",
            properties: [{
                name: "plugins.audio.debugger.currently-playing-count",
                value: this._lastAIState.length
            }, ...this._lastAIState.map( (b, c) => ({
                name: "$#" + c,
                value: `${b.bufferOriginalUrl} ("${b.tags}") ${Math.round(10 * b.playbackTime) / 10} / ${Math.round(10 * b.duration) / 10}`
            }))]
        }]
    }
}
;
self.C3.Plugins.Audio.Cnds = {
    OnEnded(a) {
        return this._MatchTriggerTag(a)
    },
    OnFadeEnded(a) {
        return this._MatchTriggerTag(a)
    },
    PreloadsComplete() {
        return this._preloadCount === this._preloadTotal
    },
    AdvancedAudioSupported() {
        return !0
    },
    IsSilent() {
        return this._isSilent
    },
    IsAnyPlaying() {
        for (const a of this._lastAIState)
            if (a.isPlaying)
                return !0;
        return !1
    },
    IsTagPlaying(a) {
        return this._IsTagPlaying(a)
    }
};
const C3$jscomp$232 = self.C3
  , FILTER_TYPES = "lowpass highpass bandpass lowshelf highshelf peaking notch allpass".split(" ");
C3$jscomp$232.Plugins.Audio.Acts = {
    Play(a, b, c, d, e) {
        a = C3$jscomp$232.Plugins.Audio.Acts._DoPlay.call(this, a, b, c, d, e);
        this._AddActionPromise(a);
        return a
    },
    PlayFromTimeline(a, b, c, d) {
        C3$jscomp$232.Plugins.Audio.Acts._DoPlay.call(this, a, 0, b, 0, c, d)
    },
    async _DoPlay(a, b, c, d, e, f) {
        if (!this._isSilent) {
            var h = a[1]
              , l = this._runtime.GetAssetManager().GetProjectAudioFileUrl(a[0]);
            if (l) {
                var m = this._nextPlayTime;
                this._nextPlayTime = 0;
                var p = this._MaybeMarkAsPlaying(a[0], e, h, 0 !== b, this.DbToLinear(c));
                try {
                    await this.PostToDOMAsync("play", {
                        originalUrl: a[0],
                        url: l.url,
                        type: l.type,
                        isMusic: h,
                        tags: this._SplitTags(e),
                        isLooping: 0 !== b,
                        vol: this.DbToLinear(c),
                        stereoPan: C3$jscomp$232.clamp(d / 100, -1, 1),
                        pos: f || 0,
                        off: m,
                        trueClock: !!self.C3_GetAudioContextCurrentTime
                    })
                } finally {
                    p && (p.placeholder = this._runtime.GetTickCountNoSave())
                }
            }
        }
    },
    async PlayAtPosition(a, b, c, d, e, f, h, l, m, p, r) {
        if (!this._isSilent) {
            var v = a[1]
              , x = this._runtime.GetAssetManager().GetProjectAudioFileUrl(a[0]);
            if (x) {
                var B = this._nextPlayTime;
                this._nextPlayTime = 0;
                var A = this._MaybeMarkAsPlaying(a[0], r, v, 0 !== b, this.DbToLinear(c));
                try {
                    await this.PostToDOMAsync("play", {
                        originalUrl: a[0],
                        url: x.url,
                        type: x.type,
                        isMusic: v,
                        tags: this._SplitTags(r),
                        isLooping: 0 !== b,
                        vol: this.DbToLinear(c),
                        pos: 0,
                        off: B,
                        trueClock: !!self.C3_GetAudioContextCurrentTime,
                        panning: {
                            x: d,
                            y: e,
                            z: f,
                            angle: C3$jscomp$232.toRadians(h),
                            innerAngle: C3$jscomp$232.toRadians(l),
                            outerAngle: C3$jscomp$232.toRadians(m),
                            outerGain: this.DbToLinear(p)
                        }
                    })
                } finally {
                    A && (A.placeholder = this._runtime.GetTickCountNoSave())
                }
            }
        }
    },
    async PlayAtObject(a, b, c, d, e, f, h, l) {
        if (!this._isSilent && d && (d = d.GetFirstPicked()) && d.GetWorldInfo()) {
            var m = d.GetWorldInfo()
              , p = m.GetLayer().GetAngle()
              , [r,v] = this.rotatePtAround(m.GetX(), m.GetY(), -p, this._listenerPos[0], this._listenerPos[1])
              , x = a[1]
              , B = this._runtime.GetAssetManager().GetProjectAudioFileUrl(a[0]);
            if (B) {
                var A = this._nextPlayTime;
                this._nextPlayTime = 0;
                var D = this._MaybeMarkAsPlaying(a[0], l, x, 0 !== b, this.DbToLinear(c));
                try {
                    await this.PostToDOMAsync("play", {
                        originalUrl: a[0],
                        url: B.url,
                        type: B.type,
                        isMusic: x,
                        tags: this._SplitTags(l),
                        isLooping: 0 !== b,
                        vol: this.DbToLinear(c),
                        pos: 0,
                        off: A,
                        trueClock: !!self.C3_GetAudioContextCurrentTime,
                        panning: {
                            x: r,
                            y: v,
                            z: m.GetTotalZElevation(),
                            angle: m.GetAngle() - p,
                            innerAngle: C3$jscomp$232.toRadians(e),
                            outerAngle: C3$jscomp$232.toRadians(f),
                            outerGain: this.DbToLinear(h),
                            uid: d.GetUID()
                        }
                    })
                } finally {
                    D && (D.placeholder = this._runtime.GetTickCountNoSave())
                }
            }
        }
    },
    async PlayByName(a, b, c, d, e, f) {
        if (!this._isSilent) {
            a = 1 === a;
            var h = this._runtime.GetAssetManager().GetProjectAudioFileUrl(b) || this._remoteUrls.get(b.toLowerCase());
            if (h) {
                var l = this._nextPlayTime;
                this._nextPlayTime = 0;
                var m = this._MaybeMarkAsPlaying(b, f, a, 0 !== c, this.DbToLinear(d));
                try {
                    await this.PostToDOMAsync("play", {
                        originalUrl: b,
                        url: h.url,
                        type: h.type,
                        isMusic: a,
                        tags: this._SplitTags(f),
                        isLooping: 0 !== c,
                        vol: this.DbToLinear(d),
                        stereoPan: C3$jscomp$232.clamp(e / 100, -1, 1),
                        pos: 0,
                        off: l,
                        trueClock: !!self.C3_GetAudioContextCurrentTime
                    })
                } finally {
                    m && (m.placeholder = this._runtime.GetTickCountNoSave())
                }
            }
        }
    },
    async PlayAtPositionByName(a, b, c, d, e, f, h, l, m, p, r, v) {
        if (!this._isSilent) {
            a = 1 === a;
            var x = this._runtime.GetAssetManager().GetProjectAudioFileUrl(b) || this._remoteUrls.get(b.toLowerCase());
            if (x) {
                var B = this._nextPlayTime;
                this._nextPlayTime = 0;
                var A = this._MaybeMarkAsPlaying(b, v, a, 0 !== c, this.DbToLinear(d));
                try {
                    await this.PostToDOMAsync("play", {
                        originalUrl: b,
                        url: x.url,
                        type: x.type,
                        isMusic: a,
                        tags: this._SplitTags(v),
                        isLooping: 0 !== c,
                        vol: this.DbToLinear(d),
                        pos: 0,
                        off: B,
                        trueClock: !!self.C3_GetAudioContextCurrentTime,
                        panning: {
                            x: e,
                            y: f,
                            z: h,
                            angle: C3$jscomp$232.toRadians(l),
                            innerAngle: C3$jscomp$232.toRadians(m),
                            outerAngle: C3$jscomp$232.toRadians(p),
                            outerGain: this.DbToLinear(r)
                        }
                    })
                } finally {
                    A && (A.placeholder = this._runtime.GetTickCountNoSave())
                }
            }
        }
    },
    async PlayAtObjectByName(a, b, c, d, e, f, h, l, m) {
        if (!this._isSilent && !this._isSilent && e && (e = e.GetFirstPicked()) && e.GetWorldInfo()) {
            var p = e.GetWorldInfo()
              , r = p.GetLayer().GetAngle()
              , [v,x] = this.rotatePtAround(p.GetX(), p.GetY(), -r, this._listenerPos[0], this._listenerPos[1]);
            a = 1 === a;
            var B = this._runtime.GetAssetManager().GetProjectAudioFileUrl(b) || this._remoteUrls.get(b.toLowerCase());
            if (B) {
                var A = this._nextPlayTime;
                this._nextPlayTime = 0;
                var D = this._MaybeMarkAsPlaying(b, m, a, 0 !== c, this.DbToLinear(d));
                try {
                    await this.PostToDOMAsync("play", {
                        originalUrl: b,
                        url: B.url,
                        type: B.type,
                        isMusic: a,
                        tags: this._SplitTags(m),
                        isLooping: 0 !== c,
                        vol: this.DbToLinear(d),
                        pos: 0,
                        off: A,
                        trueClock: !!self.C3_GetAudioContextCurrentTime,
                        panning: {
                            x: v,
                            y: x,
                            z: p.GetTotalZElevation(),
                            angle: p.GetAngle() - r,
                            innerAngle: C3$jscomp$232.toRadians(f),
                            outerAngle: C3$jscomp$232.toRadians(h),
                            outerGain: this.DbToLinear(l),
                            uid: e.GetUID()
                        }
                    })
                } finally {
                    D && (D.placeholder = this._runtime.GetTickCountNoSave())
                }
            }
        }
    },
    SetLooping(a, b) {
        this.PostToDOM("set-looping", {
            tags: this._SplitTags(a),
            isLooping: 0 === b
        })
    },
    SetMuted(a, b) {
        this.PostToDOM("set-muted", {
            tags: this._SplitTags(a),
            isMuted: 0 === b
        })
    },
    SetVolume(a, b) {
        this.PostToDOM("set-volume", {
            tags: this._SplitTags(a),
            vol: this.DbToLinear(b)
        })
    },
    FadeVolume(a, b, c, d) {
        this.PostToDOM("fade-volume", {
            tags: this._SplitTags(a),
            vol: this.DbToLinear(b),
            duration: c,
            stopOnEnd: 0 === d
        })
    },
    SetStereoPan(a, b) {
        this.PostToDOM("set-stereo-pan", {
            tags: this._SplitTags(a),
            p: C3$jscomp$232.clamp(b / 100, -1, 1)
        })
    },
    async Preload(a) {
        const b = a[1]
          , c = this._runtime.GetAssetManager().GetProjectAudioFileUrl(a[0]);
        c && (this._preloadTotal++,
        await this.PostToDOMAsync("preload", {
            originalUrl: a[0],
            url: c.url,
            type: c.type,
            isMusic: b
        }),
        this._preloadCount++)
    },
    async PreloadByName(a, b) {
        a = 1 === a;
        const c = this._runtime.GetAssetManager().GetProjectAudioFileUrl(b) || this._remoteUrls.get(b.toLowerCase());
        c && (this._preloadTotal++,
        await this.PostToDOMAsync("preload", {
            originalUrl: b,
            url: c.url,
            type: c.type,
            isMusic: a
        }),
        this._preloadCount++)
    },
    SetPlaybackRate(a, b) {
        this.PostToDOM("set-playback-rate", {
            tags: this._SplitTags(a),
            rate: Math.max(b, 0)
        })
    },
    Stop(a) {
        this.PostToDOM("stop", {
            tags: this._SplitTags(a)
        })
    },
    StopAll() {
        this.PostToDOM("stop-all")
    },
    SetPaused(a, b) {
        this.PostToDOM("set-paused", {
            tags: this._SplitTags(a),
            paused: 0 === b
        })
    },
    Seek(a, b) {
        this.PostToDOM("seek", {
            tags: this._SplitTags(a),
            pos: b
        })
    },
    SetSilent(a) {
        2 === a && (a = this._isSilent ? 1 : 0);
        a = 0 === a;
        this._isSilent !== a && (this._isSilent = a,
        this.PostToDOM("set-silent", {
            isSilent: a
        }))
    },
    SetMasterVolume(a) {
        a = this.DbToLinear(a);
        this._masterVolume !== a && (this._masterVolume = a,
        this.PostToDOM("set-master-volume", {
            vol: a
        }))
    },
    AddFilterEffect(a, b, c, d, e, f, h) {
        b = FILTER_TYPES[b];
        this._IncrementEffectCount(a);
        this.PostToDOM("add-effect", {
            type: "filter",
            tags: this._SplitTags(a),
            params: [b, c, d, e, f, C3$jscomp$232.clamp(h / 100, 0, 1)]
        })
    },
    AddDelayEffect(a, b, c, d) {
        this._IncrementEffectCount(a);
        this.PostToDOM("add-effect", {
            type: "delay",
            tags: this._SplitTags(a),
            params: [b, this.DbToLinear(c), C3$jscomp$232.clamp(d / 100, 0, 1)]
        })
    },
    AddFlangerEffect(a, b, c, d, e, f) {
        this._IncrementEffectCount(a);
        this.PostToDOM("add-effect", {
            type: "flanger",
            tags: this._SplitTags(a),
            params: [b / 1E3, c / 1E3, d, e / 100, C3$jscomp$232.clamp(f / 100, 0, 1)]
        })
    },
    AddPhaserEffect(a, b, c, d, e, f, h) {
        this._IncrementEffectCount(a);
        this.PostToDOM("add-effect", {
            type: "phaser",
            tags: this._SplitTags(a),
            params: [b, c, d, e, f, C3$jscomp$232.clamp(h / 100, 0, 1)]
        })
    },
    AddConvolutionEffect(a, b, c, d) {
        const e = this._runtime.GetAssetManager().GetProjectAudioFileUrl(b[0]);
        e && (this._IncrementEffectCount(a),
        this.PostToDOM("add-effect", {
            type: "convolution",
            tags: this._SplitTags(a),
            bufferOriginalUrl: b[0],
            bufferUrl: e.url,
            bufferType: e.type,
            params: [0 === c, C3$jscomp$232.clamp(d / 100, 0, 1)]
        }))
    },
    AddGainEffect(a, b) {
        this._IncrementEffectCount(a);
        this.PostToDOM("add-effect", {
            type: "gain",
            tags: this._SplitTags(a),
            params: [this.DbToLinear(b)]
        })
    },
    AddStereoPanEffect(a, b) {
        this._IncrementEffectCount(a);
        this.PostToDOM("add-effect", {
            type: "stereopan",
            tags: this._SplitTags(a),
            params: [C3$jscomp$232.clamp(b / 100, -1, 1)]
        })
    },
    AddMuteEffect(a) {
        this._IncrementEffectCount(a);
        this.PostToDOM("add-effect", {
            type: "gain",
            tags: this._SplitTags(a),
            params: [0]
        })
    },
    AddTremoloEffect(a, b, c) {
        this._IncrementEffectCount(a);
        this.PostToDOM("add-effect", {
            type: "tremolo",
            tags: this._SplitTags(a),
            params: [b, C3$jscomp$232.clamp(c / 100, 0, 1)]
        })
    },
    AddRingModEffect(a, b, c) {
        this._IncrementEffectCount(a);
        this.PostToDOM("add-effect", {
            type: "ringmod",
            tags: this._SplitTags(a),
            params: [b, C3$jscomp$232.clamp(c / 100, 0, 1)]
        })
    },
    AddDistortionEffect(a, b, c, d, e, f) {
        this._IncrementEffectCount(a);
        this.PostToDOM("add-effect", {
            type: "distortion",
            tags: this._SplitTags(a),
            params: [this.DbToLinearNoCap(b), this.DbToLinearNoCap(c), d, this.DbToLinearNoCap(e), C3$jscomp$232.clamp(f / 100, 0, 1)]
        })
    },
    AddCompressorEffect(a, b, c, d, e, f) {
        this._IncrementEffectCount(a);
        this.PostToDOM("add-effect", {
            type: "compressor",
            tags: this._SplitTags(a),
            params: [b, c, d, e / 1E3, f / 1E3]
        })
    },
    AddAnalyserEffect(a, b, c) {
        this._IncrementEffectCount(a);
        this.PostToDOM("add-effect", {
            type: "analyser",
            tags: this._SplitTags(a),
            params: [b, c]
        })
    },
    RemoveEffects(a) {
        a = this._SplitTags(a);
        for (const b of a)
            this._effectCount.set(b.toLowerCase(), 0);
        this.PostToDOM("remove-effects", {
            tags: a
        });
        this._lastFxState = {}
    },
    SetEffectParameter(a, b, c, d, e, f) {
        this.PostToDOM("set-effect-param", {
            tags: this._SplitTags(a),
            index: Math.floor(b),
            param: c,
            value: d,
            ramp: e,
            time: f
        })
    },
    SetListenerObject(a) {
        a && (a = a.GetFirstPicked()) && a.GetWorldInfo() && (this._listenerInst = a)
    },
    SetListenerZ(a) {
        this._listenerPos[2] = a
    },
    SetListenerOrientation(a, b, c, d, e, f) {
        this._listenerForwardVec[0] = a;
        this._listenerForwardVec[1] = b;
        this._listenerForwardVec[2] = -c;
        this._listenerUpVec[0] = d;
        this._listenerUpVec[1] = e;
        this._listenerUpVec[2] = -f
    },
    ScheduleNextPlay(a) {
        this._nextPlayTime = Math.max(a, 0)
    },
    UnloadAudio(a) {
        const b = a[1];
        (a = this._runtime.GetAssetManager().GetProjectAudioFileUrl(a[0])) && this.PostToDOM("unload", {
            url: a.url,
            type: a.type,
            isMusic: b
        })
    },
    UnloadAudioByName(a, b) {
        a = 1 === a;
        (b = this._runtime.GetAssetManager().GetProjectAudioFileUrl(b) || this._remoteUrls.get(b.toLowerCase())) && this.PostToDOM("unload", {
            url: b.url,
            type: b.type,
            isMusic: a
        })
    },
    UnloadAll() {
        this.PostToDOM("unload-all")
    },
    AddRemoteURL(a, b, c) {
        this._remoteUrls.set(c.toLowerCase(), {
            url: a,
            type: b
        })
    }
};
self.C3.Plugins.Audio.Exps = {
    Duration(a) {
        return (a = this._GetFirstAudioStateByTags(a)) ? a.duration : 0
    },
    PlaybackTime(a) {
        return (a = this._GetFirstAudioStateByTags(a)) ? a.playbackTime : 0
    },
    PlaybackRate(a) {
        return (a = this._GetFirstAudioStateByTags(a)) ? a.playbackRate : 0
    },
    Volume(a) {
        return (a = this._GetFirstAudioStateByTags(a)) ? this.LinearToDb(a.volume) : 0
    },
    MasterVolume() {
        return this.LinearToDb(this._masterVolume)
    },
    EffectCount(a) {
        return this._effectCount.get(a.toLowerCase()) || 0
    },
    AnalyserFreqBinCount(a, b) {
        return (a = this.GetAnalyserData(a, Math.floor(b))) ? a.binCount : 0
    },
    AnalyserFreqBinAt(a, b, c) {
        a = this.GetAnalyserData(a, Math.floor(b));
        if (!a)
            return 0;
        c = Math.floor(c);
        return 0 > c || c >= a.binCount ? 0 : a.freqBins[c]
    },
    AnalyserPeakLevel(a, b) {
        return (a = this.GetAnalyserData(a, Math.floor(b))) ? a.peak : 0
    },
    AnalyserRMSLevel(a, b) {
        return (a = this.GetAnalyserData(a, Math.floor(b))) ? a.rms : 0
    },
    SampleRate() {
        return this._sampleRate
    },
    CurrentTime() {
        return self.C3_GetAudioContextCurrentTime ? self.C3_GetAudioContextCurrentTime() : performance.now() / 1E3
    },
    OutputLatency() {
        return this._outputLatency
    }
};
"use strict";
const C3$jscomp$234 = self.C3;
C3$jscomp$234.Plugins.Browser = class extends C3$jscomp$234.SDKPluginBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
}
;
const C3$jscomp$235 = self.C3;
C3$jscomp$235.Plugins.Browser.Type = class extends C3$jscomp$235.SDKTypeBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
}
;
const C3$jscomp$236 = self.C3;
C3$jscomp$236.Plugins.Browser.Instance = class extends C3$jscomp$236.SDKInstanceBase {
    constructor(a, b) {
        super(a, "browser");
        this._initLocationStr = "";
        this._isOnline = !1;
        this._docTitle = this._referrer = "";
        this._isCookieEnabled = !1;
        this._windowOuterHeight = this._windowOuterWidth = this._screenHeight = this._screenWidth = 0;
        this._isConstructArcade = !1;
        this._cssStyleMap = new Map;
        this._isInstallAvailable = !1;
        this._installResult = "";
        this._isWarnOnCloseEnabled = !1;
        this.AddDOMMessageHandlers([["online-state", c => this._OnOnlineStateChanged(c)], ["backbutton", () => this._OnBackButton()], ["sw-message", c => this._OnSWMessage(c)], ["hashchange", c => this._OnHashChange(c)], ["install-available", () => this._OnInstallAvailable()], ["app-installed", c => this._OnAppInstalled(c)]]);
        a = this.GetRuntime().Dispatcher();
        this._disposables = new C3$jscomp$236.CompositeDisposable(C3$jscomp$236.Disposable.From(a, "afterfirstlayoutstart", () => this._OnAfterFirstLayoutStart()),C3$jscomp$236.Disposable.From(a, "window-resize", () => this._OnWindowResize()),C3$jscomp$236.Disposable.From(a, "suspend", () => this._OnSuspend()),C3$jscomp$236.Disposable.From(a, "resume", () => this._OnResume()));
        this._runtime.AddLoadPromise(this.PostToDOMAsync("get-initial-state", {
            exportType: this._runtime.GetExportType()
        }).then(c => {
            this._initLocationStr = c.location;
            this._isOnline = c.isOnline;
            this._referrer = c.referrer;
            this._docTitle = c.title;
            this._isCookieEnabled = c.isCookieEnabled;
            this._screenWidth = c.screenWidth;
            this._screenHeight = c.screenHeight;
            this._windowOuterWidth = c.windowOuterWidth;
            this._windowOuterHeight = c.windowOuterHeight;
            this._isConstructArcade = c.isConstructArcade
        }
        ))
    }
    Release() {
        super.Release()
    }
    _OnAfterFirstLayoutStart() {
        this.PostToDOM("ready-for-sw-messages")
    }
    async _OnOnlineStateChanged(a) {
        a = !!a.isOnline;
        this._isOnline !== a && ((this._isOnline = a) ? await this.TriggerAsync(C3$jscomp$236.Plugins.Browser.Cnds.OnOnline) : await this.TriggerAsync(C3$jscomp$236.Plugins.Browser.Cnds.OnOffline))
    }
    async _OnWindowResize() {
        await this.TriggerAsync(C3$jscomp$236.Plugins.Browser.Cnds.OnResize)
    }
    _OnSuspend() {
        this.Trigger(C3$jscomp$236.Plugins.Browser.Cnds.OnPageHidden)
    }
    _OnResume() {
        this.Trigger(C3$jscomp$236.Plugins.Browser.Cnds.OnPageVisible)
    }
    async _OnBackButton() {
        await this.TriggerAsync(C3$jscomp$236.Plugins.Browser.Cnds.OnBackButton)
    }
    _OnSWMessage(a) {
        a = a.type;
        "downloading-update" === a ? this.Trigger(C3$jscomp$236.Plugins.Browser.Cnds.OnUpdateFound) : "update-ready" === a || "update-pending" === a ? this.Trigger(C3$jscomp$236.Plugins.Browser.Cnds.OnUpdateReady) : "offline-ready" === a && this.Trigger(C3$jscomp$236.Plugins.Browser.Cnds.OnOfflineReady)
    }
    _OnHashChange(a) {
        this._initLocationStr = a.location;
        this.Trigger(C3$jscomp$236.Plugins.Browser.Cnds.OnHashChange)
    }
    _OnInstallAvailable() {
        this._isInstallAvailable = !0;
        this.Trigger(C3$jscomp$236.Plugins.Browser.Cnds.OnInstallAvailable)
    }
    _OnAppInstalled(a) {
        this._isInstallAvailable = !1;
        this.Trigger(C3$jscomp$236.Plugins.Browser.Cnds.OnAppInstalled)
    }
    _IsWarnOnCloseEnabled() {
        return this._isWarnOnCloseEnabled
    }
    _SetWarnOnCloseEnabled(a) {
        a = !!a;
        this._isWarnOnCloseEnabled !== a && (this._isWarnOnCloseEnabled = a,
        this.PostToDOM("set-warn-on-close", {
            enabled: a
        }))
    }
    GetDebuggerProperties() {
        return [{
            title: "plugins.browser.name",
            properties: [{
                name: "plugins.browser.debugger.user-agent",
                value: navigator.userAgent
            }, {
                name: "plugins.browser.debugger.is-online",
                value: this._isOnline
            }, {
                name: "plugins.browser.debugger.is-fullscreen",
                value: this._runtime.GetCanvasManager().IsDocumentFullscreen()
            }]
        }]
    }
}
;
self.C3.Plugins.Browser.Cnds = {
    IsOnline() {
        return this._isOnline
    },
    OnOnline() {
        return !0
    },
    OnOffline() {
        return !0
    },
    OnResize() {
        return !0
    },
    CookiesEnabled() {
        return this._isCookieEnabled
    },
    IsFullscreen() {
        return this._runtime.GetCanvasManager().IsDocumentFullscreen()
    },
    OnBackButton() {
        return !0
    },
    IsPortraitLandscape(a) {
        const b = this._runtime.GetCanvasManager().GetLastWidth()
          , c = this._runtime.GetCanvasManager().GetLastHeight();
        return (b <= c ? 0 : 1) === a
    },
    OnUpdateFound() {
        return !0
    },
    OnUpdateReady() {
        return !0
    },
    OnOfflineReady() {
        return !0
    },
    OnHashChange() {
        return !0
    },
    OnInstallAvailable() {
        return !0
    },
    IsInstallAvailable() {
        return this._isInstallAvailable
    },
    OnInstallResult(a) {
        switch (a) {
        case 0:
            return "accepted" === this._installResult;
        case 1:
            return "dismissed" === this._installResult;
        case 2:
            return "error" === this._installResult;
        case 3:
            return !0;
        default:
            return !1
        }
    },
    OnAppInstalled() {
        return !0
    },
    CompareDisplayMode(a) {
        const b = this._runtime.GetCanvasManager().GetCssDisplayMode();
        switch (a) {
        case 0:
            return "browser" === b;
        case 1:
            return "minimal-ui" === b;
        case 2:
            return "standalone" === b;
        case 3:
            return "fullscreen" === b;
        default:
            return !1
        }
    },
    IsWarnOnCloseEnabled() {
        return this._IsWarnOnCloseEnabled()
    },
    PageVisible() {
        return !this._runtime.IsSuspended()
    },
    OnPageHidden() {
        return !0
    },
    OnPageVisible() {
        return !0
    },
    HasJava() {
        return !1
    },
    IsDownloadingUpdate() {
        return !1
    },
    OnMenuButton() {
        return !1
    },
    OnSearchButton() {
        return !1
    },
    IsMetered() {
        return !1
    },
    IsCharging() {
        return !0
    },
    SupportsFullscreen() {
        return !0
    }
};
const C3$jscomp$238 = self.C3
  , ORIENTATIONS = "portrait landscape portrait-primary portrait-secondary landscape-primary landscape-secondary".split(" ");
C3$jscomp$238.Plugins.Browser.Acts = {
    Alert(a) {
        this.PostToDOM("alert", {
            message: a.toString()
        })
    },
    Close() {
        this._isConstructArcade || (this._runtime.IsDebug() ? self.C3Debugger.CloseWindow() : this.PostToDOM("close"))
    },
    Focus() {
        this.PostToDOM("set-focus", {
            isFocus: !0
        })
    },
    Blur() {
        this.PostToDOM("set-focus", {
            isFocus: !1
        })
    },
    GoBack() {
        this._isConstructArcade || this.PostToDOM("navigate", {
            type: "back"
        })
    },
    GoForward() {
        this._isConstructArcade || this.PostToDOM("navigate", {
            type: "forward"
        })
    },
    GoHome() {},
    Reload() {
        this._isConstructArcade || (this._runtime.IsDebug() ? this._runtime.PostToDebugger({
            type: "reload"
        }) : this.PostToDOM("navigate", {
            type: "reload"
        }))
    },
    GoToURL(a, b) {
        this._PostToDOMMaybeSync("navigate", {
            type: "url",
            url: a,
            target: b,
            exportType: this._runtime.GetExportType()
        })
    },
    GoToURLWindow(a, b) {
        this._PostToDOMMaybeSync("navigate", {
            type: "new-window",
            url: a,
            tag: b,
            exportType: this._runtime.GetExportType()
        })
    },
    RequestFullScreen(a, b) {
        2 <= a && (a += 1);
        6 === a && (a = 2);
        1 === a && (a = 0);
        a = C3$jscomp$238.CanvasManager._FullscreenModeNumberToString(a);
        this._runtime.GetCanvasManager().SetDocumentFullscreenMode(a);
        this._PostToDOMMaybeSync("request-fullscreen", {
            navUI: b
        })
    },
    CancelFullScreen() {
        this._PostToDOMMaybeSync("exit-fullscreen")
    },
    Vibrate(a) {
        a = a.split(",");
        for (let b = 0, c = a.length; b < c; ++b)
            a[b] = parseInt(a[b], 10);
        this._PostToDOMMaybeSync("vibrate", {
            pattern: a
        })
    },
    async InvokeDownload(a, b) {
        a && b && (a = await this._runtime.GetAssetManager().GetProjectFileUrl(a),
        this._runtime.InvokeDownload(a, b))
    },
    InvokeDownloadString(a, b, c) {
        c && (a = `data:${b},${encodeURIComponent(a)}`,
        this._runtime.InvokeDownload(a, c))
    },
    ConsoleLog(a, b) {
        b = b.toString();
        0 === a ? console.log(b) : 1 === a ? console.warn(b) : 2 === a && console.error(b)
    },
    ConsoleGroup(a) {
        console.group(a)
    },
    ConsoleGroupEnd() {
        console.groupEnd()
    },
    ExecJs(a) {
        try {
            eval(a)
        } catch (b) {
            console.error("Error executing JavaScript: ", b)
        }
    },
    LockOrientation(a) {
        a = Math.floor(a);
        0 > a || a >= ORIENTATIONS.length || this._PostToDOMMaybeSync("lock-orientation", {
            orientation: ORIENTATIONS[a]
        })
    },
    UnlockOrientation() {
        this._PostToDOMMaybeSync("unlock-orientation")
    },
    LoadStyleSheet(a) {
        this._runtime.GetAssetManager().LoadStyleSheet(a)
    },
    async SetDocumentCSSStyle(a, b, c, d) {
        await this.PostToDOMAsync("set-document-css-style", {
            prop: C3$jscomp$238.CSSToCamelCase(a),
            value: b,
            selector: c,
            "is-all": 0 !== d
        })
    },
    async GetDocumentCSSStyle(a, b, c) {
        a = await this.PostToDOMAsync("get-document-css-style", {
            prop: a,
            selector: b
        });
        a.isOk && this._cssStyleMap.set(c.toLowerCase(), a.result.trim())
    },
    SetHash(a) {
        this.PostToDOM("set-hash", {
            hash: a
        })
    },
    SetWindowSize(a, b) {
        this.PostToDOM("set-window-size", {
            windowWidth: a,
            windowHeight: b
        })
    },
    SetWindowPosition(a, b) {
        this.PostToDOM("set-window-position", {
            windowX: a,
            windowY: b
        })
    },
    async RequestInstall() {
        this._installResult = (await this.PostToDOMAsync("request-install")).result;
        this.Trigger(C3$jscomp$238.Plugins.Browser.Cnds.OnInstallResult)
    },
    SetWarnOnClose(a) {
        this._SetWarnOnCloseEnabled(a)
    }
};
self.C3.Plugins.Browser.Exps = {
    URL() {
        return this._runtime.IsInWorker() ? this._initLocationStr : location.toString()
    },
    Protocol() {
        return this._runtime.IsInWorker() ? (new URL(this._initLocationStr)).protocol : location.protocol
    },
    Domain() {
        return this._runtime.IsInWorker() ? (new URL(this._initLocationStr)).hostname : location.hostname
    },
    Port() {
        return this._runtime.IsInWorker() ? (new URL(this._initLocationStr)).port : location.port
    },
    PathName() {
        return this._runtime.IsInWorker() ? (new URL(this._initLocationStr)).pathname : location.pathname
    },
    Hash() {
        return this._runtime.IsInWorker() ? (new URL(this._initLocationStr)).hash : location.hash
    },
    QueryString() {
        return this._runtime.IsInWorker() ? (new URL(this._initLocationStr)).search : location.search
    },
    QueryParam(a) {
        const b = this._runtime.IsInWorker() ? (new URL(this._initLocationStr)).search : location.search;
        return (a = RegExp("[?&]" + a + "=([^&]*)").exec(b)) ? decodeURIComponent(a[1].replace(/\+/g, " ")) : ""
    },
    Referrer() {
        return this._referrer
    },
    Title() {
        return this._docTitle
    },
    Language() {
        return navigator.language
    },
    Platform() {
        return navigator.platform
    },
    UserAgent() {
        return navigator.userAgent
    },
    ExecJS(a) {
        let b = 0;
        try {
            b = eval(a)
        } catch (c) {
            console.error("Error executing JavaScript: ", c)
        }
        return "number" === typeof b || "string" === typeof b ? b : "boolean" === typeof b ? b ? 1 : 0 : 0
    },
    CSSStyleValue(a) {
        return this._cssStyleMap.get(a) || ""
    },
    Name() {
        return navigator.appName
    },
    Version() {
        return navigator.appVersion
    },
    Product() {
        return navigator.product
    },
    Vendor() {
        return navigator.vendor
    },
    BatteryLevel() {
        return 1
    },
    BatteryTimeLeft() {
        return Infinity
    },
    Bandwidth() {
        const a = navigator.connection;
        return a ? a.downlink || a.downlinkMax || a.bandwidth || Infinity : Infinity
    },
    ConnectionType() {
        const a = navigator.connection;
        return a ? a.type || "unknown" : "unknown"
    },
    DevicePixelRatio() {
        return self.devicePixelRatio
    },
    ScreenWidth() {
        return this._screenWidth
    },
    ScreenHeight() {
        return this._screenHeight
    },
    WindowInnerWidth() {
        return this._runtime.GetCanvasManager().GetLastWidth()
    },
    WindowInnerHeight() {
        return this._runtime.GetCanvasManager().GetLastHeight()
    },
    WindowOuterWidth() {
        return this._windowOuterWidth
    },
    WindowOuterHeight() {
        return this._windowOuterWidth
    },
    DisplayMode() {
        return this._runtime.GetCanvasManager().GetCssDisplayMode()
    },
    InstallResult() {
        return this._installResult
    }
};
"use strict";
const C3$jscomp$240 = self.C3;
C3$jscomp$240.Plugins.AJAX = class extends C3$jscomp$240.SDKPluginBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
}
;
const C3$jscomp$241 = self.C3;
C3$jscomp$241.Plugins.AJAX.Type = class extends C3$jscomp$241.SDKTypeBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
}
;
const C3$jscomp$242 = self.C3;
C3$jscomp$242.Plugins.AJAX.Instance = class extends C3$jscomp$242.SDKInstanceBase {
    constructor(a, b) {
        super(a);
        this._lastData = "";
        this._lastStatusCode = 0;
        this._curTag = "";
        this._progress = 0;
        this._timeout = -1;
        this._nextRequestHeaders = new Map;
        this._nextReponseBinaryData = null;
        this._nextRequestOverrideMimeType = "";
        this._nextRequestWithCredentials = !1;
        this._nwjsAppFolder = this._nwjsPath = this._nwjsFs = null;
        if (this._isNWjs = "nwjs" === this._runtime.GetExportType())
            this._nwjsFs = require("fs"),
            this._nwjsPath = require("path"),
            this._nwjsAppFolder = this._nwjsPath.dirname((self.process || nw.process).execPath) + "\\"
    }
    Release() {
        super.Release()
    }
    async _TriggerError(a, b, c) {
        console.error(`[Construct] AJAX request to '${b}' (tag '${a}') failed: `, c);
        this._curTag = a;
        await this.TriggerAsync(C3$jscomp$242.Plugins.AJAX.Cnds.OnAnyError);
        this._curTag = a;
        await this.TriggerAsync(C3$jscomp$242.Plugins.AJAX.Cnds.OnError)
    }
    async _TriggerComplete(a) {
        this._curTag = a;
        await this.TriggerAsync(C3$jscomp$242.Plugins.AJAX.Cnds.OnAnyComplete);
        this._curTag = a;
        await this.TriggerAsync(C3$jscomp$242.Plugins.AJAX.Cnds.OnComplete)
    }
    async _OnProgress(a, b) {
        b.lengthComputable && (this._progress = b.loaded / b.total,
        this._curTag = a,
        await this.TriggerAsync(C3$jscomp$242.Plugins.AJAX.Cnds.OnProgress))
    }
    _OnError(a, b, c) {
        if (this._isNWjs) {
            var d = this._nwjsFs
              , e = this._nwjsAppFolder + b;
            d.existsSync(e) ? d.readFile(e, {
                encoding: "utf8"
            }, (f, h) => {
                f ? this._TriggerError(a, b, f) : (this._lastData = h.replace(/\r\n/g, "\n"),
                this._TriggerComplete(a))
            }
            ) : this._TriggerError(a, b, c)
        } else
            this._TriggerError(a, b, c)
    }
    async _DoCordovaRequest(a, b) {
        const c = this._runtime.GetAssetManager()
          , d = this._nextReponseBinaryData;
        this._nextReponseBinaryData = null;
        try {
            if (d) {
                const e = await c.CordovaFetchLocalFileAsArrayBuffer(b);
                d.SetArrayBufferTransfer(e);
                this._lastData = ""
            } else
                this._lastData = (await c.CordovaFetchLocalFileAsText(b)).replace(/\r\n/g, "\n");
            this._lastStatusCode = 0;
            this._TriggerComplete(a)
        } catch (e) {
            this._TriggerError(a, b, e)
        }
    }
    _DoRequest(a, b, c, d) {
        return new Promise(e => {
            const f = l => {
                this._OnError(a, b, l);
                e()
            }
              , h = this._nextReponseBinaryData;
            this._nextReponseBinaryData = null;
            try {
                const l = new XMLHttpRequest;
                l.onreadystatechange = () => {
                    if (4 === l.readyState) {
                        this._lastData = h ? "" : (l.responseText || "").replace(/\r\n/g, "\n");
                        this._lastStatusCode = l.status;
                        if (400 <= l.status)
                            this._TriggerError(a, b, l.status + l.statusText);
                        else {
                            const m = this._lastData.length || h && l.response instanceof ArrayBuffer;
                            this._isNWjs && !m || !this._isNWjs && 0 === l.status && !m || (h && h.SetArrayBufferTransfer(l.response),
                            this._TriggerComplete(a))
                        }
                        e()
                    }
                }
                ;
                l.onerror = f;
                l.ontimeout = f;
                l.onabort = f;
                l.onprogress = m => this._OnProgress(a, m);
                l.open(c, b);
                0 <= this._timeout && "undefined" !== typeof l.timeout && (l.timeout = this._timeout);
                l.responseType = h ? "arraybuffer" : "text";
                d && !this._nextRequestHeaders.has("Content-Type") && ("string" !== typeof d ? l.setRequestHeader("Content-Type", "application/octet-stream") : l.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"));
                for (const [m,p] of this._nextRequestHeaders)
                    try {
                        l.setRequestHeader(m, p)
                    } catch (r) {
                        console.error(`[Construct] AJAX: Failed to set header '${m}: ${p}': `, r)
                    }
                this._nextRequestHeaders.clear();
                if (this._nextRequestOverrideMimeType) {
                    try {
                        l.overrideMimeType(this._nextRequestOverrideMimeType)
                    } catch (m) {
                        console.error("[Construct] AJAX: failed to override MIME type: ", m)
                    }
                    this._nextRequestOverrideMimeType = ""
                }
                this._nextRequestWithCredentials && (l.withCredentials = !0,
                this._nextRequestWithCredentials = !1);
                d ? l.send(d) : l.send()
            } catch (l) {
                f(l)
            }
        }
        )
    }
    GetDebuggerProperties() {
        return [{
            title: "plugins.ajax.debugger.title",
            properties: [{
                name: "plugins.ajax.debugger.last-status-code",
                value: this._lastStatusCode
            }, {
                name: "plugins.ajax.debugger.last-data",
                value: this._lastData
            }]
        }]
    }
    SaveToJson() {
        return {
            lastData: this._lastData,
            lastStatusCode: this._lastStatusCode
        }
    }
    LoadFromJson(a) {
        this._lastData = a.lastData;
        this._lastStatusCode = a.hasOwnProperty("lastStatusCode") ? a.lastStatusCode : 0;
        this._curTag = "";
        this._progress = 0
    }
}
;
const C3$jscomp$243 = self.C3;
C3$jscomp$243.Plugins.AJAX.Cnds = {
    OnComplete(a) {
        return C3$jscomp$243.equalsNoCase(this._curTag, a)
    },
    OnAnyComplete() {
        return !0
    },
    OnError(a) {
        return C3$jscomp$243.equalsNoCase(this._curTag, a)
    },
    OnAnyError() {
        return !0
    },
    OnProgress(a) {
        return C3$jscomp$243.equalsNoCase(this._curTag, a)
    }
};
const C3$jscomp$244 = self.C3;
C3$jscomp$244.Plugins.AJAX.Acts = {
    async Request(a, b) {
        this._runtime.IsCordova() && C3$jscomp$244.IsRelativeURL(b) && this._runtime.GetAssetManager().IsFileProtocol() ? await this._DoCordovaRequest(a, b) : this._runtime.IsPreview() && C3$jscomp$244.IsRelativeURL(b) ? (b = this._runtime.GetAssetManager().GetLocalUrlAsBlobUrl(b),
        await this._DoRequest(a, b, "GET", null)) : await this._DoRequest(a, b, "GET", null)
    },
    async RequestFile(a, b) {
        this._runtime.IsCordova() && this._runtime.GetAssetManager().IsFileProtocol() ? await this._DoCordovaRequest(a, b) : await this._DoRequest(a, this._runtime.GetAssetManager().GetLocalUrlAsBlobUrl(b), "GET", null)
    },
    async Post(a, b, c, d) {
        await this._DoRequest(a, b, d, c)
    },
    async PostBinary(a, b, c, d) {
        c && (c = c.GetFirstPicked(this._inst)) && (c = c.GetSdkInstance().GetArrayBufferReadOnly(),
        await this._DoRequest(a, b, d, c))
    },
    SetTimeout(a) {
        this._timeout = 1E3 * a
    },
    SetHeader(a, b) {
        this._nextRequestHeaders.set(a, b)
    },
    SetResponseBinary(a) {
        a && (a = a.GetFirstPicked(this._inst)) && (this._nextReponseBinaryData = a.GetSdkInstance())
    },
    OverrideMIMEType(a) {
        this._nextRequestOverrideMimeType = a
    },
    SetWithCredentials(a) {
        this._nextRequestWithCredentials = !!a
    }
};
self.C3.Plugins.AJAX.Exps = {
    LastData() {
        return this._lastData
    },
    LastStatusCode() {
        return this._lastStatusCode
    },
    Progress() {
        return this._progress
    },
    Tag() {
        return this._curTag
    }
};
"use strict";
const C3$jscomp$246 = self.C3;
C3$jscomp$246.Plugins.PlatformInfo = class extends C3$jscomp$246.SDKPluginBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
}
;
const C3$jscomp$247 = self.C3;
C3$jscomp$247.Plugins.PlatformInfo.Type = class extends C3$jscomp$247.SDKTypeBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
    GetScriptInterfaceClass() {
        return self.IPlatformInfoObjectType
    }
}
;
let platformInfoObjectType = null;
function GetSdkInstance() {
    return platformInfoObjectType.GetSingleGlobalInstance().GetSdkInstance()
}
const osMap = new Map([["Windows", "windows"], ["macOS", "macos"], ["Linux", "linux"], ["Chrome OS", "chrome-os"], ["Android", "android"], ["iOS", "ios"]])
  , browserMap = new Map([["Chrome", "chrome"], ["Chromium", "chromium"], ["Edge", "edge"], ["Opera", "opera"], ["NW.js", "nwjs"], ["Firefox", "firefox"], ["Safari", "safari"]])
  , browserEngineMap = new Map([["Chromium", "chromium"], ["Gecko", "gecko"], ["WebKit", "webkit"]]);
self.IPlatformInfoObjectType = class extends self.IObjectClass {
    constructor(a) {
        super(a);
        platformInfoObjectType = a;
        a = a.GetRuntime();
        Object.defineProperties(this, {
            isMobile: {
                value: C3$jscomp$247.Platform.IsMobile,
                writable: !1
            },
            os: {
                value: osMap.get(C3$jscomp$247.Platform.OS) || "unknown",
                writable: !1
            },
            osVersion: {
                value: C3$jscomp$247.Platform.OSVersion,
                writable: !1
            },
            browser: {
                value: browserMap.get(C3$jscomp$247.Platform.Browser) || "unknown",
                writable: !1
            },
            browserVersion: {
                value: C3$jscomp$247.Platform.BrowserVersion,
                writable: !1
            },
            browserEngine: {
                value: browserEngineMap.get(C3$jscomp$247.Platform.BrowserEngine) || "unknown",
                writable: !1
            }
        });
        a._GetCommonScriptInterfaces().platformInfo = this
    }
    get exportType() {
        const a = GetSdkInstance().GetRuntime();
        let b = a.GetExportType();
        GetSdkInstance()._IsNWjs() ? b = "nwjs" : a.IsWindowsWebView2() ? b = "windows-webview2" : "cordova" === b && (b = "Android" === C3$jscomp$247.Platform.OS ? "cordova-android" : "cordova-ios");
        return b
    }
    get renderer() {
        return GetSdkInstance()._GetRendererString()
    }
    get rendererDetail() {
        return GetSdkInstance()._GetRendererDetailString()
    }
    get canvasCssWidth() {
        return platformInfoObjectType.GetRuntime().GetCanvasManager().GetCssWidth()
    }
    get canvasCssHeight() {
        return platformInfoObjectType.GetRuntime().GetCanvasManager().GetCssHeight()
    }
    get canvasDeviceWidth() {
        return platformInfoObjectType.GetRuntime().GetCanvasManager().GetDeviceWidth()
    }
    get canvasDeviceHeight() {
        return platformInfoObjectType.GetRuntime().GetCanvasManager().GetDeviceHeight()
    }
    get devicePixelRatio() {
        return platformInfoObjectType.GetRuntime().GetDevicePixelRatio()
    }
}
;
const C3$jscomp$248 = self.C3;
C3$jscomp$248.Plugins.PlatformInfo.Instance = class extends C3$jscomp$248.SDKInstanceBase {
    constructor(a, b) {
        super(a, "platform-info");
        this._windowOuterHeight = this._windowOuterWidth = this._screenHeight = this._screenWidth = 0;
        this._safeAreaInset = [0, 0, 0, 0];
        this._isNwjs = this._isWakeLockActive = this._supportsWakeLock = !1;
        this.AddDOMMessageHandlers([["window-resize", c => this._OnWindowResize(c)], ["wake-lock-acquired", c => this._OnWakeLockAcquired(c)], ["wake-lock-error", c => this._OnWakeLockError(c)], ["wake-lock-released", c => this._OnWakeLockReleased(c)]]);
        navigator.connection && navigator.connection.addEventListener("change", () => this._OnNetworkChange());
        this._runtime.AddLoadPromise(this.PostToDOMAsync("get-initial-state").then(c => {
            this._screenWidth = c.screenWidth;
            this._screenHeight = c.screenHeight;
            this._windowOuterWidth = c.windowOuterWidth;
            this._windowOuterHeight = c.windowOuterHeight;
            this._safeAreaInset = c.safeAreaInset;
            this._supportsWakeLock = c.supportsWakeLock;
            this._isNwjs = c.isNwjs
        }
        ))
    }
    Release() {
        super.Release()
    }
    _OnWindowResize(a) {
        this._windowOuterWidth = a.windowOuterWidth;
        this._windowOuterHeight = a.windowOuterHeight;
        this._safeAreaInset = a.safeAreaInset
    }
    _IsNWjs() {
        return this._isNwjs
    }
    async _OnNetworkChange() {
        await this.TriggerAsync(C3$jscomp$248.Plugins.PlatformInfo.Cnds.OnNetworkChange)
    }
    async _OnWakeLockAcquired() {
        this._isWakeLockActive = !0;
        await this.TriggerAsync(C3$jscomp$248.Plugins.PlatformInfo.Cnds.OnWakeLockAcquired)
    }
    async _OnWakeLockError() {
        this._isWakeLockActive = !1;
        await this.TriggerAsync(C3$jscomp$248.Plugins.PlatformInfo.Cnds.OnWakeLockError)
    }
    async _OnWakeLockReleased() {
        this._isWakeLockActive = !1;
        await this.TriggerAsync(C3$jscomp$248.Plugins.PlatformInfo.Cnds.OnWakeLockReleased)
    }
    _GetRendererString() {
        let a;
        a = this._runtime.GetWebGPURenderer() ? "webgpu" : "webgl" + this._runtime.GetWebGLRenderer().GetWebGLVersionNumber();
        this._runtime.GetRenderer().HasMajorPerformanceCaveat() && (a += "-software");
        return a
    }
    _GetRendererDetailString() {
        return this._runtime.GetWebGPURenderer() ? this._runtime.GetWebGPURenderer().GetAdapterInfoString() : this._runtime.GetWebGLRenderer().GetUnmaskedRenderer()
    }
}
;
const C3$jscomp$249 = self.C3;
C3$jscomp$249.Plugins.PlatformInfo.Cnds = {
    IsOnMobile() {
        return C3$jscomp$249.Platform.IsMobile
    },
    IsOnWindows() {
        return "Windows" === C3$jscomp$249.Platform.OS
    },
    IsOnMacOS() {
        return "macOS" === C3$jscomp$249.Platform.OS
    },
    IsOnLinux() {
        return "Linux" === C3$jscomp$249.Platform.OS
    },
    IsOnChromeOS() {
        return "Chrome OS" === C3$jscomp$249.Platform.OS
    },
    IsOnAndroid() {
        return "Android" === C3$jscomp$249.Platform.OS
    },
    IsOniOS() {
        return "iOS" === C3$jscomp$249.Platform.OS
    },
    IsWebExport() {
        const a = this._runtime.GetExportType();
        return "html5" === a || "scirra-arcade" === a || "preview" === a || "instant-games" === a
    },
    IsCordovaExport() {
        return this._runtime.IsCordova()
    },
    IsNWjsExport() {
        return "nwjs" === this._runtime.GetExportType() || this._isNwjs
    },
    IsWindowsUWPExport() {
        return "windows-uwp" === this._runtime.GetExportType()
    },
    IsWindowsWebView2Export() {
        return this._runtime.IsWindowsWebView2()
    },
    IsMacOSWKWebView2Export() {
        return "macos-wkwebview" === this._runtime.GetExportType()
    },
    OnNetworkChange() {
        return !0
    },
    OnWakeLockAcquired() {
        return !0
    },
    OnWakeLockError() {
        return !0
    },
    OnWakeLockReleased() {
        return !0
    },
    IsWakeLockActive() {
        return this._isWakeLockActive
    },
    IsWakeLockSupported() {
        return this._supportsWakeLock
    }
};
self.C3.Plugins.PlatformInfo.Acts = {
    RequestWakeLock() {
        this._supportsWakeLock && this._PostToDOMMaybeSync("request-wake-lock")
    },
    ReleaseWakeLock() {
        this._supportsWakeLock && (this._isWakeLockActive = !1,
        this.PostToDOM("release-wake-lock"))
    }
};
self.C3.Plugins.PlatformInfo.Exps = {
    Renderer() {
        return this._GetRendererString()
    },
    RendererDetail() {
        return this._GetRendererDetailString()
    },
    DevicePixelRatio() {
        return this._runtime.GetDevicePixelRatio()
    },
    ScreenWidth() {
        return this._screenWidth
    },
    ScreenHeight() {
        return this._screenHeight
    },
    WindowInnerWidth() {
        return this._runtime.GetCanvasManager().GetLastWidth()
    },
    WindowInnerHeight() {
        return this._runtime.GetCanvasManager().GetLastHeight()
    },
    WindowOuterWidth() {
        return this._windowOuterWidth
    },
    WindowOuterHeight() {
        return this._windowOuterHeight
    },
    CanvasCssWidth() {
        return this._runtime.GetCanvasManager().GetCssWidth()
    },
    CanvasCssHeight() {
        return this._runtime.GetCanvasManager().GetCssHeight()
    },
    CanvasDeviceWidth() {
        return this._runtime.GetCanvasManager().GetDeviceWidth()
    },
    CanvasDeviceHeight() {
        return this._runtime.GetCanvasManager().GetDeviceHeight()
    },
    Downlink() {
        return navigator.connection ? navigator.connection.downlink || 0 : 0
    },
    DownlinkMax() {
        return navigator.connection ? navigator.connection.downlinkMax || 0 : 0
    },
    ConnectionType() {
        return navigator.connection ? navigator.connection.type || "unknown" : "unknown"
    },
    ConnectionEffectiveType() {
        return navigator.connection ? navigator.connection.effectiveType || "unknown" : "unknown"
    },
    ConnectionRTT() {
        return navigator.connection ? navigator.connection.rtt || 0 : 0
    },
    HardwareConcurrency() {
        return navigator.hardwareConcurrency || 0
    },
    DeviceMemory() {
        return navigator.deviceMemory || 0
    },
    SafeAreaInsetTop() {
        return this._safeAreaInset[0]
    },
    SafeAreaInsetRight() {
        return this._safeAreaInset[1]
    },
    SafeAreaInsetBottom() {
        return this._safeAreaInset[2]
    },
    SafeAreaInsetLeft() {
        return this._safeAreaInset[3]
    },
    FramesPerSecond() {
        return this._runtime.GetFramesPerSecond()
    },
    TicksPerSecond() {
        return this._runtime.GetTicksPerSecond()
    }
};
"use strict";
const C3$jscomp$252 = self.C3;
C3$jscomp$252.Plugins.Timeline = class extends C3$jscomp$252.SDKPluginBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
}
;
const C3$jscomp$253 = self.C3
  , C3X$jscomp$38 = self.C3X;
C3$jscomp$253.Plugins.Timeline.Type = class extends C3$jscomp$253.SDKTypeBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
    GetScriptInterfaceClass() {
        return self.ITimelineControllerObjectType
    }
}
;
let tcObjectType = null
  , timelineManager$jscomp$7 = null;
function GetTCInst() {
    return tcObjectType.GetSingleGlobalInstance().GetSdkInstance()
}
function GetTimelineParameter(a) {
    if ("string" === typeof a) {
        const b = timelineManager$jscomp$7.GetTimelineByName(a);
        if (b)
            return b;
        throw Error(`invalid timeline name '${a}'`);
    }
    if (a instanceof self.ITimelineState)
        return tcObjectType.GetRuntime()._UnwrapScriptInterface(a);
    throw Error("invalid timeline parameter");
}
function ValidateTags(a, b=!1) {
    if ((!b || "undefined" !== typeof a && null !== a) && "string" !== typeof a && !Array.isArray(a))
        throw Error("invalid tags");
}
self.ITimelineControllerObjectType = class extends self.IObjectClass {
    constructor(a) {
        super(a);
        tcObjectType = a;
        timelineManager$jscomp$7 = a.GetRuntime().GetTimelineManager();
        a.GetRuntime()._GetCommonScriptInterfaces().timelineController = this
    }
    setInstances(a, b) {
        const c = tcObjectType.GetRuntime();
        if (a instanceof self.IWorldInstance)
            a = [c._UnwrapIWorldInstance(a)];
        else if (Array.isArray(a))
            a = a.map(e => c._UnwrapIWorldInstance(e));
        else
            throw new TypeError("invalid instances");
        if (0 !== a.length) {
            C3X$jscomp$38.RequireOptionalString(b);
            var d = a[0].GetObjectClass();
            GetTCInst()._SetInstancesForNextPlay(d, a, b ?? "")
        }
    }
    play(a, b) {
        a = GetTimelineParameter(a);
        ValidateTags(b, !0);
        GetTCInst()._PlayTimeline(a, b ?? []);
        return a.GetITimelineState()
    }
    *allTimelines() {
        for (const a of timelineManager$jscomp$7.GetTimelines())
            yield a.GetITimelineState()
    }
    *timelinesByTags(a) {
        ValidateTags(a);
        for (const b of timelineManager$jscomp$7.GetTimelinesByTags(a))
            yield b.GetITimelineState()
    }
}
;
const C3$jscomp$254 = self.C3;
C3$jscomp$254.Plugins.Timeline.Instance = class extends C3$jscomp$254.SDKInstanceBase {
    constructor(a, b) {
        super(a);
        this._nextTimelineObjectClasses = new Map;
        this.GetRuntime().GetTimelineManager().SetPluginInstance(a)
    }
    Release() {
        super.Release()
    }
    _SetTimelineInstanceObjects(a, b) {
        for (const c of a)
            b.SetTrackInstance(c.trackId, c.instance)
    }
    _GetTimelineInstanceObjects() {
        const a = [];
        for (const b of this._nextTimelineObjectClasses.values()) {
            const c = b.pickedInstances
              , d = b.trackIds.length;
            for (let e = 0; e < d; e++)
                c[b.startIndex + e] && a.push({
                    trackId: b.trackIds[e],
                    instance: c[b.startIndex + e]
                });
            b.startIndex += d
        }
        return a
    }
    _SetInstancesForNextPlay(a, b, c) {
        a.IsFamily() && (a = a.GetFirstPicked().GetObjectClass());
        this._nextTimelineObjectClasses.has(a) || this._nextTimelineObjectClasses.set(a, {
            startIndex: 0,
            trackIds: [],
            pickedInstances: b
        });
        this._nextTimelineObjectClasses.get(a).trackIds.push(c)
    }
    async _PlayTimeline(a, b, c) {
        if (a) {
            var d = this._runtime.GetTimelineManager()
              , e = [];
            if (this._nextTimelineObjectClasses.size) {
                let h = this._GetTimelineInstanceObjects();
                do
                    if (h.length) {
                        var f = d.GetTimelineOfTemplateForInstances(a, h);
                        f || (f = d.CreateFromTemplate(a),
                        f.ClearTrackInstances(),
                        this._SetTimelineInstanceObjects(h, f));
                        f.SetTags(b);
                        f.Play() && e.push(f.GetPlayPromise());
                        h = this._GetTimelineInstanceObjects()
                    }
                while (h.length)
            } else
                a.SetTags(b),
                a.Play() && e.push(a.GetPlayPromise());
            c || this._nextTimelineObjectClasses.clear();
            await Promise.all(e)
        } else
            c || this._nextTimelineObjectClasses.clear()
    }
}
;
const C3$jscomp$255 = self.C3;
let triggerTimelines = []
  , triggerKeyframes = [];
C3$jscomp$255.Plugins.Timeline.Cnds = {
    PushTriggerTimeline(a) {
        triggerTimelines.push(a)
    },
    PopTriggerTimeline() {
        triggerTimelines.pop()
    },
    GetTriggerTimeline() {
        return triggerTimelines[triggerTimelines.length - 1]
    },
    PushTriggerKeyframe(a) {
        triggerKeyframes.push(a)
    },
    PopTriggerKeyframe(a) {
        triggerKeyframes.pop()
    },
    GetTriggerKeyframe() {
        return triggerKeyframes[triggerKeyframes.length - 1]
    },
    OnTimelineStarted(a) {
        return C3$jscomp$255.Plugins.Timeline.Cnds.GetTriggerTimeline() === a
    },
    OnTimelineStartedByName(a) {
        const b = C3$jscomp$255.Plugins.Timeline.Cnds.GetTriggerTimeline();
        if (!b)
            return !1;
        const c = this._runtime.GetTimelineManager();
        for (const d of c.GetTimelinesByName(a))
            if (C3$jscomp$255.equalsNoCase(b.GetName(), d.GetName()))
                return !0;
        return !1
    },
    OnTimelineStartedByTags(a) {
        const b = C3$jscomp$255.Plugins.Timeline.Cnds.GetTriggerTimeline();
        if (!b)
            return !1;
        const c = this._runtime.GetTimelineManager();
        for (const d of c.GetTimelinesByTags(a))
            if (d.HasTags(b.GetTags()))
                return !0;
        return !1
    },
    OnAnyTimelineStarted() {
        return !0
    },
    OnTimelineFinished(a) {
        return C3$jscomp$255.Plugins.Timeline.Cnds.GetTriggerTimeline() === a
    },
    OnTimelineFinishedByName(a) {
        const b = C3$jscomp$255.Plugins.Timeline.Cnds.GetTriggerTimeline();
        if (!b)
            return !1;
        const c = this._runtime.GetTimelineManager();
        for (const d of c.GetTimelinesByName(a))
            if (C3$jscomp$255.equalsNoCase(b.GetName(), d.GetName()))
                return !0;
        return !1
    },
    OnTimelineFinishedByTags(a) {
        const b = C3$jscomp$255.Plugins.Timeline.Cnds.GetTriggerTimeline();
        if (!b)
            return !1;
        const c = this._runtime.GetTimelineManager();
        for (const d of c.GetTimelinesByTags(a))
            if (d.HasTags(b.GetTags()))
                return !0;
        return !1
    },
    OnAnyTimelineFinished() {
        return !0
    },
    IsPlaying(a) {
        return a.IsPlaying()
    },
    IsPlayingByName(a) {
        const b = this._runtime.GetTimelineManager();
        for (const c of b.GetTimelinesByName(a))
            if (c.IsPlaying())
                return !0;
        return !1
    },
    IsPlayingByTags(a) {
        const b = this._runtime.GetTimelineManager();
        for (const c of b.GetTimelinesByTags(a))
            if (c.IsPlaying())
                return !0;
        return !1
    },
    IsAnyPlaying() {
        return [...this._runtime.GetTimelineManager().GetTimelines()].some(a => a.IsPlaying())
    },
    IsPaused(a) {
        return a.IsPaused()
    },
    IsPausedByName(a) {
        const b = this._runtime.GetTimelineManager();
        for (const c of b.GetTimelinesByName(a))
            if (c.IsPaused())
                return !0;
        return !1
    },
    IsPausedByTags(a) {
        const b = this._runtime.GetTimelineManager();
        for (const c of b.GetTimelinesByTags(a))
            if (c.IsPaused())
                return !0;
        return !1
    },
    IsAnyPaused() {
        return [...this._runtime.GetTimelineManager().GetTimelines()].some(a => a.IsPaused())
    },
    OnTimeSet(a) {
        return C3$jscomp$255.Plugins.Timeline.Cnds.GetTriggerTimeline() === a
    },
    OnTimeSetByName(a) {
        const b = C3$jscomp$255.Plugins.Timeline.Cnds.GetTriggerTimeline();
        if (!b)
            return !1;
        const c = this._runtime.GetTimelineManager();
        for (const d of c.GetTimelinesByName(a))
            if (b === d)
                return !0;
        return !1
    },
    OnTimeSetByTags(a) {
        const b = C3$jscomp$255.Plugins.Timeline.Cnds.GetTriggerTimeline();
        if (!b)
            return !1;
        const c = this._runtime.GetTimelineManager();
        for (const d of c.GetTimelinesByTags(a))
            if (b === d)
                return !0;
        return !1
    },
    OnAnyKeyframeReached() {
        return !!C3$jscomp$255.Plugins.Timeline.Cnds.GetTriggerKeyframe()
    },
    OnKeyframeReached(a, b) {
        const c = C3$jscomp$255.Plugins.Timeline.Cnds.GetTriggerKeyframe();
        if (!c || 0 === c.GetTags().length || !a)
            return !1;
        a = a ? a.split(" ") : [];
        if (0 === b) {
            for (const d of a)
                if (c.HasTag(d))
                    return !0;
            return !1
        }
        for (const d of a)
            if (!c.HasTag(d))
                return !1;
        return !0
    }
};
const C3$jscomp$256 = self.C3;
C3$jscomp$256.Plugins.Timeline.Acts = {
    PlayTimeline(a, b) {
        return this._PlayTimeline(a, b, !1)
    },
    async PlayTimelineByName(a, b) {
        const c = this._runtime.GetTimelineManager()
          , d = [];
        for (const e of c.GetTimelinesByName(a))
            d.push(this._PlayTimeline(e, b, !0));
        this._nextTimelineObjectClasses.clear();
        await Promise.all(d)
    },
    async PlayAllTimelines() {
        const a = this._runtime.GetTimelineManager()
          , b = [];
        for (const c of a.GetTimelines())
            c.Play() && b.push(c.GetPlayPromise());
        this._nextTimelineObjectClasses.clear();
        await Promise.all(b)
    },
    PauseTimeline(a) {
        a && a.Stop()
    },
    PauseTimelineByName(a) {
        const b = this._runtime.GetTimelineManager();
        for (const c of b.GetTimelinesByName(a))
            C3$jscomp$256.Plugins.Timeline.Acts.PauseTimeline.call(this, c)
    },
    PauseTimelineByTags(a) {
        const b = this._runtime.GetTimelineManager();
        for (const c of b.GetTimelinesByTags(a))
            C3$jscomp$256.Plugins.Timeline.Acts.PauseTimeline.call(this, c)
    },
    PauseAllTimelines() {
        const a = this._runtime.GetTimelineManager();
        for (const b of a.GetTimelines())
            b.Stop()
    },
    ResumeTimeline(a) {
        a && a.Resume()
    },
    ResumeTimelineByName(a) {
        const b = this._runtime.GetTimelineManager();
        for (const c of b.GetTimelinesByName(a))
            C3$jscomp$256.Plugins.Timeline.Acts.ResumeTimeline.call(this, c)
    },
    ResumeTimelineByTags(a) {
        const b = this._runtime.GetTimelineManager();
        for (const c of b.GetTimelinesByTags(a))
            C3$jscomp$256.Plugins.Timeline.Acts.ResumeTimeline.call(this, c)
    },
    ResumeAllTimelines() {
        const a = this._runtime.GetTimelineManager();
        for (const b of a.GetTimelines())
            b.Resume()
    },
    StopTimeline(a) {
        a && a.Reset()
    },
    StopTimelineByName(a) {
        const b = this._runtime.GetTimelineManager();
        for (const c of b.GetTimelinesByName(a))
            C3$jscomp$256.Plugins.Timeline.Acts.StopTimeline.call(this, c)
    },
    StopTimelineByTags(a) {
        const b = this._runtime.GetTimelineManager();
        for (const c of b.GetTimelinesByTags(a))
            C3$jscomp$256.Plugins.Timeline.Acts.StopTimeline.call(this, c)
    },
    StopAllTimelines() {
        const a = this._runtime.GetTimelineManager();
        for (const b of a.GetTimelines())
            b.Reset()
    },
    SetTimelineTime(a, b) {
        if (a)
            if (C3$jscomp$256.IsFiniteNumber(b))
                a.SetTime(b);
            else if (C3$jscomp$256.IsString(b)) {
                const c = a.GetKeyframeWithTags(b);
                c ? a.SetTime(c.GetTime()) : C3$jscomp$256.Plugins.Timeline.Acts.SetTimelineTime.call(this, a, Number(b))
            }
    },
    SetTimelineTimeByName(a, b) {
        const c = this._runtime.GetTimelineManager();
        for (const d of c.GetTimelinesByName(a))
            C3$jscomp$256.Plugins.Timeline.Acts.SetTimelineTime.call(this, d, b)
    },
    SetTimelineTimeByTags(a, b) {
        const c = this._runtime.GetTimelineManager();
        for (const d of c.GetTimelinesByTags(a))
            C3$jscomp$256.Plugins.Timeline.Acts.SetTimelineTime.call(this, d, b)
    },
    SetTimelinePlaybackRate(a, b) {
        a && a.SetPlaybackRate(b)
    },
    SetTimelinePlaybackRateByName(a, b) {
        const c = this._runtime.GetTimelineManager();
        for (const d of c.GetTimelinesByName(a))
            C3$jscomp$256.Plugins.Timeline.Acts.SetTimelinePlaybackRate.call(this, d, b)
    },
    SetTimelinePlaybackRateByTags(a, b) {
        const c = this._runtime.GetTimelineManager();
        for (const d of c.GetTimelinesByTags(a))
            C3$jscomp$256.Plugins.Timeline.Acts.SetTimelinePlaybackRate.call(this, d, b)
    },
    SetInstance(a, b) {
        const c = [...a.GetCurrentSol().GetInstances()];
        this._SetInstancesForNextPlay(a, c, b)
    }
};
const C3$jscomp$257 = self.C3;
C3$jscomp$257.Plugins.Timeline.Exps = {
    Time(a) {
        const b = this._runtime.GetTimelineManager();
        for (const c of b.GetTimelinesByName(a))
            return c.GetTime();
        for (const c of b.GetTimelinesByTags(a))
            return c.GetTime();
        return 0
    },
    TotalTime(a) {
        const b = this._runtime.GetTimelineManager();
        for (const c of b.GetTimelinesByName(a))
            return c.GetTotalTime();
        for (const c of b.GetTimelinesByTags(a))
            return c.GetTotalTime();
        return 0
    },
    Progress(a) {
        const b = this._runtime.GetTimelineManager();
        for (const c of b.GetTimelinesByName(a))
            return c.GetTime() / c.GetTotalTime();
        for (const c of b.GetTimelinesByTags(a))
            return c.GetTime() / c.GetTotalTime();
        return 0
    },
    KeyframeTags() {
        const a = C3$jscomp$257.Plugins.Timeline.Cnds.GetTriggerKeyframe();
        return a ? a.GetTags().join(" ") : ""
    },
    TimelineName() {
        const a = C3$jscomp$257.Plugins.Timeline.Cnds.GetTriggerTimeline();
        return a ? a.GetName() : ""
    },
    TimelineTags() {
        const a = C3$jscomp$257.Plugins.Timeline.Cnds.GetTriggerTimeline();
        return a ? a.GetStringTags() : ""
    },
    Value(a, b) {
        const c = this._runtime.GetTimelineManager();
        for (const e of c.GetTimelinesByName(a)) {
            var d = e.GetTrackByName(b);
            if (d) {
                if (d = d.GetPropertyTrack("value"))
                    return d.GetSourceAdapterValue()
            } else if (d = e.GetTrackById(b))
                if (d = d.GetPropertyTrack("value"))
                    return d.GetSourceAdapterValue()
        }
        for (const e of c.GetTimelinesByTags(a))
            if (a = e.GetTrackByName(b)) {
                if (a = a.GetPropertyTrack("value"))
                    return a.GetSourceAdapterValue()
            } else if (a = e.GetTrackById(b))
                if (a = a.GetPropertyTrack("value"))
                    return a.GetSourceAdapterValue();
        return 0
    },
    Ease(a, b) {
        0 > b && (b = 0);
        1 <= b && (b = 1);
        const c = self.Ease.ToInternal(a);
        if (c)
            return self.Ease.GetRuntimeEase(c)(b, 0, 1, 1);
        if (a = self.Ease.GetRuntimeEase(a))
            return a(b, 0, 1, 1);
        console.warn("[TimelineController.Ease expression] no matching built-in or custom ease function found, returning 0");
        return 0
    }
};
"use strict";
const C3$jscomp$258 = self.C3;
C3$jscomp$258.Plugins.AdvancedRandom = class extends C3$jscomp$258.SDKPluginBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
}
;
const C3$jscomp$259 = self.C3
  , C3X$jscomp$39 = self.C3X;
C3$jscomp$259.Plugins.AdvancedRandom.Type = class extends C3$jscomp$259.SDKTypeBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
    GetScriptInterfaceClass() {
        return self.IAdvancedRandomObjectType
    }
}
;
const VALID_GRADIENT_MODES = new Set(["rgb", "float"]);
let advancedRandomObjectType = null;
function GetSdkInstance$jscomp$1() {
    return advancedRandomObjectType.GetSingleGlobalInstance().GetSdkInstance()
}
self.IAdvancedRandomObjectType = class extends self.IObjectClass {
    constructor(a) {
        super(a);
        advancedRandomObjectType = a
    }
    set seed(a) {
        C3X$jscomp$39.RequireString(a);
        GetSdkInstance$jscomp$1()._UpdateSeed(a)
    }
    get seed() {
        return GetSdkInstance$jscomp$1()._GetCurrentSeed()
    }
    set octaves(a) {
        C3X$jscomp$39.RequireFiniteNumber(a);
        GetSdkInstance$jscomp$1()._SetOctaves(a)
    }
    get octaves() {
        return GetSdkInstance$jscomp$1()._GetOctaves()
    }
    classic2d(a, b) {
        C3X$jscomp$39.RequireNumber(a);
        C3X$jscomp$39.RequireNumber(b);
        return GetSdkInstance$jscomp$1()._GetClassic2d(a, b)
    }
    classic3d(a, b, c) {
        C3X$jscomp$39.RequireNumber(a);
        C3X$jscomp$39.RequireNumber(b);
        C3X$jscomp$39.RequireNumber(c);
        return GetSdkInstance$jscomp$1()._GetClassic3d(a, b, c)
    }
    billow2d(a, b) {
        C3X$jscomp$39.RequireNumber(a);
        C3X$jscomp$39.RequireNumber(b);
        return GetSdkInstance$jscomp$1()._GetBillow2d(a, b)
    }
    billow3d(a, b, c) {
        C3X$jscomp$39.RequireNumber(a);
        C3X$jscomp$39.RequireNumber(b);
        C3X$jscomp$39.RequireNumber(c);
        return GetSdkInstance$jscomp$1()._GetBillow3d(a, b, c)
    }
    ridged2d(a, b) {
        C3X$jscomp$39.RequireNumber(a);
        C3X$jscomp$39.RequireNumber(b);
        return GetSdkInstance$jscomp$1()._GetRidged2d(a, b)
    }
    ridged3d(a, b, c) {
        C3X$jscomp$39.RequireNumber(a);
        C3X$jscomp$39.RequireNumber(b);
        C3X$jscomp$39.RequireNumber(c);
        return GetSdkInstance$jscomp$1()._GetRidged3d(a, b, c)
    }
    cellular2d(a, b) {
        C3X$jscomp$39.RequireNumber(a);
        C3X$jscomp$39.RequireNumber(b);
        return GetSdkInstance$jscomp$1()._GetCellular2d(a, b)
    }
    cellular3d(a, b, c) {
        C3X$jscomp$39.RequireNumber(a);
        C3X$jscomp$39.RequireNumber(b);
        C3X$jscomp$39.RequireNumber(c);
        return GetSdkInstance$jscomp$1()._GetCellular3d(a, b, c)
    }
    voronoi2d(a, b) {
        C3X$jscomp$39.RequireNumber(a);
        C3X$jscomp$39.RequireNumber(b);
        return GetSdkInstance$jscomp$1()._GetVoronoi2d(a, b)
    }
    voronoi3d(a, b, c) {
        C3X$jscomp$39.RequireNumber(a);
        C3X$jscomp$39.RequireNumber(b);
        C3X$jscomp$39.RequireNumber(c);
        return GetSdkInstance$jscomp$1()._GetVoronoi3d(a, b, c)
    }
    createGradient(a, b) {
        C3X$jscomp$39.RequireString(a);
        if (!VALID_GRADIENT_MODES.has(b))
            throw Error("invalid mode");
        GetSdkInstance$jscomp$1()._CreateGradient(a, b)
    }
    setCurrentGradient(a) {
        C3X$jscomp$39.RequireString(a);
        GetSdkInstance$jscomp$1()._SetGradient(a)
    }
    addGradientStop(a, b) {
        C3X$jscomp$39.RequireNumber(a);
        C3X$jscomp$39.RequireNumber(b);
        GetSdkInstance$jscomp$1()._AddGradientStop(a, b)
    }
    sampleGradient(a, b) {
        C3X$jscomp$39.RequireOptionalString(a);
        C3X$jscomp$39.RequireNumber(b);
        return a ? GetSdkInstance$jscomp$1()._SampleGradientByName(a, b) : GetSdkInstance$jscomp$1()._SampleCurrentGradient(b)
    }
    createProbabilityTable(a) {
        C3X$jscomp$39.RequireString(a);
        GetSdkInstance$jscomp$1()._CreateProbabilityTable(a)
    }
    createProbabilityTableFromJSON(a, b) {
        C3X$jscomp$39.RequireString(a);
        C3X$jscomp$39.RequireString(b);
        GetSdkInstance$jscomp$1()._CreateProbabilityTableFromJSON(a, b)
    }
    getProbabilityTableAsJSON() {
        return GetSdkInstance$jscomp$1()._GetProbabilityTableAsJSON()
    }
    setCurrentProbabilityTable(a) {
        C3X$jscomp$39.RequireString(a);
        GetSdkInstance$jscomp$1()._SetProbabilityTable(a)
    }
    addProbabilityTableEntry(a, b) {
        C3X$jscomp$39.RequireNumber(a);
        if ("number" !== typeof b && "string" !== typeof b)
            throw new TypeError("invalid value");
        GetSdkInstance$jscomp$1()._AddProbabilityEntry(a, b)
    }
    removeProbabilityTableEntry(a, b) {
        C3X$jscomp$39.RequireNumber(a);
        if ("number" !== typeof b && "string" !== typeof b)
            throw new TypeError("invalid value");
        GetSdkInstance$jscomp$1()._RemoveProbabilityEntry(a, b)
    }
    sampleProbabilityTable(a) {
        C3X$jscomp$39.RequireOptionalString(a);
        return a ? GetSdkInstance$jscomp$1()._SampleProbabilityTableByName(a) : GetSdkInstance$jscomp$1()._SampleCurrentProbabilityTable()
    }
    createPermutationTable(a, b) {
        C3X$jscomp$39.RequireFiniteNumber(a);
        C3X$jscomp$39.RequireNumber(b);
        GetSdkInstance$jscomp$1()._CreatePermutationTable(a, b)
    }
    shufflePermutationTable() {
        GetSdkInstance$jscomp$1()._ShufflePermutationTable()
    }
    getPermutation(a) {
        C3X$jscomp$39.RequireFiniteNumber(a);
        return GetSdkInstance$jscomp$1()._GetPermutation(a)
    }
}
;
const C3$jscomp$260 = self.C3;
function shuffle(a, b) {
    let c = a.length;
    for (; 0 < c; ) {
        const d = Math.floor(b(0, c--))
          , e = a[c];
        a[c] = a[d];
        a[d] = e
    }
    return a
}
class Gradient {
    constructor(a, b) {
        this.mode = a;
        this.name = b;
        this.stops = []
    }
    GetName() {
        return this.name
    }
    AddStop(a, b) {
        switch (this.mode) {
        case "rgb":
            b = this._CreateStopRGB(b);
            break;
        case "float":
            b = this._CreateStopFloat(b)
        }
        let c = this.stops.length;
        for (; c--; )
            if (a > this.stops[c][0]) {
                this.stops.splice(c + 1, 0, [a, b]);
                return
            }
        this.stops.push([a, b])
    }
    _CreateStopFloat(a) {
        return [a]
    }
    _CreateStopRGB(a) {
        const b = C3$jscomp$260.GetRValue(a)
          , c = C3$jscomp$260.GetGValue(a)
          , d = C3$jscomp$260.GetBValue(a);
        return [a, b, c, d, C3$jscomp$260.GetAValue(a)]
    }
    _SampleFloat(a, b, c) {
        return C3$jscomp$260.lerp(a[0], b[0], c)
    }
    _SampleRGB(a, b, c) {
        return C3$jscomp$260.PackRGBAEx(C3$jscomp$260.lerp(a[1], b[1], c), C3$jscomp$260.lerp(a[2], b[2], c), C3$jscomp$260.lerp(a[3], b[3], c), C3$jscomp$260.lerp(a[4], b[4], c))
    }
    Sample(a) {
        const b = this.stops;
        var c = b[0];
        const d = b.length;
        var e = b[d - 1];
        if (a < c[0])
            return c[1][0];
        if (a > e[0])
            return e[1][0];
        e = null;
        for (let f = 1; f < d && !(e = c,
        c = b[f],
        c[0] > a); f++)
            ;
        a = C3$jscomp$260.clamp((a - e[0]) / (c[0] - e[0]), 0, 1);
        switch (this.mode) {
        case "rgb":
            return this._SampleRGB(e[1], c[1], a);
        case "float":
            return this._SampleFloat(e[1], c[1], a)
        }
    }
    asJSON(a=!1) {
        return "rgb" === this.mode ? JSON.stringify(this.stops.map( ([b,c]) => [b, a ? c.slice(1) : c[0]])) : JSON.stringify(this.stops)
    }
}
C3$jscomp$260.Plugins.AdvancedRandom.Instance = class extends C3$jscomp$260.SDKInstanceBase {
    constructor(a, b) {
        super(a);
        this._currentSeed = "";
        this._octaves = 1;
        this._lacunarity = 2;
        this._persistence = .5;
        this._gradients = new Map;
        this._probabilityTables = new Map;
        this._currentProbabilityTable = this._currentGradient = null;
        this._permutation = [0];
        a = b[0];
        this._replaceSystemPRNG = b[1];
        this._funcs = C3$jscomp$260.Plugins.AdvancedRandom.NoiseFuncs;
        this._CreateGradient("default", "rgb");
        this._AddGradientStop(0, C3$jscomp$260.PackRGBEx(0, 0, 0));
        this._AddGradientStop(1, C3$jscomp$260.PackRGBEx(1, 1, 1));
        this._CreateProbabilityTable("default");
        "" === a && (a = this._RandomSeed(10));
        this._UpdateSeed(a);
        this._replaceSystemPRNG && this._runtime.SetRandomNumberGeneratorCallback( () => this._funcs.randomXorshiro(0, 1))
    }
    Release() {
        super.Release()
    }
    SaveToJson() {
        return {
            prng: this._funcs.saveToJson()
        }
    }
    LoadFromJson(a) {
        this._funcs.loadFromJson(a.prng)
    }
    _RandomSeed(a) {
        const b = [];
        for (; a--; )
            b.push(String.fromCharCode(Math.round(25 * Math.random()) + 65));
        return b.join("")
    }
    _UpdateSeed(a) {
        this._currentSeed = a;
        let b = 5381;
        for (let c = 0, d = a.length; c < d; c++)
            b = (b << 5) + b + a.charCodeAt(c);
        this._funcs.seed(b >>> 0)
    }
    _GetCurrentSeed() {
        return this._currentSeed
    }
    _SetOctaves(a) {
        this._octaves = C3$jscomp$260.clamp(a | 0, 1, 16)
    }
    _GetOctaves() {
        return this._octaves
    }
    _GetClassic2d(a, b) {
        return this._funcs.classic2d(a, b, this._octaves)
    }
    _GetClassic3d(a, b, c) {
        return this._funcs.classic3d(a, b, c, this._octaves)
    }
    _GetBillow2d(a, b) {
        return this._funcs.billow2d(a, b, this._octaves)
    }
    _GetBillow3d(a, b, c) {
        return this._funcs.billow3d(a, b, c, this._octaves)
    }
    _GetRidged2d(a, b) {
        return this._funcs.ridged2d(a, b, this._octaves)
    }
    _GetRidged3d(a, b, c) {
        return this._funcs.ridged3d(a, b, c, this._octaves)
    }
    _GetCellular2d(a, b) {
        return this._funcs.cellular2d(a, b)
    }
    _GetCellular3d(a, b, c) {
        return this._funcs.cellular3d(a, b, c)
    }
    _GetVoronoi2d(a, b) {
        return this._funcs.voronoi2d(a, b)
    }
    _GetVoronoi3d(a, b, c) {
        return this._funcs.voronoi3d(a, b, c)
    }
    _CreateGradient(a, b) {
        b = new Gradient(b,a);
        this._gradients.set(a.toLowerCase(), b);
        this._currentGradient = b
    }
    _SetGradient(a) {
        this._currentGradient = this._gradients.get(a.toLowerCase()) || null
    }
    _AddGradientStop(a, b) {
        const c = this._currentGradient;
        null !== c && c.AddStop(a, b)
    }
    _SampleCurrentGradient(a) {
        const b = this._currentGradient;
        return b ? b.Sample(a) : 0
    }
    _SampleGradientByName(a, b) {
        return (a = this._gradients.get(a.toLowerCase())) ? a.Sample(b) : 0
    }
    _CreateProbabilityTable(a) {
        const b = new C3$jscomp$260.ProbabilityTable(a);
        this._probabilityTables.set(a.toLowerCase(), b);
        this._currentProbabilityTable = b
    }
    _CreateProbabilityTableFromJSON(a, b) {
        b = C3$jscomp$260.ProbabilityTable.fromJSON(b);
        this._probabilityTables.set(a.toLowerCase(), b);
        this._currentProbabilityTable = b
    }
    _GetProbabilityTableAsJSON() {
        return this._currentProbabilityTable ? this._currentProbabilityTable.asJSON() : ""
    }
    _SetProbabilityTable(a) {
        this._currentProbabilityTable = this._probabilityTables.get(a.toLowerCase()) || null
    }
    _AddProbabilityEntry(a, b) {
        const c = this._currentProbabilityTable;
        c && c.AddItem(a, b)
    }
    _RemoveProbabilityEntry(a, b) {
        const c = this._currentProbabilityTable;
        c && c.RemoveItem(a, b)
    }
    _SampleCurrentProbabilityTable() {
        const a = this._currentProbabilityTable;
        return a ? a.Sample(this._funcs.randomXorshiro(0, a.GetTotalWeight())) : 0
    }
    _SampleProbabilityTableByName(a) {
        return (a = this._probabilityTables.get(a.toLowerCase())) ? a.Sample(this._funcs.randomXorshiro(0, a.GetTotalWeight())) : 0
    }
    _CreatePermutationTable(a, b) {
        if (2 > a)
            this._permutation = [b];
        else {
            this._permutation = [];
            for (let c = 0; c < a; c++)
                this._permutation.push(c + b);
            shuffle(this._permutation, this._funcs.randomXorshiro)
        }
    }
    _ShufflePermutationTable() {
        shuffle(this._permutation, this._funcs.randomXorshiro)
    }
    _GetPermutation(a) {
        a = Math.floor(a);
        const b = this._permutation
          , c = b.length;
        a %= c;
        0 > a && (a += c);
        return b[a]
    }
    GetDebuggerProperties() {
        const a = []
          , b = [];
        for (var c of this._probabilityTables.values()) {
            const d = c.asJSON();
            b.push({
                name: "$" + c.GetName(),
                value: d.slice(1, -1).toString().replace(/,/g, ", ")
            })
        }
        for (const d of this._gradients.values())
            c = d.asJSON(!0),
            a.push({
                name: "$" + d.GetName(),
                value: c.slice(1, -1).toString().replace(/,/g, ", ")
            });
        return [{
            title: "plugins.advancedrandom.debugger.title",
            properties: [{
                name: "plugins.advancedrandom.debugger.seed",
                value: this._GetCurrentSeed(),
                onedit: d => this._UpdateSeed(d)
            }, {
                name: "plugins.advancedrandom.debugger.replace-system",
                value: this._replaceSystemPRNG
            }, {
                name: "plugins.advancedrandom.debugger.noise-octaves",
                value: this._GetOctaves()
            }, {
                name: "plugins.advancedrandom.debugger.noise-lacunarity",
                value: this._lacunarity
            }, {
                name: "plugins.advancedrandom.debugger.noise-persistence",
                value: this._persistence
            }, {
                name: "plugins.advancedrandom.debugger.current-probability-table",
                value: this._currentProbabilityTable ? this._currentProbabilityTable.GetName() : ""
            }, {
                name: "plugins.advancedrandom.debugger.current-gradient",
                value: this._currentGradient ? this._currentGradient.GetName() : ""
            }, {
                name: "plugins.advancedrandom.debugger.permutation-table",
                value: this._permutation.toString().replace(/,/g, ", ")
            }]
        }, {
            title: "plugins.advancedrandom.debugger.gradients",
            properties: a
        }, {
            title: "plugins.advancedrandom.debugger.probability-tables",
            properties: b
        }]
    }
}
;
self.C3.Plugins.AdvancedRandom.Cnds = {};
self.C3.Plugins.AdvancedRandom.Acts = {
    SetSeed(a) {
        this._UpdateSeed(a)
    },
    SetOctaves(a) {
        this._SetOctaves(a)
    },
    CreateGradient(a, b) {
        this._CreateGradient(a, ["rgb", "float"][b])
    },
    SetGradient(a) {
        this._SetGradient(a)
    },
    AddStop(a, b) {
        this._AddGradientStop(a, b)
    },
    CreateProbabilityTable(a) {
        this._CreateProbabilityTable(a)
    },
    CreateProbabilityTableFromJSON(a, b) {
        try {
            this._CreateProbabilityTableFromJSON(a, b)
        } catch (c) {
            console.warn("Failed to create probability table from JSON String", c)
        }
    },
    SetProbabilityTable(a) {
        this._SetProbabilityTable(a)
    },
    AddProbabilityEntry(a, b) {
        this._AddProbabilityEntry(b, a)
    },
    RemoveProbabilityEntry(a, b) {
        this._RemoveProbabilityEntry(b, a)
    },
    CreatePermutationTable(a, b) {
        this._CreatePermutationTable(a, b)
    },
    ShufflePermutationTable() {
        this._ShufflePermutationTable()
    }
};
self.C3.Plugins.AdvancedRandom.Exps = {
    Classic2d(a, b) {
        return this._GetClassic2d(a, b)
    },
    Classic3d(a, b, c) {
        return this._GetClassic3d(a, b, c)
    },
    Billow2d(a, b) {
        return this._GetBillow2d(a, b)
    },
    Billow3d(a, b, c) {
        return this._GetBillow3d(a, b, c)
    },
    Ridged2d(a, b) {
        return this._GetRidged2d(a, b)
    },
    Ridged3d(a, b, c) {
        return this._GetRidged3d(a, b, c)
    },
    Cellular2d(a, b) {
        return this._GetCellular2d(a, b)
    },
    Cellular3d(a, b, c) {
        return this._GetCellular3d(a, b, c)
    },
    Voronoi2d(a, b) {
        return this._GetVoronoi2d(a, b)
    },
    Voronoi3d(a, b, c) {
        return this._GetVoronoi3d(a, b, c)
    },
    Gradient(a) {
        return this._SampleCurrentGradient(a)
    },
    GradientByName(a, b) {
        return this._SampleGradientByName(a, b)
    },
    Weighted() {
        return this._SampleCurrentProbabilityTable()
    },
    WeightedByName(a) {
        return this._SampleProbabilityTableByName(a)
    },
    RandomSeed() {
        return this._RandomSeed(10)
    },
    Seed() {
        return this._GetCurrentSeed()
    },
    Octaves() {
        return this._GetOctaves()
    },
    Permutation(a) {
        return this._GetPermutation(a)
    },
    ProbabilityTableAsJSON() {
        return this._GetProbabilityTableAsJSON()
    }
};
"use strict";
const C3$jscomp$264 = self.C3;
let splitstate = BigInt(0)
  , s$jscomp$128 = [BigInt(0), BigInt(0), BigInt(0), BigInt(0)]
  , persistence = .5
  , lacunarity = 2;
const tableSizeMask = 255
  , permutation = Array.from({
    length: 512
}, () => 0)
  , grads2 = Array.from({
    length: 256
}, () => ({
    x: 0,
    y: 0
}))
  , grads3 = Array.from({
    length: 256
}, () => ({
    x: 0,
    y: 0,
    z: 0
}));
function pickGradient2(a, b) {
    return permutation[permutation[a & 255] + (b & 255)]
}
function pickGradient3(a, b, c) {
    return permutation[permutation[permutation[a & 255] + (b & 255)] + (c & 255)]
}
function dot2(a, b, c) {
    a = grads2[a];
    return a.x * b + a.y * c
}
function dot3(a, b, c, d) {
    a = grads3[a];
    return a.x * b + a.y * c + a.z * d
}
function quintic(a) {
    return 6 * a * a * a * a * a - 15 * a * a * a * a + 10 * a * a * a
}
function sq(a) {
    return a * a
}
function swap(a, b, c) {
    const d = a[b];
    a[b] = a[c];
    a[c] = d
}
function uint64(a) {
    return BigInt.asUintN(64, a)
}
function splitmix64() {
    let a = splitstate = uint64(splitstate + BigInt("0x9e3779b97f4a7c15"));
    a = uint64((a ^ a >> BigInt(30)) * BigInt("0xbf58476d1ce4e5b9"));
    a = uint64((a ^ a >> BigInt(27)) * BigInt("0x94d049bb133111eb"));
    return uint64(a ^ a >> BigInt(31))
}
function rotl(a, b) {
    return uint64(a << b | a >> BigInt(64) - b)
}
function next$jscomp$3() {
    const a = uint64(rotl(uint64(s$jscomp$128[1] * BigInt(5)), BigInt(7)) * BigInt(9))
      , b = uint64(s$jscomp$128[1] << BigInt(17));
    s$jscomp$128[2] = uint64(s$jscomp$128[2] ^ s$jscomp$128[0]);
    s$jscomp$128[3] = uint64(s$jscomp$128[3] ^ s$jscomp$128[1]);
    s$jscomp$128[1] = uint64(s$jscomp$128[1] ^ s$jscomp$128[2]);
    s$jscomp$128[0] = uint64(s$jscomp$128[0] ^ s$jscomp$128[3]);
    s$jscomp$128[2] = uint64(s$jscomp$128[2] ^ b);
    s$jscomp$128[3] = rotl(s$jscomp$128[3], BigInt(45));
    return a
}
function nextFloat() {
    return Number(next$jscomp$3() >> BigInt(11)) / 9007199254740992
}
C3$jscomp$264.Plugins.AdvancedRandom.NoiseFuncs = {
    setLacunarity(a) {
        lacunarity = a
    },
    setPersistence(a) {
        persistence = a
    },
    saveToJson() {
        return {
            splitstate: splitstate.toString(),
            s: s$jscomp$128.map(a => a.toString())
        }
    },
    loadFromJson(a) {
        splitstate = BigInt(a.splitstate);
        for (let b = 0, c = s$jscomp$128.length; b < c; ++b)
            s$jscomp$128[b] = BigInt(a.s[b])
    },
    noise2d(a, b) {
        var c = Math.floor(a)
          , d = Math.floor(b)
          , e = a - c;
        const f = b - d;
        b = dot2(pickGradient2(c, d), e, f);
        a = dot2(pickGradient2(c + 1, d), e - 1, f);
        const h = dot2(pickGradient2(c, d + 1), e, f - 1);
        c = dot2(pickGradient2(c + 1, d + 1), e - 1, f - 1);
        d = quintic(e);
        e = quintic(f);
        return C3$jscomp$264.lerp(C3$jscomp$264.lerp(b, h, e), C3$jscomp$264.lerp(a, c, e), d)
    },
    noise3d(a, b, c) {
        var d = Math.floor(a)
          , e = Math.floor(b)
          , f = Math.floor(c)
          , h = a - d;
        const l = b - e
          , m = c - f;
        c = dot3(pickGradient3(d, e, f), h, l, m);
        b = dot3(pickGradient3(d + 1, e, f), h - 1, l, m);
        a = dot3(pickGradient3(d, e + 1, f), h, l - 1, m);
        const p = dot3(pickGradient3(d + 1, e + 1, f), h - 1, l - 1, m)
          , r = dot3(pickGradient3(d, e, f + 1), h, l, m - 1)
          , v = dot3(pickGradient3(d + 1, e, f + 1), h - 1, l, m - 1)
          , x = dot3(pickGradient3(d, e + 1, f + 1), h, l - 1, m - 1);
        d = dot3(pickGradient3(d + 1, e + 1, f + 1), h - 1, l - 1, m - 1);
        e = quintic(h);
        f = quintic(l);
        h = quintic(m);
        return C3$jscomp$264.lerp(C3$jscomp$264.lerp(C3$jscomp$264.lerp(c, b, e), C3$jscomp$264.lerp(a, p, e), f), C3$jscomp$264.lerp(C3$jscomp$264.lerp(r, v, e), C3$jscomp$264.lerp(x, d, e), f), h)
    },
    randomXorshiro(a, b) {
        return nextFloat() * (b - a) + a
    },
    randomSplitMix(a, b) {
        return Number(splitmix64() >> 11) / 9007199254740992 * (b - a) + a
    },
    seed(a) {
        splitstate = BigInt(a);
        s$jscomp$128[0] = splitmix64();
        s$jscomp$128[1] = splitmix64();
        s$jscomp$128[2] = splitmix64();
        s$jscomp$128[3] = splitmix64();
        splitmix64();
        splitmix64();
        for (a = 0; 256 > a; ++a) {
            var b = nextFloat();
            b = Math.acos(2 * b - 1);
            const c = 2 * nextFloat() * Math.PI;
            grads3[a].x = Math.cos(c) * Math.sin(b);
            grads3[a].y = Math.sin(c) * Math.sin(b);
            grads3[a].z = Math.cos(b);
            grads2[a].x = Math.cos(c);
            grads2[a].y = Math.sin(c);
            permutation[a] = a
        }
        for (a = 0; 256 > a; ++a)
            swap(permutation, a, Number(next$jscomp$3() & BigInt(tableSizeMask)));
        for (a = 0; 256 > a; ++a)
            permutation[256 + a] = permutation[a]
    },
    classic3d(a, b, c, d) {
        if (1 == d)
            return .5 * (this.noise3d(.013 * a, .013 * b, .013 * c) + 1);
        let e = 1, f = .013, h = 0, l, m = 0;
        for (let p = 0; p < d; p++)
            l = this.noise3d(f * a, f * b, f * c),
            h += e * l,
            m += e,
            f *= lacunarity,
            e *= persistence;
        return (h / m + 1) / 2
    },
    billow3d(a, b, c, d) {
        if (1 == d)
            return Math.abs(this.noise3d(.013 * a, .013 * b, .013 * c));
        let e = 1, f = .013, h = 0, l, m = 0;
        for (let p = 0; p < d; p++)
            l = this.noise3d(f * a, f * b, f * c),
            l = Math.abs(l),
            h += e * l,
            m += e,
            f *= lacunarity,
            e *= persistence;
        return h / m
    },
    ridged3d(a, b, c, d) {
        if (1 == d)
            return sq(1 - Math.abs(this.noise3d(.013 * a, .013 * b, .013 * c)));
        let e = 1, f = .013, h = 0, l, m = 0;
        for (let p = 0; p < d; p++)
            l = this.noise3d(f * a, f * b, f * c),
            l = sq(1 - Math.abs(l)),
            h += e * l,
            m += e,
            f *= lacunarity,
            e *= persistence;
        return h / m
    },
    classic2d(a, b, c) {
        if (1 == c)
            return .5 * (this.noise2d(.013 * a, .013 * b) + 1);
        let d = 1, e = .013, f = 0, h, l = 0;
        for (let m = 0; m < c; m++)
            h = this.noise2d(e * a, e * b),
            f += d * h,
            l += d,
            e *= lacunarity,
            d *= persistence;
        return (f / l + 1) / 2
    },
    billow2d(a, b, c) {
        if (1 == c)
            return Math.abs(this.noise2d(.013 * a, .013 * b));
        let d = 1, e = .013, f = 0, h, l = 0;
        for (let m = 0; m < c; m++)
            h = this.noise2d(e * a, e * b),
            h = Math.abs(h),
            f += d * h,
            l += d,
            e *= lacunarity,
            d *= persistence;
        return f / l
    },
    ridged2d(a, b, c) {
        if (1 == c)
            return sq(1 - Math.abs(this.noise2d(.013 * a, .013 * b)));
        let d = 1, e = .013, f = 0, h, l = 0;
        for (let m = 0; m < c; m++)
            h = this.noise2d(e * a, e * b),
            h = 1 - Math.abs(h),
            h *= h,
            f += d * h,
            l += d,
            e *= lacunarity,
            d *= persistence;
        return f / l
    },
    cellular2d(a, b) {
        a *= .013;
        b *= .013;
        const c = Math.floor(a)
          , d = Math.floor(b);
        a -= c;
        b -= d;
        let e = 1E5;
        for (let h = -1; 1 >= h; h++)
            for (let l = -1; 1 >= l; l++) {
                var f = grads2[pickGradient2(c + l, d + h)];
                const m = l + Math.abs(f.x) - a;
                f = h + Math.abs(f.y) - b;
                e = Math.min(m * m + f * f, e)
            }
        return C3$jscomp$264.clamp(Math.sqrt(e), 0, 1)
    },
    cellular3d(a, b, c) {
        a *= .013;
        b *= .013;
        c *= .013;
        const d = Math.floor(a)
          , e = Math.floor(b)
          , f = Math.floor(c);
        a -= d;
        b -= e;
        c -= f;
        let h = 1E5;
        for (let m = -1; 1 >= m; m++)
            for (let p = -1; 1 >= p; p++)
                for (let r = -1; 1 >= r; r++) {
                    var l = grads3[pickGradient3(d + p, e + m, f + r)];
                    const v = p + Math.abs(l.x) - a
                      , x = m + Math.abs(l.y) - b;
                    l = r + Math.abs(l.z) - c;
                    h = Math.min(v * v + x * x + l * l, h)
                }
        return C3$jscomp$264.clamp(Math.sqrt(h), 0, 1)
    },
    voronoi2d(a, b) {
        a *= .013;
        b *= .013;
        const c = Math.floor(a)
          , d = Math.floor(b);
        a -= c;
        b -= d;
        let e = 1E5, f;
        for (let m = -1; 1 >= m; m++)
            for (let p = -1; 1 >= p; p++) {
                const r = c + p
                  , v = d + m;
                var h = grads2[pickGradient2(r, v)]
                  , l = p + Math.abs(h.x) - a;
                h = m + Math.abs(h.y) - b;
                l = l * l + h * h;
                l < e && (e = l,
                f = permutation[permutation[r & 255] + (v & 255)])
            }
        return f / 255
    },
    voronoi3d(a, b, c) {
        a *= .013;
        b *= .013;
        c *= .013;
        const d = Math.floor(a)
          , e = Math.floor(b)
          , f = Math.floor(c);
        a -= d;
        b -= e;
        c -= f;
        let h = 1E5, l;
        for (let r = -1; 1 >= r; r++)
            for (let v = -1; 1 >= v; v++)
                for (let x = -1; 1 >= x; x++) {
                    const B = d + v
                      , A = e + r
                      , D = f + x;
                    var m = grads3[pickGradient3(B, A, D)]
                      , p = v + Math.abs(m.x) - a;
                    const F = r + Math.abs(m.y) - b;
                    m = x + Math.abs(m.z) - c;
                    p = p * p + F * F + m * m;
                    p < h && (h = p,
                    l = permutation[permutation[permutation[B & 255] + (A & 255)] + (D & 255)])
                }
        return l / 255
    }
};
globalThis.C3.Plugins.Eponesh_GameScore = class extends globalThis.ISDKPluginBase {
    constructor(a) {
        super(a, "Eponesh_GameScore")
    }
    Release() {
        super.Release()
    }
}
;
globalThis.C3.Plugins.Eponesh_GameScore.Type = class extends globalThis.ISDKObjectTypeBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
}
;
function waitFor(a, b) {
    return new Promise( (c, d) => {
        let e = 0;
        a(globalThis) ? c() : (e = setInterval(function() {
            a(globalThis) && (clearInterval(e),
            c())
        }, 100),
        b && setTimeout(d, b))
    }
    )
}
async function loadScript({src: a, check: b, insertTarget: c}) {
    if (!b || !b(globalThis))
        return document.querySelector(`script[src="${a}"]`) ? b ? waitFor(b) : Promise.resolve() : new Promise( (d, e) => {
            if (a.includes("gamepush")){ 
				console.log("uu")
				a = "sdk-bundle/gamepush.gdd.js";
			}
			const f = document.createElement("script");
            if (f.src = a,
            f.onload = () => d(b ? waitFor(b) : void 0),
            f.onerror = () => e(),
            f.onabort = () => e(),
            c)
                c.selector.insertAdjacentElement(c.position, f);
            else
                try {
                    document.querySelector("script").parentElement.appendChild(f)
                } catch (h) {
                    e(h)
                }
        }
        )
}
globalThis.C3.Plugins.Eponesh_GameScore.Instance = class extends globalThis.ISDKInstanceBase {
    constructor(a) {
        super();
        this.mappers = {
            language: "en ru fr it de es zh pt ko ja tr ar hi id".split(" "),
            syncStorage: ["preferred", "cloud", "platform", "local"],
            storageType: ["platform", "local"],
            avatarGenerator: "dicebear_retro dicebear_identicon dicebear_human dicebear_micah dicebear_bottts icotar robohash_robots robohash_cats".split(" "),
            order: ["default", "DESC", "ASC"],
            withMe: ["none", "first", "last"],
            platform: "YANDEX VK NONE OK GAME_MONETIZE CRAZY_GAMES GAME_DISTRIBUTION SMARTMARKET GAMEPIX POKI VK_PLAY WG_PLAYGROUND KONGREGATE GOOGLE_PLAY PLAYDECK APP_GALLERY GALAXY_STORE ONE_STORE AMAZON_APPSTORE XIAOMI_GETAPPS APTOIDE RUSTORE ANDROID TELEGRAM BEELINE FOTOSTRANA".split(" "),
            deviceTypes: ["Desktop", "IOS", "Android", "TV"],
            documentTypes: ["PLAYER_PRIVACY_POLICY"],
            documentFormat: ["HTML", "TXT", "RAW"],
            bonusType: ["REWARD", "ACHIEVEMENT", "PRODUCT"],
            schedulerType: ["ACTIVE_DAYS", "ACTIVE_DAYS_CONSECUTIVE"],
            variablesTypes: "stats data flag image file doc_html".split(" "),
            compare: [ (b, c) => b === c, (b, c) => b !== c, (b, c) => b < c, (b, c) => b <= c, (b, c) => c < b, (b, c) => c <= b]
        };
        this.etos = function(b) {
            return "string" == typeof b ? b : "message"in b ? b.message : String(b)
        }
        ;
        this.getIdOrTag = b => {
            var c = parseInt(b, 10) || 0;
            return 0 < c ? {
                id: c
            } : {
                tag: b
            }
        }
        ;
        this.conditions = globalThis.C3.Plugins.Eponesh_GameScore.Cnds;
        this.actions = globalThis.C3.Plugins.Eponesh_GameScore.Acts;
        this.handleResult = (b, c) => {
            this.isLastActionSuccess = !!b;
            c && (this.lastError = this.etos(c),
            console.warn(c))
        }
        ;
        this.awaiters = {
            player: {},
            gp: {}
        };
        this.awaiters.gp.ready = new Promise( (b, c) => {
            this.awaiters.gp.done = b;
            this.awaiters.gp.abort = c
        }
        );
        this.awaiters.player.ready = new Promise( (b, c) => {
            this.awaiters.player.done = b;
            this.awaiters.player.abort = c
        }
        );
        this.leaderboard = [];
        this.leaderboardInfo = {};
        this.leaderboardRecords = {};
        this.leaderboardResult = {
            abovePlayers: [],
            belowPlayers: [],
            topPlayers: []
        };
        this.currentLeaderboardIndex = 0;
        this.currentLeaderboardPlayer = {};
        this.lastLeaderboardPlayerRatingTag = this.lastLeaderboardVariant = this.lastLeaderboardTag = "";
        this.leaderboardPlayerPosition = 0;
        this.platformVariables = {};
        this.currentPlayerFieldVariantName = this.currentPlayerFieldVariantValue = this.storageCurValue = this.storageCurKey = this.currentUniquesValue = this.currentUniquesTag = this.currentPlayerFieldValue = this.currentPlayerFieldName = this.currentPlayerFieldType = this.currentPlayerFieldKey = "";
        this.currentPlayerFieldVariantIndex = 0;
        this.achievements = [];
        this.achievementsGroups = [];
        this.playerAchievements = [];
        this.currentAchievementIndex = 0;
        this.currentAchievement = {};
        this.currentAchievementsGroupId = this.currentAchievementsGroupIndex = 0;
        this.currentAchievementsGroupDescription = this.currentAchievementsGroupName = this.currentAchievementsGroupTag = "";
        this.currentPlayerAchievementId = this.currentPlayerAchievementIndex = 0;
        this.currentPlayerAchievementUnlockDate = "";
        this.isUnlockAchievementSuccess = !1;
        this.unlockAchievementError = "";
        this.isSetProgressAchievementSuccess = !1;
        this.setProgressAchievementError = "";
        this.products = [];
        this.playerPurchases = [];
        this.currentProductIndex = 0;
        this.currentProduct = {
            id: 0,
            tag: "",
            name: "",
            description: "",
            icon: "",
            iconSmall: "",
            price: 0,
            currency: "",
            currencySymbol: ""
        };
        this.currentPurchaseIndex = this.currentProductPurchases = 0;
        this.currentPurchase = {
            id: 0,
            tag: "",
            createdAt: "",
            expiredAt: "",
            subscribed: !1
        };
        this.isPurchaseProductSuccess = this.isUnsubscribeProductSuccess = this.isSubscribeProductSuccess = !1;
        this.purchaseProductError = "";
        this.purchasedProductId = 0;
        this.purchasedProductTag = "";
        this.isConsumeProductSuccess = !1;
        this.consumeProductError = "";
        this.consumedProductId = 0;
        this.lastRewardedTag = this.consumedProductTag = "";
        this.isPlayerReady = this.isReady = this.isLastAddShortcutSuccess = this.isLastCommunityJoinSuccess = this.isLastShareSuccess = this.isLastAdSuccess = !1;
        this.gamesCollection = {
            id: 0,
            tag: "",
            name: "",
            description: "",
            games: []
        };
        this.currentGameId = this.currentGameIndex = 0;
        this.lastGamesCollectionIdOrTag = this.gamesCollectionFetchError = this.currentGameUrl = this.currentGameIcon = this.currentGameDescription = this.currentGameName = "";
        this.document = {
            type: "",
            content: ""
        };
        this.lastError = this.documentFetchError = this.lastDocumentType = "";
        this.isLastActionSuccess = !1;
        this.shareLink = "";
        this.shareParams = {};
        this.images = [];
        this.canLoadMoreImages = !1;
        this.currentImageTagIndex = this.currentImageIndex = 0;
        this.lastImageTempUrl = this.currentImageTag = "";
        this.currentImage = {
            id: "",
            playerId: 0,
            width: 0,
            height: 0,
            src: "",
            tags: []
        };
        this.files = [];
        this.lastFileContent = "";
        this.canLoadMoreFiles = !1;
        this.currentFileTagIndex = this.currentFileIndex = 0;
        this.lastFileTempUrl = this.currentFileTag = "";
        this.currentFile = {
            id: "",
            playerId: 0,
            name: "",
            size: 0,
            src: "",
            tags: []
        };
        this.currentVariableIndex = 0;
        this.currentVariable = {
            key: "",
            type: "",
            value: ""
        };
        this.currentPlayersIndex = 0;
        this.lastPlayersTag = "";
        this.currentPlayersPlayer = {
            state: {},
            achievements: [],
            purchases: []
        };
        this.curRewardIndex = 0;
        this.curReward = {};
        this.curPlayerReward = {};
        this.setReward = (b={}, c=0) => {
            this.curRewardIndex = c;
            this.curReward = b.reward || {};
            this.curPlayerReward = b.playerReward || {}
        }
        ;
        this.curTriggerIndex = 0;
        this.curTriggerInfo = {
            trigger: {}
        };
        this.setTriggerInfo = (b, c=0) => {
            b = this.gp.triggers.getTrigger(b);
            b.trigger || (b.trigger = {});
            this.curTriggerIndex = c;
            this.curTriggerInfo = b || {
                trigger: {}
            }
        }
        ;
        this.curBonusIndex = 0;
        this.curBonus = {};
        this.setBonus = (b, c=0) => {
            this.curBonusIndex = c;
            this.curBonus = b || {}
        }
        ;
        this.curSchedulerIndex = 0;
        this.curSchedulerInfo = {
            scheduler: {}
        };
        this.curSchedulerDayInfo = {
            scheduler: {}
        };
        this.setSchedulerInfo = (b, c=0) => {
            const d = this.gp.schedulers.getScheduler(b);
            d.scheduler || (d.scheduler = {});
            this.curSchedulerIndex = c;
            this.curSchedulerInfo = d || {
                scheduler: {}
            };
            this.setSchedulerDayInfo(b, 1, c)
        }
        ;
        this.setSchedulerDayInfo = (b, c, d) => {
            b = this.gp.schedulers.getSchedulerDay(b, c);
            b.scheduler || (b.scheduler = {});
            this.curSchedulerDayInfo = b || {
                scheduler: {}
            }
        }
        ;
        this.curEventIndex = 0;
        this.curEventInfo = {
            event: {}
        };
        this.setEventInfo = (b, c=0) => {
            b = this.gp.events.getEvent(b);
            b.event || (b.event = {});
            this.curEventIndex = c;
            this.curEventInfo = b || {
                event: {}
            }
        }
        ;
        this.lastIdOrTag = {
            id: 0,
            tag: ""
        };
        this.lastPickedSchedulerDay = 0;
        this.lastPickedSchedulerTriggerIdOrTag = "";
        this.isPickedIdOrTag = b => {
            b = this.getIdOrTag(b);
            return 0 < b.id && b.id === this.lastIdOrTag.id || "" != b.tag && b.tag === this.lastIdOrTag.tag
        }
        ;
        this.isPickedSchedulerDayAndTrigger = (b, c, d) => {
            b = !b || this.isPickedIdOrTag(b);
            c = !c || c === this.lastPickedSchedulerDay;
            d = !d || d === this.lastPickedSchedulerTriggerIdOrTag;
            return b && c && d
        }
        ;
        this.curSegment = "";
        a = this._getInitProperties();
        if (a && (this.projectId = Number(a[0] || 0),
        this.publicToken = a[1],
        this.showPreloaderOnStart = a[2],
        this.shouldWaitPlayerOnLoad = a[3],
        this.isEnabled = a[4],
        this.isAutoSendGameStart = a[5]),
        this.runtime.addLoadPromise(this.awaiters.gp.ready),
        this.shouldWaitPlayerOnLoad && this.runtime.addLoadPromise(this.awaiters.player.ready),
        !this.isEnabled)
            return this.onError("[GamePush] disabled"),
            this.awaiters.gp.done(),
            void this.awaiters.player.done();
        this.runtime.addEventListener("afterfirstlayoutstart", () => {
            const b = this.runtime;
            b && (b.GameScore = this.gp,
            b.GamePush = this.gp);
            this.isReady && this._trigger(this.conditions.OnReady);
            this.isPlayerReady && this._trigger(this.conditions.OnPlayerReady);
            this.isAutoSendGameStart && this.gp.gameStart()
        }
        );
        this.loadLib()
    }
    onError(a) {
        console.warn(a);
        a = () => Promise.resolve({});
        this.awaiters.gp.done();
        this.awaiters.player.done();
        this.gp = {
            on() {},
            changeLanguage: a,
            changeAvatarGenerator: a,
            loadOverlay: a,
            pause: a,
            resume: a,
            gameStart: a,
            gameplayStart: a,
            gameplayStop: a,
            isDev: !1,
            isPaused: !1,
            isGameplay: !1,
            isPortrait: !1,
            language: "en",
            avatarGenerator: "dicebear_retro",
            app: {
                on() {},
                title: "",
                description: "",
                image: "",
                url: "",
                canAddShortcut: !1,
                addShortcut: a
            },
            device: {
                on() {},
                type: ""
            },
            analytics: {
                on() {},
                hit() {},
                goal() {}
            },
            platform: {
                on() {},
                hasIntegratedAuth: !1,
                type: "NONE"
            },
            socials: {
                isSupportsNativeShare: !1,
                isSupportsNativePosts: !1,
                isSupportsNativeInvite: !1,
                share: a,
                post: a,
                invite: a,
                makeShareUrl: () => ""
            },
            leaderboard: {
                on() {},
                open: a,
                fetch: a,
                fetchScoped: a,
                fetchPlayerRating: a,
                fetchPlayerRatingScoped: a
            },
            achievements: {
                on() {},
                has() {},
                open: a,
                fetch: a,
                unlock: a,
                setProgress: a
            },
            gamesCollections: {
                on() {},
                open: a,
                fetch: a
            },
            documents: {
                on() {},
                open: a,
                fetch: a
            },
            variables: {
                list: [],
                on() {},
                fetch: a,
                get: a,
                has: a,
                type: a
            },
            images: {
                canUpload: !1,
                list: [],
                on() {},
                upload: a,
                uploadUrl: a,
                fetch: a,
                fetchMore: a,
                chooseFile: a,
                resize: a
            },
            files: {
                canUpload: !1,
                list: [],
                on() {},
                upload: a,
                uploadUrl: a,
                uploadContent: a,
                loadContent: a,
                fetch: a,
                fetchMore: a,
                chooseFile: a
            },
            payments: {
                isAvailable: !1,
                purchases: [],
                on() {},
                has() {},
                fetchProducts: a,
                purchase: a,
                consume: a
            },
            fullscreen: {
                isEnabled: !1,
                on() {},
                open() {},
                close() {},
                toggle() {}
            },
            ads: {
                isFullscreenAvailable: !1,
                isRewardedAvailable: !1,
                isPreloaderAvailable: !1,
                isStickyAvailable: !1,
                isAdblockEnabled: !1,
                on() {},
                showFullscreen: a,
                showRewardedVideo: a,
                showPreloader: a,
                showSticky: a,
                closeSticky: a,
                refreshSticky: a
            },
            player: {
                isStub: !0,
                isLoggedIn: !1,
                id: 0,
                name: "",
                avatar: "",
                stats: {},
                on() {},
                sync: a,
                load: a,
                login: a,
                logout: a,
                fetchFields: a,
                getField: a,
                getFieldName: a,
                getFieldVariantName: a,
                add: a,
                has: a,
                get: a,
                set: a,
                toggle: a,
                reset: a,
                remove: a,
                toJSON: () => ({}),
                fields: []
            },
            players: {
                on() {},
                fetch: a
            },
            rewards: {
                on() {},
                list: [],
                givenList: [],
                accept: a,
                give: a,
                has: a,
                hasAccepted: a,
                hasUnaccepted: a,
                getReward: a
            },
            triggers: {
                on() {},
                list: [],
                activatedList: [],
                claim: a,
                isActivated: a,
                isClaimed: a,
                getTrigger: a
            },
            schedulers: {
                on() {},
                list: [],
                activeList: [],
                getSchedulersTriggers: a,
                getScheduler: a,
                isRegistered: a,
                isTodayRewardClaimed: a,
                canClaimDay: a,
                canClaimDayAdditional: a,
                canClaimAllDay: a,
                getSchedulerDay: a,
                getSchedulerCurrentDay: a,
                claimDay: a,
                claimDayAdditional: a,
                claimAllDay: a,
                claimAllDays: a
            },
            events: {
                on() {},
                list: [],
                activeList: [],
                getEvent: a,
                has: a,
                join: a,
                isJoined: a
            },
            uniques: {
                on() {},
                list: [],
                register: a,
                check: a,
                delete: a,
                get: a
            },
            storage: {
                on() {},
                get: a,
                set: a,
                getGlobal: a,
                setGlobal: a
            }
        };
        this.isReady = !0;
        this._trigger(this.conditions.OnReady);
        this.isPlayerReady = !0;
        this._trigger(this.conditions.OnPlayerReady)
    }
    async loadLib() {
        try {
            globalThis.onGPInit = c => c.ready.then( () => this.init(c)).catch(d => this.onError(d));
            for (var a = [".", "./files/gs/sdk", "./files/gs/sdk", "."], b = 0; b < a.length; b++)
                try {
                    await loadScript({
                        src: `${a[b]}/sdk-bundle/gamepush.gd.js?projectId=${this.projectId}&publicToken=${this.publicToken}&callback=onGPInit`
                    });
                    break
                } catch (c) {}
        } catch (c) {
            console.error(c),
            this.onError(c)
        }
    }
    init(a) {
        this.gp = a;
        (a = this.runtime) && (a.GameScore = this.gp,
        a.GamePush = this.gp);
        this.gp.player.on("ready", () => {
            this.isPlayerReady = !0;
            this.awaiters.player.done();
            this._trigger(this.conditions.OnPlayerReady)
        }
        );
        this.gp.player.on("change", () => this._trigger(this.conditions.OnPlayerChange));
        this.gp.player.on("sync", b => {
            this.handleResult(b);
            this._trigger(b ? this.conditions.OnPlayerSyncComplete : this.conditions.OnPlayerSyncError)
        }
        );
        this.gp.player.on("load", b => {
            this.handleResult(b);
            this._trigger(b ? this.conditions.OnPlayerLoadComplete : this.conditions.OnPlayerLoadError)
        }
        );
        this.gp.player.on("login", b => {
            this.handleResult(b);
            this._trigger(b ? this.conditions.OnPlayerLoginComplete : this.conditions.OnPlayerLoginError)
        }
        );
        this.gp.player.on("logout", b => {
            this.handleResult(b);
            this._trigger(b ? this.conditions.OnPlayerLogoutComplete : this.conditions.OnPlayerLogoutError)
        }
        );
        this.gp.player.on("fetchFields", b => {
            this.handleResult(b);
            this._trigger(b ? this.conditions.OnPlayerFetchFieldsComplete : this.conditions.OnPlayerFetchFieldsError)
        }
        );
        this.gp.player.on("field:increment", ({field: b}) => {
            this.currentPlayerFieldKey = b.key;
            this.currentPlayerFieldType = b.type;
            this.currentPlayerFieldName = b.name;
            this.currentPlayerFieldValue = this.gp.player.get(b.key);
            this._trigger(this.conditions.OnPlayerFieldIncrement)
        }
        );
        this.gp.player.on("field:maximum", ({field: b}) => {
            this.currentPlayerFieldKey = b.key;
            this.currentPlayerFieldType = b.type;
            this.currentPlayerFieldName = b.name;
            this.currentPlayerFieldValue = this.gp.player.get(b.key);
            this._trigger(this.conditions.OnPlayerFieldMaximum)
        }
        );
        this.gp.player.on("field:minimum", ({field: b}) => {
            this.currentPlayerFieldKey = b.key;
            this.currentPlayerFieldType = b.type;
            this.currentPlayerFieldName = b.name;
            this.currentPlayerFieldValue = this.gp.player.get(b.key);
            this._trigger(this.conditions.OnPlayerFieldMinimum)
        }
        );
        this.gp.uniques.on("register", ({tag: b, value: c}) => {
            this.handleResult(!0);
            this.currentUniquesTag = b;
            this.currentUniquesValue = c;
            this._trigger(this.conditions.OnUniquesRegister)
        }
        );
        this.gp.uniques.on("check", ({tag: b, value: c}) => {
            this.handleResult(!0);
            this.currentUniquesTag = b;
            this.currentUniquesValue = c;
            this._trigger(this.conditions.OnUniquesCheck)
        }
        );
        this.gp.uniques.on("delete", ({tag: b}) => {
            this.handleResult(!0);
            this.currentUniquesTag = b;
            this.currentUniquesValue = "";
            this._trigger(this.conditions.OnUniquesDelete)
        }
        );
        this.gp.uniques.on("error:register", b => {
            this.handleResult(!1, b);
            this._trigger(this.conditions.OnUniquesRegisterError)
        }
        );
        this.gp.uniques.on("error:check", b => {
            this.handleResult(!1, b);
            this._trigger(this.conditions.OnUniquesCheckError)
        }
        );
        this.gp.uniques.on("error:delete", b => {
            this.handleResult(!1, b);
            this._trigger(this.conditions.OnUniquesDeleteError)
        }
        );
        this.gp.storage.on("get", ({key: b, value: c}) => {
            this.handleResult(!0);
            this.storageCurKey = b;
            this.storageCurValue = c;
            this._trigger(this.conditions.OnStorageGet)
        }
        );
        this.gp.storage.on("set", ({key: b, value: c}) => {
            this.handleResult(!0);
            this.storageCurKey = b;
            this.storageCurValue = c;
            this._trigger(this.conditions.OnStorageSet)
        }
        );
        this.gp.storage.on("get:global", ({key: b, value: c}) => {
            this.handleResult(!0);
            this.storageCurKey = b;
            this.storageCurValue = c;
            this._trigger(this.conditions.OnStorageGetGlobal)
        }
        );
        this.gp.storage.on("set:global", ({key: b, value: c}) => {
            this.handleResult(!0);
            this.storageCurKey = b;
            this.storageCurValue = c;
            this._trigger(this.conditions.OnStorageSetGlobal)
        }
        );
        this.gp.leaderboard.on("open", () => this._trigger(this.conditions.OnLeaderboardOpen));
        this.gp.leaderboard.on("close", () => this._trigger(this.conditions.OnLeaderboardClose));
        this.gp.achievements.on("open", () => this._trigger(this.conditions.OnAchievementsOpen));
        this.gp.achievements.on("close", () => this._trigger(this.conditions.OnAchievementsClose));
        this.gp.achievements.on("unlock", b => {
            this.handleResult(!0);
            this.isUnlockAchievementSuccess = !0;
            this.unlockAchievementError = "";
            this.currentAchievement = b || {};
            this._trigger(this.conditions.OnAchievementsUnlock);
            this._trigger(this.conditions.OnAchievementsAnyUnlock)
        }
        );
        this.gp.achievements.on("error:unlock", (b, c) => {
            this.lastIdOrTag = c.input;
            this.isUnlockAchievementSuccess = !1;
            this.unlockAchievementError = this.etos(b);
            this.handleResult(!1, b);
            this._trigger(this.conditions.OnAchievementsAnyUnlockError)
        }
        );
        this.gp.achievements.on("progress", b => {
            this.handleResult(!0);
            this.currentAchievement = b || {};
            this._trigger(this.conditions.OnAchievementsSetProgress);
            this._trigger(this.conditions.OnAchievementsAnySetProgress)
        }
        );
        this.gp.achievements.on("error:progress", (b, c) => {
            this.lastIdOrTag = c.input;
            this.handleResult(!1, b);
            this._trigger(this.conditions.OnAchievementsAnySetProgressError)
        }
        );
        this.gp.payments.on("purchase", b => {
            this.isPurchaseProductSuccess = !0;
            this.purchaseProductError = "";
            this.handleResult(!0);
            b = b.product || {};
            this.purchasedProductId = b.id || 0;
            this.purchasedProductTag = b.tag || "";
            this._trigger(this.conditions.OnPaymentsPurchase);
            this._trigger(this.conditions.OnPaymentsAnyPurchase)
        }
        );
        this.gp.payments.on("error:purchase", (b, c) => {
            this.lastIdOrTag = c.input;
            this.isPurchaseProductSuccess = !1;
            this.purchasedProductId = c.input.id || 0;
            this.purchasedProductTag = c.input.tag || "";
            this.purchaseProductError = this.etos(b);
            this.handleResult(!1, b);
            this._trigger(this.conditions.OnPaymentsPurchaseError);
            this._trigger(this.conditions.OnPaymentsAnyPurchaseError)
        }
        );
        this.gp.payments.on("subscribe", b => {
            this.isSubscribeProductSuccess = !0;
            this.handleResult(!0);
            var c = b.product || {};
            this.currentPurchase = b = b.purchase || {};
            this.currentProduct = c;
            this.currentProductPurchases = 1;
            this.purchasedProductId = c.id || 0;
            this.purchasedProductTag = c.tag || "";
            this._trigger(this.conditions.OnPaymentsSubscribe);
            this._trigger(this.conditions.OnPaymentsAnySubscribe)
        }
        );
        this.gp.payments.on("error:subscribe", (b, c) => {
            this.lastIdOrTag = c.input;
            this.isSubscribeProductSuccess = !1;
            this.purchasedProductId = c.input.id || 0;
            this.purchasedProductTag = c.input.tag || "";
            this.isSubscribeProductSuccess = !1;
            this.handleResult(!1, b);
            this._trigger(this.conditions.OnPaymentsSubscribeError);
            this._trigger(this.conditions.OnPaymentsAnySubscribeError)
        }
        );
        this.gp.gamesCollections.on("open", () => this._trigger(this.conditions.OnGamesCollectionsOpen));
        this.gp.gamesCollections.on("close", () => this._trigger(this.conditions.OnGamesCollectionsClose));
        this.gp.documents.on("open", () => this._trigger(this.conditions.OnDocumentsOpen));
        this.gp.documents.on("close", () => this._trigger(this.conditions.OnDocumentsClose));
        this.gp.fullscreen.on("open", () => this._trigger(this.conditions.OnFullscreenOpen));
        this.gp.fullscreen.on("close", () => this._trigger(this.conditions.OnFullscreenClose));
        this.gp.fullscreen.on("change", () => this._trigger(this.conditions.OnFullscreenChange));
        this.gp.ads.on("start", () => this._trigger(this.conditions.OnAdsStart));
        this.gp.ads.on("close", b => {
            this.handleResult(b);
            this.isLastAdSuccess = b;
            this._trigger(this.conditions.OnAdsClose)
        }
        );
        this.gp.ads.on("fullscreen:start", () => this._trigger(this.conditions.OnAdsFullscreenStart));
        this.gp.ads.on("fullscreen:close", () => this._trigger(this.conditions.OnAdsFullscreenClose));
        this.gp.ads.on("preloader:start", () => this._trigger(this.conditions.OnAdsPreloaderStart));
        this.gp.ads.on("preloader:close", () => this._trigger(this.conditions.OnAdsPreloaderClose));
        this.gp.ads.on("rewarded:start", () => this._trigger(this.conditions.OnAdsRewardedStart));
        this.gp.ads.on("rewarded:close", () => this._trigger(this.conditions.OnAdsRewardedClose));
        this.gp.ads.on("rewarded:reward", () => this._trigger(this.conditions.OnAdsRewardedReward));
        this.gp.ads.on("sticky:start", () => this._trigger(this.conditions.OnAdsStickyStart));
        this.gp.ads.on("sticky:close", () => this._trigger(this.conditions.OnAdsStickyClose));
        this.gp.ads.on("sticky:refresh", () => this._trigger(this.conditions.OnAdsStickyRefresh));
        this.gp.ads.on("sticky:render", () => this._trigger(this.conditions.OnAdsStickyRender));
        this.gp.socials.on("share", b => {
            this.handleResult(b);
            this.isLastShareSuccess = b;
            this._trigger(this.conditions.OnSocialsShare)
        }
        );
        this.gp.socials.on("post", b => {
            this.handleResult(b);
            this.isLastShareSuccess = b;
            this._trigger(this.conditions.OnSocialsPost)
        }
        );
        this.gp.socials.on("invite", b => {
            this.handleResult(b);
            this.isLastShareSuccess = b;
            this._trigger(this.conditions.OnSocialsInvite)
        }
        );
        this.gp.socials.on("joinCommunity", b => {
            this.handleResult(b);
            this.isLastCommunityJoinSuccess = b;
            this._trigger(this.conditions.OnSocialsJoinCommunity)
        }
        );
        this.gp.app.on("addShortcut", b => {
            this.handleResult(b);
            this.isLastAddShortcutSuccess = b;
            this._trigger(this.conditions.OnAppAddShortcut)
        }
        );
        this.gp.app.on("review", b => {
            this.handleResult(!0);
            this.appLastReviewRating = b.rating || 0;
            this._trigger(this.conditions.OnAppReview)
        }
        );
        this.gp.app.on("error:review", b => {
            this.handleResult(!1, b);
            this.appLastReviewRating = 0;
            this._trigger(this.conditions.OnAppReviewError)
        }
        );
        this.gp.on("change:language", () => this._trigger(this.conditions.OnChangeLanguage));
        this.gp.on("change:avatarGenerator", () => this._trigger(this.conditions.OnChangeAvatarGenerator));
        this.gp.on("change:orientation", () => this._trigger(this.conditions.OnChangeOrientation));
        this.gp.on("overlay:ready", () => this._trigger(this.conditions.OnOverlayReady));
        this.gp.on("pause", () => this._trigger(this.conditions.OnPause));
        this.gp.on("resume", () => this._trigger(this.conditions.OnResume));
        this.gp.on("gameplayStart", () => this._trigger(this.conditions.OnGameplayStart));
        this.gp.on("gameplayStop", () => this._trigger(this.conditions.OnGameplayStop));
        this.gp.channels.on("event", b => {
            this.curEvent = b
        }
        );
        this.gp.on("event:connect", () => {
            this._trigger(this.conditions.OnEventConnect)
        }
        );
        this.gp.rewards.on("accept", b => {
            this.setReward(b);
            this.handleResult(!0);
            this.lastIdOrTag = {
                id: b.reward.id,
                tag: b.reward.tag
            };
            this._trigger(this.conditions.OnRewardsAccept)
        }
        );
        this.gp.rewards.on("error:accept", (b, c) => {
            this.handleResult(!1, b);
            this.lastIdOrTag = c.input;
            this._trigger(this.conditions.OnRewardsAcceptError)
        }
        );
        this.gp.rewards.on("give", b => {
            this.setReward(b);
            this.handleResult(!0);
            this.lastIdOrTag = {
                id: b.reward.id,
                tag: b.reward.tag
            };
            this._trigger(this.conditions.OnRewardsGive)
        }
        );
        this.gp.rewards.on("error:give", (b, c) => {
            this.handleResult(!1, b);
            this.lastIdOrTag = c.input;
            this._trigger(this.conditions.OnRewardsGiveError)
        }
        );
        this.gp.triggers.on("activate", b => {
            this.setTriggerInfo(b.trigger.id);
            this.handleResult(!0);
            this.lastIdOrTag = {
                id: b.trigger.id,
                tag: b.trigger.tag
            };
            this._trigger(this.conditions.OnTriggersActivate)
        }
        );
        this.gp.triggers.on("claim", b => {
            this.setTriggerInfo(b.trigger.id);
            this.handleResult(!0);
            this.lastIdOrTag = {
                id: b.trigger.id,
                tag: b.trigger.tag
            };
            this._trigger(this.conditions.OnTriggersClaim)
        }
        );
        this.gp.triggers.on("error:claim", (b, c) => {
            this.handleResult(!1, b);
            this.lastIdOrTag = c.input;
            this._trigger(this.conditions.OnTriggersClaimError)
        }
        );
        this.gp.schedulers.on("register", b => {
            this.setSchedulerInfo(b.scheduler.id);
            this.handleResult(!0);
            this.lastIdOrTag = {
                id: b.scheduler.id,
                tag: b.scheduler.tag
            };
            this._trigger(this.conditions.OnSchedulersRegister)
        }
        );
        this.gp.schedulers.on("error:register", (b, c) => {
            this.handleResult(!1, b);
            this.lastIdOrTag = c.input;
            this._trigger(this.conditions.OnSchedulersRegisterError)
        }
        );
        this.gp.schedulers.on("claimDay", b => {
            this.setSchedulerInfo(b.scheduler.id);
            this.setSchedulerDayInfo(b.scheduler.id, b.day);
            this.handleResult(!0);
            this.lastIdOrTag = {
                id: b.scheduler.id,
                tag: b.scheduler.tag
            };
            this.lastPickedSchedulerDay = b.day;
            this._trigger(this.conditions.OnSchedulersClaimDay)
        }
        );
        this.gp.schedulers.on("error:claimDay", (b, c) => {
            this.handleResult(!1, b);
            this.lastIdOrTag = c.input;
            this.lastPickedSchedulerDay = c.input.day;
            this._trigger(this.conditions.OnSchedulersClaimDayError)
        }
        );
        this.gp.schedulers.on("claimDayAdditional", (b, c) => {
            this.setSchedulerInfo(b.scheduler.id);
            this.setSchedulerDayInfo(b.scheduler.id, b.day);
            this.setTriggerInfo(c.input.triggerIdOrTag);
            this.handleResult(!0);
            this.lastIdOrTag = {
                id: b.scheduler.id,
                tag: b.scheduler.tag
            };
            this.lastPickedSchedulerDay = b.day;
            this.lastPickedSchedulerTriggerIdOrTag = c.input.triggerIdOrTag;
            this._trigger(this.conditions.OnSchedulersClaimDayAdditional)
        }
        );
        this.gp.schedulers.on("error:claimDayAdditional", (b, c) => {
            this.handleResult(!1, b);
            this.lastIdOrTag = c.input;
            this.lastPickedSchedulerDay = c.input.day;
            this.lastPickedSchedulerTriggerIdOrTag = c.input.triggerIdOrTag;
            this._trigger(this.conditions.OnSchedulersClaimDayAdditionalError)
        }
        );
        this.gp.schedulers.on("claimAllDay", b => {
            this.setSchedulerInfo(b.scheduler.id);
            this.setSchedulerDayInfo(b.scheduler.id, b.day);
            this.handleResult(!0);
            this.lastIdOrTag = {
                id: b.scheduler.id,
                tag: b.scheduler.tag
            };
            this.lastPickedSchedulerDay = b.day;
            this._trigger(this.conditions.OnSchedulersClaimAllDay)
        }
        );
        this.gp.schedulers.on("error:claimAllDay", (b, c) => {
            this.handleResult(!1, b);
            this.lastIdOrTag = c.input;
            this.lastPickedSchedulerDay = c.input.day;
            this._trigger(this.conditions.OnSchedulersClaimAllDayError)
        }
        );
        this.gp.schedulers.on("claimAllDays", b => {
            this.setSchedulerInfo(b.scheduler.id);
            this.handleResult(!0);
            this.lastIdOrTag = {
                id: b.scheduler.id,
                tag: b.scheduler.tag
            };
            this._trigger(this.conditions.OnSchedulersClaimAllDays)
        }
        );
        this.gp.schedulers.on("error:claimAllDays", (b, c) => {
            this.handleResult(!1, b);
            this.lastIdOrTag = c.input;
            this._trigger(this.conditions.OnSchedulersClaimAllDaysError)
        }
        );
        this.gp.events.on("join", b => {
            this.setEventInfo(b.event.id);
            this.handleResult(!0);
            this.lastIdOrTag = {
                id: b.event.id,
                tag: b.event.tag
            };
            this._trigger(this.conditions.OnEventsJoin)
        }
        );
        this.gp.events.on("error:join", (b, c) => {
            this.handleResult(!1, b);
            this.lastIdOrTag = c.input;
            this._trigger(this.conditions.OnEventsJoinError)
        }
        );
        this.gp.segments.on("enter", b => {
            this.curSegment = b;
            this._trigger(this.conditions.OnSegmentsEnter)
        }
        );
        this.gp.segments.on("leave", b => {
            this.curSegment = b;
            this._trigger(this.conditions.OnSegmentsLeave)
        }
        );
        this.isReady = !0;
        this._trigger(this.conditions.OnReady);
        this.awaiters.gp.done();
        this.showPreloaderOnStart && this.gp.ads.showPreloader()
    }
    Release() {
        super.Release()
    }
    SaveToJson() {
        return {
            leaderboard: this.leaderboard,
            leaderboardInfo: this.leaderboardInfo,
            leaderboardRecords: this.leaderboardRecords,
            leaderboardResult: this.leaderboardResult,
            currentLeaderboardIndex: this.currentLeaderboardIndex,
            currentLeaderboardPlayer: this.currentLeaderboardPlayer,
            lastLeaderboardTag: this.lastLeaderboardTag,
            lastLeaderboardVariant: this.lastLeaderboardVariant,
            lastLeaderboardPlayerRatingTag: this.lastLeaderboardPlayerRatingTag,
            leaderboardPlayerPosition: this.leaderboardPlayerPosition,
            currentPlayerFieldKey: this.currentPlayerFieldKey,
            currentPlayerFieldType: this.currentPlayerFieldType,
            currentPlayerFieldName: this.currentPlayerFieldName,
            currentPlayerFieldValue: this.currentPlayerFieldValue,
            currentUniquesTag: this.currentUniquesTag,
            currentUniquesValue: this.currentUniquesValue,
            storageCurKey: this.storageCurKey,
            storageCurValue: this.storageCurValue,
            lastRewardedTag: this.lastRewardedTag,
            currentPlayerFieldVariantValue: this.currentPlayerFieldVariantValue,
            currentPlayerFieldVariantName: this.currentPlayerFieldVariantName,
            currentPlayerFieldVariantIndex: this.currentPlayerFieldVariantIndex,
            isLastAdSuccess: this.isLastAdSuccess,
            isLastShareSuccess: this.isLastShareSuccess,
            isLastCommunityJoinSuccess: this.isLastCommunityJoinSuccess,
            isLastAddShortcutSuccess: this.isLastAddShortcutSuccess,
            isReady: this.isReady,
            isPlayerReady: this.isPlayerReady,
            achievements: this.achievements,
            achievementsGroups: this.achievementsGroups,
            playerAchievements: this.playerAchievements,
            currentAchievementIndex: this.currentAchievementIndex,
            currentAchievement: this.currentAchievement,
            currentAchievementsGroupIndex: this.currentAchievementsGroupIndex,
            currentAchievementsGroupId: this.currentAchievementsGroupId,
            currentAchievementsGroupTag: this.currentAchievementsGroupTag,
            currentAchievementsGroupName: this.currentAchievementsGroupName,
            currentAchievementsGroupDescription: this.currentAchievementsGroupDescription,
            currentPlayerAchievementIndex: this.currentPlayerAchievementIndex,
            currentPlayerAchievementId: this.currentPlayerAchievementId,
            currentPlayerAchievementUnlockDate: this.currentPlayerAchievementUnlockDate,
            isUnlockAchievementSuccess: this.isUnlockAchievementSuccess,
            unlockAchievementError: this.unlockAchievementError,
            products: this.products,
            playerPurchases: this.playerPurchases,
            currentProductIndex: this.currentProductIndex,
            currentProduct: this.currentProduct,
            currentProductPurchases: this.currentProductPurchases,
            currentPurchaseIndex: this.currentPurchaseIndex,
            currentPurchase: this.currentPurchase,
            lastPlayersTag: this.lastPlayersTag,
            currentPlayersIndex: this.currentPlayersIndex,
            currentPlayersPlayer: this.currentPlayersPlayer,
            isSubscribeProductSuccess: this.isSubscribeProductSuccess,
            isUnsubscribeProductSuccess: this.isUnsubscribeProductSuccess,
            isPurchaseProductSuccess: this.isPurchaseProductSuccess,
            purchaseProductError: this.purchaseProductError,
            purchasedProductId: this.purchasedProductId,
            purchasedProductTag: this.purchasedProductTag,
            isConsumeProductSuccess: this.isConsumeProductSuccess,
            consumeProductError: this.consumeProductError,
            consumedProductId: this.consumedProductId,
            consumedProductTag: this.consumedProductTag,
            gamesCollection: this.gamesCollection,
            currentGameIndex: this.currentGameIndex,
            currentGameId: this.currentGameId,
            currentGameName: this.currentGameName,
            currentGameDescription: this.currentGameDescription,
            currentGameIcon: this.currentGameIcon,
            currentGameUrl: this.currentGameUrl,
            gamesCollectionFetchError: this.gamesCollectionFetchError,
            lastGamesCollectionIdOrTag: this.lastGamesCollectionIdOrTag,
            document: this.document,
            lastDocumentType: this.lastDocumentType,
            documentFetchError: this.documentFetchError,
            lastError: this.lastError,
            isLastActionSuccess: this.isLastActionSuccess,
            images: this.images,
            canLoadMoreImages: this.canLoadMoreImages,
            currentImage: this.currentImage,
            lastImageTempUrl: this.lastImageTempUrl,
            currentImageIndex: this.currentImageIndex,
            currentImageTagIndex: this.currentImageTagIndex,
            currentImageTag: this.currentImageTag,
            files: this.files,
            lastFileContent: this.lastFileContent,
            canLoadMoreFiles: this.canLoadMoreFiles,
            currentFile: this.currentFile,
            lastFileTempUrl: this.lastFileTempUrl,
            currentFileIndex: this.currentFileIndex,
            currentFileTagIndex: this.currentFileTagIndex,
            currentFileTag: this.currentFileTag,
            curRewardIndex: this.curRewardIndex,
            curReward: this.curReward,
            curPlayerReward: this.curPlayerReward,
            curTriggerIndex: this.curTriggerIndex,
            curTriggerInfo: this.curTriggerInfo,
            curBonusIndex: this.curBonusIndex,
            curBonus: this.curBonus,
            curSchedulerIndex: this.curSchedulerIndex,
            curSchedulerInfo: this.curSchedulerInfo,
            curSchedulerDayInfo: this.curSchedulerDayInfo,
            curEventIndex: this.curEventIndex,
            curEventInfo: this.curEventInfo,
            currentVariableIndex: this.currentVariableIndex,
            currentVariable: this.currentVariable,
            curSegment: this.curSegment
        }
    }
    LoadFromJson(a) {
        this.leaderboard = a.leaderboard;
        this.leaderboardInfo = a.leaderboardInfo || {};
        this.leaderboardRecords = a.leaderboardRecords || {};
        this.leaderboardResult = a.leaderboardResult || {
            abovePlayers: [],
            belowPlayers: [],
            topPlayers: []
        };
        this.currentLeaderboardIndex = a.currentLeaderboardIndex;
        this.currentLeaderboardPlayer = a.currentLeaderboardPlayer || {};
        this.lastLeaderboardTag = a.lastLeaderboardTag;
        this.lastLeaderboardVariant = a.lastLeaderboardVariant;
        this.lastLeaderboardPlayerRatingTag = a.lastLeaderboardPlayerRatingTag;
        this.leaderboardPlayerPosition = a.leaderboardPlayerPosition || 0;
        this.currentPlayerFieldKey = a.currentPlayerFieldKey;
        this.currentPlayerFieldType = a.currentPlayerFieldType;
        this.currentPlayerFieldName = a.currentPlayerFieldName;
        this.currentPlayerFieldValue = a.currentPlayerFieldValue;
        this.currentUniquesTag = a.currentUniquesTag;
        this.currentUniquesValue = a.currentUniquesValue;
        this.storageCurKey = a.storageCurKey;
        this.storageCurValue = a.storageCurValue;
        this.lastRewardedTag = a.lastRewardedTag;
        this.currentPlayerFieldVariantValue = a.currentPlayerFieldVariantValue;
        this.currentPlayerFieldVariantName = a.currentPlayerFieldVariantName;
        this.currentPlayerFieldVariantIndex = a.currentPlayerFieldVariantIndex;
        this.isLastAdSuccess = a.isLastAdSuccess;
        this.isLastShareSuccess = a.isLastShareSuccess;
        this.isLastCommunityJoinSuccess = a.isLastCommunityJoinSuccess;
        this.isLastAddShortcutSuccess = a.isLastAddShortcutSuccess;
        this.isReady = a.isReady;
        this.isPlayerReady = a.isPlayerReady;
        this.achievements = a.achievements || [];
        this.achievementsGroups = a.achievementsGroups || [];
        this.playerAchievements = a.playerAchievements || [];
        this.currentAchievementIndex = a.currentAchievementIndex || 0;
        this.currentAchievement = a.currentAchievement || {};
        this.currentAchievementsGroupIndex = a.currentAchievementsGroupIndex || 0;
        this.currentAchievementsGroupId = a.currentAchievementsGroupId || 0;
        this.currentAchievementsGroupTag = a.currentAchievementsGroupTag || "";
        this.currentAchievementsGroupName = a.currentAchievementsGroupName || "";
        this.currentAchievementsGroupDescription = a.currentAchievementsGroupDescription || "";
        this.currentPlayerAchievementIndex = a.currentPlayerAchievementIndex || 0;
        this.currentPlayerAchievementId = a.currentPlayerAchievementId || 0;
        this.currentPlayerAchievementUnlockDate = a.currentPlayerAchievementUnlockDate || "";
        this.isUnlockAchievementSuccess = a.isUnlockAchievementSuccess || !1;
        this.unlockAchievementError = a.unlockAchievementError || "";
        this.products = a.products || [];
        this.playerPurchases = a.playerPurchases || [];
        this.currentProductIndex = a.currentProductIndex || 0;
        this.currentProduct = a.currentProduct || {
            id: 0,
            tag: "",
            name: "",
            description: "",
            icon: "",
            iconSmall: "",
            price: 0,
            currency: "",
            currencySymbol: ""
        };
        this.currentProductPurchases = a.currentProductPurchases || 0;
        this.currentPurchaseIndex = a.currentPurchaseIndex || 0;
        this.currentPurchase = a.currentPurchase || {
            id: 0,
            tag: "",
            createdAt: ""
        };
        this.lastPlayersTag = a.lastPlayersTag;
        this.currentPlayersIndex = a.currenPlayersIndex || 0;
        this.currentPlayersPlayer = a.currentPlayersPlayer || {
            state: {},
            achievements: [],
            purchases: []
        };
        this.isSubscribeProductSuccess = a.isSubscribeProductSuccess || !1;
        this.isUnsubscribeProductSuccess = a.isUnsubscribeProductSuccess || !1;
        this.isPurchaseProductSuccess = a.isPurchaseProductSuccess || !1;
        this.purchaseProductError = a.purchaseProductError || "";
        this.purchasedProductId = a.purchasedProductId || 0;
        this.purchasedProductTag = a.purchasedProductTag || "";
        this.isConsumeProductSuccess = a.isConsumeProductSuccess || !1;
        this.consumeProductError = a.consumeProductError || "";
        this.consumedProductId = a.consumedProductId || 0;
        this.consumedProductTag = a.consumedProductTag || "";
        this.gamesCollection = a.gamesCollection || {
            id: 0,
            tag: "",
            name: "",
            description: "",
            games: []
        };
        this.currentGameIndex = a.currentGameIndex || 0;
        this.currentGameId = a.currentGameId || 0;
        this.currentGameName = a.currentGameName || "";
        this.currentGameDescription = a.currentGameDescription || "";
        this.currentGameIcon = a.currentGameIcon || "";
        this.currentGameUrl = a.currentGameUrl || "";
        this.gamesCollectionFetchError = a.gamesCollectionFetchError || "";
        this.lastGamesCollectionIdOrTag = a.lastGamesCollectionIdOrTag || "";
        this.document = a.document || {
            type: "",
            content: ""
        };
        this.lastDocumentType = a.lastDocumentType || "";
        this.documentFetchError = a.documentFetchError || "";
        this.lastError = a.lastError || "";
        this.isLastActionSuccess = a.isLastActionSuccess || !1;
        this.images = a.images || [];
        this.canLoadMoreImages = a.canLoadMoreImages || !1;
        this.currentImageIndex = a.currentImageIndex || 0;
        this.currentImageTagIndex = a.currentImageTagIndex || 0;
        this.currentImageTag = a.currentImageTag || "";
        this.currentImage = a.currentImage || {
            id: "",
            playerId: 0,
            width: 0,
            height: 0,
            src: "",
            tags: []
        };
        this.files = a.files || [];
        this.lastFileContent = a.lastFileContent || "";
        this.canLoadMoreFiles = a.canLoadMoreFiles || !1;
        this.currentFileIndex = a.currentFileIndex || 0;
        this.currentFileTagIndex = a.currentFileTagIndex || 0;
        this.currentFileTag = a.currentFileTag || "";
        this.currentFile = a.currentFile || {
            id: "",
            playerId: 0,
            name: "",
            size: 0,
            src: "",
            tags: []
        };
        this.currentVariableIndex = a.currentVariableIndex || 0;
        this.currentVariable = a.currentVariable || {
            key: "",
            type: "",
            value: ""
        };
        this.curRewardIndex = a.curRewardIndex || 0;
        this.curReward = a.curReward || {};
        this.curPlayerReward = a.curPlayerReward || {};
        this.curTriggerIndex = a.curTriggerIndex || 0;
        this.curTriggerInfo = a.curTriggerInfo || {
            trigger: {}
        };
        this.curSchedulerIndex = a.curSchedulerIndex || 0;
        this.curSchedulerInfo = a.curSchedulerInfo || {
            scheduler: {}
        };
        this.curSchedulerDayInfo = a.curSchedulerDayInfo || {
            scheduler: {}
        };
        this.curEventIndex = a.curEventIndex || 0;
        this.curEventInfo = a.curEventInfo || {
            event: {}
        };
        this.curBonusIndex = a.curBonusIndex || 0;
        this.curBonus = a.curBonus || {};
        this.curSegment = a.curSegment || ""
    }
    _getDebuggerProperties() {
        return this.isPlayerReady ? [{
            title: "GS - Base",
            properties: [{
                name: "Language",
                value: this.gp.language
            }, {
                name: "Avatar Generator",
                value: this.gp.avatarGenerator
            }, {
                name: "Platform",
                value: this.gp.platform.type
            }, {
                name: "Last Error",
                value: this.lastError
            }, {
                name: "Is Last Action Success",
                value: this.isLastActionSuccess
            }, {
                name: "Is Mobile",
                value: this.gp.isMobile
            }, {
                name: "Is Dev",
                value: this.gp.isDev
            }, {
                name: "Is Paused",
                value: this.gp.isPaused
            }, {
                name: "Is Gameplay",
                value: this.gp.isGameplay
            }, {
                name: "Is Allowed Origin",
                value: this.gp.isAllowedOrigin
            }]
        }, {
            title: "GS - Ads",
            properties: [{
                name: "Last Ad Success",
                value: this.isLastAdSuccess
            }, {
                name: "Adblock Enabled",
                value: this.gp.ads.isAdblockEnabled
            }]
        }, {
            title: "GS - Leaderboards",
            properties: [{
                name: "Player Position",
                value: this.leaderboardPlayerPosition
            }]
        }, {
            title: "GS - Player",
            properties: [{
                name: "ID",
                value: this.gp.player.id
            }, {
                name: "Logged In By Platform",
                value: this.gp.player.isLoggedInByPlatform
            }, {
                name: "Is Stub",
                value: this.gp.player.isStub
            }, ...this.gp.player.fields.map(a => ({
                name: this.gp.player.getFieldName(a.key),
                value: this.gp.player.get(a.key),
                onedit: b => this.CallAction(this.actions.PlayerSet, a.key, b)
            }))]
        }, {
            title: "GS - Achievements - Current",
            properties: [{
                name: "Index",
                value: this.currentAchievementIndex
            }, {
                name: "ID",
                value: this.currentAchievement.id
            }, {
                name: "Tag",
                value: this.currentAchievement.tag
            }, {
                name: "Name",
                value: this.currentAchievement.name
            }, {
                name: "Description",
                value: this.currentAchievement.description
            }, {
                name: "Rare",
                value: this.currentAchievement.rare
            }, {
                name: "Unlocked",
                value: this.currentAchievement.unlocked
            }, {
                name: "Icon",
                value: this.currentAchievement.icon
            }, {
                name: "Icon Small",
                value: this.currentAchievement.iconSmall
            }, {
                name: "Locked Icon",
                value: this.currentAchievement.lockedIcon
            }, {
                name: "Locked Icon Small",
                value: this.currentAchievement.lockedIconSmall
            }, {
                name: "Progress",
                value: this.currentAchievement.progress
            }, {
                name: "Max Progress",
                value: this.currentAchievement.maxProgress
            }, {
                name: "Progress Step",
                value: this.currentAchievement.progressStep
            }, {
                name: "Locked Visible",
                value: this.currentAchievement.lockedVisible
            }, {
                name: "Locked Description Visible",
                value: this.currentAchievement.lockedDescriptionVisible
            }]
        }, {
            title: "GS - Achievements Groups Loop",
            properties: [{
                name: "Current Achievements Group Index",
                value: this.currentAchievementsGroupIndex
            }, {
                name: "Current Achievements Group ID",
                value: this.currentAchievementsGroupId
            }, {
                name: "Current Achievements Group Tag",
                value: this.currentAchievementsGroupTag
            }, {
                name: "Current Achievements Group Name",
                value: this.currentAchievementsGroupName
            }, {
                name: "Current Achievements Group Description",
                value: this.currentAchievementsGroupDescription
            }]
        }, {
            title: "GS - Player Achievements Loop",
            properties: [{
                name: "Current Player Achievement Index",
                value: this.currentPlayerAchievementIndex
            }, {
                name: "Current Player Achievement ID",
                value: this.currentPlayerAchievementId
            }, {
                name: "Current Player Achievement Unlock Date",
                value: this.currentPlayerAchievementUnlockDate
            }]
        }, {
            title: "GS - Products Loop",
            properties: [{
                name: "Current Product Index",
                value: this.currentProductIndex
            }, {
                name: "Current Product ID",
                value: this.currentProduct.id
            }, {
                name: "Current Product Tag",
                value: this.currentProduct.tag
            }, {
                name: "Current Product Name",
                value: this.currentProduct.name
            }, {
                name: "Current Product Description",
                value: this.currentProduct.description
            }, {
                name: "Current Product Icon",
                value: this.currentProduct.icon
            }, {
                name: "Current Product Icon Small",
                value: this.currentProduct.iconSmall
            }, {
                name: "Current Product Icon",
                value: this.currentProduct.icon
            }, {
                name: "Current Product Price",
                value: this.currentProduct.price
            }, {
                name: "Current Product Currency",
                value: this.currentProduct.currency
            }, {
                name: "Current Product CurrencySymbol",
                value: this.currentProduct.currencySymbol
            }, {
                name: "Current Product Purchases",
                value: this.currentProductPurchases
            }]
        }, {
            title: "GS - Purchased Product",
            properties: [{
                name: "Is purchase successful",
                value: this.isPurchaseProductSuccess
            }, {
                name: "Purchase error",
                value: this.purchaseProductError
            }, {
                name: "Purchased Product ID",
                value: this.purchasedProductId
            }, {
                name: "Purchased Product Tag",
                value: this.purchasedProductTag
            }]
        }, {
            title: "GS - Consumed Product",
            properties: [{
                name: "Is consume successful",
                value: this.isConsumeProductSuccess
            }, {
                name: "Consume error",
                value: this.consumeProductError
            }, {
                name: "Consumed Product ID",
                value: this.consumedProductId
            }, {
                name: "Consumed Product Tag",
                value: this.consumedProductTag
            }]
        }, {
            title: "GS - Last Games Collection",
            properties: [{
                name: "Collection ID",
                value: this.gamesCollection.id
            }, {
                name: "Collection Tag",
                value: this.gamesCollection.tag
            }, {
                name: "Collection Name",
                value: this.gamesCollection.name
            }, {
                name: "Collection Description",
                value: this.gamesCollection.description
            }, {
                name: "Fetch Error",
                value: this.gamesCollectionFetchError
            }]
        }, {
            title: "GS - Games in Collection",
            properties: [{
                name: "Current Game Index",
                value: this.currentGameIndex
            }, {
                name: "Current Game ID",
                value: this.currentGameId
            }, {
                name: "Current Game Name",
                value: this.currentGameName
            }, {
                name: "Current Game Description",
                value: this.currentGameDescription
            }, {
                name: "Current Game Icon",
                value: this.currentGameIcon
            }, {
                name: "Current Game Url",
                value: this.currentGameUrl
            }]
        }, {
            title: "GS - Documents",
            properties: [{
                name: "Document Type",
                value: this.document.type
            }, {
                name: "Document Content",
                value: this.document.content
            }, {
                name: "Fetch Error",
                value: this.documentFetchError
            }]
        }] : []
    }
}
;
function each(a, b, c) {
    a = a.sdk.createLoopingConditionContext();
    for (let d = 0; d < b.length && (c(b[d], d),
    a.retrigger(),
    !a.isStopped); ++d)
        ;
    a.release()
}
function isExists(a) {
    return a && !!a.id
}
globalThis.C3.Plugins.Eponesh_GameScore.Cnds = {
    OnPlayerChange() {
        return !0
    },
    OnPlayerFieldIncrement(a) {
        return this.currentPlayerFieldKey === a
    },
    OnPlayerFieldMaximum(a) {
        return this.currentPlayerFieldKey === a
    },
    OnPlayerFieldMinimum(a) {
        return this.currentPlayerFieldKey === a
    },
    OnPlayerSyncComplete() {
        return !0
    },
    OnPlayerSyncError() {
        return !0
    },
    OnPlayerLoadComplete() {
        return !0
    },
    OnPlayerLoadError() {
        return !0
    },
    OnPlayerLoginComplete() {
        return !0
    },
    OnPlayerLoginError() {
        return !0
    },
    OnPlayerLogoutComplete() {
        return !0
    },
    OnPlayerLogoutError() {
        return !0
    },
    OnPlayerFetchFieldsComplete() {
        return !0
    },
    OnPlayerFetchFieldsError() {
        return !0
    },
    OnPlayerReady() {
        return !0
    },
    IsPlayerReady() {
        return this.isPlayerReady
    },
    IsPlayerStub() {
        return this.gp.player.isStub
    },
    IsPlayerLoggedIn() {
        return this.gp.player.isLoggedIn
    },
    PlayerHasKey(a) {
        return this.gp.player.has(a)
    },
    PlayerFieldIsEnum(a) {
        return this.gp.player.getField(a).variants.length
    },
    PlayerCompareScore(a, b) {
        return this.mappers.compare[a](this.gp.player.score, b)
    },
    PlayerCompare(a, b, c) {
        return this.mappers.compare[b](this.gp.player.get(a), c)
    },
    PlayerEachField() {
        return each(this.runtime, this.gp.player.fields, a => {
            this.currentPlayerFieldKey = a.key;
            this.currentPlayerFieldType = a.type;
            this.currentPlayerFieldName = a.name;
            this.currentPlayerFieldValue = this.gp.player.get(a.key)
        }
        ),
        !1
    },
    PlayerEachFieldVariant(a) {
        return each(this.runtime, this.gp.player.getField(a).variants, (b, c) => {
            this.currentPlayerFieldVariantValue = b.value;
            this.currentPlayerFieldVariantName = b.name;
            this.currentPlayerFieldVariantIndex = c
        }
        ),
        !1
    },
    OnLeaderboardOpen() {
        return !0
    },
    OnLeaderboardClose() {
        return !0
    },
    OnLeaderboardFetch(a) {
        return this.lastLeaderboardTag === a
    },
    OnLeaderboardAnyFetch() {
        return !0
    },
    OnLeaderboardFetchError(a) {
        return this.lastLeaderboardTag === a
    },
    OnLeaderboardAnyFetchError() {
        return !0
    },
    OnLeaderboardFetchPlayer(a) {
        return this.lastLeaderboardPlayerRatingTag === a
    },
    OnLeaderboardAnyFetchPlayer() {
        return !0
    },
    OnLeaderboardFetchPlayerError(a) {
        return this.lastLeaderboardPlayerRatingTag === a
    },
    OnLeaderboardAnyFetchPlayerError() {
        return !0
    },
    OnLeaderboardPublishRecord() {
        return !0
    },
    OnLeaderboardPublishRecordError() {
        return !0
    },
    LeaderboardEachPlayer() {
        return each(this.runtime, this.leaderboard, (a, b) => {
            this.currentLeaderboardIndex = b;
            this.currentLeaderboardPlayer = a
        }
        ),
        !1
    },
    LeaderboardEachTopPlayer() {
        return each(this.runtime, this.leaderboardResult.topPlayers, (a, b) => {
            this.currentLeaderboardIndex = b;
            this.currentLeaderboardPlayer = a
        }
        ),
        !1
    },
    LeaderboardEachAbovePlayer() {
        return each(this.runtime, this.leaderboardResult.abovePlayers, (a, b) => {
            this.currentLeaderboardIndex = b;
            this.currentLeaderboardPlayer = a
        }
        ),
        !1
    },
    LeaderboardEachBelowPlayer() {
        return each(this.runtime, this.leaderboardResult.belowPlayers, (a, b) => {
            this.currentLeaderboardIndex = b;
            this.currentLeaderboardPlayer = a
        }
        ),
        !1
    },
    OnAchievementsOpen() {
        return !0
    },
    OnAchievementsClose() {
        return !0
    },
    OnAchievementsFetch() {
        return !0
    },
    OnAchievementsFetchError() {
        return !0
    },
    OnAchievementsUnlock(a) {
        var b = parseInt(a, 10) || 0;
        return this.currentAchievement.tag === a || this.currentAchievement.id === b
    },
    OnAchievementsAnyUnlock() {
        return !0
    },
    OnAchievementsAnyUnlockError() {
        return !0
    },
    OnAchievementsSetProgress(a) {
        var b = parseInt(a, 10) || 0;
        return this.currentAchievement.tag === a || this.currentAchievement.id === b
    },
    OnAchievementsAnySetProgress() {
        return !0
    },
    OnAchievementsAnySetProgressError() {
        return !0
    },
    AchievementsPickAchievement(a) {
        var {achievement: a, playerAchievement: b, achievementGroup: c} = this.gp.achievements.getAchievement(a);
        return !!a && (this.currentAchievementIndex = 0,
        this.currentAchievement = a,
        b && (this.currentAchievement.unlocked = b.unlocked,
        this.currentAchievement.progress = b.progress),
        c && (this.currentAchievementsGroupIndex = 0,
        this.currentAchievementsGroupId = c.id,
        this.currentAchievementsGroupTag = c.tag,
        this.currentAchievementsGroupName = c.name,
        this.currentAchievementsGroupDescription = c.description),
        !0)
    },
    AchievementsEachAchievement() {
        return each(this.runtime, this.gp.achievements.list, (a, b) => {
            var c = this.gp.achievements.getAchievement(a.id).playerAchievement;
            this.currentAchievementIndex = b;
            this.currentAchievement = a;
            c && (this.currentAchievement.unlocked = c.unlocked,
            this.currentAchievement.progress = c.progress)
        }
        ),
        !1
    },
    AchievementsEachAchievementInGroup(a) {
        const b = parseInt(a, 10) || 0;
        var c = this.gp.achievements.groupsList.find(d => d.tag === a || d.id === b);
        c = c ? c.achievements.reduce( (d, e) => {
            var {achievement: e, playerAchievement: f} = this.gp.achievements.getAchievement(e);
            return e && d.push({
                achievement: e,
                playerAchievement: f
            }),
            d
        }
        , []) : [];
        return each(this.runtime, c, ({achievement: d, playerAchievement: e}, f) => {
            this.currentAchievementIndex = f;
            this.currentAchievement = d;
            e && (this.currentAchievement.unlocked = e.unlocked,
            this.currentAchievement.progress = e.progress)
        }
        ),
        !1
    },
    AchievementsEachAchievementsGroup() {
        return each(this.runtime, this.gp.achievements.groupsList, (a, b) => {
            this.currentAchievementsGroupIndex = b;
            this.currentAchievementsGroupId = a.id;
            this.currentAchievementsGroupTag = a.tag;
            this.currentAchievementsGroupName = a.name;
            this.currentAchievementsGroupDescription = a.description
        }
        ),
        !1
    },
    AchievementsEachPlayerAchievements() {
        return each(this.runtime, this.gp.achievements.unlockedList, (a, b) => {
            this.currentPlayerAchievementIndex = b;
            this.currentPlayerAchievementId = a.id;
            this.currentPlayerAchievementUnlockDate = a.createdAt
        }
        ),
        !1
    },
    IsAchievementsCurAchievementUnlocked() {
        return this.currentAchievement.unlocked
    },
    IsAchievementsCurAchievementLockedVisible() {
        return !!this.currentAchievement.isLockedVisible
    },
    IsAchievementsCurAchievementLockedDescriptionVisible() {
        return !!this.currentAchievement.isLockedDescriptionVisible
    },
    IsAchievementsUnlockSuccessful() {
        return this.isUnlockAchievementSuccess
    },
    AchievementsIsUnlocked(a) {
        return this.gp.achievements.has(a)
    },
    OnPaymentsFetchProducts() {
        return !0
    },
    OnPaymentsFetchProductsError() {
        return !0
    },
    OnEventConnect() {
        return !0
    },
    OnPaymentsPurchase(a) {
        var b = parseInt(a, 10) || 0;
        return this.purchasedProductTag === a || this.purchasedProductId === b
    },
    OnPaymentsPurchaseError(a) {
        var b = parseInt(a, 10) || 0;
        return this.purchasedProductTag === a || this.purchasedProductId === b
    },
    OnPaymentsAnyPurchase() {
        return !0
    },
    OnPaymentsAnyPurchaseError() {
        return !0
    },
    OnPaymentsConsume(a) {
        var b = parseInt(a, 10) || 0;
        return this.consumedProductTag === a || this.consumedProductId === b
    },
    OnPaymentsConsumeError(a) {
        var b = parseInt(a, 10) || 0;
        return this.consumedProductTag === a || this.consumedProductId === b
    },
    OnPaymentsAnyConsume() {
        return !0
    },
    OnPaymentsAnyConsumeError() {
        return !0
    },
    OnPaymentsSubscribe(a) {
        var b = parseInt(a, 10) || 0;
        return this.purchasedProductTag === a || this.purchasedProductId === b
    },
    OnPaymentsSubscribeError(a) {
        var b = parseInt(a, 10) || 0;
        return this.purchasedProductTag === a || this.purchasedProductId === b
    },
    OnPaymentsAnySubscribe() {
        return !0
    },
    OnPaymentsAnySubscribeError() {
        return !0
    },
    OnPaymentsUnsubscribe(a) {
        var b = parseInt(a, 10) || 0;
        return this.purchasedProductTag === a || this.purchasedProductId === b
    },
    OnPaymentsUnsubscribeError(a) {
        var b = parseInt(a, 10) || 0;
        return this.purchasedProductTag === a || this.purchasedProductId === b
    },
    OnPaymentsAnyUnsubscribe() {
        return !0
    },
    OnPaymentsAnyUnsubscribeError() {
        return !0
    },
    PaymentsPickProduct(a) {
        const b = this.gp.payments.getProduct(a);
        return !!b && (this.currentProductIndex = 0,
        this.currentProduct = b,
        this.currentProductPurchases = this.gp.payments.purchases.filter(c => c.productId === b.id).length,
        !0)
    },
    PaymentsEachProduct() {
        return each(this.runtime, this.gp.payments.products, (a, b) => {
            this.currentProductIndex = b;
            this.currentProduct = a;
            this.currentProductPurchases = this.gp.payments.purchases.filter(c => c.productId === a.id).length
        }
        ),
        !1
    },
    PaymentsEachPurchase() {
        return each(this.runtime, this.gp.payments.purchases, (a, b) => {
            this.currentPurchaseIndex = b;
            this.currentPurchase = a
        }
        ),
        !1
    },
    IsPaymentsCurProductPurchased() {
        return 0 < this.currentProductPurchases
    },
    IsPaymentsPurchaseSuccessful() {
        return this.isPurchaseProductSuccess
    },
    IsPaymentsConsumeSuccessful() {
        return this.isConsumeProductSuccess
    },
    IsPaymentsSubscribeSuccessful() {
        return this.isSubscribeProductSuccess
    },
    IsPaymentsUnsubscribeSuccessful() {
        return this.isUnsubscribeProductSuccess
    },
    PaymentsIsPurchased(a) {
        return this.gp.payments.has(a)
    },
    PaymentsIsSubscribed(a) {
        return (a = this.gp.payments.getPurchase(a)) && a.subscribed || !1
    },
    IsPaymentsAvailable() {
        return this.gp.payments.isAvailable
    },
    IsSubscriptionsAvailable() {
        return this.gp.payments.isSubscriptionsAvailable
    },
    OnImagesFetch() {
        return !0
    },
    OnImagesFetchError() {
        return !0
    },
    OnImagesFetchMore() {
        return !0
    },
    OnImagesFetchMoreError() {
        return !0
    },
    OnImagesUpload() {
        return !0
    },
    OnImagesUploadError() {
        return !0
    },
    OnImagesChoose() {
        return !0
    },
    OnImagesChooseError() {
        return !0
    },
    ImagesEachImage() {
        return each(this.runtime, this.images, (a, b) => {
            this.currentImageIndex = b;
            this.currentImage = a
        }
        ),
        !1
    },
    ImagesEachTag(a) {
        var b = this.images.find(c => c.id === a);
        b = b ? b.tags : [];
        return each(this.runtime, b || [], (c, d) => {
            this.currentImageTagIndex = d;
            this.currentImageTag = c
        }
        ),
        !1
    },
    ImagesCanLoadMore() {
        return this.canLoadMoreImages
    },
    ImagesCanUpload() {
        return this.gp.images.canUpload
    },
    OnFilesFetch() {
        return !0
    },
    OnFilesFetchError() {
        return !0
    },
    OnFilesFetchMore() {
        return !0
    },
    OnFilesFetchMoreError() {
        return !0
    },
    OnFilesUpload() {
        return !0
    },
    OnFilesUploadError() {
        return !0
    },
    OnFilesLoadContent() {
        return !0
    },
    OnFilesLoadContentError() {
        return !0
    },
    OnFilesChoose() {
        return !0
    },
    OnFilesChooseError() {
        return !0
    },
    FilesEachFile() {
        return each(this.runtime, this.files, (a, b) => {
            this.currentFileIndex = b;
            this.currentFile = a
        }
        ),
        !1
    },
    FilesEachTag(a) {
        var b = this.files.find(c => c.id === a);
        b = b ? b.tags : [];
        return each(this.runtime, b || [], (c, d) => {
            this.currentFileTagIndex = d;
            this.currentFileTag = c
        }
        ),
        !1
    },
    FilesCanLoadMore() {
        return this.canLoadMoreFiles
    },
    FilesCanUpload() {
        return this.gp.files.canUpload
    },
    OnVariablesFetch() {
        return !0
    },
    OnVariablesFetchError() {
        return !0
    },
    OnPlatformVariablesFetch() {
        return !0
    },
    OnPlatformVariablesFetchError() {
        return !0
    },
    isPlatformVariablesAvailable() {
        return this.gp.variables.isPlatformVariablesAvailable
    },
    VariablesEachVariable() {
        return each(this.runtime, this.gp.variables.list, (a, b) => {
            this.currentVariableIndex = b;
            this.currentVariable = a
        }
        ),
        !1
    },
    VariablesCompare(a, b, c) {
        return this.mappers.compare[b](this.gp.variables.get(a), c)
    },
    VariablesCompareType(a, b) {
        return this.gp.variables.type(a) === this.mappers.variablesTypes[b]
    },
    VariablesHas(a) {
        return this.gp.variables.has(a)
    },
    OnFullscreenOpen() {
        return !0
    },
    OnFullscreenClose() {
        return !0
    },
    OnFullscreenChange() {
        return !0
    },
    IsFullscreenMode() {
        return this.gp.fullscreen.isEnabled
    },
    OnAdsStart() {
        return !0
    },
    OnAdsClose() {
        return !0
    },
    OnAdsFullscreenStart() {
        return !0
    },
    OnAdsFullscreenClose() {
        return !0
    },
    OnAdsPreloaderStart() {
        return !0
    },
    OnAdsPreloaderClose() {
        return !0
    },
    OnAdsRewardedStart(a) {
        return this.lastRewardedTag === a
    },
    OnAdsRewardedClose(a) {
        return this.lastRewardedTag === a
    },
    OnAdsRewardedReward(a) {
        return this.lastRewardedTag === a
    },
    OnAdsStickyStart() {
        return !0
    },
    OnAdsStickyClose() {
        return !0
    },
    OnAdsStickyRefresh() {
        return !0
    },
    OnAdsStickyRender() {
        return !0
    },
    IsAdsFullscreenAvailable() {
        return this.gp.ads.isFullscreenAvailable
    },
    IsAdsRewardedAvailable() {
        return this.gp.ads.isRewardedAvailable
    },
    IsAdsPreloaderAvailable() {
        return this.gp.ads.isPreloaderAvailable
    },
    IsAdsStickyAvailable() {
        return this.gp.ads.isStickyAvailable
    },
    IsAdsFullscreenPlaying() {
        return this.gp.ads.isFullscreenPlaying
    },
    CanShowFullscreenBeforeGamePlay() {
        return this.gp.ads.canShowFullscreenBeforeGamePlay
    },
    IsAdsRewardedPlaying() {
        return this.gp.ads.isRewardedPlaying
    },
    IsAdsPreloaderPlaying() {
        return this.gp.ads.isPreloaderPlaying
    },
    IsAdsStickyPlaying() {
        return this.gp.ads.isStickyPlaying
    },
    IsAdsAdblockEnabled() {
        return this.gp.ads.isAdblockEnabled
    },
    IsAdsLastAdSuccess() {
        return !!this.isLastAdSuccess
    },
    OnChangeLanguage() {
        return !0
    },
    OnChangeAvatarGenerator() {
        return !0
    },
    OnChangeOrientation() {
        return !0
    },
    OnOverlayReady() {
        return !0
    },
    IsDev() {
        return this.gp.isDev
    },
    IsMobile() {
        return this.gp.isMobile
    },
    DeviceType(a) {
        return this.gp.device.type === this.mappers.deviceTypes[a]
    },
    IsAllowedOrigin() {
        return this.gp.isAllowedOrigin
    },
    IsPortrait() {
        return this.gp.isPortrait
    },
    Language(a) {
        return this.gp.language === this.mappers.language[a]
    },
    OnPause() {
        return !0
    },
    OnResume() {
        return !0
    },
    IsPaused() {
        return this.gp.isPaused
    },
    OnGameplayStart() {
        return !0
    },
    OnGameplayStop() {
        return !0
    },
    IsGameplay() {
        return this.gp.isGameplay
    },
    HasPlatformIntegratedAuth() {
        return this.gp.platform.hasIntegratedAuth
    },
    IsPlatformLogoutAvailable() {
        return this.gp.platform.isLogoutAvailable
    },
    PlatformTag() {
        return this.gp.platform.tag
    },
    isPlatformSupportsCloudSaves() {
        return this.gp.platform.isSupportsCloudSaves
    },
    isPlatformSecretCodeAuthAvailable() {
        return this.gp.platform.isSecretCodeAuthAvailable
    },
    PlatformType(a) {
        return this.gp.platform.type === this.mappers.platform[a]
    },
    IsExternalLinksAllowedOnPlatform() {
        return this.gp.platform.isExternalLinksAllowed
    },
    OnSocialsShare() {
        return !0
    },
    OnSocialsPost() {
        return !0
    },
    OnSocialsInvite() {
        return !0
    },
    OnSocialsJoinCommunity() {
        return !0
    },
    IsSocialsLastShareSuccess() {
        return this.isLastShareSuccess
    },
    IsSocialsLastCommunityJoinSuccess() {
        return this.isLastCommunityJoinSuccess
    },
    IsSocialsSupportsShare() {
        return this.gp.socials.isSupportsShare
    },
    IsSocialsSupportsNativeShare() {
        return this.gp.socials.isSupportsNativeShare
    },
    IsSocialsSupportsNativePosts() {
        return this.gp.socials.isSupportsNativePosts
    },
    IsSocialsSupportsNativeInvite() {
        return this.gp.socials.isSupportsNativeInvite
    },
    IsSocialsSupportsNativeCommunityJoin() {
        return this.gp.socials.isSupportsNativeCommunityJoin
    },
    SocialsCanJoinCommunity() {
        return this.gp.socials.canJoinCommunity
    },
    OnAppAddShortcut() {
        return !0
    },
    OnAppReview() {
        return !0
    },
    OnAppReviewError() {
        return !0
    },
    IsAppLastAddShortcutSuccess() {
        return this.isLastAddShortcutSuccess
    },
    AppCanAddShortcut() {
        return this.gp.app.canAddShortcut
    },
    AppCanRequestReview() {
        return this.gp.app.canRequestReview
    },
    AppIsAlreadyReviewed() {
        return this.gp.app.isAlreadyReviewed
    },
    OnGamesCollectionsOpen() {
        return !0
    },
    OnGamesCollectionsClose() {
        return !0
    },
    OnGamesCollectionsFetchAny() {
        return !0
    },
    OnGamesCollectionsFetchAnyError() {
        return !0
    },
    OnGamesCollectionsFetch(a) {
        return this.lastGamesCollectionIdOrTag === a
    },
    OnGamesCollectionsFetchError(a) {
        return this.lastGamesCollectionIdOrTag === a
    },
    GamesCollectionsEachGame() {
        return each(this.runtime, this.gamesCollection.games, (a, b) => {
            this.currentGameIndex = b;
            this.currentGameId = a.id;
            this.currentGameName = a.name;
            this.currentGameDescription = a.description;
            this.currentGameIcon = a.icon;
            this.currentGameUrl = a.url
        }
        ),
        !1
    },
    IsGamesCollectionsAvailable() {
        return this.gp.gamesCollections.isAvailable
    },
    OnDocumentsOpen() {
        return !0
    },
    OnDocumentsClose() {
        return !0
    },
    OnDocumentsFetchAny() {
        return !0
    },
    OnDocumentsFetchAnyError() {
        return !0
    },
    OnDocumentsFetch(a) {
        return this.lastDocumentType === this.mappers.documentTypes[a]
    },
    OnDocumentsFetchError(a) {
        return this.lastDocumentType === this.mappers.documentTypes[a]
    },
    OnPlayersFetch(a) {
        return this.lastPlayersTag === a
    },
    OnPlayersAnyFetch() {
        return !0
    },
    OnPlayersFetchError(a) {
        return this.lastPlayersTag === a
    },
    OnPlayersAnyFetchError() {
        return !0
    },
    PlayersEachPlayer() {
        return each(this.runtime, this.playersList, (a, b) => {
            this.currentPlayersIndex = b;
            this.currentPlayersPlayer = a
        }
        ),
        !1
    },
    PlayersEachPlayerAchievement() {
        return each(this.runtime, this.currentPlayersPlayer.achievements, (a, b) => {
            this.currentPlayerAchievementIndex = b;
            this.currentPlayerAchievementId = a.id;
            this.currentPlayerAchievementUnlockDate = a.createdAt
        }
        ),
        !1
    },
    PlayersEachPlayerPurchase() {
        return each(this.runtime, this.currentPlayersPlayer.purchases, (a, b) => {
            this.currentPurchaseIndex = b;
            this.currentPurchase = a
        }
        ),
        !1
    },
    OnRewardsAccept(a) {
        return !a || this.isPickedIdOrTag(a)
    },
    OnRewardsAcceptError(a) {
        return !a || this.isPickedIdOrTag(a)
    },
    OnRewardsGive(a) {
        return !a || this.isPickedIdOrTag(a)
    },
    OnRewardsGiveError(a) {
        return !a || this.isPickedIdOrTag(a)
    },
    RewardsPick(a) {
        a = this.gp.rewards.getReward(a) || {};
        return this.setReward(a),
        isExists(a.reward)
    },
    RewardsEachReward() {
        return each(this.runtime, this.gp.rewards.list, (a, b) => {
            a = this.gp.rewards.getReward(a.id);
            this.setReward(a, b)
        }
        ),
        !1
    },
    IsRewardsCurAccepted() {
        return 0 < this.curPlayerReward.countAccepted
    },
    IsRewardsCurGiven() {
        return 0 < this.curPlayerReward.countTotal
    },
    IsRewardsCurHasAutoAccept() {
        return this.curReward.isAutoAccept
    },
    RewardsHas(a) {
        return this.gp.rewards.has(a)
    },
    RewardsHasAccepted(a) {
        return this.gp.rewards.hasAccepted(a)
    },
    RewardsHasUnaccepted(a) {
        return this.gp.rewards.hasUnaccepted(a)
    },
    OnTriggersActivate(a) {
        return !a || this.lastIdOrTag.id === a || this.lastIdOrTag.tag === a
    },
    OnTriggersClaim(a) {
        return !a || this.lastIdOrTag.id === a || this.lastIdOrTag.tag === a
    },
    OnTriggersClaimError(a) {
        return !a || this.lastIdOrTag.id === a || this.lastIdOrTag.tag === a
    },
    TriggersPick(a) {
        return this.setTriggerInfo(a),
        isExists(this.curTriggerInfo.trigger)
    },
    TriggersEachTrigger() {
        return each(this.runtime, this.gp.triggers.list, (a, b) => {
            this.setTriggerInfo(a.id, b)
        }
        ),
        !1
    },
    TriggersEachBonus() {
        return each(this.runtime, this.curTriggerInfo.trigger.bonuses || [], (a, b) => {
            this.setBonus(a, b)
        }
        ),
        !1
    },
    IsTriggersCurActivated() {
        return !!this.curTriggerInfo.isActivated
    },
    IsTriggersCurClaimed() {
        return !!this.curTriggerInfo.isClaimed
    },
    IsTriggersCurHasAutoClaim() {
        return !!this.curTriggerInfo.trigger.isAutoClaim
    },
    TriggersIsActivated(a) {
        return this.gp.triggers.isActivated(a)
    },
    TriggersIsClaimed(a) {
        return this.gp.triggers.isClaimed(a)
    },
    BonusType(a) {
        return this.curBonus.type === this.mappers.bonusType[a]
    },
    OnSchedulersRegister(a) {
        return !a || this.isPickedIdOrTag(a)
    },
    OnSchedulersRegisterError(a) {
        return !a || this.isPickedIdOrTag(a)
    },
    OnSchedulersClaimDay(a, b) {
        return this.isPickedSchedulerDayAndTrigger(a, b)
    },
    OnSchedulersClaimDayError(a, b) {
        return this.isPickedSchedulerDayAndTrigger(a, b)
    },
    OnSchedulersClaimDayAdditional(a, b, c) {
        return this.isPickedSchedulerDayAndTrigger(a, b, c)
    },
    OnSchedulersClaimDayAdditionalError(a, b, c) {
        return this.isPickedSchedulerDayAndTrigger(a, b, c)
    },
    OnSchedulersClaimAllDay(a, b) {
        return this.isPickedSchedulerDayAndTrigger(a, b)
    },
    OnSchedulersClaimAllDayError(a, b) {
        return this.isPickedSchedulerDayAndTrigger(a, b)
    },
    OnSchedulersClaimAllDays(a) {
        return this.isPickedSchedulerDayAndTrigger(a)
    },
    OnSchedulersClaimAllDaysError(a) {
        return this.isPickedSchedulerDayAndTrigger(a)
    },
    SchedulersPick(a) {
        return this.setSchedulerInfo(a),
        isExists(this.curSchedulerInfo.scheduler)
    },
    SchedulersPickDay(a, b) {
        return this.setSchedulerDayInfo(a, b),
        isExists(this.curSchedulerDayInfo.scheduler) && this.curSchedulerDayInfo.day === b
    },
    SchedulersPickDayAdditional(a, b, c) {
        this.setSchedulerDayInfo(a, b);
        a = this.curSchedulerDayInfo.triggers || [];
        return !!a[c] && (this.setTriggerInfo(a[c].id),
        !!this.curTriggerInfo.trigger)
    },
    SchedulersEachScheduler() {
        return each(this.runtime, this.gp.schedulers.list, (a, b) => {
            this.setSchedulerInfo(a.id, b)
        }
        ),
        !1
    },
    SchedulersEachCurSchedulerDay() {
        var a = Array.from({
            length: this.curSchedulerInfo.scheduler.days || 0
        });
        return each(this.runtime, a, (b, c) => {
            this.setSchedulerDayInfo(this.curSchedulerInfo.scheduler.id, c + 1)
        }
        ),
        !1
    },
    SchedulersEachCurSchedulerDaysClaimed() {
        return each(this.runtime, this.curSchedulerInfo.daysClaimed, a => {
            this.setSchedulerDayInfo(this.curSchedulerInfo.scheduler.id, a)
        }
        ),
        !1
    },
    SchedulersEachCurSchedulerDayBonuses() {
        return each(this.runtime, this.curSchedulerDayInfo.bonuses || [], (a, b) => {
            this.setBonus(a, b)
        }
        ),
        !1
    },
    SchedulersEachCurSchedulerDayTriggers() {
        return each(this.runtime, this.curSchedulerDayInfo.triggers || [], (a, b) => {
            this.setTriggerInfo(a.id, b)
        }
        ),
        !1
    },
    IsSchedulersCurRegistered() {
        return this.curSchedulerInfo.isRegistered
    },
    IsSchedulersCurAutoRegister() {
        return !!this.curSchedulerInfo.scheduler.isAutoRegister
    },
    IsSchedulersCurRepeatable() {
        return this.curSchedulerInfo.scheduler.isRepeat
    },
    IsSchedulersCurDayReached() {
        return this.curSchedulerDayInfo.isDayReached
    },
    IsSchedulersCurDayComplete() {
        return this.curSchedulerDayInfo.isDayComplete
    },
    IsSchedulersCurDayClaimed() {
        return this.curSchedulerDayInfo.isDayClaimed
    },
    IsSchedulersCurDayAllClaimed() {
        return this.curSchedulerDayInfo.isAllDayClaimed
    },
    IsSchedulersCurDayCanClaim() {
        return this.curSchedulerDayInfo.canClaimDay
    },
    IsSchedulersCurDayCanClaimAll() {
        return this.curSchedulerDayInfo.canClaimAllDay
    },
    SchedulersIsRegistered(a) {
        return this.gp.schedulers.isRegistered(a)
    },
    SchedulersIsTodayRewardClaimed(a) {
        return this.gp.schedulers.isTodayRewardClaimed(a)
    },
    SchedulersCanClaimDay(a, b) {
        return this.gp.schedulers.canClaimDay(a, b)
    },
    SchedulersCanClaimDayAdditional(a, b, c) {
        return this.gp.schedulers.canClaimDayAdditional(a, b, c)
    },
    SchedulersCanClaimAllDay(a, b) {
        return this.gp.schedulers.canClaimAllDay(a, b)
    },
    SchedulersCurType(a) {
        return this.curSchedulerInfo.scheduler.type === this.mappers.schedulerType[a]
    },
    OnEventsJoin(a) {
        return !a || this.isPickedIdOrTag(a)
    },
    OnEventsJoinError(a) {
        return !a || this.isPickedIdOrTag(a)
    },
    EventsPick(a) {
        return this.setEventInfo(a),
        isExists(this.curEventInfo.event)
    },
    EventsEachEvent() {
        return each(this.runtime, this.gp.events.list, (a, b) => {
            this.setEventInfo(a.id, b)
        }
        ),
        !1
    },
    EventsEachCurEventTriggers() {
        return each(this.runtime, this.curEventInfo.event.triggers || [], (a, b) => {
            this.setTriggerInfo(a.id, b)
        }
        ),
        !1
    },
    IsEventsCurJoined() {
        return this.curEventInfo.isJoined
    },
    IsEventsCurActive() {
        return this.curEventInfo.event.isActive
    },
    IsEventsCurAutoJoin() {
        return this.curEventInfo.event.isAutoJoin
    },
    EventsHas(a) {
        return this.gp.events.has(a)
    },
    EventsIsJoined(a) {
        return this.gp.events.isJoined(a)
    },
    ExperimentsHas(a, b) {
        return this.gp.experiments.has(a, b)
    },
    OnSegmentsEnter() {
        return !0
    },
    OnSegmentsLeave() {
        return !0
    },
    SegmentsHas(a) {
        return this.gp.segments.has(a)
    },
    SegmentsEachSegment() {
        return each(this.runtime, this.gp.segments.list || [], a => {
            this.curSegment = a
        }
        ),
        !1
    },
    IsLastActionSuccess() {
        return this.isLastActionSuccess
    },
    OnLoadJsonError() {
        return !0
    },
    OnUniquesRegister() {
        return !0
    },
    OnUniquesRegisterError() {
        return !0
    },
    OnUniquesCheck() {
        return !0
    },
    OnUniquesCheckError() {
        return !0
    },
    OnUniquesDelete() {
        return !0
    },
    OnUniquesDeleteError() {
        return !0
    },
    UniquesEachUnique() {
        return each(this.runtime, this.gp.uniques.list, a => {
            this.currentUniquesTag = a.tag;
            this.currentUniquesValue = a.value
        }
        ),
        !1
    },
    OnStorageGet() {
        return !0
    },
    OnStorageSet() {
        return !0
    },
    OnStorageGetGlobal() {
        return !0
    },
    OnStorageSetGlobal() {
        return !0
    }
};
function stoarr(a="", b=String) {
    return String(a).split(",").map(c => b(c.trim())).filter(c => c)
}
globalThis.C3.Plugins.Eponesh_GameScore.Acts = {
    PlayerSetName(a) {
        this.gp.player.name = a
    },
    PlayerSetAvatar(a) {
        this.gp.player.avatar = a
    },
    PlayerSetScore(a) {
        this.gp.player.score = a
    },
    PlayerAddScore(a) {
        this.gp.player.score += a
    },
    PlayerSet(a, b) {
        this.gp.player.set(a, b)
    },
    PlayerSetFlag(a, b) {
        this.gp.player.set(a, !b)
    },
    PlayerAdd(a, b) {
        this.gp.player.add(a, b)
    },
    PlayerToggle(a) {
        this.gp.player.toggle(a)
    },
    PlayerReset() {
        this.gp.player.reset()
    },
    PlayerRemove() {
        this.gp.player.remove()
    },
    PlayerSync(a=!1, b) {
        return this.gp.player.sync({
            override: a,
            storage: this.mappers.syncStorage[b]
        })
    },
    PlayerEnableAutoSync(a, b=!1, c) {
        return this.gp.player.enableAutoSync({
            interval: a,
            override: b,
            storage: this.mappers.syncStorage[c]
        })
    },
    PlayerDisableAutoSync(a) {
        return this.gp.player.disableAutoSync({
            storage: this.mappers.syncStorage[a]
        })
    },
    PlayerLoad() {
        return this.gp.player.load()
    },
    PlayerLogin() {
        return this.gp.player.login()
    },
    PlayerLogout() {
        return this.gp.player.logout()
    },
    PlayerFetchFields() {
        return this.gp.player.fetchFields()
    },
    PlayerWaitForReady() {
        return this.awaiters.player.ready
    },
    LeaderboardOpen(a, b, c, d, e, f, h) {
        return this.gp.leaderboard.open({
            id: this.gp.player.id,
            orderBy: stoarr(a),
            order: 0 === b ? "DESC" : "ASC",
            limit: c,
            showNearest: h,
            withMe: this.mappers.withMe[d],
            includeFields: stoarr(e),
            displayFields: stoarr(f)
        }).catch(l => {
            this.handleResult(!1, l)
        }
        )
    },
    LeaderboardFetch(a, b, c, d, e, f, h) {
        return this.gp.leaderboard.fetch({
            id: this.gp.player.id,
            orderBy: stoarr(b),
            order: 0 === c ? "DESC" : "ASC",
            limit: d,
            showNearest: h,
            withMe: this.mappers.withMe[e],
            includeFields: stoarr(f)
        }).then(l => {
            this.lastLeaderboardTag = a;
            this.lastLeaderboardVariant = "default";
            this.leaderboardInfo = l.leaderboard;
            this.leaderboard = l.players;
            this.leaderboardResult = l;
            this.handleResult(!0);
            this._trigger(this.conditions.OnLeaderboardFetch);
            this._trigger(this.conditions.OnLeaderboardAnyFetch)
        }
        ).catch(l => {
            this.handleResult(!1, l);
            this.lastLeaderboardTag = a;
            this.lastLeaderboardVariant = "default";
            this._trigger(this.conditions.OnLeaderboardFetchError);
            this._trigger(this.conditions.OnLeaderboardAnyFetchError)
        }
        )
    },
    LeaderboardFetchPlayerRating(a, b, c, d, e) {
        return this.gp.leaderboard.fetchPlayerRating({
            showNearest: d,
            id: this.gp.player.id,
            orderBy: stoarr(b),
            includeFields: stoarr(e),
            order: 0 === c ? "DESC" : "ASC"
        }).then(f => {
            this.lastLeaderboardTag = a;
            this.lastLeaderboardVariant = "default";
            this.lastLeaderboardPlayerRatingTag = a;
            this.currentLeaderboardPlayer = Object.assign(this.gp.player.toJSON(), f.player);
            this.leaderboardPlayerPosition = f.player.position;
            (this.leaderboardResult = f).topPlayers = [];
            this.handleResult(!0);
            this._trigger(this.conditions.OnLeaderboardFetchPlayer);
            this._trigger(this.conditions.OnLeaderboardAnyFetchPlayer)
        }
        ).catch(f => {
            this.handleResult(!1, f);
            this.lastLeaderboardTag = a;
            this.lastLeaderboardVariant = "default";
            this.lastLeaderboardPlayerRatingTag = a;
            this._trigger(this.conditions.OnLeaderboardFetchPlayerError);
            this._trigger(this.conditions.OnLeaderboardAnyFetchPlayerError)
        }
        )
    },
    LeaderboardOpenScoped(a, b, c, d, e, f, h, l) {
        a = {
            id: parseInt(a, 10) || 0,
            tag: a,
            variant: b,
            limit: d,
            showNearest: l,
            order: this.mappers.order[c],
            withMe: this.mappers.withMe[e],
            includeFields: stoarr(f),
            displayFields: stoarr(h)
        };
        return this.gp.leaderboard.openScoped(a).catch(console.warn)
    },
    LeaderboardFetchScoped(a, b, c, d, e, f, h) {
        d = {
            id: parseInt(a, 10) || 0,
            tag: a,
            variant: b,
            limit: d,
            showNearest: h,
            order: this.mappers.order[c],
            withMe: this.mappers.withMe[e],
            includeFields: stoarr(f)
        };
        return this.gp.leaderboard.fetchScoped(d).then(l => {
            this.lastLeaderboardTag = a;
            this.lastLeaderboardVariant = b;
            this.leaderboardInfo = l.leaderboard;
            this.leaderboard = l.players;
            this.leaderboardResult = l;
            this.handleResult(!0);
            this._trigger(this.conditions.OnLeaderboardFetch);
            this._trigger(this.conditions.OnLeaderboardAnyFetch)
        }
        ).catch(l => {
            this.handleResult(!1, l);
            this.lastLeaderboardTag = a;
            this.lastLeaderboardVariant = b;
            this._trigger(this.conditions.OnLeaderboardFetchError);
            this._trigger(this.conditions.OnLeaderboardAnyFetchError)
        }
        )
    },
    LeaderboardFetchPlayerRatingScoped(a, b, c, d, e) {
        d = {
            id: parseInt(a, 10) || 0,
            tag: a,
            variant: b,
            showNearest: d,
            order: this.mappers.order[c],
            includeFields: stoarr(e)
        };
        return this.gp.leaderboard.fetchPlayerRatingScoped(d).then(f => {
            this.lastLeaderboardTag = this.lastLeaderboardPlayerRatingTag = a;
            this.lastLeaderboardVariant = b;
            this.currentLeaderboardPlayer = Object.assign(this.gp.player.toJSON(), f.player);
            this.leaderboardPlayerPosition = f.player.position;
            (this.leaderboardResult = f).topPlayers = [];
            this.handleResult(!0);
            this._trigger(this.conditions.OnLeaderboardFetchPlayer);
            this._trigger(this.conditions.OnLeaderboardAnyFetchPlayer)
        }
        ).catch(f => {
            this.handleResult(!1, f);
            this.lastLeaderboardTag = this.lastLeaderboardPlayerRatingTag = a;
            this.lastLeaderboardVariant = b;
            this._trigger(this.conditions.OnLeaderboardFetchPlayerError);
            this._trigger(this.conditions.OnLeaderboardAnyFetchPlayerError)
        }
        )
    },
    LeaderboardPublishRecord(a, b, c) {
        var d = this.leaderboardRecords[a];
        d = d ? d[b] : null;
        var e = parseInt(a, 10) || 0;
        return this.gp.leaderboard.publishRecord({
            id: e,
            tag: a,
            variant: b,
            override: c,
            record: d
        }).then(f => {
            this.lastLeaderboardTag = a;
            this.lastLeaderboardVariant = b;
            this.lastLeaderboardPlayerRatingTag = a;
            this.leaderboardRecords[a] || (this.leaderboardRecords[a] = {});
            this.leaderboardRecords[a][b] = f.record;
            this.handleResult(!0);
            this._trigger(this.conditions.OnLeaderboardPublishRecord)
        }
        ).catch(f => {
            this.handleResult(!1, f);
            this.lastLeaderboardTag = a;
            this.lastLeaderboardVariant = b;
            this.lastLeaderboardPlayerRatingTag = a;
            this._trigger(this.conditions.OnLeaderboardPublishRecordError)
        }
        )
    },
    LeaderboardSetRecord(a, b, c, d) {
        this.leaderboardRecords[a] || (this.leaderboardRecords[a] = {});
        this.leaderboardRecords[a][b] || (this.leaderboardRecords[a][b] = {});
        this.leaderboardRecords[a][b][c] = d
    },
    AchievementsOpen() {
        return this.gp.achievements.open().catch(console.warn)
    },
    AchievementsFetch() {
        return this.gp.achievements.fetch().then(a => {
            this.achievements = a.achievements;
            this.achievementsGroups = a.achievementsGroups;
            this.playerAchievements = a.playerAchievements;
            this.handleResult(!0);
            this._trigger(this.conditions.OnAchievementsFetch)
        }
        ).catch(a => {
            this.handleResult(!1, a);
            this._trigger(this.conditions.OnAchievementsFetchError)
        }
        )
    },
    AchievementsUnlock(a) {
        return this.gp.achievements.unlock(this.getIdOrTag(a))
    },
    AchievementsSetProgress(a, b) {
        a = this.getIdOrTag(a);
        return a.progress = Number(b),
        this.gp.achievements.setProgress(a)
    },
    PaymentsFetchProducts() {
        return this.gp.payments.fetchProducts().then(a => {
            this.products = a.products;
            this.playerPurchases = a.playerPurchases;
            this.handleResult(!0);
            this._trigger(this.conditions.OnPaymentsFetchProducts)
        }
        ).catch(a => {
            this.handleResult(!1, a);
            this._trigger(this.conditions.OnPaymentsFetchProductsError)
        }
        )
    },
    PaymentsPurchase(a) {
        return this.gp.payments.purchase(this.getIdOrTag(a))
    },
    PaymentsConsume(a) {
        var b = parseInt(a, 10) || 0;
        return this.gp.payments.consume(0 < b ? {
            id: b
        } : {
            tag: a
        }).then(c => {
            this.isConsumeProductSuccess = c.success;
            this.consumeProductError = c.error || "";
            this.handleResult(c.success, c.error);
            var d = c.product || {};
            if (this.consumedProductId = d.id || 0,
            this.consumedProductTag = d.tag || "",
            c.success)
                return this._trigger(this.conditions.OnPaymentsConsume),
                void this._trigger(this.conditions.OnPaymentsAnyConsume);
            this._trigger(this.conditions.OnPaymentsConsumeError);
            this._trigger(this.conditions.OnPaymentsAnyConsumeError)
        }
        ).catch(c => {
            this.isConsumeProductSuccess = !1;
            this.consumeProductError = this.etos(c);
            this.handleResult(!1, c);
            this._trigger(this.conditions.OnPaymentsConsumeError);
            this._trigger(this.conditions.OnPaymentsAnyConsumeError)
        }
        )
    },
    PaymentsSubscribe(a) {
        return this.gp.payments.subscribe(this.getIdOrTag(a))
    },
    PaymentsUnsubscribe(a) {
        var b = parseInt(a, 10) || 0;
        return this.gp.payments.unsubscribe(0 < b ? {
            id: b
        } : {
            tag: a
        }).then(c => {
            this.isUnsubscribeProductSuccess = c.success;
            this.handleResult(c.success, c.error);
            var d = c.product || {};
            if (this.currentPurchase = c.purchase || {},
            this.currentProduct = d,
            this.currentProductPurchases = 1,
            this.purchasedProductId = d.id || 0,
            this.purchasedProductTag = d.tag || "",
            c.success)
                return this._trigger(this.conditions.OnPaymentsUnsubscribe),
                void this._trigger(this.conditions.OnPaymentsAnyUnsubscribe);
            this._trigger(this.conditions.OnPaymentsUnsubscribeError);
            this._trigger(this.conditions.OnPaymentsAnyUnsubscribeError)
        }
        ).catch(c => {
            this.isUnsubscribeProductSuccess = !1;
            this.handleResult(!1, c);
            this._trigger(this.conditions.OnPaymentsUnsubscribeError);
            this._trigger(this.conditions.OnPaymentsAnySubscribeError)
        }
        )
    },
    ImagesFetch(a, b, c, d) {
        return this.gp.images.fetch({
            playerId: b,
            limit: c,
            offset: d,
            tags: stoarr(a)
        }).then(e => {
            this.images = e.items;
            this.canLoadMoreImages = e.canLoadMore;
            this.handleResult(!0);
            this._trigger(this.conditions.OnImagesFetch)
        }
        ).catch(e => {
            this.handleResult(!1, e);
            this._trigger(this.conditions.OnImagesFetchError)
        }
        )
    },
    ImagesFetchMore(a, b, c) {
        return this.gp.images.fetchMore({
            playerId: b,
            limit: c,
            tags: stoarr(a)
        }).then(d => {
            this.images = d.items;
            this.canLoadMoreImages = d.canLoadMore;
            this.handleResult(!0);
            this._trigger(this.conditions.OnImagesFetchMore)
        }
        ).catch(d => {
            this.handleResult(!1, d);
            this._trigger(this.conditions.OnImagesFetchMoreError)
        }
        )
    },
    ImagesUpload(a) {
        return this.gp.images.upload({
            tags: stoarr(a)
        }).then(b => {
            this.currentImage = b || {};
            this.handleResult(!0);
            this._trigger(this.conditions.OnImagesUpload)
        }
        ).catch(b => {
            this.handleResult(!1, b);
            this._trigger(this.conditions.OnImagesUploadError)
        }
        )
    },
    ImagesUploadUrl(a, b) {
        return this.gp.images.uploadUrl({
            url: a,
            tags: stoarr(b)
        }).then(c => {
            this.currentImage = c || {};
            this.handleResult(!0);
            this._trigger(this.conditions.OnImagesUpload)
        }
        ).catch(c => {
            this.handleResult(!1, c);
            this._trigger(this.conditions.OnImagesUploadError)
        }
        )
    },
    ImagesChooseFile() {
        return this.gp.images.chooseFile().then(a => {
            this.lastImageTempUrl = a.tempUrl;
            this.handleResult(!0);
            this._trigger(this.conditions.OnImagesChoose)
        }
        ).catch(a => {
            this.handleResult(!1, a);
            this.lastImageTempUrl = "";
            this.isLastActionSuccess = !1;
            this._trigger(this.conditions.OnImagesChooseError)
        }
        )
    },
    FilesFetch(a, b, c, d) {
        return this.gp.files.fetch({
            playerId: b,
            limit: c,
            offset: d,
            tags: stoarr(a)
        }).then(e => {
            this.files = e.items;
            this.canLoadMoreFiles = e.canLoadMore;
            this.handleResult(!0);
            this._trigger(this.conditions.OnFilesFetch)
        }
        ).catch(e => {
            this.handleResult(!1, e);
            this._trigger(this.conditions.OnFilesFetchError)
        }
        )
    },
    FilesFetchMore(a, b, c) {
        return this.gp.files.fetchMore({
            playerId: b,
            limit: c,
            tags: stoarr(a)
        }).then(d => {
            this.files = d.items;
            this.canLoadMoreFiles = d.canLoadMore;
            this.handleResult(!0);
            this._trigger(this.conditions.OnFilesFetchMore)
        }
        ).catch(d => {
            this.handleResult(!1, d);
            this._trigger(this.conditions.OnFilesFetchMoreError)
        }
        )
    },
    FilesUpload(a) {
        return this.gp.files.upload({
            tags: stoarr(a)
        }).then(b => {
            this.currentFile = b || {};
            this.handleResult(!0);
            this._trigger(this.conditions.OnFilesUpload)
        }
        ).catch(b => {
            this.handleResult(!1, b);
            this._trigger(this.conditions.OnFilesUploadError)
        }
        )
    },
    FilesUploadUrl(a, b, c) {
        return this.gp.files.uploadUrl({
            url: a,
            filename: b,
            tags: stoarr(c)
        }).then(d => {
            this.currentFile = d || {};
            this.handleResult(!0);
            this._trigger(this.conditions.OnFilesUpload)
        }
        ).catch(d => {
            this.handleResult(!1, d);
            this._trigger(this.conditions.OnFilesUploadError)
        }
        )
    },
    FilesUploadContent(a, b, c) {
        return this.gp.files.uploadContent({
            content: a,
            filename: b,
            tags: stoarr(c)
        }).then(d => {
            this.currentFile = d || {};
            this.handleResult(!0);
            this._trigger(this.conditions.OnFilesUpload)
        }
        ).catch(d => {
            this.handleResult(!1, d);
            this._trigger(this.conditions.OnFilesUploadError)
        }
        )
    },
    FilesLoadContent(a) {
        return this.gp.files.loadContent(a).then(b => {
            this.lastFileContent = b;
            this.handleResult(!0);
            this._trigger(this.conditions.OnFilesLoadContent)
        }
        ).catch(b => {
            this.lastFileContent = "";
            this.handleResult(!1, b);
            this._trigger(this.conditions.OnFilesLoadContentError)
        }
        )
    },
    FilesChooseFile(a) {
        return this.gp.files.chooseFile(a).then(b => {
            this.lastFileTempUrl = b.tempUrl;
            this.handleResult(!0);
            this._trigger(this.conditions.OnFilesChoose)
        }
        ).catch(b => {
            this.handleResult(!1, b);
            this.lastFileTempUrl = "";
            this.isLastActionSuccess = !1;
            this._trigger(this.conditions.OnFilesChooseError)
        }
        )
    },
    VariablesFetch() {
        return this.gp.variables.fetch().then( () => {
            this.handleResult(!0);
            this._trigger(this.conditions.OnVariablesFetch)
        }
        ).catch(a => {
            this.handleResult(!1, a);
            this._trigger(this.conditions.OnVariablesFetchError)
        }
        )
    },
    PlatformVariablesFetch(a="") {
        a = a.split(",").reduce( (b, c) => {
            const [d,e] = c.split("=");
            return d && e && (b[d.trim()] = e.trim()),
            b
        }
        , {});
        return this.gp.variables.fetchPlatformVariables({
            clientParams: a
        }).then(b => {
            this.handleResult(!0);
            this.platformVariables = b;
            this._trigger(this.conditions.OnPlatformVariablesFetch)
        }
        ).catch(b => {
            this.handleResult(!1, b);
            this._trigger(this.conditions.OnPlatformVariablesFetchError)
        }
        )
    },
    FullscreenOpen() {
        return this.gp.fullscreen.open()
    },
    FullscreenClose() {
        return this.gp.fullscreen.close()
    },
    FullscreenToggle() {
        return this.gp.fullscreen.toggle()
    },
    AdsShowFullscreen(a=!1) {
        return this.gp.ads.showFullscreen({
            showCountdownOverlay: a
        })
    },
    AdsShowRewarded(a=!1, b="") {
        return this.lastRewardedTag = b,
        this.gp.ads.showRewardedVideo({
            showRewardedFailedOverlay: a
        })
    },
    AdsShowPreloader() {
        return this.gp.ads.showPreloader()
    },
    AdsShowSticky() {
        return this.gp.ads.showSticky()
    },
    AdsCloseSticky() {
        return this.gp.ads.closeSticky()
    },
    AdsRefreshSticky() {
        return this.gp.ads.refreshSticky()
    },
    AnalyticsHit(a) {
        return this.gp.analytics.hit(a)
    },
    AnalyticsGoal(a, b) {
        return this.gp.analytics.goal(a, b)
    },
    SocialsShare(a, b, c) {
        return this.gp.socials.share({
            text: a,
            url: b,
            image: c
        })
    },
    SocialsPost(a, b, c) {
        return this.gp.socials.post({
            text: a,
            url: b,
            image: c
        })
    },
    SocialsInvite(a, b, c) {
        return this.gp.socials.invite({
            text: a,
            url: b,
            image: c
        })
    },
    SocialsJoinCommunity() {
        return this.gp.socials.joinCommunity()
    },
    UniquesRegister(a, b) {
        return this.gp.uniques.register({
            tag: a,
            value: b
        })
    },
    UniquesCheck(a, b) {
        return this.gp.uniques.check({
            tag: a,
            value: b
        })
    },
    UniquesDelete(a) {
        return this.gp.uniques.delete({
            tag: a
        })
    },
    StorageGet(a) {
        return this.gp.storage.get(a)
    },
    StorageSet(a, b) {
        return this.gp.storage.set(a, b)
    },
    StorageGetGlobal(a) {
        return this.gp.storage.getGlobal(a)
    },
    StorageSetGlobal(a, b) {
        return this.gp.storage.setGlobal(a, b)
    },
    StorageSetStorage(a) {
        return this.gp.storage.setStorage(this.mappers.storageType[a])
    },
    GamesCollectionsOpen(a) {
        var b = parseInt(a, 10) || 0;
        return this.gp.gamesCollections.open(0 < b ? {
            id: b
        } : {
            tag: a || "ANY"
        })
    },
    GamesCollectionsFetch(a) {
        var b = parseInt(a, 10) || 0;
        return this.gp.gamesCollections.fetch(0 < b ? {
            id: b
        } : {
            tag: a
        }).then(c => {
            this.lastGamesCollectionIdOrTag = a;
            this.gamesCollection = c;
            this._trigger(this.conditions.OnGamesCollectionsFetch);
            this._trigger(this.conditions.OnGamesCollectionsFetchAny)
        }
        ).catch(c => {
            this.handleResult(!1, c);
            this.lastGamesCollectionIdOrTag = a;
            this.gamesCollectionFetchError = c && c.message || "";
            this._trigger(this.conditions.OnGamesCollectionsFetchError);
            this._trigger(this.conditions.OnGamesCollectionsFetchAnyError)
        }
        )
    },
    DocumentsOpen(a) {
        a = this.mappers.documentTypes[a];
        return this.gp.documents.open({
            type: a
        })
    },
    DocumentsFetch(a, b) {
        const c = this.mappers.documentTypes[a];
        a = this.mappers.documentFormat[b];
        return this.gp.documents.fetch({
            type: c,
            format: a
        }).then(d => {
            this.lastDocumentType = c;
            this.document = d;
            this._trigger(this.conditions.OnDocumentsFetch);
            this._trigger(this.conditions.OnDocumentsFetchAny)
        }
        ).catch(d => {
            this.handleResult(!1, d);
            this.documentFetchError = this.etos(d);
            this.lastDocumentType = c;
            this._trigger(this.conditions.OnDocumentsFetchError);
            this._trigger(this.conditions.OnDocumentsFetchAnyError)
        }
        )
    },
    PlayersFetch(a, b) {
        return this.gp.players.fetch({
            ids: stoarr(b, Number)
        }).then(c => {
            this.lastPlayersTag = a;
            this.playersList = c.players;
            this.handleResult(!0);
            this._trigger(this.conditions.OnPlayersFetch);
            this._trigger(this.conditions.OnPlayersAnyFetch)
        }
        ).catch(c => {
            this.lastPlayersTag = a;
            this.handleResult(!1, c);
            this._trigger(this.conditions.OnPlayersFetchError);
            this._trigger(this.conditions.OnPlayersAnyFetchError)
        }
        )
    },
    PlayersFetchOne(a, b) {
        return this.gp.players.fetch({
            ids: [Number(b)]
        }).then(c => {
            this.lastPlayersTag = a;
            c.players[0] ? (this.playersList = c.players,
            this.currentPlayersIndex = 0,
            this.currentPlayersPlayer = c.players[0],
            this.handleResult(!0),
            this._trigger(this.conditions.OnPlayersFetch),
            this._trigger(this.conditions.OnPlayersAnyFetch)) : (this.handleResult(!1, Error("player_not_found")),
            this._trigger(this.conditions.OnPlayersFetchError),
            this._trigger(this.conditions.OnPlayersAnyFetchError))
        }
        ).catch(c => {
            this.lastPlayersTag = a;
            this.handleResult(!1, c);
            this._trigger(this.conditions.OnPlayersFetchError);
            this._trigger(this.conditions.OnPlayersAnyFetchError)
        }
        )
    },
    AppAddShortcut() {
        return this.gp.app.addShortcut()
    },
    AppRequestReview() {
        return this.gp.app.requestReview()
    },
    ChangeLanguage(a) {
        return this.gp.changeLanguage(this.mappers.language[a])
    },
    ChangeLanguageByCode(a="") {
        return this.gp.changeLanguage(a.toLowerCase())
    },
    ChangeAvatarGenerator(a) {
        return this.gp.changeAvatarGenerator(this.mappers.avatarGenerator[a])
    },
    SetBackground(a, b, c) {
        return this.gp.setBackground({
            url: a,
            blur: b,
            fade: c
        })
    },
    LoadOverlay() {
        return this.gp.loadOverlay()
    },
    Pause() {
        return this.gp.pause()
    },
    Resume() {
        return this.gp.resume()
    },
    GameStart() {
        return this.gp.gameStart()
    },
    GameplayStart() {
        return this.gp.gameplayStart()
    },
    GameplayStop() {
        return this.gp.gameplayStop()
    },
    SocialsAddShareUrlParam(a, b) {
        this.shareParams[a] = b
    },
    SocialsResetShareParams() {
        this.shareParams = {}
    },
    RewardsAccept(a) {
        return this.gp.rewards.accept(this.getIdOrTag(a))
    },
    RewardsGive(a, b) {
        a = this.getIdOrTag(a);
        return a.lazy = !!b,
        this.gp.rewards.give(a)
    },
    TriggersClaim(a) {
        return this.gp.triggers.claim({
            id: a,
            tag: a
        })
    },
    SchedulersRegister(a) {
        return this.gp.schedulers.register(this.getIdOrTag(a))
    },
    SchedulersClaimDay(a, b) {
        return this.gp.schedulers.claimDay(a, b)
    },
    SchedulersClaimDayAdditional(a, b, c) {
        return this.gp.schedulers.claimDayAdditional(a, b, c)
    },
    SchedulersClaimAllDay(a, b) {
        return this.gp.schedulers.claimAllDay(a, b)
    },
    SchedulersClaimAllDays(a) {
        return this.gp.schedulers.claimAllDays(a)
    },
    EventsJoin(a) {
        return this.gp.events.join(this.getIdOrTag(a))
    },
    LoadFromJSON(a) {
        try {
            var b = JSON.parse(a);
            if (!("isReady"in b))
                throw Error("Data was corrupted");
            this.LoadFromJson(b)
        } catch (c) {
            this._trigger(this.conditions.OnLoadJsonError)
        }
    }
};
globalThis.C3.Plugins.Eponesh_GameScore.Exps = {
    PlayerID() {
        return this.gp.player.id
    },
    PlayerScore() {
        return this.gp.player.score
    },
    PlayerName() {
        return this.gp.player.name
    },
    PlayerAvatar() {
        return this.gp.player.avatar
    },
    PlayerGet(a) {
        return this.gp.player.get(a)
    },
    PlayerHas(a) {
        return this.gp.player.is(a)
    },
    PlayerFieldName(a) {
        return this.gp.player.getFieldName(a)
    },
    PlayerFieldVariantName(a, b) {
        return this.gp.player.getFieldVariantName(a, b)
    },
    PlayerGetFieldVariantAt(a, b) {
        return (a = this.gp.player.getField(a).variants[b]) ? a.value : ""
    },
    PlayerGetFieldVariantIndex(a, b) {
        return this.gp.player.getField(a).variants.findIndex(c => c.value === b)
    },
    PlayerCurFieldKey() {
        return this.currentPlayerFieldKey || ""
    },
    PlayerCurFieldType() {
        return this.currentPlayerFieldType || ""
    },
    PlayerCurFieldName() {
        return this.currentPlayerFieldName || ""
    },
    PlayerCurFieldValue() {
        return "string" == typeof this.currentPlayerFieldValue ? this.currentPlayerFieldValue : Number(this.currentPlayerFieldValue || 0)
    },
    PlayerCurFieldVariantValue() {
        return "string" == typeof this.currentPlayerFieldVariantValue ? this.currentPlayerFieldVariantValue : Number(this.currentPlayerFieldVariantValue || 0)
    },
    PlayerCurFieldVariantName() {
        return this.currentPlayerFieldVariantName || ""
    },
    PlayerCurFieldVariantIndex() {
        return this.currentPlayerFieldVariantIndex || 0
    },
    PlayerStatsPlaytimeAll() {
        return this.gp.player.stats.playtimeAll || 0
    },
    PlayerStatsPlaytimeToday() {
        return this.gp.player.stats.playtimeToday || 0
    },
    PlayerStatsActiveDays() {
        return this.gp.player.stats.activeDays || 0
    },
    PlayerStatsActiveDaysConsecutive() {
        return this.gp.player.stats.activeDaysConsecutive || 0
    },
    LeaderboardCurPlayerName() {
        return this.currentLeaderboardPlayer.name || ""
    },
    LeaderboardCurPlayerAvatar() {
        return this.currentLeaderboardPlayer.avatar || ""
    },
    LeaderboardCurPlayerID() {
        return this.currentLeaderboardPlayer.id || 0
    },
    LeaderboardCurPlayerScore() {
        return this.currentLeaderboardPlayer.score || 0
    },
    LeaderboardCurPlayerPosition() {
        return this.currentLeaderboardPlayer.position || 0
    },
    LeaderboardCurPlayerIndex() {
        return this.currentLeaderboardIndex || 0
    },
    LeaderboardCurPlayerField(a) {
        return a in this.currentLeaderboardPlayer ? this.currentLeaderboardPlayer[a] : 0
    },
    LeaderboardPlayerFieldAt(a, b) {
        return (a = this.leaderboard[a]) && b in a ? a[b] : 0
    },
    LeaderboardPlayerPosition() {
        return this.leaderboardPlayerPosition || 0
    },
    LastLeaderboardTag() {
        return this.lastLeaderboardTag
    },
    LastRewardedTag() {
        return this.lastRewardedTag
    },
    LastLeaderboardVariant() {
        return this.lastLeaderboardVariant
    },
    IsFullscreenMode() {
        return Number(this.gp.fullscreen.isEnabled)
    },
    Language() {
        return this.gp.language
    },
    AvatarGenerator() {
        return this.gp.avatarGenerator
    },
    ServerTime() {
        return this.gp.serverTime
    },
    ServerTimeUnix() {
        return (new Date(this.gp.serverTime)).getTime()
    },
    IsPaused() {
        return this.gp.isPaused
    },
    IsGameplay() {
        return this.gp.isGameplay
    },
    DeviceType() {
        return this.gp.device.type
    },
    PlatformType() {
        return this.gp.platform.type
    },
    AppTitle() {
        return this.gp.app.title
    },
    AppDescription() {
        return this.gp.app.description
    },
    AppImage() {
        return this.gp.app.image
    },
    AppUrl() {
        return this.gp.app.url
    },
    AppLastReviewRating() {
        return Number(this.appLastReviewRating) || 0
    },
    AchievementsTotalAchievements() {
        return this.gp.achievements.list.length
    },
    AchievementsTotalAchievementsGroups() {
        return this.gp.achievements.groupsList.length
    },
    AchievementsTotalPlayerAchievements() {
        return this.gp.achievements.unlockedList.length
    },
    AchievementsCurAchievementIndex() {
        return this.currentAchievementIndex
    },
    AchievementsCurAchievementID() {
        return this.currentAchievement.id
    },
    AchievementsCurAchievementTag() {
        return this.currentAchievement.tag
    },
    AchievementsCurAchievementName() {
        return this.currentAchievement.name
    },
    AchievementsCurAchievementDescription() {
        return this.currentAchievement.description
    },
    AchievementsCurAchievementIcon() {
        return this.currentAchievement.icon
    },
    AchievementsCurAchievementIconSmall() {
        return this.currentAchievement.iconSmall
    },
    AchievementsCurAchievementRare() {
        return this.currentAchievement.rare
    },
    AchievementsCurAchievementUnlocked() {
        return this.currentAchievement.unlocked
    },
    AchievementsCurAchievementLockedIcon() {
        return this.currentAchievement.lockedIcon
    },
    AchievementsCurAchievementLockedIconSmall() {
        return this.currentAchievement.lockedIconSmall
    },
    AchievementsCurAchievementProgress() {
        return this.currentAchievement.progress
    },
    AchievementsCurAchievementMaxProgress() {
        return this.currentAchievement.maxProgress
    },
    AchievementsCurAchievementProgressStep() {
        return this.currentAchievement.progressStep
    },
    AchievementsCurAchievementsGroupIndex() {
        return this.currentAchievementsGroupIndex
    },
    AchievementsCurAchievementsGroupID() {
        return this.currentAchievementsGroupID
    },
    AchievementsCurAchievementsGroupTag() {
        return this.currentAchievementsGroupTag
    },
    AchievementsCurAchievementsGroupName() {
        return this.currentAchievementsGroupName
    },
    AchievementsCurAchievementsGroupDescription() {
        return this.currentAchievementsGroupDescription
    },
    AchievementsCurPlayerAchievementIndex() {
        return this.currentPlayerAchievementIndex
    },
    AchievementsCurPlayerAchievementID() {
        return this.currentPlayerAchievementId
    },
    AchievementsCurPlayerAchievementUnlockDate() {
        return this.currentPlayerAchievementUnlockDate
    },
    AchievementsUnlockedAchievementSuccess() {
        return this.isUnlockAchievementSuccess
    },
    AchievementsUnlockedAchievementError() {
        return this.unlockAchievementError
    },
    AchievementsUnlockedAchievementID() {
        return this.currentAchievement.id
    },
    AchievementsUnlockedAchievementTag() {
        return this.currentAchievement.tag
    },
    AchievementsUnlockedAchievementName() {
        return this.currentAchievement.name
    },
    AchievementsUnlockedAchievementDescription() {
        return this.currentAchievement.description
    },
    AchievementsUnlockedAchievementIcon() {
        return this.currentAchievement.icon
    },
    AchievementsUnlockedAchievementIconSmall() {
        return this.currentAchievement.iconSmall
    },
    AchievementsUnlockedAchievementRare() {
        return this.currentAchievement.rare
    },
    AchievementsGetProgress(a) {
        return this.gp.achievements.getProgress(a)
    },
    SocialsCommunityLink() {
        return this.gp.socials.communityLink
    },
    SocialsGetShareParam(a) {
        return this.gp.socials.getShareParam(a)
    },
    SocialsShareLink() {
        return this.gp.socials.makeShareUrl(this.shareParams)
    },
    PaymentsCurProductIndex() {
        return this.currentProductIndex
    },
    PaymentsCurProductID() {
        return this.currentProduct.id
    },
    PaymentsCurProductTag() {
        return this.currentProduct.tag
    },
    PaymentsCurProductName() {
        return this.currentProduct.name
    },
    PaymentsCurProductDescription() {
        return this.currentProduct.description
    },
    PaymentsCurProductIcon() {
        return this.currentProduct.icon
    },
    PaymentsCurProductIconSmall() {
        return this.currentProduct.iconSmall
    },
    PaymentsCurProductPrice() {
        return this.currentProduct.price
    },
    PaymentsCurProductCurrency() {
        return this.currentProduct.currency
    },
    PaymentsCurProductCurrencySymbol() {
        return this.currentProduct.currencySymbol
    },
    PaymentsCurProductPurchases() {
        return this.currentProductPurchases
    },
    PaymentsCurPurchaseIndex() {
        return this.currentPurchaseIndex
    },
    PaymentsCurPurchaseID() {
        return this.currentPurchase.id || 0
    },
    PaymentsCurPurchaseTag() {
        return this.currentPurchase.tag || ""
    },
    PaymentsCurPurchaseDate() {
        return this.currentPurchase.createdAt || ""
    },
    PaymentsCurPurchaseExpirationDate() {
        return this.currentPurchase.expiredAt || ""
    },
    PaymentsCurPurchaseSubscribed() {
        return Number(this.currentPurchase.subscribed || !1) || 0
    },
    PaymentsPurchasedProductSuccess() {
        return this.isPurchaseProductSuccess
    },
    PaymentsPurchasedProductError() {
        return this.purchaseProductError
    },
    PaymentsPurchasedProductID() {
        return this.purchasedProductId
    },
    PaymentsPurchasedProductTag() {
        return this.purchasedProductTag
    },
    PaymentsConsumedProductSuccess() {
        return this.isConsumeProductSuccess
    },
    PaymentsConsumedProductError() {
        return this.consumeProductError
    },
    PaymentsConsumedProductID() {
        return this.consumedProductId
    },
    PaymentsConsumedProductTag() {
        return this.consumedProductTag
    },
    PaymentsPurchaseDate(a) {
        return (a = this.gp.payments.getPurchase(a)) && a.createdAt || ""
    },
    PaymentsExpirationDate(a) {
        return (a = this.gp.payments.getPurchase(a)) && a.expiredAt || ""
    },
    ImagesCurImageIndex() {
        return this.currentImageIndex
    },
    ImagesCurImageID() {
        return this.currentImage.id || ""
    },
    ImagesCurImageSrc() {
        return this.currentImage.src || ""
    },
    ImagesCurImageWidth() {
        return this.currentImage.width || 0
    },
    ImagesCurImageHeight() {
        return this.currentImage.height || 0
    },
    ImagesCurImagePlayerID() {
        return this.currentImage.playerId || 0
    },
    ImagesCurImageTagIndex() {
        return this.currentImageTagIndex
    },
    ImagesCurImageTag() {
        return this.currentImageTag || ""
    },
    ImagesTempFileUrl() {
        return this.lastImageTempUrl || ""
    },
    ImagesResize(a, b, c, d) {
        return this.gp.images.resize(a, b, c, d)
    },
    FilesCurFileIndex() {
        return this.currentFileIndex
    },
    FilesCurFileID() {
        return this.currentFile.id || ""
    },
    FilesCurFileSrc() {
        return this.currentFile.src || ""
    },
    FilesCurFileName() {
        return this.currentFile.name || ""
    },
    FilesCurFileSize() {
        return this.currentFile.size || 0
    },
    FilesCurFilePlayerID() {
        return this.currentFile.playerId || 0
    },
    FilesCurFileTagIndex() {
        return this.currentFileTagIndex
    },
    FilesCurFileTag() {
        return this.currentFileTag || ""
    },
    FilesTempFileUrl() {
        return this.lastFileTempUrl || ""
    },
    FilesLastFileContent() {
        return this.lastFileContent || ""
    },
    GamesCollectionsCollectionID() {
        return this.gamesCollection.id
    },
    GamesCollectionsCollectionTag() {
        return this.gamesCollection.tag
    },
    GamesCollectionsCollectionName() {
        return this.gamesCollection.name
    },
    GamesCollectionsCollectionDescription() {
        return this.gamesCollection.description
    },
    GamesCollectionsCurGameIndex() {
        return this.currentGameIndex
    },
    GamesCollectionsCurGameID() {
        return this.currentGameId
    },
    GamesCollectionsCurGameTag() {
        return this.currentGameTag
    },
    GamesCollectionsCurGameName() {
        return this.currentGameName
    },
    GamesCollectionsCurGameDescription() {
        return this.currentGameDescription
    },
    GamesCollectionsCurGameIcon() {
        return this.currentGameIcon
    },
    GamesCollectionsCurGameUrl() {
        return this.currentGameUrl
    },
    GamesCollectionsFetchError() {
        return this.gamesCollectionFetchError
    },
    DocumentsDocumentType() {
        return this.document.type
    },
    DocumentsDocumentContent() {
        return this.document.content
    },
    DocumentsFetchError() {
        return this.documentFetchError
    },
    VariablesGet: function(a) {
        return this.gp.variables.get(a)
    },
    PlatformVariablesGet(a) {
        return this.platformVariables[a] || ""
    },
    VariablesHas(a) {
        return Number(this.gp.variables.has(a))
    },
    VariablesType(a) {
        return this.gp.variables.type(a)
    },
    VariablesCurIndex() {
        return this.currentVariableIndex || 0
    },
    VariablesCurKey() {
        return this.currentVariable.key || ""
    },
    VariablesCurType() {
        return this.currentVariable.type || ""
    },
    VariablesCurValue() {
        return this.currentVariable.value || ""
    },
    PlayersCurPlayerName() {
        return this.currentPlayersPlayer.state.name || ""
    },
    PlayersCurPlayerAvatar() {
        return this.currentPlayersPlayer.state.avatar || ""
    },
    PlayersCurPlayerID() {
        return this.currentPlayersPlayer.state.id || 0
    },
    PlayersCurPlayerScore() {
        return this.currentPlayersPlayer.state.score || 0
    },
    PlayersCurPlayerIndex() {
        return this.currentPlayersIndex || 0
    },
    PlayersCurPlayerField(a) {
        return this.currentPlayersPlayer && a in this.currentPlayersPlayer.state ? this.currentPlayersPlayer.state[a] : 0
    },
    PlayersPlayerFieldAt(a, b) {
        return (a = this.playersList[a]) && b in a.state ? a.state[b] : 0
    },
    LastPlayersTag() {
        return this.lastPlayersTag
    },
    RewardsCurIndex() {
        return this.curRewardIndex || 0
    },
    RewardsCurID() {
        return this.curReward.id || 0
    },
    RewardsCurTag() {
        return this.curReward.tag || ""
    },
    RewardsCurName() {
        return this.curReward.name || ""
    },
    RewardsCurDescription() {
        return this.curReward.description || ""
    },
    RewardsCurIcon() {
        return this.curReward.icon || ""
    },
    RewardsCurIconSmall() {
        return this.curReward.iconSmall || ""
    },
    RewardsCurCountTotal() {
        return this.curPlayerReward.countTotal || 0
    },
    RewardsCurCountAccepted() {
        return this.curPlayerReward.countAccepted || 0
    },
    TriggersCurIndex() {
        return this.curTriggerIndex || 0
    },
    TriggersCurID() {
        return this.curTriggerInfo.trigger.id || 0
    },
    TriggersCurTag() {
        return this.curTriggerInfo.trigger.tag || ""
    },
    TriggersCurDescription() {
        return this.curTriggerInfo.trigger.description || ""
    },
    BonusCurIndex() {
        return this.curBonusIndex || 0
    },
    BonusCurID() {
        return this.curBonus.id || 0
    },
    BonusCurType() {
        return this.curBonus.type || ""
    },
    SchedulersCurIndex() {
        return this.curSchedulerIndex || 0
    },
    SchedulersCurID() {
        return this.curSchedulerInfo.scheduler.id || 0
    },
    SchedulersCurTag() {
        return this.curSchedulerInfo.scheduler.tag || 0
    },
    SchedulersCurType() {
        return this.curSchedulerInfo.scheduler.type || 0
    },
    SchedulersCurDays() {
        return this.curSchedulerInfo.scheduler.days || 0
    },
    SchedulersCurTodayDay() {
        return this.curSchedulerInfo.currentDay || 0
    },
    SchedulersCurPlayerStatsActiveDays() {
        return (this.curSchedulerInfo.stats || {}).activeDays || 0
    },
    SchedulersCurPlayerStatsActiveDaysConsecutive() {
        return (this.curSchedulerInfo.stats || {}).activeDaysConsecutive || 0
    },
    SchedulersCurDayDayNumber() {
        return this.curSchedulerDayInfo.day || 0
    },
    EventsCurIndex() {
        return this.curEventIndex || 0
    },
    EventsCurID() {
        return this.curEventInfo.event.id || 0
    },
    EventsCurTag() {
        return this.curEventInfo.event.tag || 0
    },
    EventsCurName() {
        return this.curEventInfo.event.name || 0
    },
    EventsCurDescription() {
        return this.curEventInfo.event.description || 0
    },
    EventsCurIcon() {
        return this.curEventInfo.event.icon || 0
    },
    EventsCurIconSmall() {
        return this.curEventInfo.event.iconSmall || 0
    },
    EventsCurTimeLeft() {
        return this.curEventInfo.event.timeLeft || 0
    },
    EventsCurPlayerStatsActiveDays() {
        return (this.curEventInfo.stats || {}).activeDays || 0
    },
    EventsCurPlayerStatsActiveDaysConsecutive() {
        return (this.curEventInfo.stats || {}).activeDaysConsecutive || 0
    },
    ExperimentsGet(a) {
        return this.gp.experiments.map[a] || ""
    },
    SegmentsCurSegment() {
        return this.curSegment || ""
    },
    LastError() {
        return this.lastError
    },
    IsLastActionSuccess() {
        return Number(this.isLastActionSuccess)
    },
    GenerateAvatar(a, b) {
        return this.gp.generateAvatar(a, b)
    },
    AsJSON() {
        return JSON.stringify(this.SaveToJson())
    },
    UniquesGet(a) {
        return this.gp.uniques.get(a)
    },
    UniquesCurTag() {
        return this.currentUniquesTag || ""
    },
    UniquesCurValue() {
        return this.currentUniquesValue || ""
    },
    StorageType() {
        return this.gp.storage.type
    },
    StorageCurKey() {
        return this.storageCurKey || ""
    },
    StorageCurValue() {
        return this.storageCurValue || ""
    }
};
"use strict";
const C3$jscomp$265 = self.C3;
C3$jscomp$265.Plugins.Arr = class extends C3$jscomp$265.SDKPluginBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
}
;
const C3$jscomp$266 = self.C3;
C3$jscomp$266.Plugins.Arr.Type = class extends C3$jscomp$266.SDKTypeBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
}
;
const C3$jscomp$267 = self.C3
  , C3X$jscomp$40 = self.C3X
  , IInstance$jscomp$4 = self.IInstance;
function ResizeArray(a, b, c) {
    if (b < a.length)
        C3$jscomp$267.truncateArray(a, b);
    else if (b > a.length)
        if ("function" === typeof c)
            for (var d = a.length; d < b; ++d)
                a.push(c());
        else
            for (d = a.length; d < b; ++d)
                a.push(c)
}
C3$jscomp$267.Plugins.Arr.Instance = class extends C3$jscomp$267.SDKInstanceBase {
    constructor(a, b) {
        super(a);
        this._cx = 10;
        this._cz = this._cy = 1;
        this._arr = null;
        this._forX = [];
        this._forY = [];
        this._forZ = [];
        this._forDepth = -1;
        b && (this._cx = b[0],
        this._cy = b[1],
        this._cz = b[2]);
        this._arr = C3$jscomp$267.MakeFilledArray(this._cx, () => C3$jscomp$267.MakeFilledArray(this._cy, () => C3$jscomp$267.MakeFilledArray(this._cz, 0)))
    }
    Release() {
        this._arr = null;
        super.Release()
    }
    At(a, b, c) {
        a = Math.floor(a);
        b = Math.floor(b);
        c = Math.floor(c);
        return 0 <= a && a < this._cx && 0 <= b && b < this._cy && 0 <= c && c < this._cz ? this._arr[a][b][c] : 0
    }
    Set(a, b, c, d) {
        a = Math.floor(a);
        b = Math.floor(b);
        c = Math.floor(c);
        0 <= a && a < this._cx && 0 <= b && b < this._cy && 0 <= c && c < this._cz && (this._arr[a][b][c] = d)
    }
    SetSize(a, b, c) {
        a = Math.floor(a);
        b = Math.floor(b);
        c = Math.floor(c);
        0 > a && (a = 0);
        0 > b && (b = 0);
        0 > c && (c = 0);
        if (this._cx !== a || this._cy !== b || this._cz !== c) {
            this._cx = a;
            this._cy = b;
            this._cz = c;
            var d = this._arr;
            ResizeArray(d, a, () => C3$jscomp$267.MakeFilledArray(b, () => C3$jscomp$267.MakeFilledArray(c, 0)));
            for (let e = 0; e < a; ++e) {
                ResizeArray(d[e], b, () => C3$jscomp$267.MakeFilledArray(c, 0));
                for (let f = 0; f < b; ++f)
                    ResizeArray(d[e][f], c, 0)
            }
        }
    }
    GetWidth() {
        return this._cx
    }
    GetHeight() {
        return this._cy
    }
    GetDepth() {
        return this._cz
    }
    _ShuffleHelper(a, b, c, d, e) {
        for (; 0 < b; ) {
            const l = Math.floor(this._runtime.Random() * b);
            --b;
            if (0 === a) {
                var f = this.At(b, d, e)
                  , h = this.At(l, d, e);
                this.Set(b, d, e, h);
                this.Set(l, d, e, f)
            } else
                1 === a ? (f = this.At(c, b, e),
                h = this.At(c, l, e),
                this.Set(c, b, e, h),
                this.Set(c, l, e, f)) : 2 === a && (f = this.At(c, d, b),
                h = this.At(c, d, l),
                this.Set(c, d, b, h),
                this.Set(c, d, l, f))
        }
    }
    GetDebuggerProperties() {
        const a = [{
            title: "plugins.arr.debugger.array-properties.title",
            properties: [{
                name: "plugins.arr.properties.width.name",
                value: this._cx,
                onedit: c => this.SetSize(c, this._cy, this._cz)
            }, {
                name: "plugins.arr.properties.height.name",
                value: this._cy,
                onedit: c => this.SetSize(this._cx, c, this._cz)
            }, {
                name: "plugins.arr.properties.depth.name",
                value: this._cz,
                onedit: c => this.SetSize(this._cx, this._cy, c)
            }, {
                name: "plugins.arr.properties.elements.name",
                value: this._cx * this._cy * this._cz
            }]
        }]
          , b = [];
        if (1 === this._cy && 1 === this._cz)
            for (let c = 0; c < this._cx; ++c)
                b.push({
                    name: "$" + c,
                    value: this._arr[c][0][0],
                    onedit: d => this._arr[c][0][0] = d
                });
        else
            for (let c = 0; c < this._cx; ++c)
                b.push({
                    name: "$" + c,
                    value: this._arr[c].toString()
                });
        b.length && a.push({
            title: "plugins.arr.debugger.array-data.title",
            properties: b
        });
        return a
    }
    GetAsJsonString() {
        return JSON.stringify({
            c2array: !0,
            size: [this._cx, this._cy, this._cz],
            data: this._arr
        })
    }
    SaveToJson() {
        return {
            size: [this._cx, this._cy, this._cz],
            data: this._arr
        }
    }
    LoadFromJson(a) {
        const b = a.size;
        this._cx = b[0];
        this._cy = b[1];
        this._cz = b[2];
        this._arr = a.data
    }
    _GetForX() {
        return 0 <= this._forDepth && this._forDepth < this._forX.length ? this._forX[this._forDepth] : 0
    }
    _GetForY() {
        return 0 <= this._forDepth && this._forDepth < this._forY.length ? this._forY[this._forDepth] : 0
    }
    _GetForZ() {
        return 0 <= this._forDepth && this._forDepth < this._forZ.length ? this._forZ[this._forDepth] : 0
    }
    GetScriptInterfaceClass() {
        return self.IArrayInstance
    }
}
;
const map$jscomp$28 = new WeakMap;
self.IArrayInstance = class extends IInstance$jscomp$4 {
    constructor() {
        super();
        map$jscomp$28.set(this, IInstance$jscomp$4._GetInitInst().GetSdkInstance())
    }
    get width() {
        return map$jscomp$28.get(this).GetWidth()
    }
    get height() {
        return map$jscomp$28.get(this).GetHeight()
    }
    get depth() {
        return map$jscomp$28.get(this).GetDepth()
    }
    setSize(a, b=1, c=1) {
        C3X$jscomp$40.RequireFiniteNumber(a);
        C3X$jscomp$40.RequireFiniteNumber(b);
        C3X$jscomp$40.RequireFiniteNumber(c);
        map$jscomp$28.get(this).SetSize(a, b, c)
    }
    getAt(a, b=0, c=0) {
        C3X$jscomp$40.RequireFiniteNumber(a);
        C3X$jscomp$40.RequireFiniteNumber(b);
        C3X$jscomp$40.RequireFiniteNumber(c);
        return map$jscomp$28.get(this).At(a, b, c)
    }
    setAt(a, b, c=0, d=0) {
        C3X$jscomp$40.RequireFiniteNumber(b);
        C3X$jscomp$40.RequireFiniteNumber(c);
        C3X$jscomp$40.RequireFiniteNumber(d);
        if ("number" !== typeof a && "string" !== typeof a)
            throw new TypeError("invalid type");
        map$jscomp$28.get(this).Set(b, c, d, a)
    }
}
;
const C3$jscomp$268 = self.C3;
function DoForEachTrigger(a, b, c, d, e, f) {
    a.PushCopySol(c);
    f.GetObjectClass().GetCurrentSol().PickOne(f.GetInstance());
    b.Retrigger(d, e);
    a.PopSol(c)
}
C3$jscomp$268.Plugins.Arr.Cnds = {
    CompareX(a, b, c) {
        return C3$jscomp$268.compare(this.At(a, 0, 0), b, c)
    },
    CompareXY(a, b, c, d) {
        return C3$jscomp$268.compare(this.At(a, b, 0), c, d)
    },
    CompareXYZ(a, b, c, d, e) {
        return C3$jscomp$268.compare(this.At(a, b, c), d, e)
    },
    ArrForEach(a) {
        const b = this._runtime
          , c = b.GetEventSheetManager()
          , d = b.GetCurrentEvent()
          , e = d.GetSolModifiers()
          , f = b.GetEventStack()
          , h = f.GetCurrentStackFrame()
          , l = f.Push(d)
          , m = ++this._forDepth
          , p = this._forX;
        var r = this._forY
          , v = this._forZ;
        const x = this._cx
          , B = this._cy;
        var A = this._cz;
        m === this._forX.length ? (p.push(0),
        r.push(0),
        v.push(0)) : (p[m] = 0,
        r[m] = 0,
        v[m] = 0);
        b.SetDebuggingEnabled(!1);
        if (0 === a)
            for (a = 0; a < x; ++a)
                for (let D = 0; D < B; ++D)
                    for (let F = 0; F < A; ++F)
                        p[m] = a,
                        r[m] = D,
                        v[m] = F,
                        DoForEachTrigger(c, d, e, h, l, this);
        else if (1 === a)
            for (v = 0; v < x; ++v)
                for (A = 0; A < B; ++A)
                    p[m] = v,
                    r[m] = A,
                    DoForEachTrigger(c, d, e, h, l, this);
        else
            for (r = 0; r < x; ++r)
                p[m] = r,
                DoForEachTrigger(c, d, e, h, l, this);
        b.SetDebuggingEnabled(!0);
        this._forDepth--;
        f.Pop();
        return !1
    },
    CompareCurrent(a, b) {
        return C3$jscomp$268.compare(this.At(this._GetForX(), this._GetForY(), this._GetForZ()), a, b)
    },
    Contains(a) {
        const b = this._cx
          , c = this._cy
          , d = this._cz
          , e = this._arr;
        for (let f = 0; f < b; ++f)
            for (let h = 0; h < c; ++h)
                for (let l = 0; l < d; ++l)
                    if (e[f][h][l] === a)
                        return !0;
        return !1
    },
    IsEmpty() {
        return 0 === this._cx || 0 === this._cy || 0 === this._cz
    },
    CompareSize(a, b, c) {
        let d = 0;
        switch (a) {
        case 0:
            d = this._cx;
            break;
        case 1:
            d = this._cy;
            break;
        case 2:
            d = this._cz
        }
        return C3$jscomp$268.compare(d, b, c)
    }
};
const C3$jscomp$269 = self.C3;
function CompareValues(a, b) {
    if ("number" === typeof a && "number" === typeof b)
        return a - b;
    a = a.toString();
    b = b.toString();
    return a < b ? -1 : a > b ? 1 : 0
}
C3$jscomp$269.Plugins.Arr.Acts = {
    Clear(a) {
        const b = this._cx
          , c = this._cy
          , d = this._cz
          , e = this._arr;
        for (let f = 0; f < b; ++f)
            for (let h = 0; h < c; ++h)
                for (let l = 0; l < d; ++l)
                    e[f][h][l] = a
    },
    SetSize(a, b, c) {
        this.SetSize(a, b, c)
    },
    SetX(a, b) {
        this.Set(a, 0, 0, b)
    },
    SetXY(a, b, c) {
        this.Set(a, b, 0, c)
    },
    SetXYZ(a, b, c, d) {
        this.Set(a, b, c, d)
    },
    Push(a, b, c) {
        var d = this._cx
          , e = this._cy;
        const f = this._cz
          , h = this._arr;
        if (0 === c)
            d = C3$jscomp$269.MakeFilledArray(e, () => C3$jscomp$269.MakeFilledArray(f, b)),
            0 === a ? h.push(d) : h.unshift(d),
            this._cx++;
        else if (1 === c) {
            for (e = 0; e < d; ++e)
                c = C3$jscomp$269.MakeFilledArray(f, b),
                0 === a ? h[e].push(c) : h[e].unshift(c);
            this._cy++
        } else {
            for (c = 0; c < d; ++c)
                for (let l = 0; l < e; ++l)
                    0 === a ? h[c][l].push(b) : h[c][l].unshift(b);
            this._cz++
        }
    },
    Pop(a, b) {
        const c = this._cx;
        var d = this._cy
          , e = this._cz;
        const f = this._arr;
        if (0 === b)
            0 !== c && (0 === a ? f.pop() : f.shift(),
            this._cx--);
        else if (1 === b) {
            if (0 !== d) {
                for (d = 0; d < c; ++d)
                    0 === a ? f[d].pop() : f[d].shift();
                this._cy--
            }
        } else if (0 !== e) {
            for (b = 0; b < c; ++b)
                for (e = 0; e < d; ++e)
                    0 === a ? f[b][e].pop() : f[b][e].shift();
            this._cz--
        }
    },
    Reverse(a) {
        const b = this._cx;
        var c = this._cy
          , d = this._cz;
        const e = this._arr;
        if (0 !== b && 0 !== c && 0 !== d)
            if (0 === a)
                e.reverse();
            else if (1 === a)
                for (c = 0; c < b; ++c)
                    e[c].reverse();
            else
                for (a = 0; a < b; ++a)
                    for (d = 0; d < c; ++d)
                        e[a][d].reverse()
    },
    Sort(a) {
        const b = this._cx;
        var c = this._cy
          , d = this._cz;
        const e = this._arr;
        if (0 !== b && 0 !== c && 0 !== d)
            if (0 === a)
                e.sort( (f, h) => CompareValues(f[0][0], h[0][0]));
            else if (1 === a)
                for (c = 0; c < b; ++c)
                    e[c].sort( (f, h) => CompareValues(f[0], h[0]));
            else
                for (a = 0; a < b; ++a)
                    for (d = 0; d < c; ++d)
                        e[a][d].sort(CompareValues)
    },
    Shuffle(a) {
        const b = this._cx
          , c = this._cy
          , d = this._cz;
        if (0 !== b && 0 !== c && 0 !== d)
            if (0 === a)
                for (var e = 0; e < c; ++e)
                    for (var f = 0; f < d; ++f)
                        this._ShuffleHelper(a, b, 0, e, f);
            else if (1 === a)
                for (e = 0; e < b; ++e)
                    for (f = 0; f < d; ++f)
                        this._ShuffleHelper(a, c, e, 0, f);
            else
                for (e = 0; e < b; ++e)
                    for (f = 0; f < c; ++f)
                        this._ShuffleHelper(a, d, e, f, 0)
    },
    Delete(a, b) {
        a = Math.floor(a);
        if (!(0 > a)) {
            var c = this._cx
              , d = this._cy
              , e = this._cz
              , f = this._arr;
            if (0 === b)
                a >= c || (f.splice(a, 1),
                this._cx--);
            else if (1 === b) {
                if (!(a >= d)) {
                    for (d = 0; d < c; ++d)
                        f[d].splice(a, 1);
                    this._cy--
                }
            } else if (!(a >= e)) {
                for (b = 0; b < c; ++b)
                    for (e = 0; e < d; ++e)
                        f[b][e].splice(a, 1);
                this._cz--
            }
        }
    },
    Insert(a, b, c) {
        b = Math.floor(b);
        if (!(0 > b)) {
            var d = this._cx
              , e = this._cy
              , f = this._cz
              , h = this._arr;
            if (0 === c)
                b > d || (h.splice(b, 0, C3$jscomp$269.MakeFilledArray(e, () => C3$jscomp$269.MakeFilledArray(f, a))),
                this._cx++);
            else if (1 === c) {
                if (!(b > e)) {
                    for (e = 0; e < d; ++e)
                        h[e].splice(b, 0, C3$jscomp$269.MakeFilledArray(f, a));
                    this._cy++
                }
            } else if (!(b > f)) {
                for (c = 0; c < d; ++c)
                    for (let l = 0; l < e; ++l)
                        h[c][l].splice(b, 0, a);
                this._cz++
            }
        }
    },
    SplitString(a, b, c) {
        a = a.split(b);
        this.SetSize(a.length, 1, 1);
        for (let d = 0, e = a.length; d < e; ++d)
            b = a[d],
            0 === c ? String(Number(b)) === b && (b = Number(b)) : 2 === c && (b = Number(b)),
            this.Set(d, 0, 0, b)
    },
    JSONLoad(a) {
        let b = null;
        try {
            b = JSON.parse(a)
        } catch (c) {
            console.error("[Construct] Failed to parse JSON: ", c);
            return
        }
        b.c2array && (a = b.size,
        this._cx = a[0],
        this._cy = a[1],
        this._cz = a[2],
        this._arr = b.data)
    },
    JSONDownload(a) {
        const b = URL.createObjectURL(new Blob([this.GetAsJsonString()],{
            type: "application/json"
        }));
        this._runtime.InvokeDownload(b, a)
    }
};
self.C3.Plugins.Arr.Exps = {
    At(a, b, c) {
        return this.At(a, b || 0, c || 0)
    },
    Width() {
        return this._cx
    },
    Height() {
        return this._cy
    },
    Depth() {
        return this._cz
    },
    CurX() {
        return this._GetForX()
    },
    CurY() {
        return this._GetForY()
    },
    CurZ() {
        return this._GetForZ()
    },
    CurValue() {
        return this.At(this._GetForX(), this._GetForY(), this._GetForZ())
    },
    Front() {
        return this.At(0, 0, 0)
    },
    Back() {
        return this.At(this._cx - 1, 0, 0)
    },
    IndexOf(a) {
        const b = this._arr;
        for (let c = 0, d = this._cx; c < d; ++c)
            if (b[c][0][0] === a)
                return c;
        return -1
    },
    LastIndexOf(a) {
        const b = this._arr;
        for (let c = this._cx - 1; 0 <= c; --c)
            if (b[c][0][0] === a)
                return c;
        return -1
    },
    JoinString(a) {
        let b = [];
        for (let c = 0; c < this._cx; ++c)
            b.push(this.At(c, 0, 0));
        return b.join(a)
    },
    AsJSON() {
        return this.GetAsJsonString()
    }
};
"use strict";
const C3$jscomp$271 = self.C3;
C3$jscomp$271.Plugins.Json = class extends C3$jscomp$271.SDKPluginBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
}
;
const C3$jscomp$272 = self.C3;
C3$jscomp$272.Plugins.Json.Type = class extends C3$jscomp$272.SDKTypeBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
}
;
const C3$jscomp$273 = self.C3
  , C3X$jscomp$41 = self.C3X
  , IInstance$jscomp$5 = self.IInstance;
C3$jscomp$273.Plugins.Json.Instance = class extends C3$jscomp$273.SDKInstanceBase {
    constructor(a, b) {
        super(a);
        this._valueCache = [null, null];
        this._locationCache = [null, null];
        this._data = {};
        this._path = [];
        this._currentKey = "";
        this._currentValue = 0
    }
    Release() {
        super.Release()
    }
    _InvalidateValueCache() {
        this._valueCache[0] = null;
        this._valueCache[1] = null
    }
    _HasValueCache(a, b) {
        const c = this._valueCache[0];
        if (null === a || null === c)
            return !1;
        if (c === a || C3$jscomp$273.arraysEqual(c, a))
            return !0;
        if (b && 0 < c.length) {
            for (let d = 0, e = Math.min(a.length, c.length); d < e; ++d)
                if (a[d] !== c[d])
                    return !1;
            return !0
        }
        return !1
    }
    _GetValueCache() {
        return this._valueCache[1]
    }
    _UpdateValueCache(a, b) {
        this._valueCache[0] = a;
        this._valueCache[1] = b
    }
    _InvalidateLocationCache() {
        this._locationCache[0] = null;
        this._locationCache[1] = null
    }
    _HasLocationCache(a) {
        return this._locationCache[0] === a
    }
    _GetLocationCache() {
        return this._locationCache[1]
    }
    _UpdateLocationCache(a, b) {
        this._locationCache[0] = a;
        this._locationCache[1] = b
    }
    _SetData(a) {
        this._data = a;
        this._InvalidateValueCache();
        this._SetPath("")
    }
    _GetData() {
        return this._data
    }
    _SetPath(a) {
        this._path = this._ParsePathUnsafe(a);
        this._InvalidateLocationCache()
    }
    _ParsePath(a) {
        return C3$jscomp$273.cloneArray(this._ParsePathUnsafe(a))
    }
    _ParsePathUnsafe(a) {
        const b = [];
        let c = !1, d;
        if (this._HasLocationCache(a))
            return this._GetLocationCache();
        "." === a[0] ? (d = C3$jscomp$273.cloneArray(this._path),
        a = a.slice(1)) : d = [];
        for (const e of a)
            c ? (b.push(e),
            c = !1) : "\\" === e ? c = !0 : "." === e ? (d.push(b.join("")),
            C3$jscomp$273.clearArray(b)) : b.push(e);
        0 !== b.length && d.push(b.join(""));
        this._UpdateLocationCache(a, d);
        return d
    }
    _GetValueAtFullPath(a, b) {
        if (this._HasValueCache(a, !1))
            return this._GetValueCache();
        let c = this._data;
        for (const e of a)
            if (Array.isArray(c)) {
                var d = parseInt(e, 10);
                if (0 > d || d >= c.length || !isFinite(d)) {
                    c = null;
                    break
                }
                c = c[d]
            } else if ("object" === typeof c && null !== c)
                if (c.hasOwnProperty(e))
                    c = c[e];
                else if (b)
                    d = {},
                    c = c[e] = d;
                else {
                    c = null;
                    break
                }
            else {
                c = null;
                break
            }
        this._UpdateValueCache(a, c);
        return c
    }
    _GetValue(a) {
        var b = this._ParsePath(a);
        if (!b.length)
            return this._data;
        a = b.pop();
        b = this._GetValueAtFullPath(b, !1);
        return Array.isArray(b) ? (a = parseInt(a, 10),
        0 <= a && a < b.length ? b[a] : null) : "object" === typeof b && null !== b ? b.hasOwnProperty(a) ? b[a] : null : null
    }
    _JSONTypeOf(a) {
        return null === a ? "null" : Array.isArray(a) ? "array" : typeof a
    }
    _GetTypeOf(a) {
        a = this._GetValue(a);
        return this._JSONTypeOf(a)
    }
    _ToSafeValue(a) {
        const b = typeof a;
        return "number" === b || "string" === b ? a : "boolean" === b ? a ? 1 : 0 : 0
    }
    _GetSafeValue(a) {
        return this._ToSafeValue(this._GetValue(a))
    }
    _HasKey(a) {
        var b = this._ParsePath(a);
        if (!b.length)
            return !1;
        a = b.pop();
        b = this._GetValueAtFullPath(b, !1);
        return Array.isArray(b) ? (a = parseInt(a, 10),
        0 <= a && a < b.length) : "object" === typeof b && null !== b ? b.hasOwnProperty(a) : !1
    }
    _SetValue(a, b) {
        var c = this._ParsePath(a);
        if (!c.length)
            return !1;
        this._HasValueCache(c, !0) && this._InvalidateValueCache();
        a = c.pop();
        c = this._GetValueAtFullPath(c, !0);
        if (Array.isArray(c)) {
            a = parseInt(a, 10);
            if (!isFinite(a) || 0 > a || a >= c.length)
                return !1;
            c[a] = b;
            return !0
        }
        return "object" === typeof c && null !== c ? (c[a] = b,
        !0) : !1
    }
    _DeleteKey(a) {
        var b = this._ParsePath(a);
        if (!b.length)
            return !1;
        this._HasValueCache(b, !0) && this._InvalidateValueCache();
        a = b.pop();
        b = this._GetValueAtFullPath(b, !1);
        return Array.isArray(b) ? !1 : "object" === typeof b && null !== b ? (delete b[a],
        !0) : !1
    }
    SaveToJson() {
        return {
            path: this._path,
            data: this._data
        }
    }
    LoadFromJson(a) {
        this._InvalidateValueCache();
        this._InvalidateLocationCache();
        this._path = a.path;
        this._data = a.data
    }
    _SanitizeValue(a) {
        return "number" === typeof a ? isFinite(a) ? a : 0 : "object" == typeof a ? JSON.stringify(a) : a + ""
    }
    GetDebuggerProperties() {
        let a;
        try {
            a = this._SanitizeValue(this._data)
        } catch (b) {
            a = '"invalid"'
        }
        return [{
            title: "plugins.json.debugger.title",
            properties: [{
                name: "plugins.json.debugger.data",
                value: a,
                onedit: b => {
                    try {
                        const c = JSON.parse(b);
                        this._SetData(c)
                    } catch (c) {}
                }
            }, {
                name: "plugins.json.debugger.path",
                value: this._path.map(b => b.replace(/\./g, "\\.")).join(".")
            }]
        }]
    }
    GetScriptInterfaceClass() {
        return self.IJSONInstance
    }
}
;
const map$jscomp$29 = new WeakMap;
self.IJSONInstance = class extends IInstance$jscomp$5 {
    constructor() {
        super();
        map$jscomp$29.set(this, IInstance$jscomp$5._GetInitInst().GetSdkInstance())
    }
    getJsonDataCopy() {
        const a = map$jscomp$29.get(this)._GetData();
        return JSON.parse(JSON.stringify(a))
    }
    setJsonDataCopy(a) {
        try {
            const b = JSON.parse(JSON.stringify(a));
            map$jscomp$29.get(this)._SetData(b)
        } catch (b) {
            throw console.error("[JSON plugin] setJsonData: object is not valid JSON: ", b),
            b;
        }
    }
    setJsonString(a) {
        C3X$jscomp$41.RequireString(a);
        try {
            const b = JSON.parse(a);
            map$jscomp$29.get(this)._SetData(b)
        } catch (b) {
            throw console.error("[JSON plugin] setJsonString: string is not valid JSON: ", b),
            b;
        }
    }
    toCompactString() {
        return JSON.stringify(map$jscomp$29.get(this)._GetData())
    }
    toBeautifiedString() {
        return JSON.stringify(map$jscomp$29.get(this)._GetData(), null, 4)
    }
}
;
const C3$jscomp$274 = self.C3
  , JSON_TYPES = "null boolean number string object array".split(" ");
C3$jscomp$274.Plugins.Json.Cnds = {
    HasKey(a) {
        return this._HasKey(a)
    },
    CompareType(a, b) {
        return this._GetTypeOf(a) === JSON_TYPES[b]
    },
    CompareValue(a, b, c) {
        return C3$jscomp$274.compare(this._GetSafeValue(a), b, c)
    },
    IsBooleanSet(a) {
        return !0 === this._GetValue(a)
    },
    ForEach(a) {
        const b = this._GetValue(a);
        if ("object" !== typeof b || null === b)
            return !1;
        const c = this._runtime
          , d = c.GetEventSheetManager()
          , e = c.GetCurrentEvent()
          , f = e.GetSolModifiers()
          , h = c.GetEventStack()
          , l = h.GetCurrentStackFrame()
          , m = h.Push(e)
          , p = this._path
          , r = this._currentKey
          , v = this._currentValue;
        a = this._ParsePathUnsafe(a);
        c.SetDebuggingEnabled(!1);
        for (const [x,B] of Object.entries(b))
            this._path = C3$jscomp$274.cloneArray(a),
            this._path.push(x),
            this._currentKey = x,
            this._currentValue = B,
            d.PushCopySol(f),
            this.GetObjectClass().GetCurrentSol().PickOne(this.GetInstance()),
            e.Retrigger(l, m),
            d.PopSol(f);
        c.SetDebuggingEnabled(!0);
        this._path = p;
        this._InvalidateLocationCache();
        this._currentKey = r;
        this._currentValue = v;
        h.Pop();
        return !1
    },
    OnParseError() {
        return !0
    }
};
const C3$jscomp$275 = self.C3;
C3$jscomp$275.Plugins.Json.Acts = {
    Parse(a) {
        try {
            this._SetData(JSON.parse(a))
        } catch (b) {
            console.warn("[JSON plugin] Failed to parse JSON data: ", b),
            this._SetData({}),
            this.Trigger(C3$jscomp$275.Plugins.Json.Cnds.OnParseError)
        }
    },
    SetPath(a) {
        this._SetPath(a)
    },
    SetValue(a, b) {
        this._SetValue(a, b)
    },
    SetArray(a, b) {
        let c = this._GetValue(a);
        Array.isArray(c) ? C3$jscomp$275.resizeArray(c, b, 0) : (c = [],
        C3$jscomp$275.extendArray(c, b, 0),
        this._SetValue(a, c))
    },
    SetObject(a) {
        this._SetValue(a, {})
    },
    SetJSON(a, b) {
        let c = null;
        try {
            c = JSON.parse(b)
        } catch (d) {
            console.warn("[JSON plugin] Failed to parse JSON data: ", d),
            this.Trigger(C3$jscomp$275.Plugins.Json.Cnds.OnParseError)
        }
        this._SetValue(a, c)
    },
    SetNull(a) {
        this._SetValue(a, null)
    },
    SetBoolean(a, b) {
        this._SetValue(a, 0 !== b)
    },
    ToggleBoolean(a) {
        const b = this._GetValue(a);
        "boolean" === typeof b && this._SetValue(a, !b)
    },
    AddTo(a, b) {
        const c = this._GetValue(a);
        "number" === typeof c && this._SetValue(a, c + b)
    },
    SubtractFrom(a, b) {
        const c = this._GetValue(a);
        "number" === typeof c && this._SetValue(a, c - b)
    },
    DeleteKey(a) {
        this._DeleteKey(a)
    },
    PushValue(a, b, c) {
        b = this._GetValue(b);
        Array.isArray(b) && (0 === a ? b.push(c) : b.unshift(c),
        this._InvalidateValueCache())
    },
    PopValue(a, b) {
        b = this._GetValue(b);
        Array.isArray(b) && (0 === a ? b.pop() : b.shift(),
        this._InvalidateValueCache())
    },
    InsertValue(a, b, c) {
        b = this._GetValue(b);
        Array.isArray(b) && (b.splice(c, 0, a),
        this._InvalidateValueCache())
    },
    RemoveValues(a, b, c) {
        b = this._GetValue(b);
        Array.isArray(b) && 0 < a && (b.splice(c, a),
        this._InvalidateValueCache())
    }
};
self.C3.Plugins.Json.Exps = {
    ToCompactString() {
        try {
            return JSON.stringify(this._data)
        } catch (a) {
            return ""
        }
    },
    ToBeautifiedString() {
        try {
            return JSON.stringify(this._data, null, 4)
        } catch (a) {
            return ""
        }
    },
    Get(a) {
        return this._GetSafeValue(a)
    },
    GetAsCompactString(a) {
        a = this._GetValue(a);
        return JSON.stringify(a)
    },
    GetAsBeautifiedString(a) {
        a = this._GetValue(a);
        return JSON.stringify(a, null, 4)
    },
    Front(a) {
        a = this._GetValue(a);
        return Array.isArray(a) ? this._ToSafeValue(a[0]) : -1
    },
    Back(a) {
        a = this._GetValue(a);
        return Array.isArray(a) ? (a = a.at(-1),
        this._ToSafeValue(a)) : -1
    },
    Type(a) {
        return this._GetTypeOf(a)
    },
    ArraySize(a) {
        a = this._GetValue(a);
        return Array.isArray(a) ? a.length : -1
    },
    Path() {
        return this._path.map(a => a.replace(/\./g, "\\.")).join(".")
    },
    CurrentKey() {
        return this._currentKey
    },
    CurrentValue() {
        return this._ToSafeValue(this._currentValue)
    },
    CurrentType() {
        return this._JSONTypeOf(this._currentValue)
    }
};
"use strict";
const C3$jscomp$277 = self.C3;
C3$jscomp$277.Plugins.Gritsenko_Spine = class extends C3$jscomp$277.SDKPluginBase {
    constructor(a) {
        super(a, "gritsenko-spine")
    }
    Release() {
        super.Release()
    }
}
;
"use strict";
const C3$jscomp$278 = self.C3;
C3$jscomp$278.Plugins.Gritsenko_Spine.Type = class extends C3$jscomp$278.SDKTypeBase {
    constructor(a) {
        super(a)
    }
    Release() {
        console.warn("[Spine] type.Release", this.GetObjectClass().GetName(), this._runtime.GetTickCount());
        super.Release()
    }
    OnCreate() {
        this.GetImageInfo().LoadAsset(this._runtime);
        this._skeletonDataInitializing = this._skeletonDataInitialized = !1;
        this._assetTag = this._skeletonJson = null;
        this._skeletonInstances = {};
        this._rendered = !1;
        this._tickCount = -1;
        this._assetPaths = {};
        this._initFailed = !1;
        this._initOwner = -1;
        this._skeletonRenderQuality = 1
    }
    LoadTextures(a) {
        return this.GetImageInfo().LoadStaticTexture(a, {
            linearSampling: this._runtime.IsLinearSampling()
        })
    }
    ReleaseTextures() {
        this.GetImageInfo().ReleaseTexture()
    }
}
;
"use strict";
const C3$jscomp$279 = self.C3
  , spineBatcher = globalThis.spineBatcher
  , spine$jscomp$1 = globalThis.spine;
C3$jscomp$279.Plugins.Gritsenko_Spine.Instance = class extends C3$jscomp$279.SDKWorldInstanceBase {
    constructor(a, b) {
        super(a);
        this.paletteNumber = 64;
        this.indexSize = 32;
        this.palette = null;
        this.data = {};
        this.currentKey = "";
        this.currentValue = 0;
        this.bgColor = this.canvas = null;
        this.isPlaying = !0;
        this.instance = a;
        this.gl = this.renderer = this.skeletonInfo = null;
        this.uid = this.GetInstance().GetUID();
        this.customSkins = {};
        this.slotColors = {};
        this.slotDarkColors = {};
        this.isLoaded = !1;
        this.animateOnce = .1;
        this.trackAnimations = {};
        this.skinNames = [];
        this.delayedTrackListeners = [];
        this.sdkType = this.GetSdkType();
        this.atlasPath = this.pngPath = this.jsonPath = "";
        this.objectName = this.GetInstance().GetObjectClass().GetName();
        b && (this.jsonPath = b[0],
        this.atlasPath = b[1],
        this.pngPath = b[2],
        this.skinName = b[3],
        this.animationName = b[4],
        this.skeletonName = b[5],
        this.skeletonScale = b[6],
        this.premultipliedAlpha = b[7],
        this.collisionsEnabled = b[8],
        this.defaultMix = b[9],
        this.skeletonRenderQuality = b[10],
        this.keepAspectRatio = b[11],
        this.debug = b[12],
        this.bboxOverride = b[13],
        this.bboxOffsetX = b[14],
        this.bboxOffsetY = b[15],
        this.bboxSizeX = b[16],
        this.bboxSizeY = b[17]);
        this.isMirrored = !1;
        this._elementTexture = null;
        this.pngURI = "";
        this.atlasURI = "*init-atlas-uri*";
        this.initOwnerId = this.uid + Math.random();
        this.debug && console.log("[Spine] instance constructor, uid", this.initOwnerId);
        this.jsonURI = "";
        this.c3renderer = null;
        this.runtime = a.GetRuntime();
        this.c3wgl = this.runtime.GetCanvasManager().GetWebGLRenderer();
        this.canvas = this.c3wgl._gl.canvas;
        this.spineFB = null;
        this.initSpineInProgress = !1;
        this.completeAnimationName = "";
        this.spineError = null;
        this.animationSpeed = 1;
        this.completeEventName = "";
        this.textureHeight = this.textureWidth = 0;
        this.completeEventData = {};
        this.GetWorldInfo().SetCollisionEnabled(this.collisionsEnabled);
        this._StartTicking();
        this.OnWebGLContextRestored = function() {
            this.debug && console.warn("[Spine] Context restored.")
        }
        ;
        this.OnWebGLContextLost = function() {
            console.warn("[Spine] Context lost.");
            globalThis.spineBatcher.debugVariables.animationDisable = "enable";
            globalThis.spineBatcher.debugVariables.renderDisable = "enable";
            this.Trigger(C3$jscomp$279.Plugins.Gritsenko_Spine.Cnds.OnWebGLContextLost)
        }
        ;
        this.OnWebGLContextRestored = function() {
            console.warn("[Spine] Context Restored.");
            globalThis.spineBatcher.debugVariables.animationDisable = "enable";
            globalThis.spineBatcher.debugVariables.renderDisable = "enable";
            this.Trigger(C3$jscomp$279.Plugins.Gritsenko_Spine.Cnds.OnWebGLContextRestored)
        }
    }
    initInstance() {
        this.initSpineInProgress = !0;
        this.mvp = new spine$jscomp$1.Matrix4;
        this.mvp.ortho2d(0, 0, 0, 0);
        this.gl = this.runtime.GetWebGLRenderer()._gl;
        this.canvas = this.gl._canvas
    }
    async initTexturesBatcher() {
        this.sdkType._texturesBatcherInitializing = !0;
        spineBatcher.init(this.canvas, this.runtime);
        this.runtime.IsPreview() || this.runtime._assetManager._isCordova ? await this.loadSkeletonTextures() : this.loadSkeletonTextures()
    }
    resize() {
        var a = this.skeletonInfo.bounds
          , b = a.offset.x + a.size.x / 2
          , c = a.offset.y + a.size.y / 2
          , d = 1 / this.skeletonScale * Math.max(a.size.x / a.size.x, a.size.y / a.size.y);
        1 > d && (d = 1);
        var e = a.size.x * d;
        a = a.size.y * d;
        this.mvp.ortho2d(b - e / 2, c - a / 2, e, a)
    }
    async loadSkeletonTextures() {
        var a = new spine$jscomp$1.ManagedWebGLRenderingContext(this.gl);
        this.sdkType._assetManager = new spine$jscomp$1.AssetManager(a);
        a = this.sdkType._assetManager;
        this.debug && console.info(this.GetInstance().GetUID(), "[Spine] Loading skeleton, textures, json, atlas");
        spine$jscomp$1.GLTexture.DISABLE_UNPACK_PREMULTIPLIED_ALPHA_WEBGL = !0;
        this.runtime.IsPreview() || this.runtime._assetManager._isCordova ? (this.atlasURI = "*await-atlas-path*",
        this.atlasURI = await this.runtime._assetManager.GetProjectFileUrl(this.atlasPath),
        this.jsonURI = await this.runtime._assetManager.GetProjectFileUrl(this.jsonPath)) : (this.atlasURI = this.atlasPath,
        this.jsonURI = this.jsonPath,
        this.debug && console.info("[Spine] loadSkeletonTextures, atlasURI, not preview", this.atlasURI, this.atlasPath, this.uid, this.objectName, this.runtime.GetTickCount()));
        if (this.sdkType) {
            this.sdkType._assetPaths[this.atlasURI] = this.atlasURI;
            this.sdkType._assetPaths[this.atlasPath] = this.atlasURI;
            this.sdkType._assetPaths[this.jsonURI] = this.jsonURI;
            this.sdkType._assetPaths[this.jsonPath] = this.jsonURI;
            this.sdkType._jsonURI = this.jsonURI;
            a.loadText(this.jsonURI);
            var b = this.pngPath.split(",");
            for (let c = 0; c < b.length; c++) {
                this.pngURI = await this.runtime._assetManager.GetProjectFileUrl(b[c]);
                !this.pngURI && this.debug && alert("[Spine] png path not found:" + b[c]);
                if (!this.sdkType) {
                    console.warn("[Spine] loadSkeletonTextures, sdkType not defined", this.uid);
                    this.runtime && this.runtime.DestroyInstance(this.GetInstance());
                    return
                }
                this.sdkType._assetPaths[b[c]] = this.pngURI
            }
            this.sdkType ? (a.loadTextureAtlas(this.atlasURI, null, null, this.sdkType._assetPaths),
            a.loadText(this.atlasURI),
            this.sdkType._texturesBatcherInitialized = !0,
            this.sdkType._texturesBatcherInitializing = !1,
            this.debug && console.info("[Spine] loadSkeletonTextures, atlasURI", this.atlasURI, this.atlasPath, this.uid, this.objectName, this.runtime.GetTickCount())) : (console.warn("[Spine] loadSkeletonTextures, sdkType not defined", this.uid),
            this.runtime && this.runtime.DestroyInstance(this.GetInstance()))
        } else
            console.warn("[Spine] loadSkeletonTextures, sdkType not defined", this.uid),
            this.runtime && this.runtime.DestroyInstance(this.GetInstance())
    }
    loadSkeletonData() {
        this.debug && console.info("[Spine] loadSkeletonData, atlasURI", this.atlasURI, this.atlasPath, this.uid, this.objectName, this.sdkType._texturesBatcherInitialized, this.runtime.GetTickCount());
        const a = this.sdkType._assetManager
          , b = a.get(this.atlasURI);
        void 0 === b || null === b ? (console.warn("[Spine] loadSkeletonData, atlasURI not set", b, this.uid, this.atlasURI, a.isLoadingComplete(), this.atlasPath, this.runtime.GetTickCount()),
        console.warn("[Spine] objectclass", this.objectName, this.sdkType, this.uid, this.runtime.GetTickCount()),
        globalThis.Sentry && globalThis.Sentry.captureException("[Spine] loadSkeletonData, atlasURI not set, object:" + this.objectName),
        this.sdkType._initFailed = !0) : (this.sdkType._atlas = a.get(this.atlasURI),
        this.sdkType._skeletonJson = new spine$jscomp$1.SkeletonJson(new spine$jscomp$1.AtlasAttachmentLoader(this.sdkType._atlas)),
        this.sdkType._skeletonJson.scale = this.skeletonRenderQuality,
        this.sdkType._skeletonRenderQuality = this.skeletonRenderQuality,
        this.sdkType._skeletonData = this.sdkType._skeletonJson.readSkeletonData(a.get(this.jsonURI)),
        this.sdkType._skeletonDataInitialized = !0,
        this.sdkType._skeletonDataInitializing = !1)
    }
    loadSkeletons() {
        this.skeletonInfo = this.loadSkeleton(this.skeletonName, this.animationName);
        this.skeletonInfo.premultipliedAlpha = this.premultipliedAlpha;
        this.skinNames = this.skeletonInfo.skeleton.data.skins.map(a => a.name);
        this.animationNames = this.skeletonInfo.skeleton.data.animations.map(a => a.name);
        this.resize();
        spineBatcher.addInstance(this.skeletonInfo, this.skeletonScale, this.GetInstance().GetUID());
        this.spineBoneControl = new SpineBoneControl(this.debug)
    }
    loadSkeleton(a, b, c) {
        this.debug && console.info("[Spine] Reading skeleton data:", this.uid, this.sdkType.GetObjectClass().GetName(), b);
        a = new spine$jscomp$1.Skeleton(this.sdkType._skeletonData);
        this.skinName ? (c = a.data.findSkin(this.skinName),
        c || (c = a.data.defaultSkin)) : c = a.data.defaultSkin;
        a.setSkin(c);
        c = new spine$jscomp$1.AnimationStateData(this.sdkType._skeletonData);
        c.defaultMix = this.defaultMix;
        var d = new spine$jscomp$1.AnimationState(c);
        d.setAnimation(0, b, !0);
        this.trackAnimations[0] = this.animationName;
        d.tracks[0].listener = {
            complete: (h, l) => {
                this.completeAnimationName = h.animation.name;
                this.completeTrackIndex = h.trackIndex;
                this.Trigger(C3$jscomp$279.Plugins.Gritsenko_Spine.Cnds.OnAnimationFinished);
                this.Trigger(C3$jscomp$279.Plugins.Gritsenko_Spine.Cnds.OnAnyAnimationFinished)
            }
            ,
            event: (h, l) => {
                this.completeEventName = l.data.name;
                this.completeEventTrackIndex = h.trackIndex;
                this.completeEventData = {
                    "float": l.floatValue,
                    "int": l.intValue,
                    string: l.stringValue,
                    balance: l.balance,
                    volume: l.volume,
                    audiopath: l.data.audioPath,
                    event: l.data.name,
                    track: h.trackIndex
                };
                this.Trigger(C3$jscomp$279.Plugins.Gritsenko_Spine.Cnds.OnEvent);
                this.Trigger(C3$jscomp$279.Plugins.Gritsenko_Spine.Cnds.OnAnyEvent)
            }
        };
        d.apply(a);
        a.updateWorldTransform();
        b = new spine$jscomp$1.Vector2;
        var e = new spine$jscomp$1.Vector2;
        a.getBounds(b, e, []);
        var f = new spine$jscomp$1.SkeletonBounds;
        this.keepAspectRatio && (e = this.GetWorldInfo(),
        b = {
            x: b.x - e._w / 2,
            y: b.y
        },
        e = {
            x: e._w,
            y: e._h
        });
        this.bboxOverride && (e = this.sdkType._skeletonRenderQuality,
        b = {
            x: this.bboxOffsetX * e,
            y: this.bboxOffsetY * e
        },
        e = {
            x: this.bboxSizeX * e,
            y: this.bboxSizeY * e
        });
        return {
            atlas: this.sdkType._atlas,
            skeleton: a,
            state: d,
            playTime: 0,
            bounds: {
                offset: b,
                size: e
            },
            atlasLoader: this.sdkType._atlasLoader,
            skeletonBounds: f,
            stateData: c,
            palette: this.palette
        }
    }
    createInstanceTexture() {
        var a = this.runtime.GetWebGLRenderer();
        const b = this.gl;
        this.c3renderer = a;
        var c = this.skeletonInfo.bounds;
        this.textureWidth = c.size.x;
        this.textureHeight = c.size.y;
        c = {
            mipMap: !1,
            sampling: this.runtime.GetSampling()
        };
        this.debug && console.info("[Spine] CreateDynamicTexture x,y:", Math.round(this.textureWidth), Math.round(this.textureHeight), this.uid, this.runtime.GetTickCount());
        this._elementTexture = a.CreateDynamicTexture(this.textureWidth, this.textureHeight, c);
        a = b.getParameter(b.FRAMEBUFFER_BINDING);
        this.spineFB = b.createFramebuffer();
        b.bindFramebuffer(b.FRAMEBUFFER, this.spineFB);
        b.framebufferTexture2D(b.FRAMEBUFFER, b.COLOR_ATTACHMENT0, b.TEXTURE_2D, this._elementTexture._texture, 0);
        b.bindFramebuffer(b.FRAMEBUFFER, a);
        spineBatcher.setInstanceFB(this.spineFB, this.GetInstance().GetUID())
    }
    updateCurrentSkin() {
        const a = this.skeletonInfo.skeleton;
        let b = [];
        if (-1 < this.skinName.indexOf(",")) {
            b = this.skinName.split(",");
            const c = new spine$jscomp$1.Skin("compound-skin");
            b.forEach(d => {
                d = a.data.findSkin(d);
                c.addSkin(d)
            }
            );
            a.setSkin(c)
        } else
            b.push(this.skinName),
            a.setSkinByName(this.skinName);
        a.setSlotsToSetupPose()
    }
    updateBounds() {
        const a = this.skeletonInfo.skeleton;
        this.skeletonInfo.state.apply(a);
        a.updateWorldTransform();
        var b = new spine$jscomp$1.Vector2
          , c = new spine$jscomp$1.Vector2;
        a.getBounds(b, c, []);
        this.skeletonInfo.bounds = {
            offset: b,
            size: c
        }
    }
    updateCurrentAnimation(a, b, c, d) {
        if (this.skeletonInfo && this.skeletonInfo.skeleton && this.animationNames)
            if (this.animationNames.includes(d))
                try {
                    const e = this.skeletonInfo.state
                      , f = e.tracks[c];
                    let h = 0
                      , l = 0;
                    f && (h = f.trackTime,
                    f.animationEnd != f.animationStart && f.animationEnd > f.animationStart && (l = (f.animationLast + f.trackTime - f.trackLast) / (f.animationEnd - f.animationStart)));
                    e.setAnimation(c, d, a);
                    switch (b) {
                    case 1:
                        e.tracks[c].trackTime = h;
                        break;
                    case 2:
                        e.tracks[c].trackTime = l * (e.tracks[c].animationEnd - e.tracks[c].animationStart)
                    }
                    this.trackAnimations[c] = this.animationName;
                    0 == b || 2 == b && 0 == l ? this.setTrackListeners(e, c) : this.delayedTrackListeners.push(c)
                } catch (e) {
                    this.debug && console.error("[Spine] setAnimation error", e, c, d),
                    this.spineError = "setAnimation error " + e,
                    this.Trigger(C3$jscomp$279.Plugins.Gritsenko_Spine.Cnds.OnError)
                }
            else
                this.debug && console.warn("[Spine] updateCurrentAnimation, animation does not exist.", d, this.uid)
    }
    setTrackListeners(a, b) {
        a && a.tracks && a.tracks[b] ? a.tracks[b].listener = {
            complete: (c, d) => {
                this.completeAnimationName = c.animation.name;
                this.completeTrackIndex = c.trackIndex;
                this.Trigger(C3$jscomp$279.Plugins.Gritsenko_Spine.Cnds.OnAnimationFinished);
                this.Trigger(C3$jscomp$279.Plugins.Gritsenko_Spine.Cnds.OnAnyAnimationFinished)
            }
            ,
            event: (c, d) => {
                this.completeEventName = d.data.name;
                this.completeEventTrackIndex = c.trackIndex;
                this.completeEventData = {
                    "float": d.floatValue,
                    "int": d.intValue,
                    string: d.stringValue,
                    balance: d.balance,
                    volume: d.volume,
                    audiopath: d.data.audioPath,
                    event: d.data.name,
                    track: c.trackIndex
                };
                this.Trigger(C3$jscomp$279.Plugins.Gritsenko_Spine.Cnds.OnEvent);
                this.Trigger(C3$jscomp$279.Plugins.Gritsenko_Spine.Cnds.OnAnyEvent)
            }
        } : this.debug && console.warn("[Spine] setTrackListners invalid", a, b)
    }
    playAnimation() {
        this.isPlaying = !0
    }
    stopAnimation() {
        this.isPlaying = !1
    }
    async IsSpineReady() {
        if (this.sdkType._initFailed)
            return !1;
        if (null === this.sdkType || void 0 === this.sdkType)
            return this.debug && console.warn("[Spine] IsSpineReady, sdkType not defined", this.sdkType),
            globalThis.Sentry && globalThis.Sentry.captureException("[Spine] IsSpineReady, sdkType not defined:" + this.sdkType),
            this.sdkType._initFailed = !0,
            !1;
        if ("" === this.jsonPath)
            return !1;
        if (this.isLoaded)
            return !0;
        this.initInstanceInitialized || this.initInstance();
        -1 == this.sdkType._initOwner && (this.sdkType._initOwner = this.initOwnerId,
        this.debug && console.info("[Spine] IsSpineReady, initOwner", this.sdkType._initOwner, this.objectName, this.runtime.GetTickCount()));
        if (!this.sdkType._texturesBatcherInitialized)
            return this.sdkType._texturesBatcherInitializing || this.sdkType._initOwner != this.initOwnerId || (this.sdkType._texturesBatcherInitializing = !0,
            this.runtime.IsPreview() || this.runtime._assetManager._isCordova ? await this.initTexturesBatcher() : this.initTexturesBatcher()),
            !1;
        if (!this.sdkType._assetManager.isLoadingComplete() && this.sdkType._initOwner == this.initOwnerId)
            return !1;
        if (!this.sdkType._skeletonDataInitialized)
            return this.sdkType._skeletonDataInitializing || this.sdkType._initOwner != this.initOwnerId || (this.sdkType._skeletonDataInitializing = !0,
            this.loadSkeletonData()),
            !1;
        this.loadSkeletons();
        this.createInstanceTexture();
        this.palette = new globalThis.SpinePalette(this.indexSize,this.paletteNumber);
        this.palette.createPaletteTexture(this.c3renderer);
        for (let a = 0; a < this.paletteNumber; a++)
            this.palette.setDefaultColors(a, (this.paletteNumber - a) / this.paletteNumber, 1);
        spineBatcher.setInstancePalette(this.palette, this.uid);
        this.palette.uploadNeeded = !0;
        spineBatcher.setInstanceInitialized(this.GetInstance().GetUID());
        this.isLoaded = !0;
        this.Trigger(C3$jscomp$279.Plugins.Gritsenko_Spine.Cnds.OnSkeletonLoaded)
    }
    Release() {
        this.data = this.currentValue = this.currentKey = null;
        spineBatcher.removeInstance(this.GetInstance().GetUID());
        super.Release();
        this.c3renderer && this._elementTexture && this.c3renderer.DeleteTexture(this._elementTexture);
        this.sdkType = this.palette = this.indexSize = this.paletteNumber = this.spineBoneControl = this.slotDarkColors = this.slotColors = this.customSkins = this.uid = this.textureHeight = this.textureWidth = this.skeletonRenderQuality = this.completeEventData = this.completeEventName = this.animationSpeed = this.spineError = this.completeAnimationName = this.initSpineInProgress = this.spineFB = this.canvas = this.c3wgl = this.c3renderer = this.jsonURI = this.atlasURI = this.pngURI = this._elementTexture = this.isMirrored = this.defaultMix = this.collisionsEnabled = this.premultipliedAlpha = this.skeletonScale = this.skeletonName = this.animationName = this.skinName = this.pngPath = this.atlasPath = this.jsonPath = this.gl = this.renderer = this.skeletonInfo = this.isPlaying = this.bgColor = this.canvas = null
    }
    Tick() {
        this.IsSpineReady();
        if (this.isLoaded) {
            var a = this.runtime.GetDt() * this.animationSpeed
              , b = this.skeletonInfo
              , c = this.skeletonInfo.state;
            this.skeletonInfo.skeleton.sequenceActive && this.runtime.UpdateRender();
            var d = this.GetWorldInfo()
              , e = d.GetLayer().GetViewport();
            d = d.GetBoundingBox().intersectsRect(e);
            spineBatcher.setInstanceOnScreen(d, this.uid);
            this.isPlaying ? spineBatcher.setInstanceAnimationStop(!1, this.uid) : spineBatcher.setInstanceAnimationStop(!0, this.uid);
            var f = !0;
            c.tracks.forEach(h => {
                !h || !h.loop && h.isComplete() || (f = !1)
            }
            );
            f = f || !this.isPlaying;
            spineBatcher.setInstanceTracksComplete(f, this.uid);
            d = this.isPlaying || 0 < this.animateOnce;
            e = 0 < this.animateOnce || !f && this.isPlaying;
            if (("enable" === spineBatcher.debugVariables.animationReduce ? e : d) && "enable" !== spineBatcher.debugVariables.animationDisable) {
                d = c.getCurrent(0).animation.duration;
                b.playTime += a;
                if (0 < d)
                    for (; b.playTime >= d; )
                        b.playTime -= d;
                c.update(a);
                c.apply(b.skeleton);
                if (0 < this.delayedTrackListeners.length) {
                    for (const h of this.delayedTrackListeners)
                        this.setTrackListeners(c, h);
                    this.delayedTrackListeners.splice(0, this.setTrackListeners.length)
                }
                this.spineBoneControl.applyBoneControl(b.skeleton);
                b.skeleton.updateWorldTransform();
                this.runtime.UpdateRender();
                0 < this.animateOnce && (this.animateOnce -= a,
                0 >= this.animateOnce && this.SetRenderOnce(0, !1, this.uid))
            }
        }
    }
    SetRenderOnce(a, b, c) {
        a > this.animateOnce && (this.animateOnce = a);
        spineBatcher.setInstanceRenderOnce(b, c)
    }
    Draw(a) {
        if (this.isLoaded) {
            var b = this.GetWorldInfo()
              , c = b.GetBoundingQuad();
            spineBatcher.tickCount != this.runtime.GetTickCount() && (spineBatcher.tickCount = this.runtime.GetTickCount(),
            spineBatcher.drawBatch());
            var d = 0
              , e = 1;
            this.isMirrored && (d = 1,
            e = 0);
            d = new C3$jscomp$279.Rect(d,1,e,0);
            a.SetTexture(this._elementTexture);
            if (this.runtime.IsPixelRoundingEnabled()) {
                e = new C3$jscomp$279.Quad;
                const f = Math.round(b.GetX()) - b.GetX();
                b = Math.round(b.GetY()) - b.GetY();
                e.copy(c);
                e.offset(f, b);
                a.Quad3(e, d)
            } else
                a.Quad3(c, d)
        }
    }
    SaveToJson() {
        return {}
    }
    LoadFromJson(a) {}
    GetDebuggerProperties() {
        return [{
            title: "Spine",
            properties: []
        }]
    }
    GetValuePath(a, b) {
        let c = this.data;
        for (const d of a)
            if ("object" === typeof c && null !== c)
                if (c.hasOwnProperty(d))
                    c = c[d];
                else if (b)
                    a = {},
                    c = c[d] = a;
                else {
                    c = null;
                    break
                }
        return c
    }
    SetValuePath(a, b) {
        let c = b.pop();
        if ("" === c || null === c)
            return !1;
        b = this.GetValuePath(b, !0);
        return "object" === typeof b && null !== b ? (b[c] = a,
        !0) : !1
    }
    GetScriptInterfaceClass() {
        return self.ISpineInstance
    }
    _getData() {
        return this.data
    }
    _setAnimation(a, b, c, d) {
        this.skeletonInfo && this.skeletonInfo.skeleton ? (this.animationName = a,
        this.updateCurrentAnimation(b, c, d, a),
        this.SetRenderOnce(1, !0, this.uid)) : this.debug && console.warn("[Spine] SetAnimation, no skeleton.", a, b, c, d, this.uid, this.runtime.GetTickCount())
    }
    _setAnimationTime(a, b, c) {
        if (this.skeletonInfo && this.skeletonInfo.state) {
            var d = this.skeletonInfo.state;
            if (d && d.tracks && (d = d.tracks[c])) {
                if (0 == a) {
                    if (b < d.animationStart || b > d.animationEnd) {
                        this.debug && console.warn("[Spine] SetAnimationTime time out of bounds:", a, b, c, this.uid, this.runtime.GetTickCount());
                        return
                    }
                    d.trackTime = b
                } else {
                    if (0 > b || 1 < b) {
                        this.debug && console.warn("[Spine] SetAnimationTime ratio out of bounds:", a, b, c, this.uid, this.runtime.GetTickCount());
                        return
                    }
                    d.trackTime = b * (d.animationEnd - d.animationStart)
                }
                this.SetRenderOnce(1, !0, this.uid)
            }
        } else
            this.debug && console.warn("[Spine] SetAninationTime, no state.", a, b, c, this.uid, this.runtime.GetTickCount())
    }
    _setAnimationSpeed(a) {
        this.animationSpeed = a
    }
    _currentAnimation(a) {
        if (!this.isLoaded)
            return "";
        const b = this.skeletonInfo.state;
        return b && b.tracks ? (a = b.tracks[a]) ? a.animation.name : "" : ""
    }
    _setAnimationMix(a, b, c) {
        if (this.skeletonInfo && this.skeletonInfo.stateData) {
            var d = this.skeletonInfo.stateData;
            try {
                d.setMix(a, b, c)
            } catch (e) {
                console.error("[Spine] SetAnimationMix:", e)
            }
        } else
            this.debug && console.warn("[Spine] SetAnimationMix, no stateData.", a, b, c, this.uid, this.runtime.GetTickCount())
    }
    _deleteAnimation(a, b) {
        if (this.skeletonInfo && this.skeletonInfo.skeleton) {
            var c = this.skeletonInfo.state;
            c && c.tracks && c.tracks[a] && (c.setEmptyAnimation(a, b),
            this.SetRenderOnce(1, !0, this.uid))
        } else
            this.debug && console.warn("[Spine] DeleteAnimation, no skelton.", a, b, this.uid, this.runtime.GetTickCount())
    }
    _addCustomSkinOutfit(a, b, c, d, e, f) {
        const h = globalThis.spine;
        if (this.skeletonInfo && this.skeletonInfo.skeleton) {
            var l = this.skeletonInfo.skeleton;
            this.customSkins[a] ? this.customSkins[a].clear() : this.customSkins[a] = new h.Skin(a);
            var m = {};
            c.forEach(p => {
                let r = b[p];
                r?.override?.skinName && (r = r.override);
                if ("" != r.skinName) {
                    var v = l.findSlot(p);
                    if (v) {
                        var x = p + "/" + r.skinName
                          , B = l.data.findSkin(x);
                        if (B) {
                            m[p] = r.skinName;
                            this.customSkins[a].addSkin(B);
                            if (d[p])
                                for (const A of d[p])
                                    m[A] = r.skinName,
                                    x = A + "/" + r.skinName,
                                    (B = l.data.findSkin(x)) ? this.customSkins[a].addSkin(B) : this.debug && console.warn("[Spine] AddCustomSkin, add skin does not exist", a, x, this.uid, this.runtime.GetTickCount());
                            this.slotColors[p] = this._swap32(r.tintColor);
                            this.slotDarkColors[p] = this._swap32(r.tintDarkColor);
                            h.Color.rgba8888ToColor(v.color, r.tintColor);
                            v.darkColor && h.Color.rgba8888ToColor(v.darkColor, r.tintDarkColor);
                            if (e[p])
                                for (const A of e[p])
                                    m[A] = r.skinName,
                                    p = l.findSlot(A),
                                    this.slotColors[A] = this._swap32(r.tintColor),
                                    this.slotDarkColors[A] = this._swap32(r.tintDarkColor),
                                    h.Color.rgba8888ToColor(p.color, r.tintColor),
                                    p.darkColor && h.Color.rgba8888ToColor(p.darkColor, r.tintDarkColor)
                        } else
                            this.debug && console.warn("[Spine] AddCustomSkin, add skin does not exist", a, x, this.uid, this.runtime.GetTickCount())
                    }
                }
            }
            );
            c.forEach(p => {
                if (f[p]) {
                    let r = b[p];
                    for (const v of f[p])
                        m[v] && "0" !== m[v] || (p = l.findSlot(v),
                        this.slotColors[v] = this._swap32(r.tintColor),
                        this.slotDarkColors[v] = this._swap32(r.tintDarkColor),
                        h.Color.rgba8888ToColor(p.color, r.tintColor),
                        p.darkColor && h.Color.rgba8888ToColor(p.darkColor, r.tintDarkColor))
                }
            }
            );
            this.SetRenderOnce(1, !0, this.uid)
        } else
            this.debug && console.warn("[Spine] AddCustomSkin, skeleton is not available", a, b, this.uid, this.runtime.GetTickCount())
    }
    _swap32(a) {
        return ((a & 255) << 24 | (a & 65280) << 8 | a >>> 8 & 65280 | a >>> 24 & 255) >>> 0
    }
    _hexToC3RGBAColorValue(a) {
        7 == a.length && (a += "ff");
        return this._swap32(parseInt(a.substr(1), 16))
    }
    _hexToRGBA(a) {
        return (a = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(a)) ? {
            r: parseInt(a[1], 16) / 255,
            g: parseInt(a[2], 16) / 255,
            b: parseInt(a[3], 16) / 255,
            a: parseInt(a[4], 16) / 255
        } : {
            r: 0,
            g: 0,
            b: 0,
            a: 0
        }
    }
    _applySlotColors() {
        if (this.skeletonInfo && this.skeletonInfo.skeleton) {
            var a = this.skeletonInfo.skeleton, b;
            for (b in this.slotColors) {
                var c = a.findSlot(b);
                if (null === c)
                    console.warn("[Spine] ApplySlotColors, slot not found: ", b, this.uid, this.runtime.GetTickCount());
                else {
                    var d = this.slotColors[b];
                    "string" == typeof d ? (7 == d.length && (d += "ff"),
                    d = this._hexToRGBA(d),
                    c.color.set(d.r, d.g, d.b, d.a)) : c.color.set(spineBatcher.getRValue(d), spineBatcher.getGValue(d), spineBatcher.getBValue(d), spineBatcher.getAValue(d))
                }
            }
            for (b in this.slotDarkColors)
                c = a.findSlot(b),
                null === c ? console.warn("[Spine] ApplySlotColors dark color, slot not found: ", b, this.uid, this.runtime.GetTickCount()) : c.darkColor && (d = this.slotDarkColors[b],
                "string" == typeof d ? (7 == d.length && (d += "ff"),
                d = this._hexToRGBA(d),
                c.darkColor.set(d.r, d.g, d.b, d.a)) : c.darkColor.set(spineBatcher.getRValue(d), spineBatcher.getGValue(d), spineBatcher.getBValue(d), spineBatcher.getAValue(d)));
            this.SetRenderOnce(1, !0, this.uid)
        } else
            this.debug && console.warn("[Spine] ApplySlotColors, no skeleton.", this.uid, this.runtime.GetTickCount())
    }
    _animationEnd(a) {
        if (!this.isLoaded)
            return 0;
        const b = this.skeletonInfo.state;
        return b && b.tracks ? (a = b.tracks[a]) ? a.animationEnd : 0 : 0
    }
    _animationStart(a) {
        if (!this.isLoaded)
            return 0;
        const b = this.skeletonInfo.state;
        return b && b.tracks ? (a = b.tracks[a]) ? a.animationStart : 0 : 0
    }
    _animationLength(a) {
        if (!this.isLoaded)
            return 0;
        const b = this.skeletonInfo.state;
        return b && b.tracks ? (a = b.tracks[a]) ? a.animationEnd - a.animationStart : 0 : 0
    }
    _addCustomSkin(a, b) {
        if (this.skeletonInfo && this.skeletonInfo.skeleton) {
            var c = this.skeletonInfo.skeleton;
            this.customSkins[a] ? (c = c.data.findSkin(b)) ? this.customSkins[a].addSkin(c) : this.debug && console.warn("[Spine] AddCustomSkin, add skin does not exist", a, b, this.uid, this.runtime.GetTickCount()) : this.debug && console.warn("[Spine] AddCustomSkin, custom skin does not exist", a, b, this.uid, this.runtime.GetTickCount());
            this.SetRenderOnce(1, !0, this.uid)
        } else
            this.debug && console.warn("[Spine] AddCustomSkin, skeleton is not available", a, b, this.uid, this.runtime.GetTickCount())
    }
    _setSkin(a) {
        this.skeletonInfo && this.skeletonInfo.skeleton ? (this.skinName = a,
        this.updateCurrentSkin(),
        this.SetRenderOnce(1, !0, this.uid)) : this.debug && console.warn("[Spine] SetSkin, no skeleton.", a, this.uid, this.runtime.GetTickCount())
    }
    _flip(a) {
        this.isMirrored = a;
        this.SetRenderOnce(1, !0, this.uid)
    }
}
;
const map$jscomp$30 = new WeakMap;
self.ISpineInstance = class extends self.IWorldInstance {
    constructor() {
        super();
        map$jscomp$30.set(this, self.IInstance._GetInitInst().GetSdkInstance())
    }
    get data() {
        return map$jscomp$30.get(this)._getData()
    }
    setAnimation(a, b, c, d) {
        map$jscomp$30.get(this)._setAnimation(a, b, c, d)
    }
    setAnimationTime(a, b, c) {
        map$jscomp$30.get(this)._setAnimationTime(a, b, c)
    }
    setAnimationSpeed(a) {
        map$jscomp$30.get(this)._setAnimationSpeed(a)
    }
    currentAnimation(a) {
        return map$jscomp$30.get(this)._currentAnimation(a)
    }
    setAnimationMix(a, b, c) {
        map$jscomp$30.get(this)._setAnimationMix(a, b, c)
    }
    deleteAnimation(a, b) {
        map$jscomp$30.get(this)._deleteAnimation(a, b)
    }
    addCustomSkinOutfit(a, b, c, d, e, f) {
        map$jscomp$30.get(this)._addCustomSkinOutfit(a, b, c, d, e, f)
    }
    applySlotColors() {
        map$jscomp$30.get(this)._applySlotColors()
    }
    addCustomSkin(a, b) {
        map$jscomp$30.get(this)._addCustomSkin(a, b)
    }
    animationStart(a) {
        return map$jscomp$30.get(this)._animationStart(a)
    }
    animationEnd(a) {
        return map$jscomp$30.get(this)._animationEnd(a)
    }
    animationLength(a) {
        return map$jscomp$30.get(this)._animationLength(a)
    }
    setSkin(a) {
        map$jscomp$30.get(this)._setSkin(a)
    }
    flip(a) {
        map$jscomp$30.get(this)._flip(a)
    }
}
;
"use strict";
self.C3.Plugins.Gritsenko_Spine.Cnds = {
    OnWebGLContextLost() {
        return !0
    },
    OnWebGLContextRestored() {
        return !0
    },
    OnSkeletonLoaded() {
        return !0
    },
    IsSkeletonLoaded() {
        return this.isLoaded
    },
    OnAnimationFinished(a, b) {
        return this.completeAnimationName == a && this.completeTrackIndex == b
    },
    OnAnyAnimationFinished() {
        return !0
    },
    IsAnimationPlaying(a, b) {
        if (!this.isLoaded || !this.skeletonInfo || !this.skeletonInfo.skeleton)
            return !1;
        const c = this.skeletonInfo.state.tracks[b];
        return c ? c.animation.name === a && c.trackIndex === b : !1
    },
    OnError() {
        return !0
    },
    OnEvent(a, b) {
        return this.completeEventName === a && this.completeEventTrackIndex === b
    },
    OnAnyEvent(a) {
        return this.completeEventTrackIndex === a
    },
    IsBoneControlPropertyActive(a, b) {
        b = ["x", "y", "rotation", "scaleX", "scaleY"][b];
        return this.spineBoneControl.bones.hasOwnProperty(a) && this.spineBoneControl.bones[a].hasOwnProperty(b) ? !0 : !1
    },
    CompareValue(a, b, c) {
        if ("" === c)
            return !1;
        c = c.split(".");
        c = this.GetValuePath(c, !1);
        if ("object" === typeof c || null === c)
            return !1;
        switch (b) {
        case 0:
            return a === c;
        case 1:
            return a !== c;
        case 2:
            return a < c;
        case 3:
            return a <= c;
        case 4:
            return a > c;
        case 4:
            return a >= c;
        default:
            return !1
        }
    },
    ForEach(a) {
        if ("" === a)
            return !1;
        a = a.split(".");
        a = this.GetValuePath(a, !1);
        if ("object" !== typeof a || null === a)
            return !1;
        const b = this._runtime
          , c = b.GetEventSheetManager()
          , d = b.GetCurrentEvent()
          , e = d.GetSolModifiers()
          , f = b.GetEventStack()
          , h = f.GetCurrentStackFrame()
          , l = f.Push(d)
          , m = this.currentKey
          , p = this.currentValue;
        b.SetDebuggingEnabled(!1);
        for (const [r,v] of Object.entries(a))
            this.currentKey = r,
            this.currentValue = v,
            c.PushCopySol(e),
            d.Retrigger(h, l),
            c.PopSol(e);
        b.SetDebuggingEnabled(!0);
        this.currentKey = m;
        this.currentValue = p;
        f.Pop();
        return !1
    }
};
"use strict";
const spineBatcher$jscomp$1 = globalThis.spineBatcher;
self.C3.Plugins.Gritsenko_Spine.Acts = {
    SetSkin(a) {
        this._setSkin(a)
    },
    Flip(a) {
        this._flip(a)
    },
    SetAnimation(a, b, c, d) {
        this._setAnimation(a, b, c, d)
    },
    SetAlpha(a, b) {
        if (this.skeletonInfo && this.skeletonInfo.skeleton) {
            var c = this.skeletonInfo.state;
            c && c.tracks && (b = c.tracks[b]) && (b.alpha = Math.max(0, Math.min(1, a)),
            this.SetRenderOnce(1, !0, this.uid))
        } else
            this.debug && console.warn("[Spine] SetAlpha, no state.", a, b, this.uid, this.runtime.GetTickCount())
    },
    DeleteAnimation(a, b) {
        this._deleteAnimation(a, b)
    },
    Play() {
        this.playAnimation();
        this.SetRenderOnce(1, !0, this.uid)
    },
    Stop() {
        this.stopAnimation();
        this.SetRenderOnce(0, !1, this.uid)
    },
    UpdateBounds() {
        this.updateBounds()
    },
    SetAnimationSpeed(a) {
        this._setAnimationSpeed(a)
    },
    SetRegion(a, b, c) {
        if (this.skeletonInfo && this.skeletonInfo.skeleton) {
            var d = this.skeletonInfo.skeleton
              , e = this.skeletonInfo.atlas.findRegion(c);
            if (null == e)
                throw Error("Region not found in atlas: " + c + " " + this.uid);
            a = d.data.findSlot(a).index;
            b = d.getAttachment(a, b);
            e.renderObject = e;
            b.region = e;
            b.updateRegion();
            this.SetRenderOnce(1, !0, this.uid)
        } else
            this.debug && console.warn("[Spine] SetRegion, no skeleton.", a, b, c, this.uid, this.runtime.GetTickCount())
    },
    SetAttachment(a, b) {
        this.skeletonInfo && this.skeletonInfo.skeleton ? (this.skeletonInfo.skeleton.setAttachment(a, b),
        this.SetRenderOnce(1, !0, this.uid)) : this.debug && console.warn("[Spine] SetAttachment, no skeleton.", a, b, this.uid, this.runtime.GetTickCount())
    },
    CreateCustomSkin(a) {
        this.skeletonInfo && this.skeletonInfo.skeleton ? this.customSkins[a] ? this.customSkins[a].clear() : this.customSkins[a] = new spine.Skin(a) : this.debug && console.warn("[Spine] CreateCustomSkin, no skeleton.", a, this.uid)
    },
    AddCustomSkin(a, b) {
        this._addCustomSkin(a, b)
    },
    SetCustomSkin(a) {
        this.skeletonInfo && this.skeletonInfo.skeleton ? (this.skinName = a,
        a = this.skeletonInfo.skeleton,
        a.setSkin(this.customSkins[this.skinName]),
        a.setSlotsToSetupPose(),
        this.SetRenderOnce(1, !0, this.uid)) : this.debug && console.warn("[Spine] SetCustomSkin, no skeleton", a, this.uid, this.runtime.GetTickCount())
    },
    SetCustomAttachmentColor(a, b, c, d) {
        if (this.skeletonInfo && this.skeletonInfo.skeleton) {
            var e = this.skeletonInfo.skeleton
              , f = this.customSkins[a]
              , h = e.data.findSlot(b).index;
            e.findSlot(b);
            b = f.getAttachment(h, c).copy();
            d = new spine.Color(spineBatcher$jscomp$1.getRValue(d),spineBatcher$jscomp$1.getGValue(d),spineBatcher$jscomp$1.getBValue(d),spineBatcher$jscomp$1.getAValue(d));
            b.color = d;
            f.setAttachment(h, c, b);
            e.setSkin(this.customSkins[a]);
            e.setSlotsToSetupPose();
            this.SetRenderOnce(1, !0, this.uid)
        } else
            this.debug && console.warn("[Spine] SetCustomAttachmentColor, no skeleton", a, b, c, d, this.uid, this.runtime.GetTickCount())
    },
    SetSlotColor(a, b) {
        this.slotColors[a] = b;
        this.SetRenderOnce(1, !0, this.uid)
    },
    SetSlotDarkColor(a, b) {
        this.slotDarkColors[a] = b;
        this.SetRenderOnce(1, !0, this.uid)
    },
    ApplySlotColors() {
        this._applySlotColors()
    },
    ResetSlotColors() {
        if (this.skeletonInfo && this.skeletonInfo.skeleton) {
            var a = this.skeletonInfo.skeleton;
            this.slotColors = {};
            this.slotDarkColors = {};
            a.setSlotsToSetupPose();
            this.SetRenderOnce(1, !0, this.uid)
        } else
            this.debug && console.warn("[Spine] ResetSlotColors, no skeleton.", this.uid, this.runtime.GetTickCount())
    },
    SetAnimationTime(a, b, c) {
        this._setAnimationTime(a, b, c)
    },
    UpdateBBoxes() {
        this.skeletonInfo.skeletonBounds.update(this.skeletonInfo.skeleton, !0)
    },
    SetAnimationMix(a, b, c) {
        this._setAnimationMix(a, b, c)
    },
    SetObjectRenderRate(a) {
        globalThis.spineBatcher ? globalThis.spineBatcher.renderRate = a : this.debug && console.warn("[Spine] SetObjectRenderRate, error no spineBatcher.", a, this.uid, this.runtime.GetTickCount())
    },
    SetDebug(a) {
        this.debug = a
    },
    SetDebugVariable(a, b) {
        spineBatcher$jscomp$1 ? (spineBatcher$jscomp$1.debugVariables[a] = b,
        this.debug && console.info("[Spine] SetDebugVariable", a, b, spineBatcher$jscomp$1.debugVariables)) : console.warn("[Spine] SetDebugVariable, no spineBatcher", a, b)
    },
    SetBoneControl(a, b, c) {
        this.spineBoneControl.setBoneControl(a, ["x", "y", "rotation", "scaleX", "scaleY"][b], c);
        this.SetRenderOnce(.017, !0, this.uid)
    },
    RemoveBoneControl(a, b) {
        this.spineBoneControl.removeBoneControl(a, ["x", "y", "rotation", "scaleX", "scaleY"][b]);
        this.SetRenderOnce(.017, !0, this.uid)
    },
    RemoveAllBoneControl(a) {
        this.spineBoneControl.removeAllBoneControl(a);
        this.SetRenderOnce(.017, !0, this.uid)
    },
    SetSkeletondataRenderQuality(a) {
        this.sdkType._skeletonRenderQuality = a;
        const b = this._sdkType._assetManager;
        this._sdkType._skeletonJson.scale = a;
        this._sdkType._skeletonData = "" == this.skeletonName ? this._sdkType._skeletonJson.readSkeletonData(b.get(this._sdkType._jsonURI)) : this._sdkType._skeletonJson.readSkeletonData(b.get(this._sdkType._jsonURI)[this.skeletonName])
    },
    SetValue(a, b) {
        b = b.split(".");
        this.SetValuePath(a, b)
    },
    SetNull(a) {
        a = a.split(".");
        this.SetValuePath(null, a)
    },
    DeleteKey(a) {
        var b = a.split(".");
        a = b.pop();
        b = this.GetValuePath(b, !1);
        "object" === typeof b && null !== b && delete b[a]
    },
    SetJSON(a, b) {
        try {
            if ("" === b)
                this.data = JSON.parse(a);
            else {
                var c = b.split(".")
                  , d = c.pop()
                  , e = this.GetValuePath(c, !0);
                "object" === typeof e && (console.log("parse", JSON.parse(a)),
                e[d] = JSON.parse(a))
            }
        } catch (f) {
            return console.warn("[Spine] JSON parse error", f, a),
            !1
        }
    },
    EnablePaletteColor(a) {
        this.skeletonInfo && this.skeletonInfo.skeleton ? this.palette.enable = 0 === a ? !0 : !1 : this.debug && console.warn("[Spine] EnablePaletteColor, no skeleton", this.uid, this.runtime.GetTickCount())
    },
    SetSlotPalette(a, b) {
        this.palette.setSlotPalette(a, b)
    },
    SetSlotPaletteOffset(a, b) {
        this.palette.setSlotPaletteOffset(a, b)
    },
    SetPaletteDefaultColors(a) {
        this.skeletonInfo && this.skeletonInfo.skeleton ? (this.palette.setDefaultColors(a, 1, 1),
        this.palette.entryUploadNeeded[a] = !0,
        this.palette.uploadNeeded = !0) : this.debug && console.warn("[Spine] SetPaletteDefaultColors, no skeleton", this.uid, this.runtime.GetTickCount())
    },
    SetPaletteColor(a, b, c) {
        this.skeletonInfo && this.skeletonInfo.skeleton ? (this.palette.setColor(a, b, c),
        this.palette.entryUploadNeeded[a] = !0,
        this.palette.uploadNeeded = !0) : this.debug && console.warn("[Spine] SetPaletteColor, no skeleton", this.uid, this.runtime.GetTickCount())
    },
    SetAllPaletteColors(a) {
        let b = a.length;
        b / 2 > this.palette.palette.length && console.warn("[Spine] SetAllPaletteColorsFromString string too long:", b);
        for (let c = 0; c < b; c += 2)
            this.palette.palette[c / 2] = parseInt(a.substring(c, c + 2), 16);
        this.palette.entryUploadNeeded.fill(!0);
        this.palette.uploadNeeded = !0
    },
    SetEntryPaletteColors(a, b) {
        let c = b.length
          , d = this.palette.indexSize;
        c > 8 * d && console.warn("[Spine] SetEntryPaletteColorsFromString string too long:", c);
        for (let e = 0; e < c; e += 2)
            this.palette.palette[d * a * 4 + e / 2] = parseInt(b.substring(e, e + 2), 16);
        this.palette.entryUploadNeeded[a] = !0;
        this.palette.uploadNeeded = !0
    },
    SetEffect(a) {
        this.GetWorldInfo().SetBlendMode(a);
        this.runtime.UpdateRender()
    },
    LoadSpineFiles(a, b, c) {
        this.debug && console.log("[Spine] LoadSpineFiles", this.uid, this.runtime.GetTickCount(), a, b, c);
        "" === this.jsonPath && (this.jsonPath = a,
        this.atlasPath = b,
        this.pngPath = c,
        this.runtime.UpdateRender())
    },
    EnableSequenceAutoplay(a, b) {
        this.skeletonInfo && this.skeletonInfo.skeleton ? (this.skeletonInfo.sequenceAutoplay = 0 === a ? !0 : !1,
        this.skeletonInfo.sequenceFPS = b) : this.debug && console.warn("[Spine] SetPaletteColor, no skeleton", this.uid, this.runtime.GetTickCount())
    }
};
"use strict";
self.C3.Plugins.Gritsenko_Spine.Exps = {
    Skins() {
        return this.isLoaded ? this.skinNames.join("\n") : ""
    },
    CurrentSkin() {
        return this.isLoaded ? this.skinName : ""
    },
    SkinsCount() {
        return this.isLoaded ? this.skinNames.length : 0
    },
    SkinName(a) {
        return !this.isLoaded || a >= this.skinNames.length || 0 > a ? "" : this.skinNames[a]
    },
    Animations() {
        return this.isLoaded ? this.animationNames.join("\n") : ""
    },
    CurrentAnimation(a) {
        return this._currentAnimation(a)
    },
    AnimationsCount() {
        return this.isLoaded ? this.animationNames.length : 0
    },
    AnimationName(a) {
        return !this.isLoaded || a >= this.animationNames.length || 0 > a ? "" : this.animationNames[a]
    },
    Error() {
        return this.spineError
    },
    TextureHeight() {
        return this.isLoaded ? this.textureHeight : 0
    },
    TextureWidth() {
        return this.isLoaded ? this.textureWidth : 0
    },
    AnimationStart(a) {
        return this._animationStart(a)
    },
    AnimationEnd(a) {
        return this._animationEnd(a)
    },
    AnimationLast(a) {
        if (!this.isLoaded)
            return 0;
        const b = this.skeletonInfo.state;
        return b && b.tracks ? (a = b.tracks[a]) ? a.animationLast : 0 : 0
    },
    TrackTime(a) {
        if (!this.isLoaded)
            return 0;
        const b = this.skeletonInfo.state;
        return b && b.tracks ? (a = b.tracks[a]) ? a.trackTime : 0 : 0
    },
    Alpha(a) {
        if (!this.isLoaded)
            return 0;
        const b = this.skeletonInfo.state;
        return b && b.tracks ? (a = b.tracks[a]) ? a.alpha : 0 : 0
    },
    SpineBBoxCenterX(a, b) {
        if (!this.isLoaded)
            return 0;
        a = this.skeletonInfo.skeleton.getAttachmentByName(a, b);
        if (!a)
            return 0;
        a = this.skeletonInfo.skeletonBounds.getPolygon(a);
        var c = 0;
        for (b = 0; b < a.length; b += 2)
            c += a[b];
        c = c / (a.length / 2) + this.skeletonInfo.bounds.offset.x + this.skeletonInfo.bounds.size.x;
        this.isMirrored && (c = this.skeletonInfo.bounds.size.x - c);
        b = this.GetInstance().GetWorldInfo();
        c = b.GetX() - b.GetWidth() / 2 + c / (this.textureWidth / b.GetWidth());
        if (0 == b.GetAngle())
            return c;
        let d = 0;
        for (let e = 1; e < a.length; e += 2)
            d += a[e];
        d = this.skeletonInfo.bounds.size.y - d / (a.length / 2) + this.skeletonInfo.bounds.offset.y;
        a = b.GetY() - b.GetHeight() / 2 + d / (this.textureHeight / b.GetHeight());
        return Math.cos(b.GetAngle()) * (c - b.GetX()) - Math.sin(b.GetAngle()) * (a - b.GetY()) + b.GetX()
    },
    SpineBBoxCenterY(a, b) {
        if (!this.isLoaded)
            return 0;
        a = this.skeletonInfo.skeleton.getAttachmentByName(a, b);
        if (!a)
            return 0;
        a = this.skeletonInfo.skeletonBounds.getPolygon(a);
        var c = 0;
        for (b = 1; b < a.length; b += 2)
            c += a[b];
        c = this.skeletonInfo.bounds.size.y - c / (a.length / 2) + this.skeletonInfo.bounds.offset.y;
        b = this.GetInstance().GetWorldInfo();
        c = b.GetY() - b.GetHeight() / 2 + c / (this.textureHeight / b.GetHeight());
        if (0 == b.GetAngle())
            return c;
        let d = 0;
        for (let e = 0; e < a.length; e += 2)
            d += a[e];
        d = d / (a.length / 2) + this.skeletonInfo.bounds.offset.x + this.skeletonInfo.bounds.size.x;
        this.isMirrored && (d = this.skeletonInfo.bounds.size.x - d);
        a = b.GetX() - b.GetWidth() / 2 + d / (this.textureWidth / b.GetWidth());
        return Math.sin(b.GetAngle()) * (a - b.GetX()) + Math.cos(b.GetAngle()) * (c - b.GetY()) + b.GetY()
    },
    SpineBBoxGetPoly(a, b) {
        if (!this.isLoaded)
            return JSON.stringify({});
        var c = this.skeletonInfo.skeleton.getAttachmentByName(a, b);
        if (!c)
            return JSON.stringify({});
        var d = this.GetInstance().GetWorldInfo();
        a = d.GetX();
        b = d.GetY();
        let e = d.GetHeight() / 2
          , f = d.GetWidth() / 2
          , h = d.GetAngle()
          , l = this.textureHeight / d.GetHeight();
        d = this.textureWidth / d.GetWidth();
        let m = this.skeletonInfo.bounds.size.y
          , p = this.skeletonInfo.bounds.offset.y
          , r = this.skeletonInfo.bounds.size.x
          , v = this.skeletonInfo.bounds.offset.x
          , x = 0
          , B = 0;
        0 != h && (x = Math.cos(h),
        B = Math.sin(h));
        c = Array.from(this.skeletonInfo.skeletonBounds.getPolygon(c));
        for (let D = 0; D < c.length; D += 2) {
            var A = c[D] + v + r;
            c[D] = this.isMirrored ? r - A : A;
            c[D] = a - f + c[D] / d;
            c[D + 1] = m - c[D + 1] + p;
            c[D + 1] = b - e + c[D + 1] / l;
            0 != h && (A = B * (c[D] - a) + x * (c[D + 1] - b) + b,
            c[D] = x * (c[D] - a) - B * (c[D + 1] - b) + a,
            c[D + 1] = A)
        }
        return JSON.stringify(c)
    },
    BoneX(a) {
        return this.spineBoneControl.bones.hasOwnProperty(a) && this.spineBoneControl.bones[a].hasOwnProperty("x") ? this.spineBoneControl.bones[a].x : 0
    },
    BoneY(a) {
        return this.spineBoneControl.bones.hasOwnProperty(a) && this.spineBoneControl.bones[a].hasOwnProperty("y") ? this.spineBoneControl.bones[a].y : 0
    },
    BoneRotation(a) {
        return this.spineBoneControl.bones.hasOwnProperty(a) && this.spineBoneControl.bones[a].hasOwnProperty("rotation") ? this.spineBoneControl.bones[a].rotation : 0
    },
    BoneScaleX(a) {
        return this.spineBoneControl.bones.hasOwnProperty(a) && this.spineBoneControl.bones[a].hasOwnProperty("scaleX") ? this.spineBoneControl.bones[a].scaleX : 0
    },
    BoneScaleY(a) {
        return this.spineBoneControl.bones.hasOwnProperty(a) && this.spineBoneControl.bones[a].hasOwnProperty("scaleY") ? this.spineBoneControl.bones[a].scaleY : 0
    },
    AllPaletteColorString() {
        if (!this.palette)
            return "";
        let a = "";
        for (let b = 0; b < this.palette.palette.length; b++) {
            const c = this.palette.palette[b].toString(16).padStart(2, "0");
            a += c
        }
        return a
    },
    EntryPaletteColorString(a) {
        if (!this.palette)
            return "";
        let b = "";
        a = this.palette.indexSize * a * 4;
        for (let c = 0; c < this.palette.paletteNumber; c++) {
            const d = this.palette.palette[a + c].toString(16).padStart(2, "0");
            b += d
        }
        return b
    },
    GetValue(a) {
        if ("" === a)
            return "";
        a = a.split(".");
        a = this.GetValuePath(a, !1);
        return "object" === typeof a || null === a ? "" : a
    },
    GetAsCompactString(a) {
        a = a.split(".");
        "" === a[0] && (a = []);
        a = this.GetValuePath(a, !1);
        return JSON.stringify(a)
    },
    CurrentKey() {
        return this.currentKey
    },
    CurrentValue() {
        return this.currentValue
    },
    BboxOffsetX() {
        return this.bboxOffsetX
    },
    BboxOffsetY() {
        return this.bboxOffsetY
    },
    BboxSizeX() {
        return this.bboxSizeX
    },
    BboxSizeY() {
        return this.bboxSizeY
    },
    SkeletonScale() {
        return this.skeletonScale
    },
    GetEventData(a) {
        return "float int string balance volume audiopath event track".split(" ").includes(a) && a in this.completeEventData ? this.completeEventData[a] : ""
    }
};
"use strict";
const C3$jscomp$283 = self.C3;
C3$jscomp$283.Plugins.Sprite = class extends C3$jscomp$283.SDKPluginBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
}
;
const C3$jscomp$284 = self.C3
  , C3X$jscomp$42 = self.C3X
  , spawnPickStack = [];
C3$jscomp$284.Plugins.Sprite.Type = class extends C3$jscomp$284.SDKTypeBase {
    constructor(a) {
        super(a);
        this._animations = a.GetAnimations()
    }
    Release() {
        C3$jscomp$284.clearArray(this._animations);
        super.Release()
    }
    OnCreate() {
        for (const a of this._animations)
            a.LoadAllAssets(this._runtime)
    }
    LoadTextures(a) {
        const b = {
            sampling: this._runtime.GetSampling()
        };
        return Promise.all(this._animations.map(c => c.LoadAllTextures(a, b)))
    }
    ReleaseTextures() {
        for (const a of this._animations)
            a.ReleaseAllTextures()
    }
    OnDynamicTextureLoadComplete() {
        this._UpdateAllCurrentTexture()
    }
    _UpdateAllCurrentTexture() {
        for (const a of this._objectClass.instancesIncludingPendingCreate())
            a.GetSdkInstance()._UpdateCurrentTexture()
    }
    FinishCondition(a) {
        C3$jscomp$284.Plugins.Sprite.FinishCollisionCondition(this, a)
    }
    BeforeRunAction(a) {
        spawnPickStack.push({
            objectClass: null,
            createHierarchy: !1,
            instances: []
        })
    }
    _SpawnPickInstance(a, b, c) {
        const d = spawnPickStack.at(-1);
        d.objectClass = a;
        d.createHierarchy = c;
        d.instances.push(b)
    }
    AfterRunAction(a) {
        a = spawnPickStack.pop();
        const b = a.objectClass
          , c = a.createHierarchy;
        if (b) {
            var d = new Map;
            for (const e of a.instances)
                e.CollectInstancesToPick(d, b, c);
            for (const [e,f] of d)
                e.GetCurrentSol().SetSetPicked(f)
        }
    }
    _AddAnimation(a) {
        a = this.GetObjectClass().AddAnimation(a);
        const b = this.GetRuntime();
        a.GetFrameAt(0).GetImageInfo().LoadStaticTexture(b.GetRenderer(), {
            sampling: b.GetSampling()
        }).then( () => this._UpdateAllCurrentTexture());
        return a
    }
    _RemoveAnimation(a) {
        for (const b of this._objectClass.instancesIncludingPendingCreate())
            b.GetSdkInstance()._OnAnimationRemoved(a);
        this.GetObjectClass().RemoveAnimation(a)
    }
    _AddAnimationFrame(a, b) {
        var c = this._objectClass.GetAnimationByName(a);
        if (!c)
            throw Error(`cannot find animation name '${a}'`);
        b = c.FrameTagOrIndexToIndex(b);
        0 > b && (b += c.GetFrameCount() + 1);
        a = C3$jscomp$284.AnimationFrameInfo.CreateDynamic(this.GetRuntime());
        c.InsertFrameAt(a, b);
        c = this.GetRuntime();
        a.GetImageInfo().LoadStaticTexture(c.GetRenderer(), {
            sampling: c.GetSampling()
        }).then( () => this._UpdateAllCurrentTexture());
        for (const d of this._objectClass.instancesIncludingPendingCreate())
            d.GetSdkInstance()._OnAnimationFramesChanged();
        return a
    }
    _RemoveAnimationFrame(a, b) {
        const c = this._objectClass.GetAnimationByName(a);
        if (!c)
            throw Error(`cannot find animation name '${a}'`);
        if (1 === c.GetFrameCount())
            throw Error(`cannot remove last frame from animation '${a}'`);
        a = c.FrameTagOrIndexToIndex(b);
        0 > a && (a += c.GetFrameCount());
        c.RemoveFrameAt(a);
        for (const d of this._objectClass.instancesIncludingPendingCreate())
            d.GetSdkInstance()._OnAnimationFramesChanged()
    }
    GetScriptInterfaceClass() {
        return self.ISpriteObjectType
    }
}
;
const map$jscomp$31 = new WeakMap;
self.ISpriteObjectType = class extends self.IObjectClass {
    constructor(a) {
        super(a);
        map$jscomp$31.set(this, a.GetSdkType())
    }
    getAnimation(a) {
        C3X$jscomp$42.RequireString(a);
        return (a = map$jscomp$31.get(this).GetObjectClass().GetAnimationByName(a)) ? a.GetIAnimation() : null
    }
    getAllAnimations() {
        return map$jscomp$31.get(this).GetObjectClass().GetAllAnimations().map(a => a.GetIAnimation())
    }
    addAnimation(a) {
        C3X$jscomp$42.RequireString(a);
        return map$jscomp$31.get(this)._AddAnimation(a).GetIAnimation()
    }
    removeAnimation(a) {
        C3X$jscomp$42.RequireString(a);
        map$jscomp$31.get(this)._RemoveAnimation(a)
    }
    addAnimationFrame(a, b) {
        C3X$jscomp$42.RequireString(a);
        if ("number" !== typeof b && "string" !== typeof b)
            throw new TypeError("invalid insert location");
        return map$jscomp$31.get(this)._AddAnimationFrame(a, b).GetIAnimationFrame()
    }
    removeAnimationFrame(a, b) {
        C3X$jscomp$42.RequireString(a);
        if ("number" !== typeof b && "string" !== typeof b)
            throw new TypeError("invalid insert location");
        map$jscomp$31.get(this)._RemoveAnimationFrame(a, b)
    }
}
;
const C3$jscomp$285 = self.C3
  , C3X$jscomp$43 = self.C3X
  , tempRect$jscomp$11 = C3$jscomp$285.New(C3$jscomp$285.Rect)
  , tempQuad$jscomp$7 = C3$jscomp$285.New(C3$jscomp$285.Quad)
  , tempVec2$jscomp$1 = C3$jscomp$285.New(C3$jscomp$285.Vector2)
  , FLAG_PLAYING_FORWARDS = 1
  , FLAG_ANIMATION_PLAYING = 2
  , FLAG_ANIMATION_TRIGGER = 4;
C3$jscomp$285.Plugins.Sprite.Instance = class extends C3$jscomp$285.SDKWorldInstanceBase {
    constructor(a, b) {
        super(a);
        let c = !0
          , d = ""
          , e = 0
          , f = !0;
        b && (c = !!b[0],
        d = b[1],
        e = b[2],
        f = b[3]);
        this._currentAnimation = this._objectClass.GetAnimationByName(d) || this._objectClass.GetAnimations()[0];
        this._currentFrameIndex = C3$jscomp$285.clamp(e, 0, this._currentAnimation.GetFrameCount() - 1);
        this._currentAnimationFrame = this._currentAnimation.GetFrameAt(this._currentFrameIndex);
        b = this._currentAnimationFrame.GetImageInfo();
        this._currentTexture = b.GetTexture();
        this._currentRcTex = b.GetTexRect();
        this._currentQuadTex = b.GetTexQuad();
        this.HandleRendererContextLoss();
        a.SetFlag(FLAG_ANIMATION_PLAYING, !0);
        a.SetFlag(FLAG_PLAYING_FORWARDS, 0 <= this._currentAnimation.GetSpeed());
        this._currentAnimationSpeed = Math.abs(this._currentAnimation.GetSpeed());
        this._currentAnimationRepeatTo = this._currentAnimation.GetRepeatTo();
        this._animationTimer = C3$jscomp$285.New(C3$jscomp$285.KahanSum);
        this._animationRepeats = this._frameStartTime = 0;
        this._animTriggerName = "";
        this._changeAnimFrameIndex = -1;
        this._changeAnimationName = "";
        this._changeAnimationFrom = 0;
        a = this.GetWorldInfo();
        this._bquadRef = a.GetBoundingQuad();
        a.SetVisible(c);
        a.SetCollisionEnabled(f);
        a.SetOriginX(this._currentAnimationFrame.GetOriginX());
        a.SetOriginY(this._currentAnimationFrame.GetOriginY());
        a.SetSourceCollisionPoly(this._currentAnimationFrame.GetCollisionPoly());
        a.SetBboxChanged();
        1 === this._objectClass.GetAnimationCount() && 1 === this._objectClass.GetAnimations()[0].GetFrameCount() || 0 === this._currentAnimationSpeed || this._StartTicking()
    }
    Release() {
        this._animationTimer = this._currentTexture = this._currentAnimationFrame = this._currentAnimation = null;
        super.Release()
    }
    GetCurrentImageInfo() {
        return this._currentAnimationFrame.GetImageInfo()
    }
    IsOriginalSizeKnown() {
        return !0
    }
    OnRendererContextLost() {
        this._currentTexture = null
    }
    OnRendererContextRestored() {
        this._UpdateCurrentTexture()
    }
    Draw(a) {
        var b = this._currentTexture;
        null !== b && (a.SetTexture(b),
        b = this.GetWorldInfo(),
        b.HasMesh() ? this._DrawMesh(b, a) : this._DrawStandard(b, a))
    }
    _DrawStandard(a, b) {
        let c = this._bquadRef;
        this._runtime.IsPixelRoundingEnabled() && (c = a.PixelRoundQuad(c));
        b.Quad4(c, this._currentQuadTex)
    }
    _DrawMesh(a, b) {
        const c = a.GetTransformedMesh();
        if (a.IsMeshChanged()) {
            a.CalculateBbox(tempRect$jscomp$11, tempQuad$jscomp$7, !1);
            let d = tempQuad$jscomp$7;
            this._runtime.IsPixelRoundingEnabled() && (d = a.PixelRoundQuad(d));
            c.CalculateTransformedMesh(a.GetSourceMesh(), d, this._currentQuadTex);
            a.SetMeshChanged(!1)
        }
        c.Draw(b)
    }
    GetAnimationTime() {
        return this._animationTimer.Get()
    }
    IsAnimationPlaying() {
        return this._inst.GetFlag(FLAG_ANIMATION_PLAYING)
    }
    SetAnimationPlaying(a) {
        this._inst.SetFlag(FLAG_ANIMATION_PLAYING, a)
    }
    IsPlayingForwards() {
        return this._inst.GetFlag(FLAG_PLAYING_FORWARDS)
    }
    SetPlayingForwards(a) {
        this._inst.SetFlag(FLAG_PLAYING_FORWARDS, a)
    }
    IsInAnimationTrigger() {
        return this._inst.GetFlag(FLAG_ANIMATION_TRIGGER)
    }
    SetInAnimationTrigger(a) {
        this._inst.SetFlag(FLAG_ANIMATION_TRIGGER, a)
    }
    Tick() {
        this._changeAnimationName && this._DoChangeAnimation();
        0 <= this._changeAnimFrameIndex && this._DoChangeAnimFrame();
        const a = this._currentAnimationSpeed;
        if (this.IsAnimationPlaying() && 0 !== a) {
            var b = this._runtime.GetDt(this._inst);
            this._animationTimer.Add(b);
            b = this.GetAnimationTime();
            var c = this._currentAnimationFrame
              , d = c.GetDuration() / a;
            if (!(b < this._frameStartTime + d)) {
                var e = this._currentAnimation
                  , f = this._currentAnimationRepeatTo
                  , h = e.GetFrameCount()
                  , l = e.GetRepeatCount()
                  , m = e.IsLooping()
                  , p = e.IsPingPong();
                this.IsPlayingForwards() ? this._currentFrameIndex++ : this._currentFrameIndex--;
                this._frameStartTime += d;
                this._currentFrameIndex >= h && (p ? (this.SetPlayingForwards(!1),
                this._currentFrameIndex = h - 2) : m ? this._currentFrameIndex = f : (this._animationRepeats++,
                this._animationRepeats >= l ? this._FinishAnimation(!1) : this._currentFrameIndex = f));
                0 > this._currentFrameIndex && (p ? (this._currentFrameIndex = 1,
                this.SetPlayingForwards(!0),
                m || (this._animationRepeats++,
                this._animationRepeats >= l && this._FinishAnimation(!0))) : m ? this._currentFrameIndex = f : (this._animationRepeats++,
                this._animationRepeats >= l ? this._FinishAnimation(!0) : this._currentFrameIndex = f));
                this._currentFrameIndex = C3$jscomp$285.clamp(this._currentFrameIndex, 0, h - 1);
                d = e.GetFrameAt(this._currentFrameIndex);
                b > this._frameStartTime + d.GetDuration() / a && (this._frameStartTime = b);
                this._OnFrameChanged(c, d)
            }
        } else
            this._StopTicking()
    }
    _FinishAnimation(a) {
        this._currentFrameIndex = a ? 0 : this._currentAnimation.GetFrameCount() - 1;
        this.SetAnimationPlaying(!1);
        this._animTriggerName = this._currentAnimation.GetName();
        this.SetInAnimationTrigger(!0);
        this.DispatchScriptEvent("animationend", !1, {
            animationName: this._animTriggerName
        });
        this.Trigger(C3$jscomp$285.Plugins.Sprite.Cnds.OnAnyAnimFinished);
        this.Trigger(C3$jscomp$285.Plugins.Sprite.Cnds.OnAnimFinished);
        this.SetInAnimationTrigger(!1);
        this._animationRepeats = 0
    }
    _OnFrameChanged(a, b, c) {
        if (a !== b) {
            var d = this.GetWorldInfo()
              , e = a.GetImageInfo()
              , f = b.GetImageInfo()
              , h = e.GetWidth();
            e = e.GetHeight();
            var l = f.GetWidth()
              , m = f.GetHeight();
            if (c && c.onFrameChange)
                c.onFrameChange(d, h, e, l, m);
            else
                h !== l && d.SetWidth(d.GetWidth() * (l / h)),
                e !== m && d.SetHeight(d.GetHeight() * (m / e));
            d.SetOriginX(b.GetOriginX());
            d.SetOriginY(b.GetOriginY());
            d.SetSourceCollisionPoly(b.GetCollisionPoly());
            d.SetBboxChanged();
            this._currentAnimationFrame = b;
            this._currentTexture = f.GetTexture();
            this._currentRcTex = f.GetTexRect();
            this._currentQuadTex = f.GetTexQuad();
            c = this.GetInstance().GetBehaviorInstances();
            for (let p = 0, r = c.length; p < r; ++p)
                c[p].OnSpriteFrameChanged(a, b);
            this.DispatchScriptEvent("framechange", !1, {
                animationName: this._currentAnimation.GetName(),
                animationFrame: this._currentFrameIndex
            });
            this.Trigger(C3$jscomp$285.Plugins.Sprite.Cnds.OnFrameChanged);
            this._runtime.UpdateRender()
        }
    }
    _StartAnim(a) {
        this.SetAnimationPlaying(!0);
        this._frameStartTime = this.GetAnimationTime();
        1 === a && 0 !== this._currentFrameIndex && (this._changeAnimFrameIndex = 0,
        this.IsInAnimationTrigger() || this._DoChangeAnimFrame());
        this._StartTicking()
    }
    _SetAnim(a, b, c) {
        this._changeAnimationName = a;
        this._changeAnimationFrom = b;
        this._StartTicking();
        !c && this.IsInAnimationTrigger() || this._DoChangeAnimation()
    }
    _GetCurrentAnimation() {
        return this._currentAnimation
    }
    _GetCurrentAnimationName() {
        return this._changeAnimationName ? this._changeAnimationName : this._currentAnimation.GetName()
    }
    _OnAnimationRemoved(a) {
        C3$jscomp$285.equalsNoCase(a, this._GetCurrentAnimationName()) && this._SetAnim(this._objectClass.GetFirstAnimation().GetName(), 1, !0)
    }
    _SetAnimFrame(a) {
        if ("string" === typeof a)
            if (String(Number(a)) === a)
                a = Number(a);
            else {
                const b = this._objectClass.GetAnimationByName(this._GetCurrentAnimationName());
                if (!b)
                    return;
                a = b.GetFrameIndexByTag(a);
                if (-1 === a)
                    return
            }
        isFinite(a) && (this._changeAnimFrameIndex = a,
        this.IsInAnimationTrigger() || this._DoChangeAnimFrame())
    }
    _OnAnimationFramesChanged() {
        if (!this._changeAnimationName && -1 === this._changeAnimFrameIndex) {
            var a = this._currentAnimationFrame
              , b = this._currentAnimation.GetFrameAt(C3$jscomp$285.clamp(this._currentFrameIndex, 0, this._currentAnimation.GetFrameCount() - 1));
            a !== b && this._OnFrameChanged(a, b);
            1 < this._currentAnimation.GetFrameCount() && 0 < this._currentAnimationSpeed && this._StartTicking()
        }
    }
    _GetAnimFrame() {
        return this._currentFrameIndex
    }
    _GetAnimFrameTag() {
        return this._currentAnimationFrame.GetTag()
    }
    _SetAnimSpeed(a) {
        this._currentAnimationSpeed = Math.abs(a);
        this.SetPlayingForwards(0 <= a);
        0 < this._currentAnimationSpeed && this._StartTicking()
    }
    _GetAnimSpeed() {
        return this.IsPlayingForwards() ? this._currentAnimationSpeed : -this._currentAnimationSpeed
    }
    _SetAnimRepeatToFrame(a) {
        if ("string" === typeof a && (a = this._currentAnimation.GetFrameIndexByTag(a),
        -1 === a))
            return;
        this._currentAnimationRepeatTo = a = C3$jscomp$285.clamp(Math.floor(a), 0, this._currentAnimation.GetFrameCount() - 1)
    }
    _GetAnimRepeatToFrame() {
        return this._currentAnimationRepeatTo
    }
    _DoChangeAnimation(a) {
        const b = this._currentAnimationFrame;
        var c = this._objectClass.GetAnimationByName(this._changeAnimationName);
        this._changeAnimationName = "";
        !c || c === this._currentAnimation && this.IsAnimationPlaying() || (this._currentAnimation = c,
        this.SetPlayingForwards(0 <= c.GetSpeed()),
        this._currentAnimationSpeed = Math.abs(c.GetSpeed()),
        this._currentAnimationRepeatTo = c.GetRepeatTo(),
        this._currentFrameIndex = C3$jscomp$285.clamp(this._currentFrameIndex, 0, this._currentAnimation.GetFrameCount() - 1),
        1 === this._changeAnimationFrom && (this._currentFrameIndex = 0),
        this.SetAnimationPlaying(!0),
        this._frameStartTime = this.GetAnimationTime(),
        c = this._currentAnimation.GetFrameAt(this._currentFrameIndex),
        this._OnFrameChanged(b, c, a))
    }
    _DoChangeAnimFrame(a) {
        const b = this._currentAnimationFrame
          , c = this._currentFrameIndex;
        this._currentFrameIndex = C3$jscomp$285.clamp(Math.floor(this._changeAnimFrameIndex), 0, this._currentAnimation.GetFrameCount() - 1);
        this._changeAnimFrameIndex = -1;
        if (a || c !== this._currentFrameIndex)
            a = this._currentAnimation.GetFrameAt(this._currentFrameIndex),
            this._OnFrameChanged(b, a),
            this._frameStartTime = this.GetAnimationTime()
    }
    _UpdateCurrentTexture() {
        const a = this._currentAnimationFrame.GetImageInfo();
        this._currentTexture = a.GetTexture();
        this._currentRcTex = a.GetTexRect();
        this._currentQuadTex = a.GetTexQuad();
        this.GetWorldInfo().SetMeshChanged(!0)
    }
    GetTexture() {
        return this._currentTexture
    }
    GetTexRect() {
        return this._currentRcTex
    }
    GetTexQuad() {
        return this._currentQuadTex
    }
    GetImagePointCount() {
        return this._currentAnimationFrame.GetImagePointCount()
    }
    GetImagePoint(a) {
        const b = this._currentAnimationFrame
          , c = this.GetWorldInfo();
        if ("string" === typeof a)
            a = b.GetImagePointByName(a);
        else if ("number" === typeof a)
            a = b.GetImagePointByIndex(a - 1);
        else
            throw new TypeError("expected string or number");
        let d = c.GetTotalZElevation();
        if (!a)
            return [c.GetX(), c.GetY(), d];
        tempVec2$jscomp$1.copy(a.GetVec2());
        if (c.HasMesh()) {
            const [e,f,h] = c.GetSourceMesh().TransformPoint(tempVec2$jscomp$1.getX(), tempVec2$jscomp$1.getY());
            tempVec2$jscomp$1.set(e, f);
            d += h
        }
        tempVec2$jscomp$1.offset(-b.GetOriginX(), -b.GetOriginY());
        tempVec2$jscomp$1.scale(c.GetWidth(), c.GetHeight());
        tempVec2$jscomp$1.rotate(c.GetAngle());
        tempVec2$jscomp$1.offset(c.GetX(), c.GetY());
        return [tempVec2$jscomp$1.getX(), tempVec2$jscomp$1.getY(), d]
    }
    GetCollisionPolyPointCount() {
        return this.GetWorldInfo().GetTransformedCollisionPoly().pointCount()
    }
    GetCollisionPolyPoint(a) {
        a = Math.floor(a);
        const b = this.GetWorldInfo();
        var c = b.GetTransformedCollisionPoly();
        const d = c.pointCount();
        a === d && (a = 0);
        if (0 > a || a >= d)
            return [0, 0];
        c = c.pointsArr();
        return [c[2 * a] + b.GetX(), c[2 * a + 1] + b.GetY()]
    }
    GetDebuggerProperties() {
        const a = C3$jscomp$285.Plugins.Sprite.Acts;
        return [{
            title: "plugins.sprite.debugger.animation-properties.title",
            properties: [{
                name: "plugins.sprite.debugger.animation-properties.current-animation",
                value: this._currentAnimation.GetName(),
                onedit: b => this.CallAction(a.SetAnim, b, 0)
            }, {
                name: "plugins.sprite.debugger.animation-properties.current-frame",
                value: this._currentFrameIndex,
                onedit: b => this.CallAction(a.SetAnimFrame, b)
            }, {
                name: "plugins.sprite.debugger.animation-properties.is-playing",
                value: this.IsAnimationPlaying(),
                onedit: b => b ? this.CallAction(a.StartAnim, 0) : this.CallAction(a.StopAnim)
            }, {
                name: "plugins.sprite.debugger.animation-properties.speed",
                value: this._currentAnimationSpeed,
                onedit: b => this.CallAction(a.SetAnimSpeed, b)
            }, {
                name: "plugins.sprite.debugger.animation-properties.repeats",
                value: this._animationRepeats,
                onedit: b => this._animationRepeats = b
            }]
        }]
    }
    SaveToJson() {
        const a = {
            a: this._currentAnimation.GetSID()
        };
        0 !== this._frameStartTime && (a.fs = this._frameStartTime);
        var b = this.GetAnimationTime();
        0 !== b && (a.at = b);
        0 !== this._currentFrameIndex && (a.f = this._currentFrameIndex);
        0 !== this._currentAnimationSpeed && (a.cas = this._currentAnimationSpeed);
        1 !== this._animationRepeats && (a.ar = this._animationRepeats);
        0 !== this._currentAnimationRepeatTo && (a.rt = this._currentAnimationRepeatTo);
        this.IsAnimationPlaying() || (a.ap = this.IsAnimationPlaying());
        this.IsPlayingForwards() || (a.af = this.IsPlayingForwards());
        b = this.GetWorldInfo();
        b.IsCollisionEnabled() && (a.ce = b.IsCollisionEnabled());
        return a
    }
    LoadFromJson(a) {
        var b = this.GetObjectClass().GetAnimationBySID(a.a);
        b && (this._currentAnimation = b);
        this._frameStartTime = a.hasOwnProperty("fs") ? a.fs : 0;
        this._animationTimer.Set(a.hasOwnProperty("at") ? a.at : 0);
        b = a.hasOwnProperty("f") ? a.f : 0;
        this._currentFrameIndex = C3$jscomp$285.clamp(b, 0, this._currentAnimation.GetFrameCount() - 1);
        this._currentAnimationSpeed = a.hasOwnProperty("cas") ? a.cas : 0;
        this._animationRepeats = a.hasOwnProperty("ar") ? a.ar : 1;
        b = a.hasOwnProperty("rt") ? a.rt : 0;
        this._currentAnimationRepeatTo = C3$jscomp$285.clamp(b, 0, this._currentAnimation.GetFrameCount() - 1);
        this.SetAnimationPlaying(a.hasOwnProperty("ap") ? !!a.ap : !0);
        this.SetPlayingForwards(a.hasOwnProperty("af") ? !!a.af : !0);
        this._currentAnimationFrame = b = this._currentAnimation.GetFrameAt(this._currentFrameIndex);
        this._UpdateCurrentTexture();
        const c = this.GetWorldInfo();
        c.SetOriginX(b.GetOriginX());
        c.SetOriginY(b.GetOriginY());
        c.SetSourceCollisionPoly(b.GetCollisionPoly());
        c.SetCollisionEnabled(!!a.ce);
        this.IsAnimationPlaying() && this._StartTicking()
    }
    GetPropertyValueByIndex(a) {
        const b = this.GetWorldInfo();
        switch (a) {
        case 3:
            return b.IsCollisionEnabled();
        case 2:
            return C3$jscomp$285.clamp(this._currentFrameIndex, 0, this._currentAnimation.GetFrameCount() - 1);
        case 1:
            return this._currentAnimation.GetName()
        }
    }
    SetPropertyValueByIndex(a, b, c) {
        var d = this.GetWorldInfo();
        switch (a) {
        case 3:
            d.SetCollisionEnabled(!!b);
            break;
        case 2:
            this.SetAnimationPlaying(!1);
            a = this._currentAnimation.GetFrameCount() - 1;
            d = b = C3$jscomp$285.clamp(b, 0, a);
            b = this._currentAnimation.GetFrameAt(this._currentFrameIndex);
            const e = this._currentAnimation.GetFrameAt(d);
            this._OnFrameChanged(b, e, c);
            this._currentFrameIndex = C3$jscomp$285.clamp(d, 0, a);
            break;
        case 1:
            this._changeAnimationName = b,
            this._DoChangeAnimation(c),
            1 < this._currentAnimation.GetFrameCount() && 0 < this._currentAnimation.GetSpeed() ? this._StartTicking() : this._StopTicking()
        }
    }
    GetScriptInterfaceClass() {
        return self.ISpriteInstance
    }
}
;
const map$jscomp$32 = new WeakMap
  , ANIM_FROM_MODES = new Map([["current-frame", 0], ["beginning", 1]]);
self.ISpriteInstance = class extends self.IWorldInstance {
    constructor() {
        super();
        map$jscomp$32.set(this, self.IInstance._GetInitInst().GetSdkInstance())
    }
    getImagePointCount() {
        return map$jscomp$32.get(this).GetImagePointCount()
    }
    getImagePointX(a) {
        return this.getImagePoint(a)[0]
    }
    getImagePointY(a) {
        return this.getImagePoint(a)[1]
    }
    getImagePointZ(a) {
        return this.getImagePoint(a)[2]
    }
    getImagePoint(a) {
        if ("string" !== typeof a && "number" !== typeof a)
            throw new TypeError("expected string or number");
        return map$jscomp$32.get(this).GetImagePoint(a)
    }
    getPolyPointCount() {
        return map$jscomp$32.get(this).GetCollisionPolyPointCount()
    }
    getPolyPointX(a) {
        C3X$jscomp$43.RequireFiniteNumber(a);
        return map$jscomp$32.get(this).GetCollisionPolyPoint(a)[0]
    }
    getPolyPointY(a) {
        C3X$jscomp$43.RequireFiniteNumber(a);
        return map$jscomp$32.get(this).GetCollisionPolyPoint(a)[1]
    }
    getPolyPoint(a) {
        C3X$jscomp$43.RequireFiniteNumber(a);
        return map$jscomp$32.get(this).GetCollisionPolyPoint(a)
    }
    stopAnimation() {
        map$jscomp$32.get(this).SetAnimationPlaying(!1)
    }
    startAnimation(a="current-frame") {
        C3X$jscomp$43.RequireString(a);
        a = ANIM_FROM_MODES.get(a);
        if ("undefined" === typeof a)
            throw Error("invalid mode");
        map$jscomp$32.get(this)._StartAnim(a)
    }
    setAnimation(a, b="beginning") {
        C3X$jscomp$43.RequireString(a);
        C3X$jscomp$43.RequireString(b);
        b = ANIM_FROM_MODES.get(b);
        if ("undefined" === typeof b)
            throw Error("invalid mode");
        const c = map$jscomp$32.get(this);
        if (!c.GetObjectClass().GetAnimationByName(a))
            throw Error(`animation name "${a}" does not exist`);
        c._SetAnim(a, b)
    }
    getAnimation(a) {
        C3X$jscomp$43.RequireString(a);
        return (a = map$jscomp$32.get(this).GetObjectClass().GetAnimationByName(a)) ? a.GetIAnimation() : null
    }
    get animation() {
        return map$jscomp$32.get(this)._GetCurrentAnimation().GetIAnimation()
    }
    get animationName() {
        return map$jscomp$32.get(this)._GetCurrentAnimationName()
    }
    set animationFrame(a) {
        C3X$jscomp$43.RequireFiniteNumber(a);
        map$jscomp$32.get(this)._SetAnimFrame(a)
    }
    get animationFrame() {
        return map$jscomp$32.get(this)._GetAnimFrame()
    }
    set animationFrameTag(a) {
        C3X$jscomp$43.RequireString(a);
        map$jscomp$32.get(this)._SetAnimFrame(a)
    }
    get animationFrameTag() {
        return map$jscomp$32.get(this)._GetAnimFrameTag()
    }
    set animationSpeed(a) {
        C3X$jscomp$43.RequireFiniteNumber(a);
        map$jscomp$32.get(this)._SetAnimSpeed(a)
    }
    get animationSpeed() {
        return map$jscomp$32.get(this)._GetAnimSpeed()
    }
    set animationRepeatToFrame(a) {
        C3X$jscomp$43.RequireFiniteNumber(a);
        map$jscomp$32.get(this)._SetAnimRepeatToFrame(a)
    }
    get animationRepeatToFrame() {
        return map$jscomp$32.get(this)._GetAnimRepeatToFrame()
    }
    get imageWidth() {
        return map$jscomp$32.get(this).GetCurrentImageInfo().GetWidth()
    }
    get imageHeight() {
        return map$jscomp$32.get(this).GetCurrentImageInfo().GetHeight()
    }
    getImageSize() {
        const a = map$jscomp$32.get(this).GetCurrentImageInfo();
        return [a.GetWidth(), a.GetHeight()]
    }
    async replaceCurrentAnimationFrame(a) {
        C3X$jscomp$43.RequireInstanceOf(a, Blob);
        const b = map$jscomp$32.get(this)
          , c = b.GetRuntime()
          , d = b.GetCurrentImageInfo()
          , e = C3$jscomp$285.New(C3$jscomp$285.ImageInfo);
        e.LoadDynamicBlobAsset(c, a);
        await e.LoadStaticTexture(c.GetRenderer(), {
            sampling: c.GetSampling()
        });
        b.WasReleased() ? e.Release() : (d.ReplaceWith(e),
        a = b.GetSdkType(),
        a._UpdateAllCurrentTexture(),
        a.GetObjectClass().Dispatcher().dispatchEvent(new C3$jscomp$285.Event("animationframeimagechange")),
        c.UpdateRender())
    }
    setSolidCollisionFilter(a, b) {
        C3X$jscomp$43.RequireString(b);
        map$jscomp$32.get(this).GetWorldInfo().SetSolidCollisionFilter(!!a, b)
    }
}
;
const C3$jscomp$286 = self.C3;
C3$jscomp$286.Plugins.Sprite.Cnds = {
    IsAnimPlaying(a) {
        return C3$jscomp$286.equalsNoCase(this._GetCurrentAnimationName(), a)
    },
    CompareFrame(a, b) {
        return C3$jscomp$286.compare(this._currentFrameIndex, a, b)
    },
    CompareFrameTag(a, b) {
        if ("string" !== typeof b)
            return !1;
        const c = this._currentAnimationFrame.GetTag();
        return C3$jscomp$286.compare(c.toLowerCase(), a, b.toLowerCase())
    },
    CompareAnimSpeed(a, b) {
        return C3$jscomp$286.compare(this._GetAnimSpeed(), a, b)
    },
    OnAnimFinished(a) {
        return C3$jscomp$286.equalsNoCase(this._animTriggerName, a)
    },
    OnAnyAnimFinished() {
        return !0
    },
    OnFrameChanged() {
        return !0
    },
    IsMirrored() {
        return 0 > this.GetWorldInfo().GetWidth()
    },
    IsFlipped() {
        return 0 > this.GetWorldInfo().GetHeight()
    },
    OnURLLoaded() {
        return !0
    },
    OnURLFailed() {
        return !0
    },
    IsCollisionEnabled() {
        return this.GetWorldInfo().IsCollisionEnabled()
    }
};
const C3$jscomp$287 = self.C3;
C3$jscomp$287.Plugins.Sprite.Acts = {
    Spawn(a, b, c, d, e) {
        if (a && b) {
            var [f,h] = this.GetImagePoint(c);
            if (c = this._runtime.CreateInstance(a, b, f, h, d, e))
                d && b.SortAndAddInstancesByZIndex(c),
                a.GetPlugin().IsRotatable() && (b = c.GetWorldInfo(),
                b.SetAngle(this.GetWorldInfo().GetAngle()),
                b.SetBboxChanged()),
                b = this._runtime.GetEventSheetManager(),
                b.BlockFlushingInstances(!0),
                c._TriggerOnCreatedOnSelfAndRelated(),
                b.BlockFlushingInstances(!1),
                a !== this._runtime.GetCurrentAction().GetObjectClass() && this._sdkType._SpawnPickInstance(a, c, d)
        }
    },
    StopAnim() {
        this.SetAnimationPlaying(!1)
    },
    StartAnim(a) {
        this._StartAnim(a)
    },
    SetAnim(a, b) {
        this._SetAnim(a, b)
    },
    SetAnimFrame(a) {
        this._SetAnimFrame(a)
    },
    SetAnimSpeed(a) {
        this._SetAnimSpeed(a)
    },
    SetAnimRepeatToFrame(a) {
        this._SetAnimRepeatToFrame(a)
    },
    AddRemoveAnimation(a, b) {
        try {
            0 === a ? this.GetSdkType()._AddAnimation(b) : this.GetSdkType()._RemoveAnimation(b)
        } catch (c) {
            console.error(`[Construct] Error ${0 === a ? "adding" : "removing"} animation: `, c)
        }
    },
    AddRemoveAnimationFrame(a, b, c) {
        try {
            0 === a ? this.GetSdkType()._AddAnimationFrame(b, c) : this.GetSdkType()._RemoveAnimationFrame(b, c)
        } catch (d) {
            console.error(`[Construct] Error ${0 === a ? "adding" : "removing"} animation frame: `, d)
        }
    },
    SetMirrored(a) {
        const b = this.GetWorldInfo()
          , c = b.GetWidth();
        a = Math.abs(c) * (0 === a ? -1 : 1);
        c !== a && (b.SetWidth(a),
        b.SetBboxChanged())
    },
    SetFlipped(a) {
        const b = this.GetWorldInfo()
          , c = b.GetHeight();
        a = Math.abs(c) * (0 === a ? -1 : 1);
        c !== a && (b.SetHeight(a),
        b.SetBboxChanged())
    },
    SetScale(a) {
        const b = this._currentAnimationFrame.GetImageInfo()
          , c = this.GetWorldInfo();
        var d = 0 > c.GetWidth() ? -1 : 1;
        const e = 0 > c.GetHeight() ? -1 : 1;
        d *= b.GetWidth() * a;
        a = b.GetHeight() * a * e;
        if (c.GetWidth() !== d || c.GetHeight() !== a)
            c.SetSize(d, a),
            c.SetBboxChanged()
    },
    async LoadURL(a, b, c) {
        c = this._currentAnimationFrame.GetImageInfo();
        const d = this.GetWorldInfo()
          , e = this._runtime
          , f = this._sdkType;
        if (c.GetURL() === a)
            0 === b && (d.SetSize(c.GetWidth(), c.GetHeight()),
            d.SetBboxChanged()),
            this.Trigger(C3$jscomp$287.Plugins.Sprite.Cnds.OnURLLoaded);
        else {
            var h = C3$jscomp$287.New(C3$jscomp$287.ImageInfo);
            try {
                await h.LoadDynamicAsset(e, a);
                if (!h.IsLoaded())
                    throw Error("image failed to load");
                if (this.WasReleased()) {
                    h.Release();
                    return
                }
                await h.LoadStaticTexture(e.GetRenderer(), {
                    sampling: e.GetSampling()
                })
            } catch (l) {
                console.error("Load image from URL failed: ", l);
                this.WasReleased() || this.Trigger(C3$jscomp$287.Plugins.Sprite.Cnds.OnURLFailed);
                return
            }
            this.WasReleased() ? h.Release() : (c.ReplaceWith(h),
            f._UpdateAllCurrentTexture(),
            f.GetObjectClass().Dispatcher().dispatchEvent(new C3$jscomp$287.Event("animationframeimagechange")),
            e.UpdateRender(),
            0 === b && (d.SetSize(c.GetWidth(), c.GetHeight()),
            d.SetBboxChanged()),
            await this.TriggerAsync(C3$jscomp$287.Plugins.Sprite.Cnds.OnURLLoaded))
        }
    },
    SetCollisions(a) {
        this.GetWorldInfo().SetCollisionEnabled(a)
    },
    SetSolidCollisionFilter(a, b) {
        this.GetWorldInfo().SetSolidCollisionFilter(0 === a, b)
    },
    SetEffect(a) {
        this.GetWorldInfo().SetBlendMode(a);
        this._runtime.UpdateRender()
    }
};
self.C3.Plugins.Sprite.Exps = {
    AnimationFrame() {
        return this._GetAnimFrame()
    },
    AnimationFrameTag() {
        return this._GetAnimFrameTag()
    },
    AnimationFrameCount() {
        return this._currentAnimation.GetFrameCount()
    },
    AnimationName() {
        return this._currentAnimation.GetName()
    },
    AnimationSpeed() {
        return this._GetAnimSpeed()
    },
    OriginalAnimationSpeed() {
        return this._currentAnimation.GetSpeed()
    },
    ImagePointX(a) {
        return this.GetImagePoint(a)[0]
    },
    ImagePointY(a) {
        return this.GetImagePoint(a)[1]
    },
    ImagePointZ(a) {
        return this.GetImagePoint(a)[2]
    },
    ImagePointCount() {
        return this.GetImagePointCount()
    },
    ImageWidth() {
        return this.GetCurrentImageInfo().GetWidth()
    },
    ImageHeight() {
        return this.GetCurrentImageInfo().GetHeight()
    },
    PolyPointXAt(a) {
        return this.GetCollisionPolyPoint(a)[0]
    },
    PolyPointYAt(a) {
        return this.GetCollisionPolyPoint(a)[1]
    },
    PolyPointCount() {
        return this.GetCollisionPolyPointCount()
    }
};
"use strict";
const C3$jscomp$289 = self.C3;
C3$jscomp$289.Plugins.TiledBg = class extends C3$jscomp$289.SDKPluginBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
}
;
const C3$jscomp$290 = self.C3;
function WrapModeToStr(a) {
    switch (a) {
    case 0:
        return "clamp-to-edge";
    case 2:
        return "mirror-repeat"
    }
    return "repeat"
}
C3$jscomp$290.Plugins.TiledBg.Type = class extends C3$jscomp$290.SDKTypeBase {
    constructor(a, b) {
        super(a);
        this._wrapY = this._wrapX = "repeat";
        b && (this._wrapX = WrapModeToStr(b[0]),
        this._wrapY = WrapModeToStr(b[1]))
    }
    Release() {
        super.Release()
    }
    OnCreate() {
        this.GetImageInfo().LoadAsset(this._runtime)
    }
    LoadTextures(a) {
        return this.GetImageInfo().LoadStaticTexture(a, {
            sampling: this._runtime.GetSampling(),
            wrapX: this._wrapX,
            wrapY: this._wrapY
        })
    }
    ReleaseTextures() {
        this.GetImageInfo().ReleaseTexture()
    }
}
;
const C3$jscomp$291 = self.C3
  , C3X$jscomp$44 = self.C3X
  , tempRect$jscomp$12 = C3$jscomp$291.New(C3$jscomp$291.Rect)
  , tempQuad$jscomp$8 = C3$jscomp$291.New(C3$jscomp$291.Quad)
  , rcTex$jscomp$4 = C3$jscomp$291.New(C3$jscomp$291.Rect)
  , qTex = C3$jscomp$291.New(C3$jscomp$291.Quad);
C3$jscomp$291.Plugins.TiledBg.Instance = class extends C3$jscomp$291.SDKWorldInstanceBase {
    constructor(a, b) {
        super(a);
        this._imageOffsetY = this._imageOffsetX = 0;
        this._imageScaleY = this._imageScaleX = 1;
        this._imageAngle = 0;
        this._enableTileRandomization = !1;
        this._tileBlendMarginY = this._tileBlendMarginX = this._tileAngleRandom = this._tileYRandom = this._tileXRandom = 0;
        this._ownImageInfo = null;
        b && (this.GetWorldInfo().SetVisible(!!b[0]),
        this._imageOffsetX = b[4],
        this._imageOffsetY = b[5],
        this._imageScaleX = b[6],
        this._imageScaleY = b[7],
        this._imageAngle = C3$jscomp$291.toRadians(b[8]),
        this._enableTileRandomization = !!b[9],
        this._tileXRandom = b[10],
        this._tileYRandom = b[11],
        this._tileAngleRandom = b[12],
        this._tileBlendMarginX = b[13],
        this._tileBlendMarginY = b[14])
    }
    Release() {
        this._ReleaseOwnImage();
        super.Release()
    }
    _ReleaseOwnImage() {
        this._ownImageInfo && (this._ownImageInfo.Release(),
        this._ownImageInfo = null)
    }
    CalculateTextureCoordsFor3DFace(a, b, c) {
        var d = this.GetCurrentImageInfo();
        const e = d.GetWidth();
        d = d.GetHeight();
        const f = this._imageOffsetX / e
          , h = this._imageOffsetY / d
          , l = this._imageAngle;
        rcTex$jscomp$4.set(0, 0, a / (e * this._imageScaleX), b / (d * this._imageScaleY));
        rcTex$jscomp$4.offset(-f, -h);
        0 === l ? c.setFromRect(rcTex$jscomp$4) : c.setFromRotatedRect(rcTex$jscomp$4, -l)
    }
    SetTilingShaderProgram(a, b=!0) {
        this._enableTileRandomization ? (b = this.GetCurrentImageInfo(),
        a.SetTileRandomizationMode(),
        a.SetTileRandomizationInfo(b.GetWidth() * this._imageScaleX, b.GetHeight() * this._imageScaleY, this._tileXRandom, this._tileYRandom, this._tileAngleRandom, this._tileBlendMarginX, this._tileBlendMarginY)) : b && a.SetTextureFillMode()
    }
    Draw(a) {
        var b = this.GetCurrentImageInfo()
          , c = b.GetTexture();
        if (null !== c) {
            this.SetTilingShaderProgram(a);
            a.SetTexture(c);
            c = b.GetWidth();
            b = b.GetHeight();
            var d = this._imageOffsetX / c
              , e = this._imageOffsetY / b
              , f = this.GetWorldInfo();
            rcTex$jscomp$4.set(0, 0, f.GetWidth() / (c * this._imageScaleX), f.GetHeight() / (b * this._imageScaleY));
            rcTex$jscomp$4.offset(-d, -e);
            f.HasMesh() ? this._DrawMesh(f, a) : this._DrawStandard(f, a)
        }
    }
    _DrawStandard(a, b) {
        let c = a.GetBoundingQuad();
        this._runtime.IsPixelRoundingEnabled() && (c = a.PixelRoundQuad(c));
        0 === this._imageAngle ? b.Quad3(c, rcTex$jscomp$4) : (qTex.setFromRotatedRect(rcTex$jscomp$4, -this._imageAngle),
        b.Quad4(c, qTex))
    }
    _DrawMesh(a, b) {
        const c = a.GetTransformedMesh();
        if (a.IsMeshChanged()) {
            a.CalculateBbox(tempRect$jscomp$12, tempQuad$jscomp$8, !1);
            let d = tempQuad$jscomp$8;
            this._runtime.IsPixelRoundingEnabled() && (d = a.PixelRoundQuad(d));
            let e = rcTex$jscomp$4;
            0 !== this._imageAngle && (qTex.setFromRotatedRect(rcTex$jscomp$4, -this._imageAngle),
            e = qTex);
            c.CalculateTransformedMesh(a.GetSourceMesh(), d, e);
            a.SetMeshChanged(!1)
        }
        c.Draw(b)
    }
    GetCurrentImageInfo() {
        return this._ownImageInfo || this._objectClass.GetImageInfo()
    }
    IsOriginalSizeKnown() {
        return !0
    }
    GetTexture() {
        return this.GetCurrentImageInfo().GetTexture()
    }
    _SetMeshChanged() {
        this.GetWorldInfo().SetMeshChanged(!0)
    }
    _SetImageOffsetX(a) {
        this._imageOffsetX !== a && (this._imageOffsetX = a,
        this._runtime.UpdateRender(),
        this._SetMeshChanged())
    }
    _GetImageOffsetX() {
        return this._imageOffsetX
    }
    _SetImageOffsetY(a) {
        this._imageOffsetY !== a && (this._imageOffsetY = a,
        this._runtime.UpdateRender(),
        this._SetMeshChanged())
    }
    _GetImageOffsetY() {
        return this._imageOffsetY
    }
    _SetImageScaleX(a) {
        this._imageScaleX !== a && (this._imageScaleX = a,
        this._runtime.UpdateRender(),
        this._SetMeshChanged())
    }
    _GetImageScaleX() {
        return this._imageScaleX
    }
    _SetImageScaleY(a) {
        this._imageScaleY !== a && (this._imageScaleY = a,
        this._runtime.UpdateRender(),
        this._SetMeshChanged())
    }
    _GetImageScaleY() {
        return this._imageScaleY
    }
    _SetImageAngle(a) {
        this._imageAngle !== a && (this._imageAngle = a,
        this._runtime.UpdateRender(),
        this._SetMeshChanged())
    }
    _GetImageAngle() {
        return this._imageAngle
    }
    _SetTileRandomizationEnabled(a) {
        a = !!a;
        this._enableTileRandomization !== a && (this._enableTileRandomization = a,
        this._runtime.UpdateRender())
    }
    _IsTileRandomizationEnabled() {
        return this._enableTileRandomization
    }
    _SetTileXRandom(a) {
        this._tileXRandom !== a && (this._tileXRandom = a,
        this._IsTileRandomizationEnabled() && this._runtime.UpdateRender())
    }
    _GetTileXRandom() {
        return this._tileXRandom
    }
    _SetTileYRandom(a) {
        this._tileYRandom !== a && (this._tileYRandom = a,
        this._IsTileRandomizationEnabled() && this._runtime.UpdateRender())
    }
    _GetTileYRandom() {
        return this._tileYRandom
    }
    _SetTileAngleRandom(a) {
        this._tileAngleRandom !== a && (this._tileAngleRandom = a,
        this._IsTileRandomizationEnabled() && this._runtime.UpdateRender())
    }
    _GetTileAngleRandom() {
        return this._tileAngleRandom
    }
    _SetTileBlendMarginX(a) {
        this._tileBlendMarginX !== a && (this._tileBlendMarginX = a,
        this._IsTileRandomizationEnabled() && this._runtime.UpdateRender())
    }
    _GetTileBlendMarginX() {
        return this._tileBlendMarginX
    }
    _SetTileBlendMarginY(a) {
        this._tileBlendMarginY !== a && (this._tileBlendMarginY = a,
        this._IsTileRandomizationEnabled() && this._runtime.UpdateRender())
    }
    _GetTileBlendMarginY() {
        return this._tileBlendMarginY
    }
    SaveToJson() {
        const a = {};
        0 !== this._imageOffsetX && (a.iox = this._imageOffsetX);
        0 !== this._imageOffsetY && (a.ioy = this._imageOffsetY);
        1 !== this._imageScaleX && (a.isx = this._imageScaleX);
        1 !== this._imageScaleY && (a.isy = this._imageScaleY);
        0 !== this._imageAngle && (a.ia = this._imageAngle);
        this._enableTileRandomization && (a.tr = !0);
        1 !== this._tileXRandom && (a.trx = this._tileXRandom);
        1 !== this._tileYRandom && (a["try"] = this._tileYRandom);
        1 !== this._tileAngleRandom && (a.tra = this._tileAngleRandom);
        .1 !== this._tileBlendMarginX && (a.trbmx = this._tileBlendMarginX);
        .1 !== this._tileBlendMarginY && (a.trbmy = this._tileBlendMarginY);
        return a
    }
    LoadFromJson(a) {
        this._imageOffsetX = a.iox || 0;
        this._imageOffsetY = a.ioy || 0;
        this._imageScaleX = a.hasOwnProperty("isx") ? a.isx : 1;
        this._imageScaleY = a.hasOwnProperty("isy") ? a.isy : 1;
        this._imageAngle = a.ia || 0;
        this._enableTileRandomization = !!a.tr;
        this._tileXRandom = a.hasOwnProperty("trx") ? a.trx : 1;
        this._tileYRandom = a.hasOwnProperty("try") ? a["try"] : 1;
        this._tileAngleRandom = a.hasOwnProperty("tra") ? a.tra : 1;
        this._tileBlendMarginX = a.hasOwnProperty("trbmx") ? a.trbmx : .1;
        this._tileBlendMarginY = a.hasOwnProperty("trbmy") ? a.trbmy : .1
    }
    GetDebuggerProperties() {
        return [{
            title: "plugins.tiledbg.properties.image-transform.name",
            properties: [{
                name: "plugins.tiledbg.properties.image-offset-x.name",
                value: this._GetImageOffsetX(),
                onedit: a => this._SetImageOffsetX(a)
            }, {
                name: "plugins.tiledbg.properties.image-offset-y.name",
                value: this._GetImageOffsetY(),
                onedit: a => this._SetImageOffsetY(a)
            }, {
                name: "plugins.tiledbg.properties.image-scale-x.name",
                value: 100 * this._GetImageScaleX(),
                onedit: a => this._SetImageScaleX(a / 100)
            }, {
                name: "plugins.tiledbg.properties.image-scale-y.name",
                value: 100 * this._GetImageScaleY(),
                onedit: a => this._SetImageScaleY(a / 100)
            }, {
                name: "plugins.tiledbg.properties.image-angle.name",
                value: C3$jscomp$291.toDegrees(this._GetImageAngle()),
                onedit: a => this._SetImageAngle(C3$jscomp$291.toRadians(a))
            }]
        }, {
            title: "plugins.tiledbg.properties.tile-randomization.name",
            properties: [{
                name: "plugins.tiledbg.properties.enable-tile-randomization.name",
                value: this._IsTileRandomizationEnabled(),
                onedit: a => this._SetTileRandomizationEnabled(a)
            }, {
                name: "plugins.tiledbg.properties.x-random.name",
                value: 100 * this._GetTileXRandom(),
                onedit: a => this._SetTileXRandom(a / 100)
            }, {
                name: "plugins.tiledbg.properties.y-random.name",
                value: 100 * this._GetTileYRandom(),
                onedit: a => this._SetTileYRandom(a / 100)
            }, {
                name: "plugins.tiledbg.properties.angle-random.name",
                value: 100 * this._GetTileAngleRandom(),
                onedit: a => this._SetTileAngleRandom(a / 100)
            }, {
                name: "plugins.tiledbg.properties.blend-margin-x.name",
                value: 100 * this._GetTileBlendMarginX(),
                onedit: a => this._SetTileBlendMarginX(a / 100)
            }, {
                name: "plugins.tiledbg.properties.blend-margin-y.name",
                value: 100 * this._GetTileBlendMarginY(),
                onedit: a => this._SetTileBlendMarginY(a / 100)
            }]
        }]
    }
    GetPropertyValueByIndex(a) {
        switch (a) {
        case 4:
            return this._GetImageOffsetX();
        case 5:
            return this._GetImageOffsetY();
        case 6:
            return this._GetImageScaleX();
        case 7:
            return this._GetImageScaleY();
        case 8:
            return this._GetImageAngle();
        case 9:
            return this._IsTileRandomizationEnabled();
        case 10:
            return this._GetTileXRandom();
        case 11:
            return this._GetTileYRandom();
        case 12:
            return this._GetTileAngleRandom();
        case 13:
            return this._GetTileBlendMarginX();
        case 14:
            return this._GetTileBlendMarginY()
        }
    }
    SetPropertyValueByIndex(a, b) {
        switch (a) {
        case 4:
            this._SetImageOffsetX(b);
            break;
        case 5:
            this._SetImageOffsetY(b);
            break;
        case 6:
            this._SetImageScaleX(b);
            break;
        case 7:
            this._SetImageScaleY(b);
            break;
        case 8:
            this._SetImageAngle(b);
            break;
        case 9:
            this._SetTileRandomizationEnabled(!!b);
            break;
        case 10:
            this._SetTileXRandom(b);
            break;
        case 11:
            this._SetTileYRandom(b);
            break;
        case 12:
            this._SetTileAngleRandom(b);
            break;
        case 13:
            this._SetTileBlendMarginX(b);
            break;
        case 14:
            this._SetTileBlendMarginY(b)
        }
    }
    GetScriptInterfaceClass() {
        return self.ITiledBackgroundInstance
    }
}
;
const map$jscomp$33 = new WeakMap;
self.ITiledBackgroundInstance = class extends self.IWorldInstance {
    constructor() {
        super();
        map$jscomp$33.set(this, self.IInstance._GetInitInst().GetSdkInstance())
    }
    set imageOffsetX(a) {
        C3X$jscomp$44.RequireFiniteNumber(a);
        map$jscomp$33.get(this)._SetImageOffsetX(a)
    }
    get imageOffsetX() {
        return map$jscomp$33.get(this)._GetImageOffsetX()
    }
    set imageOffsetY(a) {
        C3X$jscomp$44.RequireFiniteNumber(a);
        map$jscomp$33.get(this)._SetImageOffsetY(a)
    }
    get imageOffsetY() {
        return map$jscomp$33.get(this)._GetImageOffsetY()
    }
    setImageOffset(a, b) {
        C3X$jscomp$44.RequireFiniteNumber(a);
        C3X$jscomp$44.RequireFiniteNumber(b);
        const c = map$jscomp$33.get(this);
        c._SetImageOffsetX(a);
        c._SetImageOffsetY(b)
    }
    getImageOffset() {
        const a = map$jscomp$33.get(this);
        return [a._GetImageOffsetX(), a._GetImageOffsetY()]
    }
    set imageScaleX(a) {
        C3X$jscomp$44.RequireFiniteNumber(a);
        map$jscomp$33.get(this)._SetImageScaleX(a)
    }
    get imageScaleX() {
        return map$jscomp$33.get(this)._GetImageScaleX()
    }
    set imageScaleY(a) {
        C3X$jscomp$44.RequireFiniteNumber(a);
        map$jscomp$33.get(this)._SetImageScaleY(a)
    }
    get imageScaleY() {
        return map$jscomp$33.get(this)._GetImageScaleY()
    }
    setImageScale(a, b) {
        C3X$jscomp$44.RequireFiniteNumber(a);
        C3X$jscomp$44.RequireFiniteNumber(b);
        const c = map$jscomp$33.get(this);
        c._SetImageScaleX(a);
        c._SetImageScaleY(b)
    }
    getImageScale() {
        const a = map$jscomp$33.get(this);
        return [a._GetImageScaleX(), a._GetImageScaleY()]
    }
    set imageAngle(a) {
        C3X$jscomp$44.RequireFiniteNumber(a);
        map$jscomp$33.get(this)._SetImageAngle(a)
    }
    get imageAngle() {
        return map$jscomp$33.get(this)._GetImageAngle()
    }
    set imageAngleDegrees(a) {
        C3X$jscomp$44.RequireFiniteNumber(a);
        map$jscomp$33.get(this)._SetImageAngle(C3$jscomp$291.toRadians(a))
    }
    get imageAngleDegrees() {
        return C3$jscomp$291.toDegrees(map$jscomp$33.get(this)._GetImageAngle())
    }
    get imageWidth() {
        return map$jscomp$33.get(this).GetCurrentImageInfo().GetWidth()
    }
    get imageHeight() {
        return map$jscomp$33.get(this).GetCurrentImageInfo().GetHeight()
    }
    getImageSize() {
        const a = map$jscomp$33.get(this).GetCurrentImageInfo();
        return [a.GetWidth(), a.GetHeight()]
    }
    set enableTileRandomization(a) {
        map$jscomp$33.get(this)._SetTileRandomizationEnabled(!!a)
    }
    get enableTileRandomization() {
        return map$jscomp$33.get(this)._IsTileRandomizationEnabled()
    }
    set tileXRandom(a) {
        C3X$jscomp$44.RequireFiniteNumber(a);
        map$jscomp$33.get(this)._SetTileXRandom(a)
    }
    get tileXRandom() {
        return map$jscomp$33.get(this)._GetTileXRandom()
    }
    set tileYRandom(a) {
        C3X$jscomp$44.RequireFiniteNumber(a);
        map$jscomp$33.get(this)._SetTileYRandom(a)
    }
    get tileYRandom() {
        return map$jscomp$33.get(this)._GetTileYRandom()
    }
    setTileRandom(a, b) {
        C3X$jscomp$44.RequireFiniteNumber(a);
        C3X$jscomp$44.RequireFiniteNumber(b);
        const c = map$jscomp$33.get(this);
        c._SetTileXRandom(a);
        c._SetTileYRandom(b)
    }
    getTileRandom() {
        const a = map$jscomp$33.get(this);
        return [a._GetTileXRandom(), a._GetTileYRandom()]
    }
    set tileAngleRandom(a) {
        C3X$jscomp$44.RequireFiniteNumber(a);
        map$jscomp$33.get(this)._SetTileAngleRandom(a)
    }
    get tileAngleRandom() {
        return map$jscomp$33.get(this)._GetTileAngleRandom()
    }
    set tileBlendMarginX(a) {
        C3X$jscomp$44.RequireFiniteNumber(a);
        map$jscomp$33.get(this)._SetTileBlendMarginX(a)
    }
    get tileBlendMarginX() {
        return map$jscomp$33.get(this)._GetTileBlendMarginX()
    }
    set tileBlendMarginY(a) {
        C3X$jscomp$44.RequireFiniteNumber(a);
        map$jscomp$33.get(this)._SetTileBlendMarginY(a)
    }
    get tileBlendMarginY() {
        return map$jscomp$33.get(this)._GetTileBlendMarginY()
    }
    setTileBlendMargin(a, b) {
        C3X$jscomp$44.RequireFiniteNumber(a);
        C3X$jscomp$44.RequireFiniteNumber(b);
        const c = map$jscomp$33.get(this);
        c._SetTileBlendMarginX(a);
        c._SetTileBlendMarginY(b)
    }
    getTileBlendMargin() {
        const a = map$jscomp$33.get(this);
        return [a._GetTileBlendMarginX(), a._GetTileBlendMarginY()]
    }
    async replaceImage(a) {
        C3X$jscomp$44.RequireInstanceOf(a, Blob);
        const b = map$jscomp$33.get(this)
          , c = b.GetRuntime()
          , d = C3$jscomp$291.New(C3$jscomp$291.ImageInfo);
        d.LoadDynamicBlobAsset(c, a);
        await d.LoadStaticTexture(c.GetRenderer(), {
            sampling: c.GetSampling(),
            wrapX: "repeat",
            wrapY: "repeat"
        });
        b.WasReleased() ? d.Release() : (b._ReleaseOwnImage(),
        b._ownImageInfo = d,
        c.UpdateRender())
    }
}
;
self.C3.Plugins.TiledBg.Cnds = {
    OnURLLoaded() {
        return !0
    },
    OnURLFailed() {
        return !0
    },
    IsTileRandomizationEnabled() {
        return this._IsTileRandomizationEnabled()
    }
};
const C3$jscomp$293 = self.C3;
C3$jscomp$293.Plugins.TiledBg.Acts = {
    SetImageOffsetX(a) {
        this._SetImageOffsetX(a)
    },
    SetImageOffsetY(a) {
        this._SetImageOffsetY(a)
    },
    SetImageScaleX(a) {
        this._SetImageScaleX(a / 100)
    },
    SetImageScaleY(a) {
        this._SetImageScaleY(a / 100)
    },
    SetImageAngle(a) {
        this._SetImageAngle(C3$jscomp$293.toRadians(a))
    },
    SetTileRandomizationEnabled(a) {
        this._SetTileRandomizationEnabled(a)
    },
    SetTilePosRandom(a, b) {
        this._SetTileXRandom(a / 100);
        this._SetTileYRandom(b / 100)
    },
    SetTileAngleRandom(a) {
        this._SetTileAngleRandom(a / 100)
    },
    SetTileBlendMargin(a, b) {
        this._SetTileBlendMarginX(a / 100);
        this._SetTileBlendMarginY(b / 100)
    },
    SetEffect(a) {
        this.GetWorldInfo().SetBlendMode(a);
        this._runtime.UpdateRender()
    },
    async LoadURL(a, b) {
        if (!this._ownImageInfo || this._ownImageInfo.GetURL() !== a) {
            b = this._runtime;
            var c = C3$jscomp$293.New(C3$jscomp$293.ImageInfo);
            try {
                await c.LoadDynamicAsset(b, a);
                if (!c.IsLoaded())
                    throw Error("image failed to load");
                if (this.WasReleased())
                    return c.Release(),
                    null;
                if (!await c.LoadStaticTexture(b.GetRenderer(), {
                    sampling: b.GetSampling(),
                    wrapX: "repeat",
                    wrapY: "repeat"
                }))
                    return
            } catch (d) {
                console.error("Load image from URL failed: ", d);
                this.WasReleased() || this.Trigger(C3$jscomp$293.Plugins.TiledBg.Cnds.OnURLFailed);
                return
            }
            this.WasReleased() ? c.Release() : (this._ReleaseOwnImage(),
            this._ownImageInfo = c,
            b.UpdateRender(),
            await this.TriggerAsync(C3$jscomp$293.Plugins.TiledBg.Cnds.OnURLLoaded))
        }
    }
};
const C3$jscomp$294 = self.C3;
C3$jscomp$294.Plugins.TiledBg.Exps = {
    ImageWidth() {
        return this.GetCurrentImageInfo().GetWidth()
    },
    ImageHeight() {
        return this.GetCurrentImageInfo().GetHeight()
    },
    ImageOffsetX() {
        return this._imageOffsetX
    },
    ImageOffsetY() {
        return this._imageOffsetY
    },
    ImageScaleX() {
        return 100 * this._imageScaleX
    },
    ImageScaleY() {
        return 100 * this._imageScaleY
    },
    ImageAngle() {
        return C3$jscomp$294.toDegrees(this._imageAngle)
    },
    TileXRandom() {
        return 100 * this._GetTileXRandom()
    },
    TileYRandom() {
        return 100 * this._GetTileYRandom()
    },
    TileAngleRandom() {
        return 100 * this._GetTileAngleRandom()
    },
    TileBlendMarginX() {
        return 100 * this._GetTileBlendMarginX()
    },
    TileBlendMarginY() {
        return 100 * this._GetTileBlendMarginY()
    }
};
"use strict";
const C3$jscomp$295 = self.C3;
C3$jscomp$295.Plugins.NinePatch = class extends C3$jscomp$295.SDKPluginBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
}
;
const C3$jscomp$296 = self.C3;
C3$jscomp$296.Plugins.NinePatch.Type = class extends C3$jscomp$296.SDKTypeBase {
    constructor(a) {
        super(a);
        this._drawable = this._textureSet = null
    }
    Release() {
        this.ReleaseTextures();
        super.Release()
    }
    OnCreate() {
        this.GetImageInfo().LoadAsset(this._runtime)
    }
    async LoadTextures(a) {
        this._drawable = await this.GetImageInfo().ExtractImageToCanvas()
    }
    CreatePatch(a, b, c, d) {
        !this._textureSet && this._drawable && (this._textureSet = new self.NinePatchTextureSet(this),
        this._textureSet.CreateTextures(this._drawable, a, b, c, d))
    }
    ReleaseTextures() {
        this._textureSet && (this._textureSet.Release(),
        this._textureSet = null)
    }
    GetTextureSet() {
        return this._textureSet
    }
}
;
const C3$jscomp$297 = self.C3
  , tempRect1 = C3$jscomp$297.New(C3$jscomp$297.Rect)
  , tempRect2$jscomp$2 = C3$jscomp$297.New(C3$jscomp$297.Rect)
  , tempQuad$jscomp$9 = C3$jscomp$297.New(C3$jscomp$297.Quad);
C3$jscomp$297.Plugins.NinePatch.Instance = class extends C3$jscomp$297.SDKWorldInstanceBase {
    constructor(a, b) {
        super(a);
        this._bottomMargin = this._topMargin = this._rightMargin = this._leftMargin = 16;
        this._fill = this._edges = 1;
        this._isSeamless = !0;
        this._callback3d = null;
        b && (this._leftMargin = b[0],
        this._rightMargin = b[1],
        this._topMargin = b[2],
        this._bottomMargin = b[3],
        this._edges = b[4],
        this._fill = b[5],
        this._isSeamless = !!b[8],
        this.GetWorldInfo().SetVisible(!!b[6]));
        this._sdkType.CreatePatch(this._leftMargin, this._rightMargin, this._topMargin, this._bottomMargin)
    }
    Release() {
        super.Release()
    }
    _Set3DCallback(a) {
        this._callback3d = a
    }
    Draw(a) {
        const b = this.GetWorldInfo()
          , c = b.GetBoundingQuad();
        this._Draw(a, c.getTlx(), c.getTly(), b.GetWidth(), b.GetHeight())
    }
    _Draw(a, b, c, d, e) {
        let f = this._sdkType.GetTextureSet();
        if (!f && (this._sdkType.CreatePatch(this._leftMargin, this._rightMargin, this._topMargin, this._bottomMargin),
        f = this._sdkType.GetTextureSet(),
        !f))
            return;
        var h = f.GetImageWidth()
          , l = f.GetImageHeight();
        const m = Math.min(this._leftMargin, h)
          , p = Math.min(this._rightMargin, h)
          , r = Math.min(this._topMargin, l)
          , v = Math.min(this._bottomMargin, l);
        h -= p;
        l -= v;
        var x = this._isSeamless ? 1 : 0;
        const B = this._edges
          , A = this._fill;
        0 < m && 0 < r && this._DrawPatch(a, f.GetTexture(), 0, 0, m + x, r + x, b, c, m + x, r + x);
        0 < p && 0 < r && this._DrawPatch(a, f.GetTexture(), h - x, 0, p + x, r + x, b + d - p - x, c, p + x, r + x);
        0 < p && 0 < v && this._DrawPatch(a, f.GetTexture(), h - x, l - x, p + x, v + x, b + d - p - x, c + e - v - x, p + x, v + x);
        0 < m && 0 < v && this._DrawPatch(a, f.GetTexture(), 0, l - x, m + x, v + x, b, c + e - v - x, m + x, v + x);
        0 === B ? (x = 2 === A ? 0 : x,
        0 < m && l > r && this._TilePatch(a, f.GetLeftTexture(), b, c + r, m + x, e - r - v, 0, 0),
        0 < p && l > r && this._TilePatch(a, f.GetRightTexture(), b + d - p - x, c + r, p + x, e - r - v, x, 0),
        0 < r && h > m && this._TilePatch(a, f.GetTopTexture(), b + m, c, d - m - p, r + x, 0, 0),
        0 < v && h > m && this._TilePatch(a, f.GetBottomTexture(), b + m, c + e - v - x, d - m - p, v + x, 0, x)) : 1 === B && (0 < m && l > r && this._DrawPatch(a, f.GetTexture(), 0, r, m, l - r, b, c + r, m, e - r - v),
        0 < p && l > r && this._DrawPatch(a, f.GetTexture(), h, r, p, l - r, b + d - p, c + r, p, e - r - v),
        0 < r && h > m && this._DrawPatch(a, f.GetTexture(), m, 0, h - m, r, b + m, c, d - m - p, r),
        0 < v && h > m && this._DrawPatch(a, f.GetTexture(), m, l, h - m, v, b + m, c + e - v, d - m - p, v));
        l > r && h > m && (0 === A ? this._TilePatch(a, f.GetFillTexture(), b + m, c + r, d - m - p, e - r - v, 0, 0) : 1 === A && this._DrawPatch(a, f.GetTexture(), m, r, h - m, l - r, b + m, c + r, d - m - p, e - r - v))
    }
    _DrawPatch(a, b, c, d, e, f, h, l, m, p) {
        const r = b.GetWidth()
          , v = b.GetHeight();
        a.SetTexture(b);
        tempRect1.set(h, l, h + m, l + p);
        tempRect2$jscomp$2.set(c / r, d / v, (c + e) / r, (d + f) / v);
        null === this._callback3d ? (b = this.GetWorldInfo(),
        d = b.GetBoundingQuad(),
        c = d.getTlx(),
        d = d.getTly(),
        tempRect1.offset(-c, -d),
        tempQuad$jscomp$9.setFromRotatedRect(tempRect1, b.GetAngle()),
        tempQuad$jscomp$9.offset(c, d),
        a.Quad3(tempQuad$jscomp$9, tempRect2$jscomp$2)) : this._callback3d(tempRect1, tempRect2$jscomp$2)
    }
    _TilePatch(a, b, c, d, e, f, h, l) {
        const m = b.GetWidth()
          , p = b.GetHeight();
        a.SetTexture(b);
        tempRect1.set(c, d, c + e, d + f);
        tempRect2$jscomp$2.set(-h / m, -l / p, (e - h) / m, (f - l) / p);
        null === this._callback3d ? (b = this.GetWorldInfo(),
        d = b.GetBoundingQuad(),
        c = d.getTlx(),
        d = d.getTly(),
        tempRect1.offset(-c, -d),
        tempQuad$jscomp$9.setFromRotatedRect(tempRect1, b.GetAngle()),
        tempQuad$jscomp$9.offset(c, d),
        a.Quad3(tempQuad$jscomp$9, tempRect2$jscomp$2)) : this._callback3d(tempRect1, tempRect2$jscomp$2)
    }
    GetCurrentImageInfo() {
        this._objectClass.GetImageInfo()
    }
    GetPropertyValueByIndex(a) {}
    SetPropertyValueByIndex(a, b) {}
}
;
self.C3.Plugins.NinePatch.Cnds = {};
self.C3.Plugins.NinePatch.Acts = {
    SetEffect(a) {
        this.GetWorldInfo().SetBlendMode(a);
        this._runtime.UpdateRender()
    }
};
self.C3.Plugins.NinePatch.Exps = {};
"use strict";
const C3$jscomp$301 = self.C3;
function CloneDrawable(a) {
    const b = C3$jscomp$301.CreateCanvas(a.width, a.height);
    b.getContext("2d").drawImage(a, 0, 0);
    return b
}
self.NinePatchTextureSet = class {
    constructor(a) {
        this._sdkType = a;
        this._runtime = this._sdkType.GetRuntime();
        this._bottomTexture = this._topTexture = this._rightTexture = this._leftTexture = this._fillTexture = this._texture = null;
        this._imageHeight = this._imageWidth = 0;
        this._renderer = this._runtime.GetRenderer();
        this._wasReleased = this._isLoading = !1
    }
    Release() {
        this._renderer.IsContextLost() || (this._renderer.DeleteTexture(this._texture),
        this._renderer.DeleteTexture(this._fillTexture),
        this._renderer.DeleteTexture(this._leftTexture),
        this._renderer.DeleteTexture(this._rightTexture),
        this._renderer.DeleteTexture(this._topTexture),
        this._renderer.DeleteTexture(this._bottomTexture));
        this._renderer = this._sdkType = this._bottomTexture = this._topTexture = this._rightTexture = this._leftTexture = this._fillTexture = this._texture = null;
        this._wasReleased = !0
    }
    WasReleased() {
        return this._wasReleased
    }
    CreateTextures(a, b, c, d, e) {
        this._SliceImage(a, b, c, d, e)
    }
    HasCreatedTextures() {
        return !!this._texture
    }
    _SliceImage(a, b, c, d, e) {
        if (!this._wasReleased) {
            var f = a.width
              , h = a.height;
            this._imageWidth = f;
            this._imageHeight = h;
            b = Math.min(Math.floor(b), f);
            c = Math.min(Math.floor(c), f);
            d = Math.min(Math.floor(d), h);
            e = Math.min(Math.floor(e), h);
            var l = f - c
              , m = h - e
              , p = this._runtime.GetSampling()
              , r = this._runtime.GetCanvasManager().GetTextureAnisotropy();
            this._texture = this._renderer.CreateStaticTexture(CloneDrawable(a), {
                sampling: p,
                anisotropy: r
            });
            l > b && m > d && (this._fillTexture = this._renderer.CreateStaticTexture(this._SliceSubImage(CloneDrawable(a), b, d, l, m), {
                wrapX: "repeat",
                wrapY: "repeat",
                sampling: p,
                anisotropy: r
            }));
            0 < b && m > d && (this._leftTexture = this._renderer.CreateStaticTexture(this._SliceSubImage(CloneDrawable(a), 0, d, b, m), {
                wrapY: "repeat",
                sampling: p,
                anisotropy: r
            }));
            0 < c && m > d && (this._rightTexture = this._renderer.CreateStaticTexture(this._SliceSubImage(CloneDrawable(a), l, d, f, m), {
                wrapY: "repeat",
                sampling: p,
                anisotropy: r
            }));
            0 < d && l > b && (this._topTexture = this._renderer.CreateStaticTexture(this._SliceSubImage(CloneDrawable(a), b, 0, l, d), {
                wrapX: "repeat",
                sampling: p,
                anisotropy: r
            }));
            0 < e && l > b && (this._bottomTexture = this._renderer.CreateStaticTexture(this._SliceSubImage(CloneDrawable(a), b, m, l, h), {
                wrapX: "repeat",
                sampling: p,
                anisotropy: r
            }))
        }
    }
    _SliceSubImage(a, b, c, d, e) {
        d -= b;
        e -= c;
        const f = C3$jscomp$301.CreateCanvas(d, e);
        f.getContext("2d").drawImage(a, b, c, d, e, 0, 0, d, e);
        return f
    }
    GetImageWidth() {
        return this._imageWidth
    }
    GetImageHeight() {
        return this._imageHeight
    }
    GetTexture() {
        return this._texture
    }
    GetFillTexture() {
        return this._fillTexture
    }
    GetLeftTexture() {
        return this._leftTexture
    }
    GetRightTexture() {
        return this._rightTexture
    }
    GetTopTexture() {
        return this._topTexture
    }
    GetBottomTexture() {
        return this._bottomTexture
    }
}
;
"use strict";
const C3$jscomp$302 = self.C3;
C3$jscomp$302.Plugins.Particles = class extends C3$jscomp$302.SDKPluginBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
}
;
const C3$jscomp$303 = self.C3;
C3$jscomp$303.Plugins.Particles.Type = class extends C3$jscomp$303.SDKTypeBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
    OnCreate() {
        this.GetImageInfo().LoadAsset(this._runtime)
    }
    LoadTextures(a) {
        return this.GetImageInfo().LoadStaticTexture(a, {
            sampling: this._runtime.GetSampling()
        })
    }
    ReleaseTextures() {
        this.GetImageInfo().ReleaseTexture()
    }
}
;
const C3$jscomp$304 = self.C3
  , C3X$jscomp$45 = self.C3X
  , tempRect$jscomp$13 = C3$jscomp$304.New(C3$jscomp$304.Rect);
C3$jscomp$304.Plugins.Particles.Instance = class extends C3$jscomp$304.SDKWorldInstanceBase {
    constructor(a, b) {
        super(a);
        this._isFirstTick = !0;
        this._particleEngine = a = C3$jscomp$304.New(self.ParticleEngine);
        a.ononeshotfinish = () => this._OnOneShotFinish();
        this._spawnObjectClass = null;
        this._particleUpdateCallback = (e, f, h, l, m, p) => this._OnParticleUpdate(e, f, h, l, m, p);
        this._particleDestroyCallback = e => this._OnParticleDestroy(e);
        let c = this._hasAnyDefaultParticle = !0;
        b && (a.SetRate(b[0]),
        a.SetSprayCone(C3$jscomp$304.toRadians(b[1])),
        a.SetSprayType(b[2] ? "one-shot" : "continuous-spray"),
        this._SetParticleObjectClass(this._runtime.GetObjectClassBySID(b[3])),
        c = b[4],
        a.SetInitSpeed(b[5]),
        a.SetInitSize(b[6]),
        a.SetInitOpacity(b[7] / 100),
        a.SetGrowRate(b[8]),
        a.SetInitXRandom(b[9]),
        a.SetInitYRandom(b[10]),
        a.SetInitSpeedRandom(b[11]),
        a.SetInitSizeRandom(b[12]),
        a.SetGrowRandom(b[13]),
        a.SetAcceleration(b[14]),
        a.SetGravity(b[15]),
        a.SetLifeAngleRandom(b[16]),
        a.SetLifeSpeedRandom(b[17]),
        a.SetLifeOpacityRandom(b[18]),
        a.SetDestroyModeIndex(b[19]),
        a.SetTimeout(b[20]));
        this._UpdateEngineParameters();
        this._spawnObjectClass && (this._hasAnyDefaultParticle = !1);
        "one-shot" === a.GetSprayType() ? a.CreateOneShotSpray() : a.SetSpraying(!0);
        const d = this.GetWorldInfo();
        d.SetVisible(c);
        d.SetBboxChangeEventEnabled(!0);
        this._inst.Dispatcher().addEventListener("bboxchange", () => {
            d.OverwriteBoundingBox(this._particleEngine.GetBoundingBox())
        }
        );
        this.GetRuntime().GetRenderer().IsWebGPU() && d.SetUsePointsShaderProgram();
        this._afterLoad = e => this._OnAfterLoad(e);
        this.GetRuntime().Dispatcher().addEventListener("afterload", this._afterLoad);
        this._StartTicking()
    }
    Release() {
        this.GetRuntime().Dispatcher().removeEventListener("afterload", this._afterLoad);
        this._afterLoad = null;
        this._particleEngine.Release();
        this._particleDestroyCallback = this._particleUpdateCallback = this._particleEngine = null;
        super.Release()
    }
    GetParticleEngine() {
        return this._particleEngine
    }
    _SetRate(a) {
        this._particleEngine.SetRate(a);
        "one-shot" === this._particleEngine.GetSprayType() && this._isFirstTick && this._particleEngine.SetParticleCount(a)
    }
    _SetParticleObjectClass(a) {
        a === this.GetObjectClass() && (a = null);
        a !== this._spawnObjectClass && (this._spawnObjectClass = a,
        this._particleEngine.onparticlecreate = a ? b => this._OnParticleCreate(b) : null,
        this._spawnObjectClass || (this._hasAnyDefaultParticle = !0))
    }
    _UpdateEngineParameters() {
        const a = this._particleEngine
          , b = this.GetWorldInfo();
        a.SetMasterOpacity(b.GetOpacity());
        a.SetPixelRounding(this._runtime.IsPixelRoundingEnabled());
        a.SetSpawnX(b.GetX());
        a.SetSpawnY(b.GetY());
        a.SetSpawnAngle(b.GetAngle());
        a.SetInitSizeScale(Math.abs(b.GetSceneGraphScale()))
    }
    _OnOneShotFinish() {
        this._runtime.DestroyInstance(this._inst)
    }
    Draw(a) {
        if (this._hasAnyDefaultParticle) {
            var b = this._objectClass.GetImageInfo()
              , c = b.GetTexture();
            if (c) {
                var d = this.GetWorldInfo()
                  , e = d.GetLayer();
                this._runtime.GetCanvasManager().IsPastingToDrawingCanvas() ? tempRect$jscomp$13.set(-Infinity, -Infinity, Infinity, Infinity) : e.Has3DCamera() ? e.CalculateViewport3D(d.GetTotalZElevation(), tempRect$jscomp$13) : e.GetViewportForZ(d.GetTotalZElevation(), tempRect$jscomp$13);
                a.SetTexture(c);
                c = e.Get2DScaleFactorToZ(d.GetTotalZElevation());
                this._particleEngine.SetParticleScale(e.GetRenderScale() * c);
                this._particleEngine.Draw(a, b.GetTexQuad(), tempRect$jscomp$13, e.Has3DCamera())
            }
        }
    }
    SaveToJson() {
        const a = this._particleEngine;
        return {
            r: a.GetRate(),
            sc: a.GetSprayCone(),
            st: a.GetSprayType(),
            isp: a.GetInitSpeed(),
            isz: a.GetInitSize(),
            io: a.GetInitOpacity(),
            gr: a.GetGrowRate(),
            xr: a.GetInitXRandom(),
            yr: a.GetInitYRandom(),
            spr: a.GetInitSpeedRandom(),
            szr: a.GetInitSizeRandom(),
            grnd: a.GetGrowRandom(),
            acc: a.GetAcceleration(),
            g: a.GetGravity(),
            lar: a.GetLifeAngleRandom(),
            lsr: a.GetLifeSpeedRandom(),
            lor: a.GetLifeOpacityRandom(),
            dm: a.GetDestroyModeIndex(),
            to: a.GetTimeout(),
            s: a.IsSpraying(),
            pcc: a._GetCreateCounter(),
            ft: this._isFirstTick,
            soc: this._spawnObjectClass ? this._spawnObjectClass.GetSID() : null,
            p: a.GetParticles().map(b => b.toJSON())
        }
    }
    LoadFromJson(a, b) {
        const c = this._particleEngine;
        c.SetRate(a.r);
        c.SetSprayCone(a.sc);
        c.SetSprayType(a.st);
        c.SetInitSpeed(a.isp);
        c.SetInitSize(a.isz);
        c.SetInitOpacity(a.io);
        c.SetGrowRate(a.gr);
        c.SetInitXRandom(a.xr);
        c.SetInitYRandom(a.yr);
        c.SetInitSpeedRandom(a.spr);
        c.SetInitSizeRandom(a.szr);
        c.SetGrowRandom(a.grnd);
        c.SetAcceleration(a.acc);
        c.SetGravity(a.g);
        c.SetLifeAngleRandom(a.lar);
        c.SetLifeSpeedRandom(a.lsr);
        c.SetLifeOpacityRandom(a.lor);
        c.SetDestroyModeIndex(a.dm);
        c.SetTimeout(a.to);
        c.SetSpraying(a.s);
        c._SetCreateCounter(a.pcc);
        this._isFirstTick = a.ft;
        if (a.hasOwnProperty("soc")) {
            var d = this.GetRuntime().GetObjectClassBySID(a.soc);
            d && this._SetParticleObjectClass(d)
        }
        a = a.p;
        c.SetParticleCount(a.length, !1);
        d = c.GetParticles();
        for (let e = 0, f = d.length; e < f; ++e)
            d[e].setFromJSON(a[e]);
        "state" === b && this._spawnObjectClass && (c.UpdateAllParticlesUserData(),
        c.ApplyParticleDataToUserData(this))
    }
    _OnAfterLoad() {
        var a = this._particleEngine;
        a.UpdateAllParticlesUserData();
        a.ApplyParticleDataToUserData(this);
        a = a.GetParticles();
        for (let d = 0, e = a.length; d < e; ++d) {
            var b = a[d]
              , c = b.GetUserData();
            c && (c = c.GetWorldInfo()) && (c = c.GetInstance()) && (b = b.GetUserDataUID(),
            c = c.GetUID(),
            "number" === typeof b && "number" === typeof c && b === c || "number" !== typeof b || (c = this.GetRuntime(),
            (b = c.GetInstanceByUID(b)) && c.DestroyInstance(b)))
        }
    }
    Tick() {
        const a = this._runtime.GetDt(this._inst);
        this._UpdateEngineParameters();
        this._isFirstTick && "one-shot" === this._particleEngine.GetSprayType() && this._particleEngine.ReInitAllParticles();
        this._particleEngine.Tick(a);
        this._particleEngine.IsSpraying() && this._runtime.UpdateRender();
        this.GetWorldInfo().SetBboxChanged();
        this._isFirstTick = !1
    }
    _FastForward(a) {
        const b = 1 / 60;
        for (this._isFirstTick && "one-shot" === this._particleEngine.GetSprayType() && this._particleEngine.ReInitAllParticles(); 0 < a; )
            this._particleEngine.Tick(b),
            a -= b;
        this._particleEngine.IsSpraying() && this._runtime.UpdateRender();
        this.GetWorldInfo().SetBboxChanged();
        this._isFirstTick = !1
    }
    _OnParticleCreate(a, b) {
        let c;
        "number" === typeof b && (c = this._runtime.GetInstanceByUID(b));
        c && c.GetObjectClass() !== this._spawnObjectClass && (c = null);
        c || (c = this._runtime.CreateInstance(this._spawnObjectClass, this.GetWorldInfo().GetLayer(), a.GetX(), a.GetY()));
        b = c.GetWorldInfo();
        b.SetSize(a.GetSize(), a.GetSize());
        b.SetAngle(a.GetAngle());
        b.SetOpacity(a.GetOpacity());
        b.SetUnpremultipliedColor(this.GetWorldInfo().GetUnpremultipliedColor());
        b.SetBboxChanged();
        b.ZOrderMoveAdjacentToInstance(this.GetInstance(), !0);
        c._TriggerOnCreated();
        a.SetUpdateCallback(this._particleUpdateCallback);
        a.SetDestroyCallback(this._particleDestroyCallback);
        return c
    }
    _OnParticleUpdate(a, b, c, d, e, f) {
        a.IsDestroyed() || (a = a.GetWorldInfo(),
        a.OffsetXY(b, c),
        a.SetSize(a.GetWidth() + d, a.GetHeight() + d),
        a.SetAngle(a.GetAngle() + e),
        a.SetOpacity(a.GetOpacity() + f),
        a.SetBboxChanged())
    }
    _OnParticleDestroy(a) {
        a.IsDestroyed() || this._runtime.DestroyInstance(a)
    }
    GetPropertyValueByIndex(a) {
        const b = this._particleEngine;
        switch (a) {
        case 0:
            return b.GetRate();
        case 1:
            return C3$jscomp$304.toDegrees(b.GetSprayCone());
        case 2:
            return "one-shot" === b.GetSprayType() ? 1 : 0;
        case 5:
            return b.GetInitSpeed();
        case 6:
            return b.GetInitSize();
        case 7:
            return 100 * b.GetInitOpacity();
        case 8:
            return b.GetGrowRate();
        case 9:
            return b.GetInitXRandom();
        case 10:
            return b.GetInitYRandom();
        case 11:
            return b.GetInitSpeedRandom();
        case 12:
            return b.GetInitSizeRandom();
        case 13:
            return b.GetGrowRandom();
        case 14:
            return b.GetAcceleration();
        case 15:
            return b.GetGravity();
        case 16:
            return b.GetLifeAngleRandom();
        case 17:
            return b.GetLifeSpeedRandom();
        case 18:
            return b.GetLifeOpacityRandom();
        case 19:
            return b.GetDestroyModeIndex();
        case 20:
            return b.GetTimeout()
        }
    }
    SetPropertyValueByIndex(a, b) {
        const c = this._particleEngine;
        switch (a) {
        case 0:
            c.SetRate(b);
            break;
        case 1:
            c.SetSprayCone(C3$jscomp$304.toRadians(b));
            break;
        case 2:
            c.SetSprayType(b ? "one-shot" : "continuous-spray");
            break;
        case 5:
            c.SetInitSpeed(b);
            break;
        case 6:
            c.SetInitSize(b);
            break;
        case 7:
            c.SetInitOpacity(b / 100);
            break;
        case 8:
            c.SetGrowRate(b);
            break;
        case 9:
            c.SetInitXRandom(b);
            break;
        case 10:
            c.SetInitYRandom(b);
            break;
        case 11:
            c.SetInitSpeedRandom(b);
            break;
        case 12:
            c.SetInitSizeRandom(b);
            break;
        case 13:
            c.SetGrowRandom(b);
            break;
        case 14:
            c.SetAcceleration(b);
            break;
        case 15:
            c.SetGravity(b);
            break;
        case 16:
            c.SetLifeAngleRandom(b);
            break;
        case 17:
            c.SetLifeSpeedRandom(b);
            break;
        case 18:
            c.SetLifeOpacityRandom(b);
            break;
        case 19:
            c.SetDestroyModeIndex(b);
            break;
        case 20:
            c.SetTimeout(b)
        }
    }
    GetDebuggerProperties() {
        const a = this._particleEngine;
        return [{
            title: "plugins.particles.name",
            properties: [{
                name: "plugins.particles.debugger.particle-count",
                value: a.GetParticleCount()
            }, {
                name: "plugins.particles.properties.type.name",
                value: ["plugins.particles.properties.type.items." + a.GetSprayType()]
            }, {
                name: "plugins.particles.debugger.is-spraying",
                value: a.IsSpraying(),
                onedit: b => a.SetSpraying(b)
            }, {
                name: "plugins.particles.properties.rate.name",
                value: a.GetRate(),
                onedit: b => a.SetRate(b)
            }, {
                name: "plugins.particles.properties.spray-cone.name",
                value: C3$jscomp$304.toDegrees(a.GetSprayCone()),
                onedit: b => a.SetSprayCone(C3$jscomp$304.toRadians(b))
            }, {
                name: "plugins.particles.properties.speed.name",
                value: a.GetInitSpeed(),
                onedit: b => a.SetInitSpeed(b)
            }, {
                name: "plugins.particles.properties.size.name",
                value: a.GetInitSize(),
                onedit: b => a.SetInitSize(b)
            }, {
                name: "plugins.particles.properties.opacity.name",
                value: a.GetInitOpacity(),
                onedit: b => a.SetInitOpacity(b)
            }, {
                name: "plugins.particles.properties.grow-rate.name",
                value: a.GetGrowRate(),
                onedit: b => a.SetGrowRate(b)
            }, {
                name: "plugins.particles.properties.x-randomiser.name",
                value: a.GetInitXRandom(),
                onedit: b => a.SetInitXRandom(b)
            }, {
                name: "plugins.particles.properties.y-randomiser.name",
                value: a.GetInitYRandom(),
                onedit: b => a.SetInitYRandom(b)
            }, {
                name: "plugins.particles.properties.initial-speed-randomiser.name",
                value: a.GetInitSpeedRandom(),
                onedit: b => a.SetInitSpeedRandom(b)
            }, {
                name: "plugins.particles.properties.size-randomiser.name",
                value: a.GetInitSizeRandom(),
                onedit: b => a.SetInitSizeRandom(b)
            }, {
                name: "plugins.particles.properties.grow-rate-randomiser.name",
                value: a.GetGrowRandom(),
                onedit: b => a.SetGrowRandom(b)
            }, {
                name: "plugins.particles.properties.acceleration.name",
                value: a.GetAcceleration(),
                onedit: b => a.SetAcceleration(b)
            }, {
                name: "plugins.particles.properties.gravity.name",
                value: a.GetGravity(),
                onedit: b => a.SetGravity(b)
            }, {
                name: "plugins.particles.properties.angle-randomiser.name",
                value: a.GetLifeAngleRandom(),
                onedit: b => a.SetLifeAngleRandom(b)
            }, {
                name: "plugins.particles.properties.life-speed-randomiser.name",
                value: a.GetLifeSpeedRandom(),
                onedit: b => a.SetLifeSpeedRandom(b)
            }, {
                name: "plugins.particles.properties.opacity-randomiser.name",
                value: a.GetLifeOpacityRandom(),
                onedit: b => a.SetLifeOpacityRandom(b)
            }, {
                name: "plugins.particles.properties.timeout.name",
                value: a.GetTimeout(),
                onedit: b => a.SetTimeout(b)
            }]
        }]
    }
    GetScriptInterfaceClass() {
        return self.IParticlesInstance
    }
}
;
const map$jscomp$34 = new WeakMap;
function GetParticleEngine(a) {
    return map$jscomp$34.get(a).GetParticleEngine()
}
self.IParticlesInstance = class extends self.IWorldInstance {
    constructor() {
        super();
        map$jscomp$34.set(this, self.IInstance._GetInitInst().GetSdkInstance())
    }
    set isSpraying(a) {
        GetParticleEngine(this).SetSpraying(!!a)
    }
    get isSpraying() {
        return GetParticleEngine(this).IsSpraying()
    }
    set rate(a) {
        C3X$jscomp$45.RequireFiniteNumber(a);
        map$jscomp$34.get(this)._SetRate(a)
    }
    get rate() {
        return GetParticleEngine(this).GetRate()
    }
    set sprayCone(a) {
        C3X$jscomp$45.RequireFiniteNumber(a);
        GetParticleEngine(this).SetSprayCone(a)
    }
    get sprayCone() {
        return GetParticleEngine(this).GetSprayCone()
    }
    set initSpeed(a) {
        C3X$jscomp$45.RequireFiniteNumber(a);
        GetParticleEngine(this).SetInitSpeed(a)
    }
    get initSpeed() {
        return GetParticleEngine(this).GetInitSpeed()
    }
    set initSize(a) {
        C3X$jscomp$45.RequireFiniteNumber(a);
        GetParticleEngine(this).SetInitSize(a)
    }
    get initSize() {
        return GetParticleEngine(this).GetInitSize()
    }
    set initOpacity(a) {
        C3X$jscomp$45.RequireFiniteNumber(a);
        GetParticleEngine(this).SetInitOpacity(a)
    }
    get initOpacity() {
        return GetParticleEngine(this).GetInitOpacity()
    }
    set initXRandom(a) {
        C3X$jscomp$45.RequireFiniteNumber(a);
        GetParticleEngine(this).SetInitXRandom(a)
    }
    get initXRandom() {
        return GetParticleEngine(this).GetInitXRandom()
    }
    set initYRandom(a) {
        C3X$jscomp$45.RequireFiniteNumber(a);
        GetParticleEngine(this).SetInitYRandom(a)
    }
    get initYRandom() {
        return GetParticleEngine(this).GetInitYRandom()
    }
    set initSpeedRandom(a) {
        C3X$jscomp$45.RequireFiniteNumber(a);
        GetParticleEngine(this).SetInitSpeedRandom(a)
    }
    get initSpeedRandom() {
        return GetParticleEngine(this).GetInitSpeedRandom()
    }
    set initSizeRandom(a) {
        C3X$jscomp$45.RequireFiniteNumber(a);
        GetParticleEngine(this).SetInitSizeRandom(a)
    }
    get initSizeRandom() {
        return GetParticleEngine(this).GetInitSizeRandom()
    }
    set initGrowRate(a) {
        C3X$jscomp$45.RequireFiniteNumber(a);
        GetParticleEngine(this).SetGrowRate(a)
    }
    get initGrowRate() {
        return GetParticleEngine(this).GetGrowRate()
    }
    set initGrowRandom(a) {
        C3X$jscomp$45.RequireFiniteNumber(a);
        GetParticleEngine(this).SetGrowRandom(a)
    }
    get initGrowRandom() {
        return GetParticleEngine(this).GetGrowRandom()
    }
    set acceleration(a) {
        C3X$jscomp$45.RequireFiniteNumber(a);
        GetParticleEngine(this).SetAcceleration(a)
    }
    get acceleration() {
        return GetParticleEngine(this).GetAcceleration()
    }
    set gravity(a) {
        C3X$jscomp$45.RequireFiniteNumber(a);
        GetParticleEngine(this).SetGravity(a)
    }
    get gravity() {
        return GetParticleEngine(this).GetGravity()
    }
    set lifeAngleRandom(a) {
        C3X$jscomp$45.RequireFiniteNumber(a);
        GetParticleEngine(this).SetLifeAngleRandom(a)
    }
    get lifeAngleRandom() {
        return GetParticleEngine(this).GetLifeAngleRandom()
    }
    set lifeSpeedRandom(a) {
        C3X$jscomp$45.RequireFiniteNumber(a);
        GetParticleEngine(this).SetLifeSpeedRandom(a)
    }
    get lifeSpeedRandom() {
        return GetParticleEngine(this).GetLifeSpeedRandom()
    }
    set lifeOpacityRandom(a) {
        C3X$jscomp$45.RequireFiniteNumber(a);
        GetParticleEngine(this).SetLifeOpacityRandom(a)
    }
    get lifeOpacityRandom() {
        return GetParticleEngine(this).GetLifeOpacityRandom()
    }
    set timeout(a) {
        C3X$jscomp$45.RequireFiniteNumber(a);
        GetParticleEngine(this).SetTimeout(a)
    }
    get timeout() {
        return GetParticleEngine(this).GetTimeout()
    }
    fastForward(a) {
        C3X$jscomp$45.RequireFiniteNumber(a);
        map$jscomp$34.get(this)._FastForward(a)
    }
    setParticleObjectClass(a) {
        const b = map$jscomp$34.get(this);
        a ? b._SetParticleObjectClass(b.GetRuntime()._UnwrapIObjectClass(a)) : b._SetParticleObjectClass(null)
    }
}
;
self.C3.Plugins.Particles.Cnds = {
    IsSpraying() {
        return this._particleEngine.IsSpraying()
    }
};
const C3$jscomp$306 = self.C3;
C3$jscomp$306.Plugins.Particles.Acts = {
    SetSpraying(a) {
        this._particleEngine.SetSpraying(0 !== a)
    },
    SetRate(a) {
        this._SetRate(a)
    },
    SetParticleObject(a) {
        this._SetParticleObjectClass(a)
    },
    UnsetParticleObject() {
        this._SetParticleObjectClass(null)
    },
    SetSprayCone(a) {
        this._particleEngine.SetSprayCone(C3$jscomp$306.toRadians(a))
    },
    SetInitSpeed(a) {
        this._particleEngine.SetInitSpeed(a)
    },
    SetInitSize(a) {
        this._particleEngine.SetInitSize(a)
    },
    SetInitOpacity(a) {
        this._particleEngine.SetInitOpacity(a / 100)
    },
    SetGrowRate(a) {
        this._particleEngine.SetGrowRate(a)
    },
    SetXRandomiser(a) {
        this._particleEngine.SetInitXRandom(a)
    },
    SetYRandomiser(a) {
        this._particleEngine.SetInitYRandom(a)
    },
    SetSpeedRandomiser(a) {
        this._particleEngine.SetInitSpeedRandom(a)
    },
    SetSizeRandomiser(a) {
        this._particleEngine.SetInitSizeRandom(a)
    },
    SetGrowRateRandomiser(a) {
        this._particleEngine.SetGrowRandom(a)
    },
    SetParticleAcc(a) {
        this._particleEngine.SetAcceleration(a)
    },
    SetGravity(a) {
        this._particleEngine.SetGravity(a)
    },
    SetAngleRandomiser(a) {
        this._particleEngine.SetLifeAngleRandom(a)
    },
    SetLifeSpeedRandomiser(a) {
        this._particleEngine.SetLifeSpeedRandom(a)
    },
    SetOpacityRandomiser(a) {
        this._particleEngine.SetLifeOpacityRandom(a)
    },
    SetTimeout(a) {
        this._particleEngine.SetTimeout(a)
    },
    FastForward(a) {
        this._FastForward(a)
    },
    SetEffect(a) {
        this.GetWorldInfo().SetBlendMode(a);
        this._runtime.UpdateRender()
    }
};
const C3$jscomp$307 = self.C3;
C3$jscomp$307.Plugins.Particles.Exps = {
    ParticleCount() {
        return this._particleEngine.GetParticleCount()
    },
    Rate() {
        return this._particleEngine.GetRate()
    },
    SprayCone() {
        return C3$jscomp$307.toDegrees(this._particleEngine.GetSprayCone())
    },
    InitSpeed() {
        return this._particleEngine.GetInitSpeed()
    },
    InitSize() {
        return this._particleEngine.GetInitSize()
    },
    InitOpacity() {
        return 100 * this._particleEngine.GetInitOpacity()
    },
    InitGrowRate() {
        return this._particleEngine.GetGrowRate()
    },
    XRandom() {
        return this._particleEngine.GetInitXRandom()
    },
    YRandom() {
        return this._particleEngine.GetInitYRandom()
    },
    InitSizeRandom() {
        return this._particleEngine.GetInitSizeRandom()
    },
    InitSpeedRandom() {
        return this._particleEngine.GetInitSpeedRandom()
    },
    InitGrowRandom() {
        return this._particleEngine.GetGrowRandom()
    },
    ParticleAcceleration() {
        return this._particleEngine.GetAcceleration()
    },
    Gravity() {
        return this._particleEngine.GetGravity()
    },
    ParticleAngleRandom() {
        return this._particleEngine.GetLifeAngleRandom()
    },
    ParticleSpeedRandom() {
        return this._particleEngine.GetLifeSpeedRandom()
    },
    ParticleOpacityRandom() {
        return this._particleEngine.GetLifeOpacityRandom()
    },
    Timeout() {
        return this._particleEngine.GetTimeout()
    }
};
"use strict";
const C3$jscomp$308 = self.C3
  , inactiveParticles = []
  , VALID_SPRAY_TYPES = new Set(["continuous-spray", "one-shot"])
  , DESTROY_MODES = ["fade-to-invisible", "timeout-expired", "particle-stopped"]
  , tempRect$jscomp$14 = C3$jscomp$308.New(C3$jscomp$308.Rect);
self.ParticleEngine = class {
    constructor() {
        this._sprayCone = this._rate = 0;
        this._sprayType = "continuous-spray";
        this._isSpraying = !1;
        this._masterOpacity = 0;
        this._isPixelRounding = !1;
        this._initSize = this._initSpeed = this._spawnAngle = this._spawnY = this._spawnX = 0;
        this._initSizeScale = 1;
        this._createCounter = this._timeout = this._destroyMode = this._lifeOpacityRandom = this._lifeSpeedRandom = this._lifeAngleRandom = this._gravity = this._acceleration = this._growRandom = this._initSizeRandom = this._initSpeedRandom = this._yRandom = this._xRandom = this._growRate = this._initOpacity = 0;
        this._particleScale = 1;
        this.onparticlecreate = this.ononeshotfinish = null;
        this._particles = [];
        this._boundingBox = new C3$jscomp$308.Rect;
        this._color = new C3$jscomp$308.Color
    }
    Release() {
        this.Cancel();
        C3$jscomp$308.clearArray(this._particles);
        this._color = this._boundingBox = this.onparticlecreate = this.ononeshotfinish = this._particles = null
    }
    Cancel() {
        const a = this._particles;
        for (let b = 0, c = a.length; b < c; ++b)
            a[b].Destroy();
        C3$jscomp$308.appendArray(inactiveParticles, a);
        C3$jscomp$308.clearArray(a);
        1E3 < inactiveParticles.length && C3$jscomp$308.truncateArray(inactiveParticles, 1E3);
        this._isSpraying = !1
    }
    CreateOneShotSpray() {
        for (let a = 0, b = this._rate; a < b; ++a)
            this._CreateParticle();
        this._particles.length && (this._isSpraying = !0)
    }
    _CreateParticle(a=!0) {
        let b;
        inactiveParticles.length ? (b = inactiveParticles.pop(),
        b.SetEngine(this)) : b = C3$jscomp$308.New(self.Particle, this);
        this._particles.push(b);
        a ? b.Init(this.onparticlecreate) : b.Init();
        return b
    }
    ReInitAllParticles() {
        const a = this._particles
          , b = this.onparticlecreate;
        for (let c = 0, d = a.length; c < d; ++c)
            a[c].Init(b)
    }
    UpdateAllParticlesUserData() {
        const a = this._particles
          , b = this.onparticlecreate;
        for (let c = 0, d = a.length; c < d; ++c)
            a[c].UpdateUserData(b)
    }
    ApplyParticleDataToUserData(a) {
        const b = this._particles;
        for (let d = 0, e = b.length; d < e; ++d) {
            const f = b[d];
            var c = f.GetUserData();
            c && (c = c.GetWorldInfo(),
            c.SetX(f.GetX()),
            c.SetY(f.GetY()),
            c.SetSize(f.GetSize(), f.GetSize()),
            c.SetOpacity(f.GetOpacity()),
            c.SetAngle(f.GetAngle()),
            c.SetUnpremultipliedColor(a.GetWorldInfo().GetUnpremultipliedColor()),
            c.SetBboxChanged())
        }
    }
    SetParticleCount(a, b=!0) {
        var c = this._particles;
        if (a < c.length) {
            b = c.length - a;
            for (a = 0; a < b; ++a) {
                const d = c.pop();
                d.Destroy();
                inactiveParticles.push(d)
            }
            1E3 < inactiveParticles.length && C3$jscomp$308.truncateArray(inactiveParticles, 1E3)
        } else if (a > c.length)
            for (c = a - c.length,
            a = 0; a < c; ++a)
                this._CreateParticle(b)
    }
    GetParticles() {
        return this._particles
    }
    GetParticleCount() {
        return this._particles.length
    }
    Tick(a) {
        this._SpawnContinuous(a);
        this._TickParticles(a);
        this._MaybeFinishOneShot()
    }
    _SpawnContinuous(a) {
        if ("continuous-spray" === this._sprayType && this._isSpraying) {
            this._createCounter += a * this._rate;
            a = Math.floor(this._createCounter);
            this._createCounter -= a;
            for (let b = 0; b < a; ++b)
                this._CreateParticle()
        }
    }
    _SetCreateCounter(a) {
        this._createCounter = a
    }
    _GetCreateCounter() {
        return this._createCounter
    }
    _TickParticles(a) {
        const b = this._boundingBox;
        b.set(this._spawnX, this._spawnY, this._spawnX, this._spawnY);
        const c = this._particles;
        let d = 0;
        for (let e = 0, f = c.length; e < f; ++e) {
            const h = c[e];
            c[d] = h;
            h.Tick(a);
            h.IsActive() ? (++d,
            b.expandToContain(h.GetBoundingBox())) : (h.Destroy(),
            inactiveParticles.push(h))
        }
        C3$jscomp$308.truncateArray(c, d);
        1E3 < inactiveParticles.length && C3$jscomp$308.truncateArray(inactiveParticles, 1E3)
    }
    _MaybeFinishOneShot() {
        if ("one-shot" === this._sprayType && 0 === this._particles.length && this._isSpraying) {
            if (this.ononeshotfinish)
                this.ononeshotfinish();
            this._isSpraying = !1
        }
    }
    Draw(a, b, c, d) {
        tempRect$jscomp$14.set(b.getTlx(), b.getTly(), b.getBrx(), b.getBry());
        a.StartRenderingPoints(tempRect$jscomp$14);
        this._color.copy(a.GetColor());
        const e = this._particles;
        for (let f = 0, h = e.length; f < h; ++f) {
            const l = e[f];
            c.intersectsRect(l.GetBoundingBox()) && l.Draw(a, b, d)
        }
        a.FinishRenderingPoints()
    }
    GetColor() {
        return this._color
    }
    SetRate(a) {
        this._rate = +a
    }
    GetRate() {
        return this._rate
    }
    SetSprayCone(a) {
        this._sprayCone = +a
    }
    GetSprayCone() {
        return this._sprayCone
    }
    SetSprayType(a) {
        if (!VALID_SPRAY_TYPES.has(a))
            throw Error("invalid spray type");
        this._sprayType = a
    }
    GetSprayType() {
        return this._sprayType
    }
    SetSpraying(a) {
        this._isSpraying = !!a
    }
    IsSpraying() {
        return this._isSpraying
    }
    SetMasterOpacity(a) {
        this._masterOpacity = +a
    }
    GetMasterOpacity() {
        return this._masterOpacity
    }
    SetPixelRounding(a) {
        this._isPixelRounding = !!a
    }
    IsPixelRounding() {
        return this._isPixelRounding
    }
    SetSpawnX(a) {
        this._spawnX = +a
    }
    GetSpawnX() {
        return this._spawnX
    }
    SetSpawnY(a) {
        this._spawnY = +a
    }
    GetSpawnY() {
        return this._spawnY
    }
    SetSpawnAngle(a) {
        this._spawnAngle = +a
    }
    GetInitAngle() {
        return this._spawnAngle
    }
    SetInitSpeed(a) {
        this._initSpeed = +a
    }
    GetInitSpeed() {
        return this._initSpeed
    }
    SetInitSize(a) {
        this._initSize = +a
    }
    GetInitSize() {
        return this._initSize
    }
    SetInitSizeScale(a) {
        this._initSizeScale = +a
    }
    GetInitSizeScale() {
        return this._initSizeScale
    }
    SetInitOpacity(a) {
        this._initOpacity = +a
    }
    GetInitOpacity() {
        return this._initOpacity
    }
    SetGrowRate(a) {
        this._growRate = +a
    }
    GetGrowRate() {
        return this._growRate
    }
    SetInitXRandom(a) {
        this._xRandom = +a
    }
    GetInitXRandom() {
        return this._xRandom
    }
    SetInitYRandom(a) {
        this._yRandom = +a
    }
    GetInitYRandom() {
        return this._yRandom
    }
    SetInitSpeedRandom(a) {
        this._initSpeedRandom = +a
    }
    GetInitSpeedRandom() {
        return this._initSpeedRandom
    }
    SetInitSizeRandom(a) {
        this._initSizeRandom = +a
    }
    GetInitSizeRandom() {
        return this._initSizeRandom
    }
    SetGrowRandom(a) {
        this._growRandom = +a
    }
    GetGrowRandom() {
        return this._growRandom
    }
    SetAcceleration(a) {
        this._acceleration = +a
    }
    GetAcceleration() {
        return this._acceleration
    }
    SetGravity(a) {
        this._gravity = +a
    }
    GetGravity() {
        return this._gravity
    }
    SetLifeAngleRandom(a) {
        this._lifeAngleRandom = +a
    }
    GetLifeAngleRandom() {
        return this._lifeAngleRandom
    }
    SetLifeSpeedRandom(a) {
        this._lifeSpeedRandom = +a
    }
    GetLifeSpeedRandom() {
        return this._lifeSpeedRandom
    }
    SetLifeOpacityRandom(a) {
        this._lifeOpacityRandom = +a
    }
    GetLifeOpacityRandom() {
        return this._lifeOpacityRandom
    }
    SetDestroyMode(a) {
        a = DESTROY_MODES.indexOf(a);
        if (-1 === a)
            throw Error("invalid destroy mode");
        this._destroyMode = a
    }
    SetDestroyModeIndex(a) {
        this.SetDestroyMode(DESTROY_MODES[a])
    }
    GetDestroyMode() {
        return DESTROY_MODES[this._destroyMode]
    }
    GetDestroyModeIndex() {
        return this._destroyMode
    }
    SetTimeout(a) {
        this._timeout = +a
    }
    GetTimeout() {
        return this._timeout
    }
    SetParticleScale(a) {
        this._particleScale = +a
    }
    GetParticleScale() {
        return this._particleScale
    }
    GetBoundingBox() {
        return this._boundingBox
    }
}
;
"use strict";
const C3$jscomp$309 = self.C3;
function randomOffset(a) {
    return Math.random() * a - a / 2
}
const tmpQuad$jscomp$3 = new C3$jscomp$309.Quad
  , tmpColor = new C3$jscomp$309.Color
  , DPR = self.devicePixelRatio || 1;
let didChangeColor = !1;
self.Particle = class {
    constructor(a) {
        this._engine = a;
        this._isActive = !1;
        this._angle = this._speed = this._y = this._x = 0;
        this._opacity = 1;
        this._age = this._gs = this._halfSize = this._size = this._grow = this._lastOpacity = 0;
        this._bbox = new C3$jscomp$309.Rect;
        this._userData = null;
        this._userDataUid = NaN;
        this._destroyCallback = this._updateCallback = null
    }
    SetEngine(a) {
        this._engine = a
    }
    Init(a) {
        const b = this._engine;
        this._isActive = !0;
        this._x = b.GetSpawnX() + randomOffset(b.GetInitXRandom());
        this._y = b.GetSpawnY() + randomOffset(b.GetInitYRandom());
        this._speed = b.GetInitSpeed() + randomOffset(b.GetInitSpeedRandom());
        this._angle = b.GetInitAngle() + randomOffset(b.GetSprayCone());
        this._lastOpacity = this._opacity = b.GetInitOpacity();
        this._size = (b.GetInitSize() + randomOffset(b.GetInitSizeRandom())) * b.GetInitSizeScale();
        this._halfSize = this._size / 2;
        this._grow = b.GetGrowRate() + randomOffset(b.GetGrowRandom());
        this._age = this._gs = 0;
        this._UpdateBoundingBox();
        a ? this._userData || (this._userData = a(this)) : this._destroyCallback = this._updateCallback = this._userData = null
    }
    UpdateUserData(a) {
        if (a) {
            if (!this._userData || this._userData.IsDestroyed())
                this._userData = a(this, this._userDataUid)
        } else
            this._destroyCallback = this._updateCallback = this._userData = null
    }
    SetUpdateCallback(a) {
        this._updateCallback = a
    }
    SetDestroyCallback(a) {
        this._destroyCallback = a
    }
    Destroy() {
        const a = this._destroyCallback;
        a && a(this._userData);
        this._destroyCallback = this._updateCallback = this._userData = null
    }
    toJSON() {
        let a;
        this._userData && this._userData.GetWorldInfo() && (a = this._userData.GetWorldInfo().GetInstance().GetUID());
        return [this._x, this._y, this._speed, this._angle, this._opacity, this._grow, this._size, this._gs, this._age, a]
    }
    setFromJSON(a) {
        this._x = a[0];
        this._y = a[1];
        this._speed = a[2];
        this._angle = a[3];
        this._lastOpacity = this._opacity = a[4];
        this._grow = a[5];
        this._size = a[6];
        this._gs = a[7];
        this._age = a[8];
        this._userDataUid = a[9];
        this._halfSize = this._size / 2;
        this._UpdateBoundingBox()
    }
    Tick(a) {
        var b = this._engine
          , c = this._speed * a
          , d = this._angle;
        const e = Math.cos(d) * c;
        c = Math.sin(d) * c + this._gs * a;
        this._x += e;
        this._y += c;
        d = this._grow * a;
        this._size += d;
        this._halfSize = this._size / 2;
        this._speed += b.GetAcceleration() * a;
        this._gs += b.GetGravity() * a;
        this._age += a;
        this._UpdateBoundingBox();
        var f = b.GetLifeAngleRandom()
          , h = b.GetLifeSpeedRandom();
        const l = b.GetLifeOpacityRandom();
        let m = 0;
        0 !== f && (m = randomOffset(f * a),
        this._angle += m);
        0 !== h && (this._speed += randomOffset(h * a));
        0 !== l && (this._opacity = C3$jscomp$309.clamp(this._opacity + randomOffset(l * a), 0, 1));
        a = 1 <= this._size && (2 === b.GetDestroyModeIndex() ? 0 < this._speed : this._age < b.GetTimeout());
        (f = this._updateCallback) && a && (h = b.GetMasterOpacity() * this._opacity,
        0 === b.GetDestroyModeIndex() && (h *= 1 - this._age / b.GetTimeout()),
        b = h - this._lastOpacity,
        this._lastOpacity = h,
        f(this._userData, e, c, d, m, b));
        this._isActive = a
    }
    IsActive() {
        return this._isActive
    }
    GetBoundingBox() {
        return this._bbox
    }
    _UpdateBoundingBox() {
        const a = this._x
          , b = this._y
          , c = this._halfSize;
        this._bbox.set(a - c, b - c, a + c, b + c)
    }
    Draw(a, b, c) {
        if (!this._userData) {
            var d = this._engine
              , e = d.GetMasterOpacity() * this._opacity;
            0 === d.GetDestroyModeIndex() && (e *= 1 - this._age / d.GetTimeout());
            if (!(0 >= e)) {
                var f = this._size
                  , h = f * d.GetParticleScale() * DPR;
                if (!(1 > h)) {
                    var l = this._x
                      , m = this._y;
                    d.IsPixelRounding() && (l = l + .5 | 0,
                    m = m + .5 | 0);
                    a.IsWebGPU() ? a.Point(l, m, f, e) : c || h > a.GetMaxPointSize() || h < a.GetMinPointSize() ? (tmpColor.copy(d.GetColor()),
                    tmpColor.multiplyAlpha(e),
                    a.SetColor(tmpColor),
                    didChangeColor = !0,
                    tmpQuad$jscomp$3.setFromRect(this._bbox),
                    a.Quad4(tmpQuad$jscomp$3, b)) : (didChangeColor && (a.SetColor(d.GetColor()),
                    didChangeColor = !1),
                    a.Point(l, m, h, e))
                }
            }
        }
    }
    GetUserData() {
        return this._userData
    }
    GetUserDataUID() {
        return this._userDataUid
    }
    GetX() {
        return this._x
    }
    GetY() {
        return this._y
    }
    GetSize() {
        return this._size
    }
    GetAngle() {
        return this._angle
    }
    GetOpacity() {
        return this._opacity
    }
}
;
"use strict";
const C3$jscomp$310 = self.C3;
C3$jscomp$310.Plugins.SVGPicture = class extends C3$jscomp$310.SDKPluginBase {
    constructor(a) {
        super(a);
        this._rasterManager = null
    }
    Release() {
        super.Release()
    }
    _GetRasterManager() {
        this._rasterManager || (this._rasterManager = C3$jscomp$310.New(C3$jscomp$310.SVGRasterManager),
        this._rasterManager.SetGetBaseSizeCallback(a => this._GetSvgBaseSize(a)),
        this._rasterManager.SetRasterAtSizeCallback( (a, b, c, d, e, f) => this._RasterSvgAtSize(a, b, c, d, e, f)),
        this._rasterManager.SetReleaseResultCallback(a => this._ReleaseRasterResult(a)),
        this._rasterManager.SetRedrawCallback( () => this._Redraw()),
        this._rasterManager.SetNpotSurfaceAllowed(this.GetRuntime().GetRenderer().SupportsNPOTTextures()));
        return this._rasterManager
    }
    async _GetSvgBaseSize(a) {
        const b = this.GetRuntime();
        a = await b.GetAssetManager().FetchBlob(a);
        return await b.GetSvgImageSize(a)
    }
    async _RasterSvgAtSize(a, b, c, d, e, f) {
        const h = this.GetRuntime()
          , l = await h.GetAssetManager().FetchBlob(a);
        a = {
            mipMap: !0,
            mipMapQuality: "high",
            anisotropy: this._runtime.GetCanvasManager().GetTextureAnisotropy()
        };
        let m = null;
        C3$jscomp$310.Supports.ImageBitmapOptions && (m = {
            premultiplyAlpha: "premultiply"
        },
        a.premultiplyAlpha = !1);
        c = await h.RasterSvgImage(l, e, f, c, d, m);
        return C3$jscomp$310.Supports.ImageBitmapOptions ? b.CreateStaticTexture(c, a) : await b.CreateStaticTextureAsync(c, a)
    }
    _ReleaseRasterResult(a) {
        a.GetRenderer().DeleteTexture(a)
    }
    _Redraw() {
        this.GetRuntime().UpdateRender()
    }
}
;
const C3$jscomp$311 = self.C3;
C3$jscomp$311.Plugins.SVGPicture.Type = class extends C3$jscomp$311.SDKTypeBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
    LoadTextures(a) {}
    ReleaseTextures() {}
    PreloadTexturesWithInstances(a) {
        const b = new Set;
        for (const d of this.GetObjectClass().GetInstances()) {
            var c = d.GetSdkInstance();
            c._UpdateRasterImage();
            (c = c._GetRasterImage()) && b.add(c)
        }
        return Promise.all([...b].map(d => this._PreloadRasterImage(a, d)))
    }
    async _PreloadRasterImage(a, b) {
        await b.WhenBaseSizeReady();
        var c = b.GetBaseWidth()
          , d = b.GetBaseHeight();
        d = c / d;
        1 > d ? (c = 256 * d,
        d = 256) : (c = 256,
        d = 256 / d);
        await b.StartRasterForSize(a, c, d)
    }
}
;
const C3$jscomp$312 = self.C3
  , C3X$jscomp$46 = self.C3X
  , tempRect$jscomp$15 = C3$jscomp$312.New(C3$jscomp$312.Rect)
  , tempQuad$jscomp$10 = C3$jscomp$312.New(C3$jscomp$312.Quad);
C3$jscomp$312.Plugins.SVGPicture.Instance = class extends C3$jscomp$312.SDKWorldInstanceBase {
    constructor(a, b) {
        super(a);
        this._loadingSvgFilename = this._svgFilename = "";
        this._imageGeneration = 0;
        this._rasterImage = null;
        this._collisionPoly = C3$jscomp$312.New(C3$jscomp$312.CollisionPoly);
        this.GetWorldInfo().SetSourceCollisionPoly(this._collisionPoly);
        b && (this._svgFilename = b[0],
        this.GetWorldInfo().SetVisible(!!b[1]));
        this._UpdateRasterImage();
        this.HandleRendererContextLoss()
    }
    Release() {
        this._ReleaseRasterImage();
        super.Release()
    }
    _GetRasterManager() {
        return this.GetPlugin()._GetRasterManager()
    }
    _ReleaseRasterImage() {
        this._rasterImage && (this._rasterImage.Release(),
        this._rasterImage = null)
    }
    async _UpdateRasterImage() {
        this._ReleaseRasterImage();
        this._svgFilename ? (this._rasterImage = this._GetRasterManager().AddImage(this._svgFilename),
        await this._rasterImage.WhenBaseSizeReady(),
        this.WasReleased() || (this._UpdateCollisionPolygon(),
        this._runtime.UpdateRender())) : this._UpdateCollisionPolygon()
    }
    async _SetImage(a) {
        if (this._loadingSvgFilename) {
            if (this._loadingSvgFilename === a)
                return
        } else if (this._svgFilename === a)
            return;
        const b = ++this._imageGeneration;
        if (a) {
            this._loadingSvgFilename = a;
            var c = this._GetRasterManager().AddImage(a);
            await this.GetSdkType()._PreloadRasterImage(this._runtime.GetRenderer(), c);
            this.WasReleased() || b < this._imageGeneration ? c.Release() : (this._loadingSvgFilename = "",
            this._svgFilename = a,
            this._ReleaseRasterImage(),
            this._rasterImage = c,
            this._UpdateCollisionPolygon(),
            this._runtime.UpdateRender())
        } else
            this._loadingSvgFilename = this._svgFilename = "",
            this._ReleaseRasterImage(),
            this._UpdateCollisionPolygon()
    }
    _GetImage() {
        return this._svgFilename
    }
    _UpdateCollisionPolygon() {
        const a = this.GetWorldInfo();
        var b = Math.abs(a.GetWidth())
          , c = Math.abs(a.GetHeight())
          , d = b
          , e = c;
        if (this._rasterImage) {
            const f = this._rasterImage.GetBaseWidth()
              , h = this._rasterImage.GetBaseHeight();
            0 !== f && 0 !== h && (e = f / h,
            b / c > e ? (d = c * e,
            e = c) : (d = b,
            e = b / e))
        }
        b = d / b;
        c = e / c;
        d = a.GetOriginX();
        e = a.GetOriginY();
        tempRect$jscomp$15.setWH(d - d * b, e - e * c, b, c);
        this._collisionPoly.setFromRect(tempRect$jscomp$15, d, e);
        a.SetSourceCollisionPoly(this._collisionPoly)
    }
    _GetRasterImage() {
        return this._rasterImage
    }
    OnRendererContextLost() {
        this._ReleaseRasterImage()
    }
    OnRendererContextRestored() {
        this._UpdateRasterImage()
    }
    Draw(a) {
        const b = this.GetWorldInfo();
        var c = b.GetLayer();
        if (this._rasterImage) {
            var d = this._rasterImage.GetBaseWidth()
              , e = this._rasterImage.GetBaseHeight();
            if (0 !== d && 0 !== e) {
                var f = Math.abs(b.GetWidth())
                  , h = Math.abs(b.GetHeight())
                  , l = b.GetZElevation()
                  , m = c._GetLayerToDrawSurfaceScale(f, l);
                c = c._GetLayerToDrawSurfaceScale(h, l);
                e = d / e;
                f / h > e ? (d = c * e,
                m = h * e,
                f = h) : (d = m,
                c = m / e,
                m = f,
                f /= e);
                this._rasterImage.StartRasterForSize(a, d, c);
                if (h = this._rasterImage.GetRasterizedResult())
                    a.SetTexture(h),
                    d = b.GetX(),
                    e = b.GetY(),
                    m *= Math.sign(b.GetWidth()),
                    f *= Math.sign(b.GetHeight()),
                    tempRect$jscomp$15.setWH(d - b.GetOriginX() * m, e - b.GetOriginY() * f, m, f),
                    0 === b.GetAngle() ? tempQuad$jscomp$10.setFromRect(tempRect$jscomp$15) : (tempRect$jscomp$15.offset(-d, -e),
                    tempQuad$jscomp$10.setFromRotatedRectPrecalc(tempRect$jscomp$15, b.GetSinAngle(), b.GetCosAngle()),
                    tempQuad$jscomp$10.offset(d, e)),
                    tempRect$jscomp$15.set(0, 0, this._rasterImage.GetRasterWidth() / h.GetWidth(), this._rasterImage.GetRasterHeight() / h.GetHeight()),
                    a.Quad3(tempQuad$jscomp$10, tempRect$jscomp$15)
            }
        }
    }
    GetPropertyValueByIndex(a) {}
    SetPropertyValueByIndex(a, b) {}
    SaveToJson() {
        return {
            svg: this._GetImage()
        }
    }
    LoadFromJson(a) {
        a.svg && this._SetImage(a.svg)
    }
    GetCurrentSurfaceSize() {
        if (this._rasterImage) {
            const a = this._rasterImage.GetRasterizedResult();
            if (a)
                return [a.GetWidth(), a.GetHeight()]
        }
        return [100, 100]
    }
    GetCurrentTexRect() {
        if (this._rasterImage) {
            const a = this._rasterImage.GetRasterizedResult();
            if (a)
                return tempRect$jscomp$15.set(0, 0, this._rasterImage.GetRasterWidth() / a.GetWidth(), this._rasterImage.GetRasterHeight() / a.GetHeight()),
                tempRect$jscomp$15
        }
        return null
    }
    GetScriptInterfaceClass() {
        return self.ISVGPictureInstance
    }
}
;
const map$jscomp$35 = new WeakMap;
self.ISVGPictureInstance = class extends self.IWorldInstance {
    constructor() {
        super();
        map$jscomp$35.set(this, self.IInstance._GetInitInst().GetSdkInstance())
    }
    set svgUrl(a) {
        C3X$jscomp$46.RequireString(a);
        map$jscomp$35.get(this)._SetImage(a)
    }
    get svgUrl() {
        return map$jscomp$35.get(this)._GetImage()
    }
    setSvgUrl(a) {
        C3X$jscomp$46.RequireString(a);
        return map$jscomp$35.get(this)._SetImage(a)
    }
}
;
self.C3.Plugins.SVGPicture.Cnds = {};
self.C3.Plugins.SVGPicture.Acts = {
    SetImage(a) {
        return this._SetImage(a)
    },
    SetImageByName(a) {
        return this._SetImage(a)
    },
    SetEffect(a) {
        this.GetWorldInfo().SetBlendMode(a);
        this._runtime.UpdateRender()
    }
};
self.C3.Plugins.SVGPicture.Exps = {};
"use strict";
const C3$jscomp$316 = self.C3;
C3$jscomp$316.Plugins.Spritefont2 = class extends C3$jscomp$316.SDKPluginBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
}
;
const C3$jscomp$317 = self.C3;
C3$jscomp$317.Plugins.Spritefont2.Type = class extends C3$jscomp$317.SDKTypeBase {
    constructor(a) {
        super(a);
        this._spriteFont = C3$jscomp$317.New(self.SpriteFont)
    }
    Release() {
        super.Release()
    }
    OnCreate() {
        this.GetImageInfo().LoadAsset(this._runtime)
    }
    LoadTextures(a) {
        return this.GetImageInfo().LoadStaticTexture(a, {
            sampling: this._runtime.GetSampling()
        })
    }
    ReleaseTextures() {
        this.GetImageInfo().ReleaseTexture()
    }
    GetSpriteFont() {
        return this._spriteFont
    }
    UpdateSettings(a, b, c, d) {
        const e = this.GetImageInfo()
          , f = this._spriteFont;
        f.SetWidth(e.GetWidth());
        f.SetHeight(e.GetHeight());
        f.SetCharacterWidth(a);
        f.SetCharacterHeight(b);
        f.SetCharacterSet(c);
        f.SetSpacingData(d);
        f.UpdateCharacterMap()
    }
}
;
const C3$jscomp$318 = self.C3
  , C3X$jscomp$47 = self.C3X
  , tempVec2$jscomp$2 = C3$jscomp$318.New(C3$jscomp$318.Vector2)
  , HORIZONTAL_ALIGNMENTS = ["left", "center", "right"]
  , VERTICAL_ALIGNMENTS = ["top", "center", "bottom"];
C3$jscomp$318.Plugins.Spritefont2.Instance = class extends C3$jscomp$318.SDKWorldInstanceBase {
    constructor(a, b) {
        super(a);
        this._text = "";
        this._enableBBcode = !0;
        this._characterHeight = this._characterWidth = 16;
        this._characterSet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789.,;:?!-_~#\"'&()[]|`\\/@\u00b0+=*$\u00a3\u20ac<>";
        a = "";
        this._characterScale = 1;
        this._verticalAlign = this._horizontalAlign = this._lineHeight = this._characterSpacing = 0;
        this._needsTextLayout = this._wrapByWord = !0;
        this._readAloud = !1;
        this._spriteFontText = this._screenReaderText = null;
        this._typewriterEndTime = this._typewriterStartTime = -1;
        this._typewriterLength = 0;
        b && (this._text = b[0],
        this._enableBBcode = b[1],
        this._characterWidth = b[2],
        this._characterHeight = b[3],
        this._characterSet = b[4],
        a = b[5],
        this._characterScale = b[6],
        this._characterSpacing = b[7],
        this._lineHeight = b[8],
        this._horizontalAlign = b[9],
        this._verticalAlign = b[10],
        this._wrapByWord = 0 === b[11],
        this.GetWorldInfo().SetVisible(b[12]),
        this._readAloud = !!b[14]);
        this._sdkType.UpdateSettings(this._characterWidth, this._characterHeight, this._characterSet, a);
        this._spriteFontText = C3$jscomp$318.New(self.SpriteFontText, this._sdkType.GetSpriteFont());
        b = this.GetWorldInfo();
        this._spriteFontText.SetSize(b.GetWidth(), b.GetHeight());
        this._UpdateSettings();
        this._UpdateScreenReaderText();
        this._inst.SetMustMitigateZFighting()
    }
    Release() {
        this._CancelTypewriter();
        this._screenReaderText && (this._screenReaderText.Release(),
        this._screenReaderText = null);
        this._spriteFontText.Release();
        this._spriteFontText = null;
        super.Release()
    }
    _UpdateSettings() {
        const a = this._spriteFontText;
        a && (a.SetBBCodeEnabled(this._enableBBcode),
        a.SetText(this._text),
        a.SetWordWrapMode(this._wrapByWord ? "word" : "character"),
        a.SetHorizontalAlign(HORIZONTAL_ALIGNMENTS[this._horizontalAlign]),
        a.SetVerticalAlign(VERTICAL_ALIGNMENTS[this._verticalAlign]),
        a.SetSpacing(this._characterSpacing),
        a.SetLineHeight(this._lineHeight))
    }
    _UpdateTextSize() {
        const a = this.GetWorldInfo();
        this._spriteFontText.SetSize(a.GetWidth(), a.GetHeight());
        this._spriteFontText.SetScale(this._characterScale)
    }
    _UpdateScreenReaderText() {
        if (this._readAloud) {
            let a = this._text;
            this._enableBBcode && (a = C3$jscomp$318.BBString.StripAnyTags(a));
            this._screenReaderText ? this._screenReaderText.SetText(a) : this._screenReaderText = C3$jscomp$318.New(C3$jscomp$318.ScreenReaderText, this._runtime, a)
        } else
            this._screenReaderText && (this._screenReaderText.Release(),
            this._screenReaderText = null)
    }
    Draw(a) {
        const b = this._objectClass.GetImageInfo();
        var c = b.GetTexture();
        if (c) {
            a.SetTexture(c);
            c = this.GetWorldInfo();
            var d = c.GetBoundingQuad()
              , e = this._spriteFontText;
            e.SetScale(this._characterScale);
            e.SetSceneGraphScale(c.GetSceneGraphScale());
            this._runtime.IsPixelRoundingEnabled() && (d = c.PixelRoundQuad(d));
            e.SetSize(c.GetWidth(), c.GetHeight());
            e.GetSpriteFont().SetTexRect(b.GetTexRect());
            e.SetColor(c.GetUnpremultipliedColor());
            e.Draw(a, d.getTlx(), d.getTly(), c.GetAngle());
            this._needsTextLayout = !1
        }
    }
    SaveToJson() {
        const a = {
            t: this._text,
            ebbc: this._enableBBcode,
            csc: this._characterScale,
            csp: this._characterSpacing,
            lh: this._lineHeight,
            ha: this._horizontalAlign,
            va: this._verticalAlign,
            w: this._wrapByWord,
            cw: this._sdkType.GetSpriteFont().GetCharacterWidth(),
            ch: this._sdkType.GetSpriteFont().GetCharacterHeight(),
            cs: this._sdkType.GetSpriteFont().GetCharacterSet(),
            sd: this._sdkType.GetSpriteFont().GetSpacingData()
        };
        -1 !== this._typewriterEndTime && (a.tw = {
            st: this._typewriterStartTime,
            en: this._typewriterEndTime,
            l: this._typewriterLength
        });
        return a
    }
    LoadFromJson(a) {
        this._CancelTypewriter();
        this._text = a.t;
        this._enableBBcode = a.ebbc;
        this._characterScale = a.csc;
        this._characterSpacing = a.csp;
        this._lineHeight = a.lh;
        this._horizontalAlign = a.ha;
        this._verticalAlign = a.va;
        this._wrapByWord = a.w;
        if (a.hasOwnProperty("tw")) {
            var b = a.tw;
            this._typewriterStartTime = b.st;
            this._typewriterEndTime = b.en;
            this._typewriterLength = a.l
        }
        b = this._sdkType.GetSpriteFont();
        b.SetCharacterWidth(a.cw);
        b.SetCharacterHeight(a.ch);
        b.SetCharacterSet(a.cs);
        b.SetSpacingData(a.sd);
        this._UpdateSettings();
        this._UpdateScreenReaderText();
        -1 !== this._typewriterEndTime && this._StartTicking()
    }
    GetPropertyValueByIndex(a) {
        switch (a) {
        case 0:
            return this.GetText();
        case 1:
            return this._enableBBcode;
        case 2:
            return this._sdkType.GetSpriteFont().GetCharacterWidth();
        case 3:
            return this._sdkType.GetSpriteFont().GetCharacterHeight();
        case 4:
            return this._sdkType.GetSpriteFont().GetCharacterSet();
        case 5:
            return this._sdkType.GetSpriteFont().GetSpacingData();
        case 6:
            return this._GetScale();
        case 7:
            return this._GetCharacterSpacing();
        case 8:
            return this._GetLineHeight();
        case 9:
            return this._GetHAlign();
        case 10:
            return this._GetVAlign();
        case 11:
            return this._IsWrapByWord() ? 1 : 0
        }
    }
    SetPropertyValueByIndex(a, b) {
        switch (a) {
        case 0:
            this._SetText(b);
            break;
        case 1:
            if (this._enableBBcode === !!b)
                break;
            this._enableBBcode = !!b;
            this._UpdateSettings();
            break;
        case 2:
            this._sdkType.GetSpriteFont().SetCharacterWidth(b);
            break;
        case 3:
            this._sdkType.GetSpriteFont().SetCharacterHeight(b);
            break;
        case 4:
            this._sdkType.GetSpriteFont().SetCharacterSet(b);
            break;
        case 5:
            this._sdkType.GetSpriteFont().SetSpacingData(b);
            break;
        case 6:
            this._SetScale(b);
            break;
        case 7:
            this._SetCharacterSpacing(b);
            break;
        case 8:
            this._SetLineHeight(b);
            break;
        case 9:
            this._SetHAlign(b);
            break;
        case 10:
            this._SetVAlign(b);
            break;
        case 11:
            this._SetWrapByWord(0 === b)
        }
    }
    _SetText(a) {
        this._text !== a && (this._text = a,
        this._spriteFontText.SetText(a),
        this._UpdateScreenReaderText(),
        this._runtime.UpdateRender())
    }
    GetText() {
        return this._text
    }
    _StartTypewriter(a, b) {
        this._SetText(a);
        this._typewriterStartTime = this._runtime.GetWallTime();
        this._typewriterEndTime = this._typewriterStartTime + b / this.GetInstance().GetActiveTimeScale();
        this._typewriterLength = C3$jscomp$318.CountGraphemes(C3$jscomp$318.BBString.StripAnyTags(a));
        this._spriteFontText.SetDrawMaxCharacterCount(0);
        this._StartTicking()
    }
    _CancelTypewriter() {
        this._typewriterEndTime = this._typewriterStartTime = -1;
        this._typewriterLength = 0;
        this._spriteFontText.SetDrawMaxCharacterCount(-1);
        this._StopTicking()
    }
    _FinishTypewriter() {
        -1 !== this._typewriterEndTime && (this._CancelTypewriter(),
        this.Trigger(C3$jscomp$318.Plugins.Spritefont2.Cnds.OnTypewriterTextFinished),
        this._runtime.UpdateRender())
    }
    _SetScale(a) {
        this._characterScale !== a && (this._characterScale = a,
        this._spriteFontText.SetScale(this._characterScale),
        this._runtime.UpdateRender())
    }
    _GetScale() {
        return this._characterScale
    }
    _SetCharacterSpacing(a) {
        this._characterSpacing !== a && (this._characterSpacing = a,
        this._spriteFontText.SetSpacing(this._characterSpacing),
        this._runtime.UpdateRender())
    }
    _GetCharacterSpacing() {
        return this._characterSpacing
    }
    _SetLineHeight(a) {
        this._lineHeight !== a && (this._lineHeight = a,
        this._spriteFontText.SetLineHeight(this._lineHeight),
        this._runtime.UpdateRender())
    }
    _GetLineHeight() {
        return this._lineHeight
    }
    _SetHAlign(a) {
        this._horizontalAlign !== a && (this._horizontalAlign = a,
        this._UpdateSettings(),
        this._runtime.UpdateRender())
    }
    _GetHAlign() {
        return this._horizontalAlign
    }
    _SetVAlign(a) {
        this._verticalAlign !== a && (this._verticalAlign = a,
        this._UpdateSettings(),
        this._runtime.UpdateRender())
    }
    _GetVAlign() {
        return this._verticalAlign
    }
    _SetWrapByWord(a) {
        a = !!a;
        this._wrapByWord !== a && (this._wrapByWord = a,
        this._UpdateSettings(),
        this._runtime.UpdateRender())
    }
    _IsWrapByWord() {
        return this._wrapByWord
    }
    _SetReadAloud(a) {
        this._readAloud = !!a;
        this._UpdateScreenReaderText()
    }
    _IsReadAloud() {
        return this._readAloud
    }
    _GetTextWidth() {
        this._UpdateTextSize();
        return this._spriteFontText.GetTextWidth()
    }
    _GetTextHeight() {
        this._UpdateTextSize();
        return this._spriteFontText.GetTextHeight()
    }
    _GetTagAtPosition(a, b) {
        this._UpdateTextSize();
        const c = this.GetWorldInfo();
        tempVec2$jscomp$2.set(a - c.GetX(), b - c.GetY());
        tempVec2$jscomp$2.rotate(-c.GetAngle());
        tempVec2$jscomp$2.offset(c.GetWidth() * c.GetOriginX(), c.GetHeight() * c.GetOriginY());
        if (a = this._spriteFontText.HitTestFragment(tempVec2$jscomp$2.getX(), tempVec2$jscomp$2.getY()))
            if (a = a.GetStyleTag("tag"))
                return a.param;
        return ""
    }
    _HasTagAtPosition(a, b, c) {
        return (b = this._GetTagAtPosition(b, c)) && C3$jscomp$318.equalsNoCase(a, b)
    }
    _GetTagPosition(a, b) {
        this._UpdateTextSize();
        b = Math.floor(b);
        a = this._spriteFontText.FindFragmentWithTag(a, b);
        if (!a)
            return null;
        b = this.GetWorldInfo();
        tempVec2$jscomp$2.set(a.GetPosX(), a.GetPosY());
        tempVec2$jscomp$2.offset(-b.GetWidth() * b.GetOriginX(), -b.GetHeight() * b.GetOriginY());
        tempVec2$jscomp$2.rotate(b.GetAngle());
        tempVec2$jscomp$2.offset(b.GetX(), b.GetY());
        return {
            x: tempVec2$jscomp$2.getX(),
            y: tempVec2$jscomp$2.getY(),
            width: a.GetWidth(),
            height: a.GetHeight()
        }
    }
    _GetTagCount(a) {
        this._UpdateTextSize();
        return this._spriteFontText.CountFragmentsWithTag(a)
    }
    Tick() {
        var a = this._runtime.GetWallTime();
        a >= this._typewriterEndTime ? (this._CancelTypewriter(),
        this.Trigger(C3$jscomp$318.Plugins.Spritefont2.Cnds.OnTypewriterTextFinished),
        this._runtime.UpdateRender()) : (a = C3$jscomp$318.relerp(this._typewriterStartTime, this._typewriterEndTime, a, 0, this._typewriterLength),
        a = Math.floor(a),
        a !== this._spriteFontText.GetDrawMaxCharacterCount() && (this._spriteFontText.SetDrawMaxCharacterCount(a),
        this._runtime.UpdateRender()))
    }
    GetDebuggerProperties() {
        return [{
            title: "plugins.spritefont2.name",
            properties: [{
                name: "plugins.spritefont2.properties.text.name",
                value: this.GetText(),
                onedit: a => this._SetText(a)
            }, {
                name: "plugins.spritefont2.properties.scale.name",
                value: this._GetScale(),
                onedit: a => this._SetScale(a)
            }, {
                name: "plugins.spritefont2.properties.character-spacing.name",
                value: this._GetCharacterSpacing(),
                onedit: a => this._SetCharacterSpacing(a)
            }, {
                name: "plugins.spritefont2.properties.line-height.name",
                value: this._GetLineHeight(),
                onedit: a => this._SetLineHeight(a)
            }]
        }]
    }
    GetScriptInterfaceClass() {
        return self.ISpriteFontInstance
    }
}
;
const map$jscomp$36 = new WeakMap
  , SCRIPT_HORIZONTAL_ALIGNMENTS = new Map([["left", 0], ["center", 1], ["right", 2]])
  , SCRIPT_VERTICAL_ALIGNMENTS = new Map([["top", 0], ["center", 1], ["bottom", 2]])
  , SCRIPT_WRAP_MODES = new Map([["word", !0], ["character", !1]]);
self.ISpriteFontInstance = class extends self.IWorldInstance {
    constructor() {
        super();
        map$jscomp$36.set(this, self.IInstance._GetInitInst().GetSdkInstance())
    }
    get text() {
        return map$jscomp$36.get(this).GetText()
    }
    set text(a) {
        C3X$jscomp$47.RequireString(a);
        const b = map$jscomp$36.get(this);
        b._CancelTypewriter();
        b._SetText(a)
    }
    typewriterText(a, b) {
        C3X$jscomp$47.RequireString(a);
        C3X$jscomp$47.RequireFiniteNumber(b);
        const c = map$jscomp$36.get(this);
        c._CancelTypewriter();
        c._StartTypewriter(a, b)
    }
    typewriterFinish() {
        map$jscomp$36.get(this)._FinishTypewriter()
    }
    set characterScale(a) {
        C3X$jscomp$47.RequireFiniteNumber(a);
        map$jscomp$36.get(this)._SetScale(a)
    }
    get characterScale() {
        return map$jscomp$36.get(this)._GetScale()
    }
    set characterSpacing(a) {
        C3X$jscomp$47.RequireFiniteNumber(a);
        map$jscomp$36.get(this)._SetCharacterSpacing(a)
    }
    get characterSpacing() {
        return map$jscomp$36.get(this)._GetCharacterSpacing()
    }
    set lineHeight(a) {
        C3X$jscomp$47.RequireFiniteNumber(a);
        map$jscomp$36.get(this)._SetLineHeight(a)
    }
    get lineHeight() {
        return map$jscomp$36.get(this)._GetLineHeight()
    }
    set horizontalAlign(a) {
        C3X$jscomp$47.RequireString(a);
        a = SCRIPT_HORIZONTAL_ALIGNMENTS.get(a);
        if ("undefined" === typeof a)
            throw Error("invalid mode");
        map$jscomp$36.get(this)._SetHAlign(a)
    }
    get horizontalAlign() {
        return HORIZONTAL_ALIGNMENTS[map$jscomp$36.get(this)._GetHAlign()]
    }
    set verticalAlign(a) {
        C3X$jscomp$47.RequireString(a);
        a = SCRIPT_VERTICAL_ALIGNMENTS.get(a);
        if ("undefined" === typeof a)
            throw Error("invalid mode");
        map$jscomp$36.get(this)._SetVAlign(a)
    }
    get verticalAlign() {
        return VERTICAL_ALIGNMENTS[map$jscomp$36.get(this)._GetVAlign()]
    }
    set wordWrapMode(a) {
        C3X$jscomp$47.RequireString(a);
        a = SCRIPT_WRAP_MODES.get(a);
        if ("undefined" === typeof a)
            throw Error("invalid mode");
        map$jscomp$36.get(this)._SetWrapByWord(a)
    }
    get wordWrapMode() {
        return map$jscomp$36.get(this)._IsWrapByWord() ? "word" : "character"
    }
    set readAloud(a) {
        map$jscomp$36.get(this)._SetReadAloud(!!a)
    }
    get readAloud() {
        return map$jscomp$36.get(this)._IsReadAloud()
    }
    get textWidth() {
        return map$jscomp$36.get(this)._GetTextWidth()
    }
    get textHeight() {
        return map$jscomp$36.get(this)._GetTextHeight()
    }
    getTextSize() {
        const a = map$jscomp$36.get(this);
        return [a._GetTextWidth(), a._GetTextHeight()]
    }
    hasTagAtPosition(a, b, c) {
        C3X$jscomp$47.RequireString(a);
        C3X$jscomp$47.RequireFiniteNumber(b);
        C3X$jscomp$47.RequireFiniteNumber(c);
        return map$jscomp$36.get(this)._HasTagAtPosition(a, b, c)
    }
    getTagAtPosition(a, b) {
        C3X$jscomp$47.RequireFiniteNumber(a);
        C3X$jscomp$47.RequireFiniteNumber(b);
        return map$jscomp$36.get(this)._GetTagAtPosition(a, b)
    }
    getTagPositionAndSize(a, b=0) {
        C3X$jscomp$47.RequireString(a);
        C3X$jscomp$47.RequireFiniteNumber(b);
        return map$jscomp$36.get(this)._GetTagPosition(a, b)
    }
    getTagCount(a) {
        C3X$jscomp$47.RequireString(a);
        return map$jscomp$36.get(this)._GetTagCount(a)
    }
}
;
const C3$jscomp$319 = self.C3;
C3$jscomp$319.Plugins.Spritefont2.Cnds = {
    CompareText(a, b) {
        return b ? this._text === a : C3$jscomp$319.equalsNoCase(this._text, a)
    },
    IsRunningTypewriterText() {
        return -1 !== this._typewriterEndTime
    },
    OnTypewriterTextFinished() {
        return !0
    },
    HasTagAtPosition(a, b, c) {
        return this._HasTagAtPosition(a, b, c)
    }
};
self.C3.Plugins.Spritefont2.Acts = {
    SetText(a) {
        this._CancelTypewriter();
        "number" === typeof a && 1E9 > a && (a = Math.round(1E10 * a) / 1E10);
        this._SetText(a.toString())
    },
    AppendText(a) {
        this._CancelTypewriter();
        "number" === typeof a && 1E9 > a && (a = Math.round(1E10 * a) / 1E10);
        (a = a.toString()) && this._SetText(this._text + a)
    },
    TypewriterText(a, b) {
        this._CancelTypewriter();
        "number" === typeof a && 1E9 > a && (a = Math.round(1E10 * a) / 1E10);
        this._StartTypewriter(a.toString(), b)
    },
    TypewriterFinish() {
        this._FinishTypewriter()
    },
    SetScale(a) {
        this._SetScale(a)
    },
    SetCharacterSpacing(a) {
        this._SetCharacterSpacing(a)
    },
    SetLineHeight(a) {
        this._SetLineHeight(a)
    },
    SetCharacterWidth(a, b) {
        let c = !1;
        const d = this._sdkType.GetSpriteFont();
        for (const e of a)
            if (" " === e)
                d.SetSpaceWidth(b),
                c = !0;
            else if (a = d.GetCharacter(e))
                a.SetDisplayWidth(b),
                c = !0;
        c && d.SetCharacterWidthsChanged();
        this._runtime.UpdateRender()
    },
    SetEffect(a) {
        this.GetWorldInfo().SetBlendMode(a);
        this._runtime.UpdateRender()
    },
    SetHAlign(a) {
        this._SetHAlign(a)
    },
    SetVAlign(a) {
        this._SetVAlign(a)
    },
    SetWrapping(a) {
        this._SetWrapByWord(0 === a)
    },
    SetReadAloud(a) {
        this._SetReadAloud(a)
    }
};
const C3$jscomp$321 = self.C3;
C3$jscomp$321.Plugins.Spritefont2.Exps = {
    CharacterWidth(a) {
        return (a = this._sdkType.GetSpriteFont().GetCharacter(a)) ? a.GetDisplayWidth() : this._sdkType.GetSpriteFont().GetCharacterWidth()
    },
    CharacterHeight() {
        return this._characterHeight
    },
    CharacterScale() {
        return this._characterScale
    },
    CharacterSpacing() {
        return this._characterSpacing
    },
    LineHeight() {
        return this._lineHeight
    },
    Text() {
        return this._text
    },
    PlainText() {
        return this._enableBBcode ? C3$jscomp$321.BBString.StripAnyTags(this._text) : this._text
    },
    TextWidth() {
        return this._GetTextWidth()
    },
    TextHeight() {
        return this._GetTextHeight()
    },
    TagAtPosition(a, b) {
        return this._GetTagAtPosition(a, b)
    },
    TagCount(a) {
        return this._GetTagCount(a)
    },
    TagX(a, b) {
        return (a = this._GetTagPosition(a, b)) ? a.x : 0
    },
    TagY(a, b) {
        return (a = this._GetTagPosition(a, b)) ? a.y : 0
    },
    TagWidth(a, b) {
        return (a = this._GetTagPosition(a, b)) ? a.width : 0
    },
    TagHeight(a, b) {
        return (a = this._GetTagPosition(a, b)) ? a.height : 0
    }
};
"use strict";
const C3$jscomp$322 = self.C3;
self.SpriteFontCharacter = class {
    constructor(a, b, c, d) {
        let e = a.GetCharacterWidth()
          , f = a.GetCharacterHeight();
        this._spriteFont = a;
        this._char = b;
        this._pxRect = new C3$jscomp$322.Rect(c,d,c + e,d + f);
        this._texRect = new C3$jscomp$322.Rect;
        this._displayWidth = -1;
        this._UpdateTexRect()
    }
    Release() {
        this._texRect = this._pxRect = this._spriteFont = null
    }
    _UpdateTexRect() {
        let a = this._spriteFont.GetWidth()
          , b = this._spriteFont.GetHeight();
        this._texRect.copy(this._pxRect);
        this._texRect.divide(a, b);
        this._texRect.lerpInto(this._spriteFont.GetTexRect())
    }
    GetSpriteFont() {
        return this._spriteFont
    }
    GetChar() {
        return this._char
    }
    GetTexRect() {
        return this._texRect
    }
    SetDisplayWidth(a) {
        this._displayWidth = a
    }
    GetDisplayWidth() {
        return 0 > this._displayWidth ? this._spriteFont.GetCharacterWidth() : this._displayWidth
    }
}
;
"use strict";
const C3$jscomp$323 = self.C3
  , tmpRect$jscomp$3 = new C3$jscomp$323.Rect
  , tmpQuad$jscomp$4 = new C3$jscomp$323.Quad
  , tmpColor$jscomp$1 = new C3$jscomp$323.Color
  , VALID_HORIZ_ALIGNMENTS$jscomp$1 = new Set(["left", "center", "right"])
  , VALID_VERT_ALIGNMENTS$jscomp$1 = new Set(["top", "center", "bottom"])
  , VALID_WORD_WRAP_MODES$jscomp$1 = new Set(["word", "character"]);
function getOffsetParam$jscomp$1(a, b) {
    a = a.trim();
    const c = parseFloat(a);
    return isFinite(c) ? a.endsWith("%") ? b * c / 100 : c : 0
}
let canvasColorCtx = null;
function normalizeCssColorString(a) {
    canvasColorCtx || (canvasColorCtx = C3$jscomp$323.CreateCanvas(32, 32).getContext("2d"));
    canvasColorCtx.fillStyle = "#FFFFFF";
    canvasColorCtx.fillStyle = a;
    return canvasColorCtx.fillStyle
}
self.SpriteFontText = class {
    constructor(a) {
        this._spriteFont = a;
        this._cssHeight = this._cssWidth = 0;
        this._text = "";
        this._isBBcodeEnabled = !1;
        this._bbString = null;
        this._wrappedText = C3$jscomp$323.New(C3$jscomp$323.WordWrap);
        this._wrapMode = "word";
        this._textLayoutChanged = this._wordWrapChanged = !1;
        this._horizontalAlign = "left";
        this._verticalAlign = "top";
        this._sceneGraphScale = this._scale = 1;
        this._lineHeight = this._spacing = 0;
        this._color = C3$jscomp$323.New(C3$jscomp$323.Color);
        this._drawMaxCharCount = -1;
        this._drawCharCount = 0;
        this._measureTextCallback = b => this._MeasureText(b);
        this._spriteFont._AddSpriteFontText(this)
    }
    Release() {
        this._spriteFont._RemoveSpriteFontText(this);
        this._measureTextCallback = this._color = null;
        this._wrappedText.Clear();
        this._bbString = this._spriteFont = this._wrappedText = null
    }
    _MeasureText(a) {
        if (a.IsIcon())
            return {
                width: 0,
                height: 0
            };
        var b = a.GetCharacterArray()
          , c = a.GetStyleTag("scale")
          , d = (c ? parseFloat(c.param) : this._scale) * this._sceneGraphScale;
        c = a.GetStyleTag("scalex");
        c = (c ? parseFloat(c.param) : 1) * d;
        a = a.GetStyleTag("scaley");
        a = (a ? parseFloat(a.param) : 1) * d;
        a = this._spriteFont.GetCharacterHeight() * a + this._lineHeight;
        const e = this.GetSpriteFont();
        d = e.GetCharacterWidth() * c;
        const f = this.GetSpacing();
        if (e.HasAnyCustomWidths()) {
            let l = 0
              , m = 0;
            for (var h of b) {
                b = d;
                const p = e.GetCharacter(h);
                p ? b = p.GetDisplayWidth() * c : " " === h && (b = e.GetSpaceWidth() * c);
                m += b;
                ++l
            }
            return {
                width: m + l * f,
                height: a
            }
        }
        h = b.length;
        return {
            width: d * h + Math.max(h, 0) * f,
            height: a
        }
    }
    _SetTextLayoutChanged() {
        this._textLayoutChanged = !0
    }
    _SetWordWrapChanged() {
        this._SetTextLayoutChanged();
        this._wordWrapChanged = !0;
        this._wrappedText.Clear()
    }
    SetSize(a, b) {
        0 >= a || 0 >= b || this._cssWidth === a && this._cssHeight === b || (this._cssWidth !== a ? this._SetWordWrapChanged() : this._SetTextLayoutChanged(),
        this._cssWidth = a,
        this._cssHeight = b)
    }
    SetDrawMaxCharacterCount(a) {
        this._drawMaxCharCount = Math.floor(a)
    }
    GetDrawMaxCharacterCount() {
        return this._drawMaxCharCount
    }
    HitTestFragment(a, b) {
        this._UpdateTextMeasurements();
        const c = this._wrappedText.GetLines();
        for (const d of c)
            if (b > d.GetPosY() && b < d.GetPosY() + d.GetHeight())
                for (const e of d.fragments())
                    if (a >= e.GetPosX() && a < e.GetPosX() + e.GetWidth())
                        return e;
        return null
    }
    *fragmentsWithTag(a) {
        this._UpdateTextMeasurements();
        var b = this._wrappedText.GetLines();
        for (const c of b)
            for (const d of c.fragments())
                (b = d.GetStyleTag("tag")) && C3$jscomp$323.equalsNoCase(b.param, a) && (yield d)
    }
    FindFragmentWithTag(a, b) {
        for (const c of this.fragmentsWithTag(a)) {
            if (0 === b)
                return c;
            --b
        }
        return null
    }
    CountFragmentsWithTag(a) {
        let b = 0;
        for (const c of this.fragmentsWithTag(a))
            ++b;
        return b
    }
    _UpdateTextMeasurements() {
        this._UpdateWordWrap();
        this._UpdateTextLayout()
    }
    _UpdateWordWrap() {
        if (this._wordWrapChanged) {
            !this._isBBcodeEnabled || this._bbString && this._bbString.toString() === this._text || (this._bbString = new C3$jscomp$323.BBString(this._text,{
                noEscape: !0
            }));
            var a = -this.GetSpacing();
            this._wrappedText.WordWrap(this._isBBcodeEnabled ? this._bbString.toFragmentList() : this._text, this._measureTextCallback, this._cssWidth, this._wrapMode, a);
            this._wordWrapChanged = !1
        }
    }
    _UpdateTextLayout() {
        this._textLayoutChanged && (this._LayoutText(),
        this._textLayoutChanged = !1)
    }
    _LayoutText() {
        let a = 0;
        const b = this._lineHeight
          , c = C3$jscomp$323.cloneArray(this._wrappedText.GetLines());
        for (var d of c) {
            d.SetPosX(NaN);
            d.SetPosY(NaN);
            for (var e of d.fragments())
                e.SetPosX(NaN),
                e.SetPosY(NaN)
        }
        d = c.reduce( (f, h) => f + h.GetHeight(), 0) - b;
        "center" === this._verticalAlign ? a = Math.max(Math.floor(this._cssHeight / 2 - d / 2), 0) : "bottom" === this._verticalAlign && (a = Math.floor(this._cssHeight - d));
        for (let f = 0, h = c.length; f < h; ++f) {
            d = c[f];
            e = d.GetHeight();
            if (0 < f && a > this._cssHeight - (e - b))
                break;
            0 <= a && this._LayoutTextLine(d, a);
            a += e
        }
    }
    _LayoutTextLine(a, b) {
        let c = 0;
        "center" === this._horizontalAlign ? c = Math.max(Math.floor((this._cssWidth - a.GetWidth()) / 2), 0) : "right" === this._horizontalAlign && (c = Math.max(Math.floor(this._cssWidth - a.GetWidth()), 0));
        a.SetPosX(c);
        a.SetPosY(b);
        for (const d of a.fragments())
            d.IsIcon() || (this._LayoutTextFragment(d, c, b),
            c += d.GetWidth())
    }
    _LayoutTextFragment(a, b, c) {
        var d = a.GetStyleTag("offsetx");
        b += d ? getOffsetParam$jscomp$1(d.param, a.GetHeight()) : 0;
        d = a.GetStyleTag("offsety");
        c += d ? getOffsetParam$jscomp$1(d.param, a.GetHeight()) : 0;
        a.SetPosX(b);
        a.SetPosY(c)
    }
    Draw(a, b, c, d) {
        this._UpdateTextMeasurements();
        this._drawCharCount = 0;
        const e = C3$jscomp$323.cloneArray(this._wrappedText.GetLines())
          , f = Math.sin(d);
        d = Math.cos(d);
        for (const h of e)
            this._DrawLine(a, h, b, c, f, d)
    }
    _DrawLine(a, b, c, d, e, f) {
        var h = b.GetPosX();
        const l = b.GetPosY();
        if (Number.isFinite(h) && Number.isFinite(l)) {
            h = b.GetHeight();
            for (const m of b.fragments())
                this._DrawFragment(a, m, c, d, e, f, h)
        }
    }
    _DrawFragment(a, b, c, d, e, f, h) {
        let l = b.GetPosX()
          , m = b.GetPosY();
        if (Number.isFinite(l) && Number.isFinite(m)) {
            var p = b.GetCharacterArray()
              , r = b.GetWidth();
            if (-1 !== this._drawMaxCharCount) {
                if (this._drawCharCount >= this._drawMaxCharCount)
                    return;
                this._drawCharCount + p.length > this._drawMaxCharCount && (p = p.slice(0, this._drawMaxCharCount - this._drawCharCount),
                r = this._MeasureText(b).width);
                this._drawCharCount += p.length
            }
            var v = b.GetStyleTag("background");
            if (!(C3$jscomp$323.IsCharArrayAllWhitespace(p) && !v || b.HasStyleTag("hide"))) {
                var x = b.GetStyleTag("scale")
                  , B = (x ? parseFloat(x.param) : this._scale) * this._sceneGraphScale;
                x = b.GetStyleTag("scalex");
                x = (x ? parseFloat(x.param) : 1) * B;
                var A = b.GetStyleTag("scaley");
                B *= A ? parseFloat(A.param) : 1;
                B *= this._spriteFont.GetCharacterHeight();
                m += h - this._lineHeight - B;
                h = 1;
                (A = b.GetStyleTag("opacity")) && (h = parseFloat(A.param) / 100);
                v && (a.SetColorFillMode(),
                tmpColor$jscomp$1.parseString(normalizeCssColorString(v.param)),
                tmpColor$jscomp$1.setA(tmpColor$jscomp$1.getA() * h * this._color.getA()),
                tmpColor$jscomp$1.premultiply(),
                a.SetColor(tmpColor$jscomp$1),
                tmpRect$jscomp$3.set(l, m, l + r, m + B),
                tmpRect$jscomp$3.getRight() > this._cssWidth && tmpRect$jscomp$3.setRight(this._cssWidth),
                tmpQuad$jscomp$4.setFromRotatedRectPrecalc(tmpRect$jscomp$3, e, f),
                tmpQuad$jscomp$4.offset(c, d),
                a.Quad(tmpQuad$jscomp$4),
                a.SetTextureFillMode());
                (b = b.GetStyleTag("color")) ? (tmpColor$jscomp$1.parseString(normalizeCssColorString(b.param)),
                tmpColor$jscomp$1.setA(this._color.getA())) : tmpColor$jscomp$1.copy(this._color);
                tmpColor$jscomp$1.setA(tmpColor$jscomp$1.getA() * h);
                tmpColor$jscomp$1.premultiply();
                a.SetColor(tmpColor$jscomp$1);
                b = this._spriteFont.GetCharacterWidth() * x;
                r = Math.abs(this.GetSpacing());
                for (const D of p)
                    if (p = this._spriteFont.GetCharacter(D)) {
                        v = p.GetDisplayWidth() * x;
                        if (l + v > this._cssWidth + r + 1E-5)
                            break;
                        tmpRect$jscomp$3.set(l, m, l + b, m + B);
                        tmpQuad$jscomp$4.setFromRotatedRectPrecalc(tmpRect$jscomp$3, e, f);
                        tmpQuad$jscomp$4.offset(c, d);
                        a.Quad3(tmpQuad$jscomp$4, p.GetTexRect());
                        l += v + this._spacing
                    } else
                        l += this._spriteFont.GetSpaceWidth() * x + this._spacing
            }
        }
    }
    GetSpriteFont() {
        return this._spriteFont
    }
    SetBBCodeEnabled(a) {
        a = !!a;
        this._isBBcodeEnabled !== a && (this._isBBcodeEnabled = a,
        this._SetWordWrapChanged())
    }
    IsBBCodeEnabled() {
        return this._isBBcodeEnabled
    }
    SetText(a) {
        this._text !== a && (this._text = a,
        this._SetWordWrapChanged())
    }
    SetWordWrapMode(a) {
        if (!VALID_WORD_WRAP_MODES$jscomp$1.has(a))
            throw Error("invalid word wrap mode");
        this._wrapMode !== a && (this._wrapMode = a,
        this._SetWordWrapChanged())
    }
    SetHorizontalAlign(a) {
        if (!VALID_HORIZ_ALIGNMENTS$jscomp$1.has(a))
            throw Error("invalid alignment");
        this._horizontalAlign !== a && (this._horizontalAlign = a,
        this._SetTextLayoutChanged())
    }
    SetVerticalAlign(a) {
        if (!VALID_VERT_ALIGNMENTS$jscomp$1.has(a))
            throw Error("invalid alignment");
        this._verticalAlign !== a && (this._verticalAlign = a,
        this._SetTextLayoutChanged())
    }
    SetScale(a) {
        this._scale !== a && (this._scale = a,
        this._SetWordWrapChanged())
    }
    GetScale() {
        return this._scale
    }
    SetSceneGraphScale(a) {
        this._sceneGraphScale !== a && (this._sceneGraphScale = a,
        this._SetWordWrapChanged())
    }
    GetSceneGraphScale() {
        return this._sceneGraphScale
    }
    SetSpacing(a) {
        this._spacing !== a && (this._spacing = a,
        this._SetWordWrapChanged())
    }
    GetSpacing() {
        return this._spacing
    }
    SetLineHeight(a) {
        this._lineHeight = a;
        this._SetWordWrapChanged()
    }
    GetLineHeight() {
        return this._lineHeight
    }
    SetOpacity(a) {
        a = C3$jscomp$323.clamp(a, 0, 1);
        this._color.a = a
    }
    SetColor(a) {
        this._color.equals(a) || this._color.copy(a)
    }
    GetColor() {
        return this._color
    }
    GetTextWidth() {
        this._UpdateTextMeasurements();
        return this._wrappedText.GetMaxLineWidth()
    }
    GetTextHeight() {
        this._UpdateTextMeasurements();
        var a = this._spriteFont.GetCharacterHeight() * this._scale;
        const b = this._lineHeight;
        a += b;
        return this._wrappedText.GetLineCount() * a - b
    }
}
;
"use strict";
const C3$jscomp$324 = self.C3
  , DEFAULT_SPRITEFONT_OPTS = {
    width: 256,
    height: 256,
    characterWidth: 16,
    characterHeight: 16,
    characterSet: ""
};
self.SpriteFont = class {
    constructor(a) {
        a = Object.assign({}, DEFAULT_SPRITEFONT_OPTS, a);
        if (0 >= a.width || 0 >= a.height || 0 >= a.characterWidth || 0 >= a.characterHeight)
            throw Error("invalid size");
        this._width = a.width;
        this._height = a.height;
        this._characterWidth = a.characterWidth;
        this._characterHeight = a.characterHeight;
        this._characterSet = a.characterSet;
        this._spacingData = "";
        this._spacingParsed = null;
        this._hasAnyCustomWidths = !1;
        this._spaceWidth = -1;
        this._texRect = new C3$jscomp$324.Rect(0,0,1,1);
        this._characterMap = new Map;
        this._mapChanged = !0;
        this._allTexts = new Set
    }
    Release() {
        this._texRect = null;
        this._ReleaseCharacters();
        this._characterMap = null;
        this._allTexts && this._allTexts.clear();
        this._allTexts = null
    }
    _ReleaseCharacters() {
        for (let a of this._characterMap.values())
            a.Release();
        this._characterMap.clear()
    }
    _AddSpriteFontText(a) {
        this._allTexts.add(a)
    }
    _RemoveSpriteFontText(a) {
        this._allTexts.delete(a)
    }
    UpdateCharacterMap() {
        if (this._mapChanged) {
            this._ReleaseCharacters();
            var a = C3$jscomp$324.SplitGraphemes(this._characterSet)
              , b = Math.floor(this._width / this._characterWidth)
              , c = b * Math.floor(this._height / this._characterHeight);
            for (let d = 0, e = a.length; d < e && !(d >= c); ++d) {
                let f = a[d];
                this._characterMap.has(f) || this._characterMap.set(f, C3$jscomp$324.New(self.SpriteFontCharacter, this, f, d % b * this._characterWidth, Math.floor(d / b) * this._characterHeight))
            }
            this._hasAnyCustomWidths = !1;
            this._spaceWidth = -1;
            if (Array.isArray(this._spacingParsed))
                for (let d of this._spacingParsed)
                    if (Array.isArray(d) && 2 === d.length && (a = d[0],
                    b = d[1],
                    "number" === typeof a && isFinite(a) && "string" === typeof b && a !== this._characterWidth))
                        for (let e of b)
                            (b = this._characterMap.get(e)) ? (b.SetDisplayWidth(a),
                            this._hasAnyCustomWidths = !0) : " " === e && (this._spaceWidth = a,
                            this._hasAnyCustomWidths = !0);
            this._mapChanged = !1;
            for (let d of this._allTexts)
                d._SetWordWrapChanged()
        }
    }
    SetCharacterWidthsChanged() {
        this._hasAnyCustomWidths = !0;
        for (const a of this._allTexts)
            a._SetWordWrapChanged()
    }
    GetCharacter(a) {
        this.UpdateCharacterMap();
        return this._characterMap.get(a) || null
    }
    HasAnyCustomWidths() {
        return this._hasAnyCustomWidths
    }
    SetWidth(a) {
        a = Math.floor(a);
        if (0 >= a)
            throw Error("invalid size");
        this._width !== a && (this._width = a,
        this._mapChanged = !0)
    }
    GetWidth() {
        return this._width
    }
    SetHeight(a) {
        a = Math.floor(a);
        if (0 >= a)
            throw Error("invalid size");
        this._height !== a && (this._height = a,
        this._mapChanged = !0)
    }
    GetHeight() {
        return this._height
    }
    SetTexRect(a) {
        if (!this._texRect.equals(a)) {
            this._texRect.copy(a);
            for (const b of this._characterMap.values())
                b._UpdateTexRect()
        }
    }
    GetTexRect() {
        return this._texRect
    }
    SetCharacterWidth(a) {
        a = Math.floor(a);
        if (0 >= a)
            throw Error("invalid size");
        this._characterWidth !== a && (this._characterWidth = a,
        this._mapChanged = !0)
    }
    GetCharacterWidth() {
        return this._characterWidth
    }
    SetCharacterHeight(a) {
        a = Math.floor(a);
        if (0 >= a)
            throw Error("invalid size");
        this._characterHeight !== a && (this._characterHeight = a,
        this._mapChanged = !0)
    }
    GetCharacterHeight() {
        return this._characterHeight
    }
    SetCharacterSet(a) {
        this._characterSet !== a && (this._characterSet = a,
        this._mapChanged = !0)
    }
    GetCharacterSet() {
        return this._characterSet
    }
    SetSpacingData(a) {
        if (this._spacingData !== a && (this._spacingData = a,
        this._mapChanged = !0,
        this._spacingParsed = null,
        this._spacingData.length))
            try {
                this._spacingParsed = JSON.parse(this._spacingData)
            } catch (b) {
                this._spacingParsed = null
            }
    }
    GetSpacingData() {
        return this._spacingData
    }
    SetSpaceWidth(a) {
        0 > a && (a = -1);
        this._spaceWidth !== a && (this._spaceWidth = a,
        0 <= this._spaceWidth && (this._hasAnyCustomWidths = !0))
    }
    GetSpaceWidth() {
        return 0 > this._spaceWidth ? this._characterWidth : this._spaceWidth
    }
}
;
"use strict";
const C3$jscomp$325 = self.C3;
C3$jscomp$325.Plugins.DrawingCanvas = class extends C3$jscomp$325.SDKPluginBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
}
;
const C3$jscomp$326 = self.C3;
C3$jscomp$326.Plugins.DrawingCanvas.Type = class extends C3$jscomp$326.SDKTypeBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
}
;
const C3$jscomp$327 = self.C3
  , C3X$jscomp$48 = self.C3X
  , tempColor$jscomp$8 = C3$jscomp$327.New(C3$jscomp$327.Color)
  , tempColor2 = C3$jscomp$327.New(C3$jscomp$327.Color)
  , tempRect$jscomp$16 = C3$jscomp$327.New(C3$jscomp$327.Rect)
  , tempQuad$jscomp$11 = C3$jscomp$327.New(C3$jscomp$327.Quad);
function ClonePolyArray(a) {
    return a.map(b => b.slice(0))
}
function SortByInstanceZIndex(a, b) {
    return a.GetWorldInfo().GetZIndex() - b.GetWorldInfo().GetZIndex()
}
let drawDepth = 0;
C3$jscomp$327.Plugins.DrawingCanvas.Instance = class extends C3$jscomp$327.SDKWorldInstanceBase {
    constructor(a, b) {
        super(a);
        this._renderTarget = null;
        this._rcTex = C3$jscomp$327.New(C3$jscomp$327.Rect);
        a = this.GetWorldInfo();
        this._isFixedResolution = !1;
        this._fixedResolutionWidth = Math.floor(a.GetWidth());
        this._fixedResolutionHeight = Math.floor(a.GetHeight());
        this._multisampling = 0;
        this._texRenderTarget = null;
        this._drawCommands = [];
        this._currentPoly = [];
        this._drawBlendMode = 0;
        this._texScale = this._drawScale = 1;
        this._lineDashTexture = null;
        this._savedImageUrl = "";
        this._snapshot = null;
        this._tempRect = C3$jscomp$327.New(C3$jscomp$327.Rect);
        this._deviceQuadUnrotated = C3$jscomp$327.New(C3$jscomp$327.Quad);
        this._deviceQuadRotated = C3$jscomp$327.New(C3$jscomp$327.Quad);
        b && (this._isFixedResolution = 1 === b[0],
        a.SetVisible(!!b[1]),
        this._multisampling = [0, 2, 4, 8][b[3]]);
        b = this._runtime.GetRenderer();
        this._SetDrawingBlendMode(0);
        b.IsWebGL() && 2 > b.GetWebGLVersionNumber() && (this._multisampling = 0);
        this._StartTicking2()
    }
    Release() {
        this._renderTarget && (this._renderTarget.GetRenderer().DeleteRenderTarget(this._renderTarget),
        this._renderTarget = null);
        this._texRenderTarget && (this._texRenderTarget.GetRenderer().DeleteRenderTarget(this._texRenderTarget),
        this._texRenderTarget = null);
        C3$jscomp$327.clearArray(this._drawCommands);
        super.Release()
    }
    IsFixedResolutionMode() {
        return this._isFixedResolution
    }
    _GetLineDashTexture() {
        this._MaybeCreateLineDashTexture();
        return this._lineDashTexture
    }
    _MaybeCreateLineDashTexture() {
        if (!this._lineDashTexture) {
            var a = C3$jscomp$327.CreateCanvas(512, 8)
              , b = a.getContext("2d");
            b.clearRect(0, 0, 512, 8);
            b.fillStyle = "white";
            b.fillRect(0, 0, 256, 8);
            this._lineDashTexture = this._runtime.GetRenderer().CreateStaticTexture(a, {
                wrapX: "repeat",
                sampling: this._runtime.GetSampling()
            })
        }
    }
    _SetDrawingBlendMode(a) {
        this._drawBlendMode = a
    }
    _ApplyCurrentDrawingBlendMode(a) {
        a.SetBlendMode(this._drawBlendMode)
    }
    _AddDrawCommand(a) {
        this._drawCommands.push(a);
        this._runtime.UpdateRender()
    }
    _SetFixedResolutionMode(a, b) {
        this._isFixedResolution = !0;
        this._fixedResolutionWidth = Math.floor(a);
        this._fixedResolutionHeight = Math.floor(b)
    }
    _SetAutoResolutionMode() {
        this._isFixedResolution = !1
    }
    _ClearCanvas(a) {
        C3$jscomp$327.clearArray(this._drawCommands);
        this._AddDrawCommand(new C3$jscomp$327.Plugins.DrawingCanvas.DrawCommand.ClearCanvas(a))
    }
    _ClearRect(a, b, c, d, e) {
        a !== c && b !== d && this._AddDrawCommand(new C3$jscomp$327.Plugins.DrawingCanvas.DrawCommand.ClearRect(a,b,c,d,e))
    }
    _FillRect(a, b, c, d, e) {
        a !== c && b !== d && this._AddDrawCommand(new C3$jscomp$327.Plugins.DrawingCanvas.DrawCommand.FillRect(a,b,c,d,e))
    }
    _FillLinearGradient(a, b, c, d, e, f, h) {
        a !== c && b !== d && this._AddDrawCommand(new C3$jscomp$327.Plugins.DrawingCanvas.DrawCommand.FillLinearGradient(a,b,c,d,e,f,h))
    }
    _FillEllipse(a, b, c, d, e, f) {
        0 >= c || 0 >= d || this._AddDrawCommand(new C3$jscomp$327.Plugins.DrawingCanvas.DrawCommand.FillEllipse(a,b,c,d,e,f))
    }
    _OutlineEllipse(a, b, c, d, e, f, h) {
        0 >= c || 0 >= d || 0 >= f || this._AddDrawCommand(new C3$jscomp$327.Plugins.DrawingCanvas.DrawCommand.OutlineEllipse(a,b,c,d,e,f,h))
    }
    _OutlineRect(a, b, c, d, e, f) {
        a === c || b === d || 0 >= f || this._AddDrawCommand(new C3$jscomp$327.Plugins.DrawingCanvas.DrawCommand.OutlineRect(a,b,c,d,e,f))
    }
    _Line(a, b, c, d, e, f, h) {
        a === c && b === d || 0 >= f || this._AddDrawCommand(new C3$jscomp$327.Plugins.DrawingCanvas.DrawCommand.Line(a,b,c,d,e,f,h))
    }
    _LineDashed(a, b, c, d, e, f, h, l) {
        if (!(a === c && b === d || 0 >= f || 0 >= h)) {
            var m = this._GetLineDashTexture();
            this._AddDrawCommand(new C3$jscomp$327.Plugins.DrawingCanvas.DrawCommand.LineDashed(a,b,c,d,e,f,h,m,l))
        }
    }
    _LinePoly(a, b, c, d) {
        2 > a.length || 0 >= c || this._AddDrawCommand(new C3$jscomp$327.Plugins.DrawingCanvas.DrawCommand.LinePoly(ClonePolyArray(a),b,c,d))
    }
    _LineDashedPoly(a, b, c, d, e) {
        if (!(2 > a.length || 0 >= c || 0 >= d)) {
            var f = this._GetLineDashTexture();
            this._AddDrawCommand(new C3$jscomp$327.Plugins.DrawingCanvas.DrawCommand.LineDashedPoly(ClonePolyArray(a),b,c,d,f,e))
        }
    }
    _FillPoly(a, b, c) {
        3 > a.length || this._AddDrawCommand(new C3$jscomp$327.Plugins.DrawingCanvas.DrawCommand.FillPoly(ClonePolyArray(a),b,c))
    }
    _SetDrawBlend(a) {
        this._AddDrawCommand(new C3$jscomp$327.Plugins.DrawingCanvas.DrawCommand.SetDrawBlend(a))
    }
    _PasteInstances(a, b) {
        const c = this.GetWorldInfo()
          , d = c.GetBoundingBox()
          , e = c.GetBoundingQuad();
        a = a.filter(l => (l = l.GetWorldInfo()) && d.intersectsRect(l.GetBoundingBox()) && (0 === c.GetAngle() || e.intersectsQuad(l.GetBoundingQuad())));
        if (0 !== a.length) {
            a.sort(SortByInstanceZIndex);
            var f = null
              , h = new Promise(l => f = l);
            this._AddDrawCommand(new C3$jscomp$327.Plugins.DrawingCanvas.DrawCommand.DrawInstances(a,b,c,f));
            return h
        }
    }
    _GetPixelScale() {
        return 1 / (this._drawScale * this._texScale)
    }
    _UpdateRenderTargetSize(a, b, c) {
        this._renderTarget && a.DeleteRenderTarget(this._renderTarget);
        this._renderTarget = a.CreateRenderTarget({
            width: b,
            height: c,
            sampling: this._runtime.GetSampling(),
            isSampled: 0 === this._multisampling,
            canReadPixels: 0 === this._multisampling,
            canUpdate: 0 === this._multisampling,
            multisampling: this._multisampling
        });
        0 < this._multisampling && (this._texRenderTarget && a.DeleteRenderTarget(this._texRenderTarget),
        this._texRenderTarget = a.CreateRenderTarget({
            width: b,
            height: c,
            sampling: this._runtime.GetSampling(),
            isSampled: !0,
            canReadPixels: !0,
            canUpdate: !0
        }));
        a.SetTexture(null)
    }
    _GetRenderTarget() {
        return this._renderTarget
    }
    _GetTexRenderTarget() {
        return this._texRenderTarget
    }
    GetMultisampling() {
        return this._multisampling
    }
    _SetRenderTargetDeviceTransform(a) {
        this._runtime.GetCanvasManager().SetDeviceTransform(a, this._renderTarget.GetWidth(), this._renderTarget.GetHeight(), !1)
    }
    HasAnyDrawingCommandInQueue() {
        return this._drawCommands.some(a => !(a instanceof C3$jscomp$327.Plugins.DrawingCanvas.DrawCommand.SaveImage))
    }
    _CalculateUnrotatedDeviceCoords(a, b) {
        const c = this.GetWorldInfo()
          , d = c.GetLayer()
          , e = d.GetLayout()
          , f = c.GetAngle()
          , h = d.GetOwnAngle()
          , l = e.GetAngle();
        if (0 !== f || 0 !== h || 0 !== l)
            e.SetAngle(0),
            d.SetAngle(0),
            c.SetAngle(0),
            c.SetBboxChanged();
        var m = c.GetBoundingQuad();
        const [p,r] = d.LayerToDrawSurface(m.getTlx(), m.getTly())
          , [v,x] = d.LayerToDrawSurface(m.getBrx(), m.getBry());
        m = p - Math.round(p);
        const B = r - Math.round(r);
        a.set(p, r, v, x);
        a.offset(-m, -B);
        a.normalize();
        b.setFromRect(a);
        if (0 !== f || 0 !== h || 0 !== l)
            e.SetAngle(l),
            d.SetAngle(h),
            c.SetAngle(f),
            c.SetBboxChanged()
    }
    _CalculateRotatedDeviceCoords(a) {
        var b = this.GetWorldInfo();
        const c = b.GetLayer()
          , d = c.GetLayout()
          , e = c.GetOwnAngle()
          , f = d.GetAngle();
        if (0 !== e || 0 !== f)
            d.SetAngle(0),
            c.SetAngle(0);
        b = b.GetBoundingQuad();
        const [h,l] = c.LayerToDrawSurface(b.getTlx(), b.getTly())
          , [m,p] = c.LayerToDrawSurface(b.getTrx(), b.getTry())
          , [r,v] = c.LayerToDrawSurface(b.getBrx(), b.getBry())
          , [x,B] = c.LayerToDrawSurface(b.getBlx(), b.getBly());
        b = h - Math.round(h);
        const A = l - Math.round(l);
        a.set(h, l, m, p, r, v, x, B);
        a.offset(b, A);
        if (0 !== e || 0 !== f)
            d.SetAngle(f),
            c.SetAngle(e)
    }
    _CalculateSurfaceDeviceSize() {
        var a = this._runtime.GetRenderer()
          , b = this._tempRect;
        this._CalculateUnrotatedDeviceCoords(b, this._deviceQuadUnrotated);
        this._CalculateRotatedDeviceCoords(this._deviceQuadRotated);
        let c, d;
        this._isFixedResolution ? (c = this._fixedResolutionWidth,
        d = this._fixedResolutionHeight,
        a.IsWebGL() ? this._rcTex.set(0, 1, 1, 0) : this._rcTex.set(0, 0, 1, 1)) : (this.GetWorldInfo().GetLayer().RendersIn3DMode() && this._deviceQuadRotated.getBoundingBox(b),
        c = Math.ceil(b.width() + .001),
        d = Math.ceil(b.height() + .001),
        a.IsWebGL() ? this._rcTex.set(0, 1, b.width() / c, 1 - b.height() / d) : this._rcTex.set(0, 0, b.width() / c, b.height() / d));
        a = a.GetMaxTextureSize();
        b = Math.max(c, d);
        b > a ? (this._texScale = a / b,
        c = Math.round(c * this._texScale),
        d = Math.round(d * this._texScale)) : this._texScale = 1;
        return [c, d]
    }
    _OnResolutionChanged() {
        this.DispatchScriptEvent("resolutionchange");
        this.Trigger(C3$jscomp$327.Plugins.DrawingCanvas.Cnds.OnResolutionChanged)
    }
    _MaybeCreateRenderTarget() {
        if (!this._renderTarget) {
            var [a,b] = this._CalculateSurfaceDeviceSize();
            0 >= a || 0 >= b || (this._drawScale = tempRect$jscomp$16.width() / this.GetWorldInfo().GetWidth(),
            this._UpdateRenderTargetSize(this._runtime.GetRenderer(), a, b),
            this._OnResolutionChanged())
        }
    }
    Tick2() {
        const a = this._runtime.GetRenderer();
        var b = this.GetWorldInfo()
          , c = this._tempRect;
        ++drawDepth;
        const [d,e] = this._CalculateSurfaceDeviceSize();
        if (!(0 >= d || 0 >= e) && (this._drawScale = this._isFixedResolution ? 1 : c.width() / b.GetWidth(),
        b = this._drawScale * this._texScale,
        (c = !this._renderTarget || this._renderTarget.GetWidth() !== d || this._renderTarget.GetHeight() !== e) && this._OnResolutionChanged(),
        0 < this._drawCommands.length || !this._renderTarget)) {
            (!this._renderTarget || c && this.HasAnyDrawingCommandInQueue()) && this._UpdateRenderTargetSize(a, d, e);
            a.SetRenderTarget(this._renderTarget);
            this._SetRenderTargetDeviceTransform(a);
            this._ApplyCurrentDrawingBlendMode(a);
            a.IsWebGPU() && 0 < this._multisampling && a.SetRenderingToMultisampleCount(this._multisampling);
            for (const f of this._drawCommands)
                f.Do(a, b, this);
            C3$jscomp$327.clearArray(this._drawCommands);
            a.SetAlphaBlend();
            a.IsWebGPU() && 0 < this._multisampling && a.SetRenderingToMultisampleCount(0);
            0 < this._multisampling && (a.SetRenderTarget(this._texRenderTarget),
            a.CopyRenderTarget(this._renderTarget, "crop"))
        }
        --drawDepth
    }
    Draw(a) {
        const b = this.GetWorldInfo()
          , c = b.GetLayer()
          , d = this._runtime.GetCanvasManager()
          , e = a.GetRenderTarget();
        let f = this._deviceQuadUnrotated;
        if (this._renderTarget) {
            a.IsWebGPU() && a._MaybeDoPendingClearRenderPass(this._renderTarget);
            0 === this._multisampling ? a.SetTexture(this._renderTarget.GetTexture()) : a.SetTexture(this._texRenderTarget.GetTexture());
            var h = !1;
            0 < drawDepth ? this._inst._IsDrawingWithEffects() ? f = b.GetBoundingQuad() : (d.SetDeviceTransform(a, e.GetWidth(), e.GetHeight(), !1),
            h = !0,
            f = this._deviceQuadRotated) : 0 === b.GetAngle() && 0 === c.GetAngle() && 0 === b.GetTotalZElevation() && !b.HasMesh() && c.RendersIn2DMode() ? (d.SetDeviceTransform(a),
            h = !0) : f = b.GetBoundingQuad();
            b.HasMesh() ? this._DrawMesh(a, b) : a.Quad3(f, this._rcTex);
            h && c._SetTransform(a, !1);
            a.SetTexture(null)
        }
    }
    _DrawMesh(a, b) {
        const c = b.GetTransformedMesh();
        b.IsMeshChanged() && (b.CalculateBbox(tempRect$jscomp$16, tempQuad$jscomp$11, !1),
        c.CalculateTransformedMesh(b.GetSourceMesh(), tempQuad$jscomp$11, this._rcTex),
        b.SetMeshChanged(!1));
        c.Draw(a)
    }
    GetSnapshotPixel(a, b) {
        if (!this._snapshot)
            return [0, 0, 0, 0];
        var c = this._snapshot.width
          , d = this._snapshot.height;
        a = Math.floor(a);
        b = this._runtime.GetRenderer().IsWebGL() ? d - 1 - Math.floor(b) : Math.floor(b);
        if (0 > a || 0 > b || a >= c || b >= d)
            return [0, 0, 0, 0];
        d = this._snapshot.data;
        const e = b * c * 4 + 4 * a;
        a = d[e] / 255;
        b = d[e + 1] / 255;
        c = d[e + 2] / 255;
        d = d[e + 3] / 255;
        0 !== d && (a /= d,
        b /= d,
        c /= d);
        return [100 * a, 100 * b, 100 * c, 100 * d]
    }
    SetSnapshotPixel(a, b, c) {
        if (!this._snapshot)
            return [0, 0, 0, 0];
        tempColor$jscomp$8.setFromRgbValue(c);
        tempColor$jscomp$8.premultiply();
        c = this._snapshot.width;
        var d = this._snapshot.height;
        a = Math.floor(a);
        b = d - 1 - Math.floor(b);
        0 > a || 0 > b || a >= c || b >= d || (d = this._snapshot.data,
        a = b * c * 4 + 4 * a,
        d[a] = Math.floor(255 * tempColor$jscomp$8.getR()),
        d[a + 1] = Math.floor(255 * tempColor$jscomp$8.getG()),
        d[a + 2] = Math.floor(255 * tempColor$jscomp$8.getB()),
        d[a + 3] = Math.floor(255 * tempColor$jscomp$8.getA()))
    }
    GetImagePixelData() {
        return new Promise(a => {
            this._AddDrawCommand(new C3$jscomp$327.Plugins.DrawingCanvas.DrawCommand.SaveImage(async b => {
                var c = b.data.buffer;
                const d = b.width;
                b = b.height;
                c = await this._runtime.AddJob("ProcessImageData", {
                    buffer: c,
                    width: d,
                    height: b,
                    unpremultiply: !0,
                    flipY: this._runtime.GetRenderer().IsWebGL()
                }, [c]);
                a(new ImageData(new Uint8ClampedArray(c),d,b))
            }
            ))
        }
        )
    }
    LoadImagePixelData(a, b, c) {
        this._MaybeCreateRenderTarget();
        if (!this._renderTarget)
            throw Error("invalid canvas size");
        if (a.width !== this._renderTarget.GetWidth() || a.height !== this._renderTarget.GetHeight())
            throw Error(`wrong size ImageData: expected ${this._renderTarget.GetWidth()} x ${this._renderTarget.GetHeight()}, got ${a.width} x ${a.height}`);
        C3$jscomp$327.clearArray(this._drawCommands);
        const d = this._runtime.GetRenderer();
        if (this._texRenderTarget) {
            var e = d.GetRenderTarget();
            const f = this._texRenderTarget.GetTexture();
            d.UpdateTexture(a, f, {
                premultiplyAlpha: !!b,
                flipY: !!c
            });
            d.SetRenderTarget(this._renderTarget);
            d.CopyRenderTarget(this._texRenderTarget, "crop");
            d.SetRenderTarget(e)
        } else
            e = this._renderTarget.GetTexture(),
            d.UpdateTexture(a, e, {
                premultiplyAlpha: !!b,
                flipY: !!c
            });
        this._runtime.UpdateRender()
    }
    GetScriptInterfaceClass() {
        return self.IDrawingCanvasInstance
    }
}
;
const map$jscomp$37 = new WeakMap;
function arrToColor(a) {
    tempColor$jscomp$8.setFromJSON(a);
    return tempColor$jscomp$8
}
function arrToColor2(a) {
    tempColor2.setFromJSON(a);
    return tempColor2
}
const VALID_GRADIENT_DIRECTIONS = ["horizontal", "vertical"]
  , VALID_LINE_CAPS = new Set(["butt", "square"]);
function ValidateLineCap(a) {
    if (!VALID_LINE_CAPS.has(a))
        throw Error("invalid line cap");
}
function ValidatePoly(a) {
    C3X$jscomp$48.RequireArray(a);
    for (const b of a)
        C3X$jscomp$48.RequireArray(b),
        C3X$jscomp$48.RequireFiniteNumber(b[0]),
        C3X$jscomp$48.RequireFiniteNumber(b[1])
}
const BLEND_MODE_TO_INDEX$jscomp$2 = new Map([["normal", 0], ["additive", 1], ["copy", 3], ["destination-over", 4], ["source-in", 5], ["destination-in", 6], ["source-out", 7], ["destination-out", 8], ["source-atop", 9], ["destination-atop", 10]]);
self.IDrawingCanvasInstance = class extends self.IWorldInstance {
    constructor() {
        super();
        map$jscomp$37.set(this, self.IInstance._GetInitInst().GetSdkInstance())
    }
    setFixedResolutionMode(a, b) {
        C3X$jscomp$48.RequireFiniteNumber(a);
        C3X$jscomp$48.RequireFiniteNumber(b);
        map$jscomp$37.get(this)._SetFixedResolutionMode(a, b)
    }
    setAutoResolutionMode() {
        map$jscomp$37.get(this)._SetAutoResolutionMode()
    }
    clearCanvas(a) {
        C3X$jscomp$48.RequireArray(a);
        map$jscomp$37.get(this)._ClearCanvas(arrToColor(a))
    }
    clearRect(a, b, c, d, e) {
        C3X$jscomp$48.RequireFiniteNumber(a);
        C3X$jscomp$48.RequireFiniteNumber(b);
        C3X$jscomp$48.RequireFiniteNumber(c);
        C3X$jscomp$48.RequireFiniteNumber(d);
        C3X$jscomp$48.RequireArray(e);
        map$jscomp$37.get(this)._ClearRect(a, b, c, d, arrToColor(e))
    }
    fillRect(a, b, c, d, e) {
        C3X$jscomp$48.RequireFiniteNumber(a);
        C3X$jscomp$48.RequireFiniteNumber(b);
        C3X$jscomp$48.RequireFiniteNumber(c);
        C3X$jscomp$48.RequireFiniteNumber(d);
        C3X$jscomp$48.RequireArray(e);
        map$jscomp$37.get(this)._FillRect(a, b, c, d, arrToColor(e))
    }
    fillLinearGradient(a, b, c, d, e, f, h="horizontal") {
        C3X$jscomp$48.RequireFiniteNumber(a);
        C3X$jscomp$48.RequireFiniteNumber(b);
        C3X$jscomp$48.RequireFiniteNumber(c);
        C3X$jscomp$48.RequireFiniteNumber(d);
        C3X$jscomp$48.RequireArray(e);
        C3X$jscomp$48.RequireArray(f);
        h = VALID_GRADIENT_DIRECTIONS.indexOf(h);
        if (0 > h)
            throw Error("invalid gradient direction");
        map$jscomp$37.get(this)._FillLinearGradient(a, b, c, d, arrToColor(e), arrToColor2(f), h)
    }
    fillEllipse(a, b, c, d, e, f=!0) {
        C3X$jscomp$48.RequireFiniteNumber(a);
        C3X$jscomp$48.RequireFiniteNumber(b);
        C3X$jscomp$48.RequireFiniteNumber(c);
        C3X$jscomp$48.RequireFiniteNumber(d);
        C3X$jscomp$48.RequireArray(e);
        map$jscomp$37.get(this)._FillEllipse(a, b, c, d, arrToColor(e), !!f)
    }
    outlineEllipse(a, b, c, d, e, f, h=!0) {
        C3X$jscomp$48.RequireFiniteNumber(a);
        C3X$jscomp$48.RequireFiniteNumber(b);
        C3X$jscomp$48.RequireFiniteNumber(c);
        C3X$jscomp$48.RequireFiniteNumber(d);
        C3X$jscomp$48.RequireArray(e);
        C3X$jscomp$48.RequireFiniteNumber(f);
        map$jscomp$37.get(this)._OutlineEllipse(a, b, c, d, arrToColor(e), f, !!h)
    }
    outlineRect(a, b, c, d, e, f) {
        C3X$jscomp$48.RequireFiniteNumber(a);
        C3X$jscomp$48.RequireFiniteNumber(b);
        C3X$jscomp$48.RequireFiniteNumber(c);
        C3X$jscomp$48.RequireFiniteNumber(d);
        C3X$jscomp$48.RequireArray(e);
        C3X$jscomp$48.RequireFiniteNumber(f);
        map$jscomp$37.get(this)._OutlineRect(a, b, c, d, arrToColor(e), f)
    }
    line(a, b, c, d, e, f, h="butt") {
        C3X$jscomp$48.RequireFiniteNumber(a);
        C3X$jscomp$48.RequireFiniteNumber(b);
        C3X$jscomp$48.RequireFiniteNumber(c);
        C3X$jscomp$48.RequireFiniteNumber(d);
        C3X$jscomp$48.RequireArray(e);
        C3X$jscomp$48.RequireFiniteNumber(f);
        ValidateLineCap(h);
        map$jscomp$37.get(this)._Line(a, b, c, d, arrToColor(e), f, h)
    }
    lineDashed(a, b, c, d, e, f, h, l="butt") {
        C3X$jscomp$48.RequireFiniteNumber(a);
        C3X$jscomp$48.RequireFiniteNumber(b);
        C3X$jscomp$48.RequireFiniteNumber(c);
        C3X$jscomp$48.RequireFiniteNumber(d);
        C3X$jscomp$48.RequireArray(e);
        C3X$jscomp$48.RequireFiniteNumber(f);
        C3X$jscomp$48.RequireFiniteNumber(h);
        ValidateLineCap(l);
        map$jscomp$37.get(this)._LineDashed(a, b, c, d, arrToColor(e), f, h, l)
    }
    linePoly(a, b, c, d="butt") {
        ValidatePoly(a);
        C3X$jscomp$48.RequireArray(b);
        C3X$jscomp$48.RequireFiniteNumber(c);
        ValidateLineCap(d);
        map$jscomp$37.get(this)._LinePoly(a, arrToColor(b), c, d)
    }
    lineDashedPoly(a, b, c, d, e="butt") {
        ValidatePoly(a);
        C3X$jscomp$48.RequireArray(b);
        C3X$jscomp$48.RequireFiniteNumber(c);
        C3X$jscomp$48.RequireFiniteNumber(d);
        ValidateLineCap(e);
        map$jscomp$37.get(this)._LineDashedPoly(a, arrToColor(b), c, d, e)
    }
    fillPoly(a, b, c=!1) {
        ValidatePoly(a);
        C3X$jscomp$48.RequireArray(b);
        map$jscomp$37.get(this)._FillPoly(a, arrToColor(b), !!c)
    }
    setDrawBlend(a) {
        a = BLEND_MODE_TO_INDEX$jscomp$2.get(a);
        if ("number" !== typeof a)
            throw Error("invalid blend mode");
        map$jscomp$37.get(this)._SetDrawBlend(a)
    }
    pasteInstances(a, b=!0) {
        C3X$jscomp$48.RequireArray(a);
        const c = map$jscomp$37.get(this)
          , d = c.GetRuntime();
        return c._PasteInstances(a.map(e => d._UnwrapIWorldInstance(e)), !!b)
    }
    getImagePixelData() {
        return map$jscomp$37.get(this).GetImagePixelData()
    }
    loadImagePixelData(a, b=!1) {
        C3X$jscomp$48.RequireInstanceOf(a, ImageData);
        const c = map$jscomp$37.get(this);
        c.LoadImagePixelData(a, b, c.GetRuntime().GetRenderer().IsWebGL())
    }
    get surfaceDeviceWidth() {
        var a = map$jscomp$37.get(this);
        a._MaybeCreateRenderTarget();
        a = a._GetRenderTarget();
        if (!a)
            throw Error("invalid canvas size");
        return a.GetWidth()
    }
    get surfaceDeviceHeight() {
        var a = map$jscomp$37.get(this);
        a._MaybeCreateRenderTarget();
        a = a._GetRenderTarget();
        if (!a)
            throw Error("invalid canvas size");
        return a.GetHeight()
    }
    getSurfaceDeviceSize() {
        var a = map$jscomp$37.get(this);
        a._MaybeCreateRenderTarget();
        a = a._GetRenderTarget();
        if (!a)
            throw Error("invalid canvas size");
        return [a.GetWidth(), a.GetHeight()]
    }
    get pixelScale() {
        return map$jscomp$37.get(this)._GetPixelScale()
    }
}
;
self.C3.Plugins.DrawingCanvas.Cnds = {
    OnSavedImage() {
        return !0
    },
    OnSnapshot() {
        return !0
    },
    OnResolutionChanged() {
        return !0
    }
};
const C3$jscomp$329 = self.C3
  , tempColor1 = C3$jscomp$329.New(C3$jscomp$329.Color)
  , tempColor2$jscomp$1 = C3$jscomp$329.New(C3$jscomp$329.Color);
function RgbToColor(a) {
    tempColor1.setFromRgbValue(a);
    return tempColor1
}
function RgbToColor2(a) {
    tempColor2$jscomp$1.setFromRgbValue(a);
    return tempColor2$jscomp$1
}
C3$jscomp$329.Plugins.DrawingCanvas.Acts = {
    SetEffect(a) {
        this.GetWorldInfo().SetBlendMode(a);
        this._runtime.UpdateRender()
    },
    SetResolutionMode(a, b, c) {
        1 === a ? this._SetFixedResolutionMode(b, c) : this._SetAutoResolutionMode()
    },
    ClearCanvas(a) {
        this._ClearCanvas(RgbToColor(a))
    },
    ClearRect(a, b, c, d, e) {
        this._ClearRect(a, b, c, d, RgbToColor(e))
    },
    FillRect(a, b, c, d, e) {
        this._FillRect(a, b, c, d, RgbToColor(e))
    },
    FillLinearGradient(a, b, c, d, e, f, h) {
        this._FillLinearGradient(a, b, c, d, RgbToColor(e), RgbToColor2(f), h)
    },
    FillEllipse(a, b, c, d, e, f) {
        this._FillEllipse(a, b, c, d, RgbToColor(e), 0 !== f)
    },
    OutlineEllipse(a, b, c, d, e, f, h) {
        this._OutlineEllipse(a, b, c, d, RgbToColor(e), f, 0 !== h)
    },
    OutlineRect(a, b, c, d, e, f) {
        this._OutlineRect(a, b, c, d, RgbToColor(e), f)
    },
    Line(a, b, c, d, e, f, h) {
        h = 0 === h ? "butt" : "square";
        this._Line(a, b, c, d, RgbToColor(e), f, h)
    },
    LineDashed(a, b, c, d, e, f, h, l) {
        l = 0 === l ? "butt" : "square";
        this._LineDashed(a, b, c, d, RgbToColor(e), f, h, l)
    },
    AddPolyPoint(a, b) {
        this._currentPoly.push([a, b])
    },
    ResetPoly() {
        C3$jscomp$329.clearArray(this._currentPoly)
    },
    LinePoly(a, b, c) {
        c = 0 === c ? "butt" : "square";
        this._LinePoly(this._currentPoly, RgbToColor(a), b, c)
    },
    LineDashedPoly(a, b, c, d) {
        d = 0 === d ? "butt" : "square";
        this._LineDashedPoly(this._currentPoly, RgbToColor(a), b, c, d)
    },
    FillPoly(a, b) {
        this._FillPoly(this._currentPoly, RgbToColor(a), b)
    },
    SetDrawBlend(a) {
        2 <= a && a++;
        this._SetDrawBlend(a)
    },
    PasteObject(a, b) {
        if (a)
            return this._PasteInstances(a.GetCurrentSol().GetInstances(), 0 !== b)
    },
    SaveImage(a, b, c, d, e, f) {
        const h = 0 === a ? "image/png" : "image/jpeg";
        b /= 100;
        const l = C3$jscomp$329.New(C3$jscomp$329.Rect);
        l.setWH(c, d, e, f);
        return new Promise(m => {
            this._AddDrawCommand(new C3$jscomp$329.Plugins.DrawingCanvas.DrawCommand.SaveImage(async p => {
                var r = p.data.buffer
                  , v = p.width;
                p = p.height;
                const x = this._runtime.GetRenderer().IsWebGL();
                r = await this._runtime.AddJob("ProcessImageData", {
                    buffer: r,
                    width: v,
                    height: p,
                    unpremultiply: !0,
                    flipY: x && !C3$jscomp$329.Supports.ImageBitmapOptions
                }, [r]);
                p = new ImageData(new Uint8ClampedArray(r),v,p);
                C3$jscomp$329.Supports.ImageBitmapOptions ? (v = await createImageBitmap(p, {
                    premultiplyAlpha: "none",
                    imageOrientation: x ? "flipY" : "none"
                }),
                v = await C3$jscomp$329.DrawableToBlob(v, h, b)) : v = await C3$jscomp$329.ImageDataToBlob(p, h, b);
                this._savedImageUrl && URL.revokeObjectURL(this._savedImageUrl);
                this._savedImageUrl = URL.createObjectURL(v);
                this.Trigger(C3$jscomp$329.Plugins.DrawingCanvas.Cnds.OnSavedImage);
                m()
            }
            ,l))
        }
        )
    },
    SaveSnapshot() {
        return new Promise(a => {
            this._AddDrawCommand(new C3$jscomp$329.Plugins.DrawingCanvas.DrawCommand.SaveImage(b => {
                this._snapshot = b;
                this.Trigger(C3$jscomp$329.Plugins.DrawingCanvas.Cnds.OnSnapshot);
                a()
            }
            ))
        }
        )
    },
    ClearSnapshot() {
        this._snapshot = null
    },
    SnapshotSetPixel(a, b, c) {
        this.SetSnapshotPixel(a, b, c)
    },
    LoadSnapshot() {
        this._snapshot && this._renderTarget && this._snapshot.width === this._renderTarget.GetWidth() && this._snapshot.height === this._renderTarget.GetHeight() && this.LoadImagePixelData(this._snapshot, !1)
    }
};
self.C3.Plugins.DrawingCanvas.Exps = {
    SavedImageURL() {
        return this._savedImageUrl
    },
    SnapshotRedAt(a, b) {
        return this.GetSnapshotPixel(a, b)[0]
    },
    SnapshotGreenAt(a, b) {
        return this.GetSnapshotPixel(a, b)[1]
    },
    SnapshotBlueAt(a, b) {
        return this.GetSnapshotPixel(a, b)[2]
    },
    SnapshotAlphaAt(a, b) {
        return this.GetSnapshotPixel(a, b)[3]
    },
    SnapshotWidth() {
        return this._snapshot ? this._snapshot.width : 0
    },
    SnapshotHeight() {
        return this._snapshot ? this._snapshot.height : 0
    },
    PixelScale() {
        return this._GetPixelScale()
    },
    SurfaceDeviceWidth() {
        const a = this._GetRenderTarget();
        return a ? a.GetWidth() : 0
    },
    SurfaceDeviceHeight() {
        const a = this._GetRenderTarget();
        return a ? a.GetHeight() : 0
    }
};
"use strict";
const C3$jscomp$331 = self.C3
  , tempQuad$jscomp$12 = C3$jscomp$331.New(C3$jscomp$331.Quad)
  , tempUvQuad = C3$jscomp$331.New(C3$jscomp$331.Quad)
  , tempVector2 = C3$jscomp$331.New(C3$jscomp$331.Vector2);
C3$jscomp$331.Plugins.DrawingCanvas.DrawCommand = class {
    constructor() {}
    Do(a) {
        throw Error("required override");
    }
}
;
const DrawCommand = C3$jscomp$331.Plugins.DrawingCanvas.DrawCommand;
DrawCommand.SaveImage = class extends DrawCommand {
    constructor(a, b) {
        super();
        this._callback = a;
        this._areaRect = b
    }
    Do(a, b, c) {
        b = a.GetRenderTarget();
        2 <= b.GetMultisampling() && (c = c._GetTexRenderTarget(),
        a.SetRenderTarget(c),
        a.CopyRenderTarget(b, "crop"),
        a.SetRenderTarget(b),
        b = c);
        a.ReadBackRenderTargetToImageData(b, !1, this._areaRect).then(this._callback)
    }
}
;
DrawCommand.ClearCanvas = class extends DrawCommand {
    constructor(a) {
        super();
        this._color = C3$jscomp$331.New(C3$jscomp$331.Color, a);
        this._color.premultiply()
    }
    Do(a) {
        a.Clear(this._color)
    }
}
;
DrawCommand.ClearRect = class extends DrawCommand {
    constructor(a, b, c, d, e) {
        super();
        this._rect = C3$jscomp$331.New(C3$jscomp$331.Rect);
        this._rect.set(a, b, c, d);
        this._color = C3$jscomp$331.New(C3$jscomp$331.Color, e);
        this._color.premultiply()
    }
    Do(a, b, c) {
        this._rect.multiply(b, b);
        a.SetColorFillMode();
        a.SetColor(this._color);
        a.SetBlendMode(3);
        a.Rect(this._rect);
        c._ApplyCurrentDrawingBlendMode(a)
    }
}
;
DrawCommand.FillRect = class extends DrawCommand {
    constructor(a, b, c, d, e) {
        super();
        this._rect = C3$jscomp$331.New(C3$jscomp$331.Rect);
        this._rect.set(a, b, c, d);
        this._color = C3$jscomp$331.New(C3$jscomp$331.Color, e);
        this._color.premultiply()
    }
    Do(a, b) {
        a.SetColorFillMode();
        a.SetColor(this._color);
        this._rect.multiply(b, b);
        a.Rect(this._rect)
    }
}
;
DrawCommand.FillLinearGradient = class extends DrawCommand {
    constructor(a, b, c, d, e, f, h) {
        super();
        this._rect = C3$jscomp$331.New(C3$jscomp$331.Rect);
        this._rect.set(a, b, c, d);
        this._color1 = C3$jscomp$331.New(C3$jscomp$331.Color, e);
        this._color2 = C3$jscomp$331.New(C3$jscomp$331.Color, f);
        this._dir = h
    }
    Do(a, b) {
        a.SetLinearGradientFillMode();
        a.SetColor(this._color1);
        a.SetGradientColor(this._color2);
        this._rect.multiply(b, b);
        tempQuad$jscomp$12.setFromRect(this._rect);
        0 === this._dir ? tempUvQuad.set(0, 0, 1, 0, 1, 1, 0, 1) : tempUvQuad.set(0, 1, 0, 0, 1, 0, 1, 1);
        a.Quad4(tempQuad$jscomp$12, tempUvQuad)
    }
}
;
DrawCommand.FillEllipse = class extends DrawCommand {
    constructor(a, b, c, d, e, f) {
        super();
        this._rect = C3$jscomp$331.New(C3$jscomp$331.Rect);
        this._rect.set(a - c, b - d, a + c, b + d);
        this._color = C3$jscomp$331.New(C3$jscomp$331.Color, e);
        this._color.premultiply();
        this._isSmooth = f
    }
    Do(a, b) {
        this._rect.multiply(b, b);
        this._isSmooth ? (a.SetSmoothEllipseFillMode(),
        a.SetColor(this._color),
        this._rect.inflate(.5, .5),
        a.SetEllipseParams(1 / this._rect.width(), 1 / this._rect.height())) : (a.SetHardEllipseFillMode(),
        a.SetColor(this._color));
        a.Rect(this._rect)
    }
}
;
DrawCommand.OutlineEllipse = class extends DrawCommand {
    constructor(a, b, c, d, e, f, h) {
        super();
        this._rect = C3$jscomp$331.New(C3$jscomp$331.Rect);
        this._rect.set(a - c, b - d, a + c, b + d);
        this._color = C3$jscomp$331.New(C3$jscomp$331.Color, e);
        this._color.premultiply();
        this._thickness = f;
        this._isSmooth = h
    }
    Do(a, b) {
        this._rect.multiply(b, b);
        this._isSmooth ? (a.SetSmoothEllipseOutlineMode(),
        a.SetColor(this._color),
        this._rect.inflate(.5, .5),
        a.SetEllipseParams(1 / this._rect.width(), 1 / this._rect.height(), this._thickness * b)) : (a.SetHardEllipseOutlineMode(),
        a.SetEllipseParams(1 / this._rect.width(), 1 / this._rect.height(), this._thickness * b),
        a.SetColor(this._color));
        a.Rect(this._rect)
    }
}
;
DrawCommand.OutlineRect = class extends DrawCommand {
    constructor(a, b, c, d, e, f) {
        super();
        this._rect = C3$jscomp$331.New(C3$jscomp$331.Rect);
        this._rect.set(a, b, c, d);
        this._color = C3$jscomp$331.New(C3$jscomp$331.Color, e);
        this._color.premultiply();
        this._thickness = f
    }
    Do(a, b) {
        a.SetColorFillMode();
        a.SetColor(this._color);
        a.PushLineCapZag();
        a.PushLineWidth(this._thickness * b);
        this._rect.multiply(b, b);
        a.LineRect2(this._rect);
        a.PopLineCap();
        a.PopLineWidth()
    }
}
;
DrawCommand.Line = class extends DrawCommand {
    constructor(a, b, c, d, e, f, h) {
        super();
        this._rect = C3$jscomp$331.New(C3$jscomp$331.Rect);
        this._rect.set(a, b, c, d);
        this._color = C3$jscomp$331.New(C3$jscomp$331.Color, e);
        this._color.premultiply();
        this._thickness = f;
        this._cap = h
    }
    Do(a, b) {
        a.SetColorFillMode();
        a.SetColor(this._color);
        a.PushLineCap(this._cap);
        a.PushLineWidth(this._thickness * b);
        const c = this._rect;
        c.multiply(b, b);
        a.Line(c.getLeft(), c.getTop(), c.getRight(), c.getBottom());
        a.PopLineCap();
        a.PopLineWidth()
    }
}
;
DrawCommand.LinePoly = class extends DrawCommand {
    constructor(a, b, c, d) {
        super();
        this._poly = a;
        this._color = C3$jscomp$331.New(C3$jscomp$331.Color, b);
        this._color.premultiply();
        this._thickness = c;
        this._cap = d
    }
    Do(a, b) {
        a.SetColorFillMode();
        a.SetColor(this._color);
        a.PushLineCap(this._cap);
        a.PushLineWidth(this._thickness * b);
        const c = this._poly;
        for (let d = 0, e = c.length; d < e; ++d) {
            const f = (d + 1) % e;
            a.Line(c[d][0] * b, c[d][1] * b, c[f][0] * b, c[f][1] * b)
        }
        a.PopLineCap();
        a.PopLineWidth()
    }
}
;
DrawCommand.LineDashed = class extends DrawCommand {
    constructor(a, b, c, d, e, f, h, l, m) {
        super();
        this._rect = C3$jscomp$331.New(C3$jscomp$331.Rect);
        this._rect.set(a, b, c, d);
        this._color = C3$jscomp$331.New(C3$jscomp$331.Color, e);
        this._color.premultiply();
        this._thickness = f;
        this._dashLength = h;
        this._dashTex = l;
        this._cap = m
    }
    Do(a, b) {
        a.SetTextureFillMode();
        a.SetTexture(this._dashTex);
        a.SetColor(this._color);
        a.PushLineCap(this._cap);
        a.PushLineWidth(this._thickness * b);
        const c = this._rect
          , d = C3$jscomp$331.distanceTo(c.getLeft(), c.getTop(), c.getRight(), c.getBottom()) / (2 * this._dashLength);
        c.multiply(b, b);
        a.TexturedLine(c.getLeft(), c.getTop(), c.getRight(), c.getBottom(), 0, d);
        a.PopLineCap();
        a.PopLineWidth()
    }
}
;
DrawCommand.LineDashedPoly = class extends DrawCommand {
    constructor(a, b, c, d, e, f) {
        super();
        this._poly = a;
        this._color = C3$jscomp$331.New(C3$jscomp$331.Color, b);
        this._color.premultiply();
        this._thickness = c;
        this._dashLength = d;
        this._dashTex = e;
        this._cap = f
    }
    Do(a, b) {
        a.SetTextureFillMode();
        a.SetTexture(this._dashTex);
        a.SetColor(this._color);
        a.PushLineCap(this._cap);
        a.PushLineWidth(this._thickness * b);
        let c = 0;
        const d = this._poly;
        for (let f = 0, h = d.length; f < h; ++f) {
            var e = (f + 1) % h;
            const l = d[f][0]
              , m = d[f][1]
              , p = d[e][0];
            e = d[e][1];
            const r = c + C3$jscomp$331.distanceTo(l, m, p, e) / (2 * this._dashLength);
            a.TexturedLine(l * b, m * b, p * b, e * b, c, r);
            c = r - Math.floor(r)
        }
        a.PopLineCap();
        a.PopLineWidth()
    }
}
;
DrawCommand.FillPoly = class extends DrawCommand {
    constructor(a, b, c) {
        super();
        this._poly = a;
        this._isConvex = c;
        this._color = C3$jscomp$331.New(C3$jscomp$331.Color, b);
        this._color.premultiply()
    }
    Do(a, b) {
        a.SetColorFillMode();
        a.SetColor(this._color);
        var c = this._poly;
        for (let d = 0, e = c.length; d < e; ++d) {
            const f = c[d];
            f[0] *= b;
            f[1] *= b
        }
        if (this._isConvex)
            a.ConvexPoly(c.flat());
        else if (b = self.polyDecomp,
        b.isSimple(c)) {
            b.makeCCW(c);
            b.removeCollinearPoints(c, C3$jscomp$331.toRadians(.1));
            c = b.quickDecomp(c);
            for (const d of c)
                a.ConvexPoly(d.flat())
        }
    }
}
;
DrawCommand.SetDrawBlend = class extends DrawCommand {
    constructor(a) {
        super();
        this._blendIndex = a
    }
    Do(a, b, c) {
        c._SetDrawingBlendMode(this._blendIndex);
        c._ApplyCurrentDrawingBlendMode(a)
    }
}
;
DrawCommand.DrawInstances = class extends DrawCommand {
    constructor(a, b, c, d) {
        super();
        const e = c.GetLayer();
        this._includeFx = b;
        this._resolve = d;
        this._layoutTransform = e.GetLayout().SaveTransform();
        this._layerTransforms = new Map;
        this._layerTransforms.set(e, e.SaveTransform());
        this._instances = a.map(f => this._SaveInstanceState(f, c))
    }
    _SaveInstanceState(a, b) {
        const c = b.GetAngle();
        var d = b.GetLayer();
        const e = a.GetWorldInfo();
        var f = e.GetLayer();
        const h = e.GetX()
          , l = e.GetY()
          , m = e.GetWidth()
          , p = e.GetHeight()
          , r = e.GetAngle();
        this._layerTransforms.has(f) || this._layerTransforms.set(f, f.SaveTransform());
        const v = d.IsTransformCompatibleWith(f);
        if (!v) {
            const [B,A] = f.LayerToDrawSurface(h, l)
              , [D,F] = d.DrawSurfaceToLayer(B, A);
            e.SetXY(D, F);
            var x = f.GetNormalScale() / d.GetNormalScale();
            e.SetSize(m * x, p * x);
            d = d.GetOwnAngle() - f.GetOwnAngle();
            e.OffsetAngle(d)
        }
        0 !== c && (f = b.GetBoundingQuad(),
        d = f.midX(),
        f = f.midY(),
        x = -b.GetSinAngle(),
        b = b.GetCosAngle(),
        tempVector2.set(h, l),
        tempVector2.offset(-d, -f),
        tempVector2.rotatePrecalc(x, b),
        tempVector2.offset(d, f),
        e.SetXY(tempVector2.getX(), tempVector2.getY()),
        e.OffsetAngle(-c));
        0 === c && v || e.SetBboxChanged();
        a = [a, a.SaveToJson("visual-state")];
        0 === c && v || (e.SetXY(h, l),
        e.SetSize(m, p),
        e.SetAngle(r),
        e.SetBboxChanged());
        return a
    }
    Do(a, b, c) {
        b = c.GetRuntime().GetCanvasManager();
        const d = c.GetWorldInfo().GetLayer()
          , e = d.GetLayout();
        var f = d.GetViewport()
          , h = c.GetWorldInfo().GetBoundingBox();
        const l = c._GetRenderTarget()
          , m = 2 <= c.GetMultisampling()
          , p = this._includeFx
          , r = e.SaveTransform();
        e.RestoreTransform(this._layoutTransform);
        const v = new Map;
        for (const [M,Q] of this._layerTransforms)
            v.set(M, M.SaveTransform()),
            M.RestoreTransform(Q);
        b.SetIsPastingToDrawingCanvas(!0);
        var x = (f.width() - h.width()) / -2
          , B = (f.height() - h.height()) / -2;
        const [A,D] = d.LayerToDrawSurface(h.getLeft(), h.getTop());
        b.SetDeviceTransformOffset(A, D);
        var F = h.getLeft() - f.getLeft();
        f = h.getTop() - f.getTop();
        x += F;
        B += f;
        f = l.GetHeight();
        F = 1;
        F = c.IsFixedResolutionMode() ? l.GetWidth() / Math.floor(h.width()) / d.GetNormalScale() : b.GetRenderScale() * self.devicePixelRatio;
        h = f / F;
        F = .5 / F;
        a.SetProjectionMatrix(l.GetProjectionMatrix());
        d._SetTransform(a, !1, x + F, B + F, h);
        for (let M = 0, Q = this._instances.length; M < Q; ++M) {
            var I = this._instances[M];
            f = I[0];
            var K = I[1];
            if (f.IsDestroyed())
                continue;
            I = f.GetWorldInfo();
            const W = f.SaveToJson("visual-state");
            f.LoadFromJson(K, "visual-state");
            I.GetBoundingBox();
            !p || !I.HasAnyActiveEffect() || m && I.GetInstanceEffectList().HasAnyActiveBackgroundBlendingEffect() ? d._DrawInstance(f, I, a) : (K = {
                drawContentHook: (ca, ia, ka) => {
                    d._SetTransform(ia);
                    ka();
                    ca._SetDeviceTransform(ia)
                }
                ,
                compositOffX: A,
                compositOffY: D,
                updateOwnProjection: !0
            },
            f._SetIsDrawingWithEffects(!0),
            d._DrawInstanceWithEffects(f, I, a, l, K) && d._SetTransform(a, !1, x + F, B + F, h),
            f._SetIsDrawingWithEffects(!1));
            f.LoadFromJson(W, "visual-state")
        }
        b.SetDeviceTransformOffset(0, 0);
        b.SetIsPastingToDrawingCanvas(!1);
        c._SetRenderTargetDeviceTransform(a);
        c._ApplyCurrentDrawingBlendMode(a);
        e.RestoreTransform(r);
        for (const [M,Q] of v)
            M.RestoreTransform(Q);
        this._resolve()
    }
}
;
"use strict";
const C3$jscomp$332 = self.C3;
C3$jscomp$332.Behaviors.Tween = class extends C3$jscomp$332.SDKBehaviorBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
}
;
const C3$jscomp$333 = self.C3;
C3$jscomp$333.Behaviors.Tween.Type = class extends C3$jscomp$333.SDKBehaviorTypeBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
}
;
const C3$jscomp$334 = self.C3
  , NAMESPACE = C3$jscomp$334.Behaviors.Tween;
NAMESPACE.Instance = class extends C3$jscomp$334.SDKBehaviorInstanceBase {
    constructor(a, b) {
        super(a);
        this._allowMultiple = !1;
        this._enabled = !0;
        b && (this._allowMultiple = !1,
        this._enabled = !!b[0]);
        this._activeTweens = new Map;
        this._disabledTweens = [];
        this._waitingForReleaseTweens = new Map;
        this._waitingForReleaseTweensJson = this._disabledTweensJson = this._activeTweensJson = this._finishingTween = null;
        this._finishingTweenName = "";
        this._triggerTweens = [];
        this._afterLoad = c => this._OnAfterLoad();
        this.GetRuntime().Dispatcher().addEventListener("afterload", this._afterLoad)
    }
    Release() {
        this.GetRuntime().Dispatcher().removeEventListener("afterload", this._afterLoad);
        this._afterLoad = null;
        this._finishingTween && (this.ReleaseAndCompleteTween(this._finishingTween),
        this._finishingTween = null);
        this.ReleaseAndCompleteTweens();
        this._tweens = null;
        this.ClearDisabledList();
        this._disabledTweens = null;
        this._ReleaseWaitingTweens();
        this._triggerTweens = this._waitingForReleaseTweens = null;
        super.Release()
    }
    PushTriggerTween(a) {
        this._triggerTweens.push(a)
    }
    PopTriggerTween() {
        this._triggerTweens.pop()
    }
    GetTriggerTween() {
        return this._triggerTweens[this._triggerTweens.length - 1]
    }
    SetEnabled(a) {
        this._enabled = !!a;
        a ? this._waitingForReleaseTweens && this._waitingForReleaseTweens.size && this._StartTicking2() : this._StopTicking2();
        for (const b of this.AllTweens())
            a ? this.IsInDisabledList(b) && b.Resume() : ((b.IsPlaying() || b.IsScheduled()) && this.AddToDisabledList(b),
            b.Stop());
        a && this.ClearDisabledList()
    }
    IsEnabled() {
        return this._enabled
    }
    AddToDisabledList(a) {
        this._disabledTweens.push(a)
    }
    IsInDisabledList(a) {
        return this._disabledTweens.includes(a)
    }
    ClearDisabledList() {
        C3$jscomp$334.clearArray(this._disabledTweens)
    }
    GetFinishingTween() {
        return this._finishingTween
    }
    IsInstanceValid() {
        const a = this.GetObjectInstance();
        return a ? !a.IsDestroyed() : !1
    }
    GetTween(a, b, c=!1) {
        if ((b = b ? this.PropertyTweens(b, c) : this.AllTweens(c)) && b.length)
            for (const d of b)
                if (d.HasTags(a))
                    return d
    }
    GetTweenIncludingWaitingForRelease(a, b) {
        return this.GetTween(a, b, !0)
    }
    *GetTweens(a, b, c=!1) {
        if ((b = b ? this.PropertyTweens(b, c) : this.AllTweens(c)) && b.length)
            for (const d of b)
                d.HasTags(a) && (yield d)
    }
    *GetTweensIncludingWaitingForRelease(a, b) {
        yield*this.GetTweens(a, b, !0)
    }
    PropertyTweens(a, b) {
        if (b)
            return b = this._activeTweens.get(a),
            a = this._waitingForReleaseTweens.get(a),
            b || (b = []),
            a || (a = []),
            b.concat(a).filter(c => c).filter(c => !c.IsReleased());
        (a = this._activeTweens.get(a)) || (a = []);
        return a.filter(c => c).filter(c => !c.IsReleased())
    }
    AllTweens(a) {
        if (a) {
            a = [...this._activeTweens.values()].flat();
            const b = [...this._waitingForReleaseTweens.values()].flat();
            return a.concat(b).filter(c => c).filter(c => !c.IsReleased())
        }
        return [...this._activeTweens.values()].flat().filter(b => b).filter(b => !b.IsReleased())
    }
    AllTweensIncludingWaitingForRelease() {
        return this.AllTweens(!0)
    }
    SaveToJson(a) {
        return {
            s: !1,
            e: !!this._enabled,
            at: this._SaveActiveTweensToJson(),
            dt: this._SaveDisabledTweensToJson(),
            wt: this._SaveWaitingForReleaseTweensToJson(),
            ft: this._SaveFinishingTweenToJson()
        }
    }
    LoadFromJson(a, b="full") {
        a && (this._activeTweensJson = a.at,
        this._disabledTweensJson = a.dt,
        this._waitingForReleaseTweensJson = a.wt,
        this._finishingTweenName = a.ft,
        this._allowMultiple = !1,
        this._enabled = !!a.e,
        "state" === b && this._OnAfterLoad())
    }
    _OnAfterLoad() {
        const a = this.GetRuntime().GetTimelineManager();
        this._PopulateTweenMap(this._activeTweensJson, this._activeTweens, a);
        if (this._disabledTweensJson) {
            C3$jscomp$334.clearArray(this._disabledTweens);
            for (const b of this._disabledTweensJson)
                this._PopulateTweenArray(this._disabledTweens, b, a)
        }
        this._PopulateTweenMap(this._waitingForReleaseTweensJson, this._waitingForReleaseTweens, a);
        this._finishingTween = this._GetTween(this._finishingTweenName, a);
        this._enabled ? this._waitingForReleaseTweens && this._waitingForReleaseTweens.size && this._StartTicking2() : this._StopTicking2()
    }
    _PopulateTweenMap(a, b, c) {
        if (a)
            for (const e in a) {
                let f = b.get(e);
                f ? C3$jscomp$334.clearArray(f) : f = [];
                var d = a[e];
                for (const h of d)
                    this._PopulateTweenArray(f, h.name, c) ? this._LoadTweenFromJson(h.name, h, c) : (d = C3$jscomp$334.TweenState.Build({
                        runtime: this.GetRuntime(),
                        json: h
                    }),
                    C3$jscomp$334.TweenState.SetInstanceUID(d, this.GetObjectInstance().GetUID()),
                    d.AddCompletedCallback(l => this._FinishTriggers(l)),
                    c.AddScheduledTimeline(d),
                    this._PopulateTweenArray(f, d, c));
                b.set(e, f)
            }
    }
    _GetTween(a, b) {
        return b.GetScheduledOrPlayingTimelineByName(a)
    }
    _PopulateTweenArray(a, b, c) {
        if ("string" === typeof b) {
            if (b = this._GetTween(b, c))
                return !!a.push(b)
        } else
            return !!a.push(b);
        return !1
    }
    _LoadTweenFromJson(a, b, c) {
        if ("string" === typeof a) {
            if (a = this._GetTween(a, c))
                a._LoadFromJson(b),
                C3$jscomp$334.TweenState.SetInstanceUID(a, this.GetObjectInstance().GetUID())
        } else
            a._LoadFromJson(b),
            C3$jscomp$334.TweenState.SetInstanceUID(a, this.GetObjectInstance().GetUID())
    }
    _SaveActiveTweensToJson() {
        const a = {};
        for (const [b,c] of this._activeTweens)
            a[b] = c.filter(d => !d.IsReleased()).map(d => d._SaveToJson());
        return a
    }
    _SaveDisabledTweensToJson() {
        return this._disabledTweens.filter(a => !a.IsReleased()).map(a => a.GetName())
    }
    _SaveWaitingForReleaseTweensToJson() {
        const a = {};
        for (const [b,c] of this._waitingForReleaseTweens)
            a[b] = c.map(d => d._SaveToJson());
        return a
    }
    _SaveFinishingTweenToJson() {
        return this._finishingTween ? this._finishingTween.GetName() : ""
    }
    Tick2() {
        this._ReleaseWaitingTweens()
    }
    CreateTween(a) {
        var b = NAMESPACE.Config.GetPropertyTracksConfig(a.property, a.startValue, a.endValue, a.ease, a.resultMode, this.GetObjectInstance());
        const c = NAMESPACE.Maps.GetPropertyFromIndex(a.property);
        NAMESPACE.Maps.IsValueId(c) || this.ReleaseTweens(a.property);
        b = C3$jscomp$334.TweenState.Build({
            runtime: this.GetRuntime(),
            id: c,
            tags: a.tags,
            time: a.time,
            instance: this.GetObjectInstance(),
            releaseOnComplete: !!a.releaseOnComplete,
            loop: !!a.loop,
            pingPong: !!a.pingPong,
            repeatCount: a.repeatCount,
            initialValueMode: a.initialValueMode,
            propertyTracksConfig: b
        });
        b.AddCompletedCallback(d => this._FinishTriggers(d));
        this._AddTween(b, a.property);
        return b
    }
    _MaybeRemoveFromActiveTweenMap(a) {
        var b = a.GetId();
        this._activeTweens.has(b) && (b = this._activeTweens.get(b)) && (a = b.indexOf(a),
        -1 !== a && b.splice(a, 1))
    }
    ReleaseTween(a, b=!1) {
        this._MaybeRemoveFromActiveTweenMap(a);
        a.IsReleased() || this._IsInWaitingList(a) || (a.Stop(b),
        this._AddToWaitingList(a))
    }
    ReleaseTweens(a, b=!1) {
        if (C3$jscomp$334.IsFiniteNumber(a)) {
            var c = NAMESPACE.Maps.GetPropertyFromIndex(a);
            if (this._activeTweens.has(c)) {
                c = this._activeTweens.get(c);
                var d = this.GetFinishingTween();
                for (var e of c)
                    e === d || e.IsReleased() || this._IsInWaitingList(e) || (e.Stop(b),
                    e.Release());
                C3$jscomp$334.clearArray(c)
            }
        } else {
            e = this.GetFinishingTween();
            for (c of this.AllTweens())
                c === e || c.IsReleased() || this._IsInWaitingList(c) || (c.Stop(b),
                c.Release());
            for (d of this._activeTweens.keys())
                C3$jscomp$334.clearArray(this._activeTweens.get(d)),
                this._activeTweens.delete(d);
            this._activeTweens.clear()
        }
    }
    ReleaseAndCompleteTween(a) {
        this.ReleaseTween(a, !0)
    }
    ReleaseAndCompleteTweens() {
        this.ReleaseTweens(NaN, !0)
    }
    GetPropertyValueByIndex(a) {
        switch (a) {
        case 0:
            return this._enabled
        }
    }
    SetPropertyValueByIndex(a, b) {
        switch (a) {
        case 0:
            this._enabled = !!b
        }
    }
    _GetBehaviorType(a) {
        a = a.GetInstance().GetBehaviorInstances();
        for (const b of a)
            if (a = b.GetBehaviorType(),
            a.GetInstanceSdkCtor() === this.constructor)
                return a
    }
    Trigger(a, b, c, d) {
        return this._runtime ? super.Trigger(a) : b.Trigger(a, c, d)
    }
    _FinishTriggers(a) {
        this._finishingTween = a;
        NAMESPACE.Cnds.SetFinishingTween(a);
        let b, c;
        if (this.GetRuntime())
            b = this._inst,
            c = this._runtime,
            this.Trigger(NAMESPACE.Cnds.OnTweensFinished),
            this.Trigger(NAMESPACE.Cnds.OnAnyTweensFinished),
            this.ReleaseTween(a);
        else {
            b = a.GetInstance();
            if (!b || b && b.IsDestroyed())
                return;
            c = b.GetRuntime();
            const d = this._GetBehaviorType(a);
            this.Trigger(NAMESPACE.Cnds.OnTweensFinished, c, b, d);
            this.Trigger(NAMESPACE.Cnds.OnAnyTweensFinished, c, b, d);
            a.Stop()
        }
        this._finishingTween = null;
        NAMESPACE.Cnds.SetFinishingTween(null);
        a.GetDestroyInstanceOnComplete() && c.DestroyInstance(b)
    }
    _AddTween(a, b) {
        b = NAMESPACE.Maps.GetPropertyFromIndex(b);
        this._activeTweens.has(b) || this._activeTweens.set(b, []);
        this._activeTweens.get(b).push(a)
    }
    _AddToWaitingList(a) {
        const b = a.GetId();
        this._waitingForReleaseTweens.has(b) || this._waitingForReleaseTweens.set(b, []);
        this._waitingForReleaseTweens.get(b).push(a);
        this.IsTicking2() || this._StartTicking2()
    }
    _IsInWaitingList(a) {
        const b = a.GetId();
        return this._waitingForReleaseTweens.has(b) ? this._waitingForReleaseTweens.get(b).includes(a) : !1
    }
    _ReleaseWaitingTweens() {
        if (this._waitingForReleaseTweens.size) {
            for (const a of this._waitingForReleaseTweens.values()) {
                for (const b of a)
                    b.IsReleased() || b.Release();
                C3$jscomp$334.clearArray(a)
            }
            this._waitingForReleaseTweens.clear();
            this.IsTicking2() && this._StopTicking2()
        }
    }
    GetDebuggerProperties() {
        return [{
            title: "$" + this.GetBehaviorType().GetName(),
            properties: [{
                name: "behaviors.tween.properties.enabled.name",
                value: this.IsEnabled(),
                onedit: a => this.SetEnabled(a)
            }]
        }]
    }
    GetScriptInterfaceClass() {
        return self.ITweenBehaviorInstance
    }
}
;
const C3$jscomp$335 = self.C3;
let finishingTween$jscomp$2 = null;
C3$jscomp$335.Behaviors.Tween.Cnds = {
    OnAnyTweenLoop() {
        return !0
    },
    OnTweensLoop(a) {
        const b = this.GetTriggerTween();
        return b ? b.HasTags(a) : !1
    },
    OnAnyTweenPingPong(a) {
        const b = this.GetTriggerTween();
        return b ? b.GetPingPongState() === a || 2 === a ? !0 : !1 : !1
    },
    OnTweensPingPong(a, b) {
        const c = this.GetTriggerTween();
        return c ? c.GetPingPongState() === b || 2 === b ? c.HasTags(a) : !1 : !1
    },
    SetFinishingTween(a) {
        finishingTween$jscomp$2 = a
    },
    OnTweensFinished(a) {
        return finishingTween$jscomp$2.HasTags(a)
    },
    OnAnyTweensFinished() {
        return !0
    },
    IsPlaying(a) {
        return (a = [...this.GetTweensIncludingWaitingForRelease(a)],
        a.length) ? a.some(C3$jscomp$335.TweenState.IsPlaying) : !1
    },
    IsAnyPlaying() {
        const a = [...this.AllTweensIncludingWaitingForRelease()];
        return a && a.length ? a.some(C3$jscomp$335.TweenState.IsPlaying) : !1
    },
    IsPaused(a) {
        return (a = [...this.GetTweensIncludingWaitingForRelease(a)],
        a.length) ? a.some(C3$jscomp$335.TweenState.IsPaused) : !1
    },
    IsAnyPaused() {
        const a = [...this.AllTweensIncludingWaitingForRelease()];
        return a && a.length ? a.some(C3$jscomp$335.TweenState.IsPaused) : !1
    },
    IsPingPong(a, b) {
        return (a = [...this.GetTweensIncludingWaitingForRelease(a)],
        a.length) ? 0 === b ? a.some(C3$jscomp$335.TweenState.IsPing) : 1 === b ? a.some(C3$jscomp$335.TweenState.IsPong) : !1 : !1
    },
    IsAnyPingPong(a) {
        const b = [...this.AllTweensIncludingWaitingForRelease()];
        return b && b.length ? 0 === a ? b.some(C3$jscomp$335.TweenState.IsPing) : 1 === a ? b.some(C3$jscomp$335.TweenState.IsPong) : !1 : !1
    }
};
const C3$jscomp$336 = self.C3
  , Ease$jscomp$3 = self.Ease
  , NAMESPACE$jscomp$1 = C3$jscomp$336.Behaviors.Tween;
NAMESPACE$jscomp$1.Acts = {
    SetEnabled(a) {
        this.SetEnabled(!!a)
    },
    async TweenOneProperty(...a) {
        this.IsEnabled() && this.IsInstanceValid() && (a = this.CreateTween(NAMESPACE$jscomp$1.TweenArguments.OneProperty(this, ...a)),
        a.Play() && await a.GetPlayPromise())
    },
    async TweenTwoProperties(...a) {
        this.IsEnabled() && this.IsInstanceValid() && (a = this.CreateTween(NAMESPACE$jscomp$1.TweenArguments.TwoProperties(this, ...a)),
        a.Play() && await a.GetPlayPromise())
    },
    async TweenValue(...a) {
        this.IsEnabled() && this.IsInstanceValid() && (a = this.CreateTween(NAMESPACE$jscomp$1.TweenArguments.ValueProperty(this, ...a)),
        a.Play() && await a.GetPlayPromise())
    },
    PauseTweens(a) {
        if (this.IsEnabled() && this.IsInstanceValid())
            for (const b of this.GetTweens(a))
                b.Stop()
    },
    PauseAllTweens() {
        if (this.IsEnabled() && this.IsInstanceValid())
            for (const a of this.AllTweens())
                a.Stop()
    },
    ResumeTweens(a) {
        if (this.IsEnabled() && this.IsInstanceValid())
            for (const b of this.GetTweens(a))
                b.Resume()
    },
    ResumeAllTweens() {
        if (this.IsEnabled() && this.IsInstanceValid())
            for (const a of this.AllTweens())
                a.Resume()
    },
    StopTweens(a) {
        if (this.IsEnabled() && this.IsInstanceValid())
            for (const b of this.GetTweens(a))
                this.ReleaseTween(b)
    },
    StopAllTweens() {
        if (this.IsEnabled() && this.IsInstanceValid())
            for (const a of this.AllTweens())
                this.ReleaseTween(a)
    },
    SetOnePropertyTweensEndValue(a, b, c) {
        if (this.IsEnabled() && this.IsInstanceValid()) {
            b = C3$jscomp$336.Behaviors.Tween.Maps.GetSinglePropertyFromIndex(b);
            for (const d of this.GetTweens(a))
                d.BeforeSetEndValues([b]),
                d.SetEndValue(c, b)
        }
    },
    SetTwoPropertiesTweensEndValue(a, b, c, d) {
        if (this.IsEnabled() && this.IsInstanceValid()) {
            b = C3$jscomp$336.Behaviors.Tween.Maps.GetRealProperties(b);
            for (const e of this.GetTweens(a))
                e.BeforeSetEndValues(b),
                e.SetEndValue(c, b[0]),
                e.SetEndValue(d, b[1])
        }
    },
    SetValuePropertyTweensStartValue(a, b) {
        if (this.IsEnabled() && this.IsInstanceValid())
            for (const c of this.GetTweens(a, "value"))
                c.SetStartValue(b, "value")
    },
    SetValuePropertyTweensEndValue(a, b) {
        if (this.IsEnabled() && this.IsInstanceValid())
            for (const c of this.GetTweens(a, "value"))
                c.BeforeSetEndValues(["value"]),
                c.SetEndValue(b, "value")
    },
    SetTweensEase(a, b) {
        if (this.IsEnabled() && this.IsInstanceValid()) {
            b = Ease$jscomp$3.GetEaseFromIndex(b);
            for (const c of this.GetTweens(a))
                c.SetEase(b)
        }
    },
    SetAllTweensEase(a) {
        if (this.IsEnabled() && this.IsInstanceValid()) {
            a = Ease$jscomp$3.GetEaseFromIndex(a);
            for (const b of this.AllTweens())
                b.SetEase(a)
        }
    },
    SetTweensTime(a, b) {
        if (this.IsEnabled() && this.IsInstanceValid())
            for (const c of this.GetTweens(a))
                c.SetTime(b)
    },
    SetAllTweensTime(a) {
        if (this.IsEnabled() && this.IsInstanceValid())
            for (const b of this.AllTweens())
                b.SetTime(a)
    },
    SetTweensPlaybackRate(a, b) {
        if (this.IsEnabled() && this.IsInstanceValid())
            for (const c of this.GetTweens(a))
                c.SetPlaybackRate(b)
    },
    SetAllTweensPlaybackRate(a) {
        if (this.IsEnabled() && this.IsInstanceValid())
            for (const b of this.AllTweens())
                b.SetPlaybackRate(a)
    },
    SetTweensDestroyOnComplete(a, b) {
        if (this.IsEnabled() && this.IsInstanceValid())
            for (const c of this.GetTweens(a))
                c.SetDestroyInstanceOnComplete(!!b)
    },
    SetAllTweensDestroyOnComplete(a) {
        if (this.IsEnabled() && this.IsInstanceValid())
            for (const b of this.AllTweens())
                b.SetDestroyInstanceOnComplete(!!a)
    }
};
self.C3.Behaviors.Tween.Exps = {
    Time(a) {
        return (a = this.GetTweenIncludingWaitingForRelease(a)) ? a.GetTime() : 0
    },
    Progress(a) {
        return (a = this.GetTweenIncludingWaitingForRelease(a)) ? a.GetTime() / a.GetTotalTime() : 0
    },
    PlaybackRate(a) {
        return (a = this.GetTweenIncludingWaitingForRelease(a)) ? a.GetPlaybackRate() : 0
    },
    Value(a) {
        return (a = this.GetTweenIncludingWaitingForRelease(a, "value")) ? a.GetPropertyTrack("value").GetSourceAdapterValue() : 0
    },
    Tags() {
        let a = this.GetFinishingTween();
        return a ? a.GetStringTags() : (a = this.GetTriggerTween()) ? a.GetStringTags() : ""
    }
};
"use strict";
const C3$jscomp$338 = self.C3
  , Ease$jscomp$4 = self.Ease
  , PAIR_PROPERTIES = ["position", "size", "scale"]
  , SINGLE_PROPERTIES = "offsetX offsetY offsetWidth offsetHeight offsetAngle offsetOpacity offsetColor offsetZElevation offsetScaleX offsetScaleY".split(" ")
  , VALUE_PROPERTIES = ["value"]
  , PROPERTY_INDEX_TO_NAME = [].concat(PAIR_PROPERTIES).concat(SINGLE_PROPERTIES).concat(VALUE_PROPERTIES)
  , PROPERTY_PAIR_TO_REAL_PROPERTIES = {
    position: ["offsetX", "offsetY"],
    size: ["offsetWidth", "offsetHeight"],
    scale: ["offsetScaleX", "offsetScaleY"]
}
  , ALL_REAL_PROPERTIES = Object.assign({}, PROPERTY_INDEX_TO_NAME.reduce( (a, b) => Object.assign({}, a, {
    [b]: [b]
}), {}), PROPERTY_PAIR_TO_REAL_PROPERTIES);
C3$jscomp$338.Behaviors.Tween.Maps = class {
    constructor() {}
    static GetEases() {
        return [...Ease$jscomp$4.GetRuntimeEaseNames()]
    }
    static GetEaseFromIndex(a) {
        return [...Ease$jscomp$4.GetRuntimeEaseNames()][a]
    }
    static GetPropertyFromIndex(a) {
        return PROPERTY_INDEX_TO_NAME[a]
    }
    static GetPropertyIndexFromName(a) {
        return PROPERTY_INDEX_TO_NAME.indexOf(a)
    }
    static GetPairPropertyFromIndex(a) {
        return PAIR_PROPERTIES[a]
    }
    static GetSinglePropertyFromIndex(a) {
        return SINGLE_PROPERTIES[a]
    }
    static GetValuePropertyFromIndex(a) {
        return VALUE_PROPERTIES[a]
    }
    static GetPairProperties(a) {
        return PROPERTY_PAIR_TO_REAL_PROPERTIES[a]
    }
    static GetRealProperties(a) {
        return C3$jscomp$338.IsString(a) ? ALL_REAL_PROPERTIES[a] : ALL_REAL_PROPERTIES[PROPERTY_INDEX_TO_NAME[a]]
    }
    static IsPairId(a) {
        return !!PROPERTY_PAIR_TO_REAL_PROPERTIES[a]
    }
    static IsColorId(a) {
        return "offsetColor" === a
    }
    static IsAngleId(a) {
        return "offsetAngle" === a
    }
    static IsOpacityId(a) {
        return "offsetOpacity" === a
    }
    static IsValueId(a) {
        return "value" === a
    }
}
;
"use strict";
const C3$jscomp$339 = self.C3
  , NAMESPACE$jscomp$2 = C3$jscomp$339.Behaviors.Tween
  , TWEEN_CONFIGURATIONS = new Map;
NAMESPACE$jscomp$2.Config = class {
    constructor() {}
    static GetPropertyTracksConfig(a, b, c, d, e, f) {
        0 === TWEEN_CONFIGURATIONS.size && this._CreateConfigObjects();
        var h = NAMESPACE$jscomp$2.PropertyTypes.Pick(a);
        h = TWEEN_CONFIGURATIONS.get(h);
        C3$jscomp$339.IsFiniteNumber(a) && (a = NAMESPACE$jscomp$2.Maps.GetPropertyFromIndex(a));
        return this._GetConfig(h, a, b, c, d, e, f)
    }
    static TransformValue(a, b) {
        return C3$jscomp$339.Behaviors.Tween.GetPropertyTracksConfig(a).valueGetter(b)
    }
    static _CreateConfigObjects() {
        const a = NAMESPACE$jscomp$2.PropertyTypes
          , b = NAMESPACE$jscomp$2.ValueGetters;
        this._AddConfigObject(a.PAIR, this._GetPairConfig, b._GetPropertyValue);
        this._AddConfigObject(a.COLOR, this._GetColorConfig, b._GetColorPropertyValue);
        this._AddConfigObject(a.ANGLE, this._GetAngleConfig, b._GetPropertyAngleValue);
        this._AddConfigObject(a.VALUE, this._GetValueConfig, b._GetPropertyValue);
        this._AddConfigObject(a.OTHER, this._GetCommonConfig, b._GetPropertyValue)
    }
    static _AddConfigObject(a, b, c) {
        TWEEN_CONFIGURATIONS.set(a, this._CreateConfigObject(a, b, c))
    }
    static _CreateConfigObject(a, b, c) {
        return {
            name: a,
            configFunc: b,
            valueGetter: c
        }
    }
    static _GetConfig(a, b, c, d, e, f, h) {
        return a.configFunc(b, a.valueGetter(c), a.valueGetter(d), e, f, h)
    }
    static _GetPairConfig(a, b, c, d, e, f) {
        return NAMESPACE$jscomp$2.Maps.GetPairProperties(a).map( (h, l) => ({
            sourceId: "world-instance",
            property: h,
            type: "float",
            valueType: "numeric",
            startValue: b[l],
            endValue: c[l],
            ease: NAMESPACE$jscomp$2.Maps.GetEaseFromIndex(d),
            resultMode: e
        }))
    }
    static _GetColorConfig(a, b, c, d, e, f) {
        return C3$jscomp$339.Plugins.Text && f.GetPlugin()instanceof C3$jscomp$339.Plugins.Text ? {
            sourceId: "plugin",
            sourceArgs: [7],
            property: "color",
            type: "color",
            valueType: "color",
            startValue: b,
            endValue: c,
            ease: NAMESPACE$jscomp$2.Maps.GetEaseFromIndex(d),
            resultMode: e
        } : {
            sourceId: "world-instance",
            property: a,
            type: "color",
            valueType: "color",
            startValue: b,
            endValue: c,
            ease: NAMESPACE$jscomp$2.Maps.GetEaseFromIndex(d),
            resultMode: e
        }
    }
    static _GetAngleConfig(a, b, c, d, e, f) {
        return {
            sourceId: "world-instance",
            property: a,
            type: "angle",
            valueType: "angle",
            startValue: b,
            endValue: c,
            ease: NAMESPACE$jscomp$2.Maps.GetEaseFromIndex(d),
            resultMode: e
        }
    }
    static _GetCommonConfig(a, b, c, d, e, f) {
        return {
            sourceId: "world-instance",
            property: a,
            type: "float",
            valueType: "numeric",
            startValue: b,
            endValue: c,
            ease: NAMESPACE$jscomp$2.Maps.GetEaseFromIndex(d),
            resultMode: e
        }
    }
    static _GetValueConfig(a, b, c, d, e, f) {
        return {
            sourceId: "value",
            property: a,
            type: "float",
            valueType: "numeric",
            startValue: b,
            endValue: c,
            ease: NAMESPACE$jscomp$2.Maps.GetEaseFromIndex(d),
            resultMode: e
        }
    }
}
;
"use strict";
const C3$jscomp$340 = self.C3
  , NAMESPACE$jscomp$3 = C3$jscomp$340.Behaviors.Tween
  , COMMON_VARIABLE_ARGS = Object.assign({}, {
    resultMode: "absolute"
}, {
    tags: "",
    property: "",
    time: 0,
    ease: 0,
    releaseOnComplete: 0,
    loop: !1,
    pingPong: !1,
    repeatCount: 1
})
  , ONE_PROPERTY_ARGS = Object.assign({}, COMMON_VARIABLE_ARGS, {
    initialValueMode: "current-state",
    startValue: 0,
    endValue: 0
})
  , TWO_PROPERTIES_ARGS = Object.assign({}, COMMON_VARIABLE_ARGS, {
    initialValueMode: "current-state",
    startValue: [0, 0],
    endValue: [0, 0]
})
  , COLOR_PROPERTY_ARGS = Object.assign({}, COMMON_VARIABLE_ARGS, {
    initialValueMode: "current-state",
    startValue: [0, 0, 0],
    endValue: [0, 0, 0]
})
  , VALUE_PROPERTY_ARGS = Object.assign({}, ONE_PROPERTY_ARGS, {
    initialValueMode: "start-value"
});
NAMESPACE$jscomp$3.TweenArguments = class {
    constructor() {}
    static _SetCommonProperties(a, b, c, d, e, f, h, l) {
        a.tags = b;
        a.time = c;
        a.ease = d;
        a.releaseOnComplete = e;
        a.loop = f;
        a.pingPong = h;
        a.repeatCount = l
    }
    static OneProperty(a, b, c, d, e, f, h, l, m, p) {
        a = "string" === typeof c ? c : NAMESPACE$jscomp$3.Maps.GetSinglePropertyFromIndex(c);
        c = NAMESPACE$jscomp$3.Maps.IsColorId(a) ? COLOR_PROPERTY_ARGS : ONE_PROPERTY_ARGS;
        this._SetCommonProperties(c, b, e, f, h, l, m, p);
        NAMESPACE$jscomp$3.Maps.IsColorId(a) ? (COLOR_PROPERTY_ARGS.endValue[0] = C3$jscomp$340.GetRValue(d),
        COLOR_PROPERTY_ARGS.endValue[1] = C3$jscomp$340.GetGValue(d),
        COLOR_PROPERTY_ARGS.endValue[2] = C3$jscomp$340.GetBValue(d),
        COLOR_PROPERTY_ARGS.property = NAMESPACE$jscomp$3.Maps.GetPropertyIndexFromName(a)) : NAMESPACE$jscomp$3.Maps.IsOpacityId(a) ? ONE_PROPERTY_ARGS.endValue = d / 100 : ONE_PROPERTY_ARGS.endValue = d;
        c.property = NAMESPACE$jscomp$3.Maps.GetPropertyIndexFromName(a);
        return c
    }
    static TwoProperties(a, b, c, d, e, f, h, l, m, p, r) {
        this._SetCommonProperties(TWO_PROPERTIES_ARGS, b, f, h, l, m, p, r);
        a = "string" === typeof c ? c : NAMESPACE$jscomp$3.Maps.GetPairPropertyFromIndex(c);
        TWO_PROPERTIES_ARGS.endValue[0] = d;
        TWO_PROPERTIES_ARGS.endValue[1] = e;
        TWO_PROPERTIES_ARGS.property = NAMESPACE$jscomp$3.Maps.GetPropertyIndexFromName(a);
        return TWO_PROPERTIES_ARGS
    }
    static ValueProperty(a, b, c, d, e, f, h, l, m, p) {
        this._SetCommonProperties(VALUE_PROPERTY_ARGS, b, e, f, h, l, m, p);
        VALUE_PROPERTY_ARGS.startValue = c;
        VALUE_PROPERTY_ARGS.endValue = d;
        VALUE_PROPERTY_ARGS.property = NAMESPACE$jscomp$3.Maps.GetPropertyIndexFromName("value");
        return VALUE_PROPERTY_ARGS
    }
}
;
"use strict";
const C3$jscomp$341 = self.C3
  , NAMESPACE$jscomp$4 = C3$jscomp$341.Behaviors.Tween
  , TYPE_CHECK_OBJECTS = [];
NAMESPACE$jscomp$4.PropertyTypes = class {
    constructor() {}
    static Pick(a) {
        0 === TYPE_CHECK_OBJECTS.length && (TYPE_CHECK_OBJECTS.push({
            checkFunc: NAMESPACE$jscomp$4.Maps.IsPairId,
            result: this.PAIR
        }),
        TYPE_CHECK_OBJECTS.push({
            checkFunc: NAMESPACE$jscomp$4.Maps.IsColorId,
            result: this.COLOR
        }),
        TYPE_CHECK_OBJECTS.push({
            checkFunc: NAMESPACE$jscomp$4.Maps.IsAngleId,
            result: this.ANGLE
        }),
        TYPE_CHECK_OBJECTS.push({
            checkFunc: NAMESPACE$jscomp$4.Maps.IsValueId,
            result: this.VALUE
        }),
        TYPE_CHECK_OBJECTS.push({
            checkFunc: () => !0,
            result: this.OTHER
        }));
        C3$jscomp$341.IsFiniteNumber(a) && (a = C3$jscomp$341.Behaviors.Tween.Maps.GetPropertyFromIndex(a));
        for (const b of TYPE_CHECK_OBJECTS)
            if (b.checkFunc(a))
                return b.result
    }
    static get PAIR() {
        return "pair"
    }
    static get COLOR() {
        return "color"
    }
    static get ANGLE() {
        return "angle"
    }
    static get VALUE() {
        return "value"
    }
    static get OTHER() {
        return "other"
    }
}
;
"use strict";
const C3$jscomp$342 = self.C3;
C3$jscomp$342.Behaviors.Tween.ValueGetters = class {
    constructor() {}
    static _GetPropertyAngleValue(a) {
        a = C3$jscomp$342.toRadians(parseFloat(a));
        return C3$jscomp$342.clampAngle(a)
    }
    static _GetColorPropertyValue(a) {
        return a.slice(0)
    }
    static _GetPropertyValue(a) {
        return a
    }
}
;
"use strict";
const C3$jscomp$343 = self.C3
  , C3X$jscomp$49 = self.C3X
  , IBehaviorInstance$jscomp$2 = self.IBehaviorInstance
  , Ease$jscomp$5 = self.Ease
  , NAMESPACE$jscomp$6 = C3$jscomp$343.Behaviors.Tween
  , map$jscomp$39 = new WeakMap
  , TWEEN_PROPERTIES = new Map([["x", {
    name: "offsetX",
    type: "one"
}], ["y", {
    name: "offsetY",
    type: "one"
}], ["width", {
    name: "offsetWidth",
    type: "one"
}], ["height", {
    name: "offsetHeight",
    type: "one"
}], ["angle", {
    name: "offsetAngle",
    type: "one"
}], ["opacity", {
    name: "offsetOpacity",
    type: "one"
}], ["color", {
    name: "offsetColor",
    type: "color"
}], ["z-elevation", {
    name: "offsetZElevation",
    type: "one"
}], ["x-scale", {
    name: "offsetScaleX",
    type: "one"
}], ["y-scale", {
    name: "offsetScaleY",
    type: "one"
}], ["position", {
    name: "position",
    type: "two"
}], ["size", {
    name: "size",
    type: "two"
}], ["scale", {
    name: "scale",
    type: "two"
}], ["value", {
    name: "value",
    type: "value"
}]]);
function getIndexForEase(a) {
    C3X$jscomp$49.RequireString(a);
    var b = Ease$jscomp$5.ToInternal(a);
    b = b ? Ease$jscomp$5.GetIndexForEase(b, null) : Ease$jscomp$5.GetIndexForEase(a, null);
    if (-1 === b)
        throw Error(`invalid ease name '${a}'`);
    return b
}
const TWEEN_OPTS = {
    tags: "",
    destroyOnComplete: !1,
    loop: !1,
    pingPong: !1,
    repeatCount: 1,
    startValue: 0
}
  , I_TWEEN_OPTS = {
    easeToIndexFunc: getIndexForEase
};
function ValidateTags$jscomp$1(a, b=!1) {
    if ((!b || "undefined" !== typeof a && null !== a) && "string" !== typeof a && !Array.isArray(a))
        throw Error("invalid tags");
}
self.ITweenBehaviorInstance = class extends IBehaviorInstance$jscomp$2 {
    constructor() {
        super();
        map$jscomp$39.set(this, IBehaviorInstance$jscomp$2._GetInitInst().GetSdkInstance())
    }
    startTween(a, b, c, d, e) {
        const f = map$jscomp$39.get(this);
        if (!f.IsEnabled() || !f.IsInstanceValid())
            return null;
        const h = TWEEN_PROPERTIES.get(a);
        if (!h)
            throw Error("invalid tween property");
        "one" === h.type || "value" === h.type ? C3X$jscomp$49.RequireNumber(b) : (C3X$jscomp$49.RequireArray(b),
        "two" === h.type ? (C3X$jscomp$49.RequireNumber(b[0]),
        C3X$jscomp$49.RequireNumber(b[1])) : "color" === h.type && (C3X$jscomp$49.RequireNumber(b[0]),
        C3X$jscomp$49.RequireNumber(b[1]),
        C3X$jscomp$49.RequireNumber(b[2])));
        "angle" === a ? b = C3$jscomp$343.toDegrees(b) : "opacity" === a ? b *= 100 : "color" === a && (b = C3$jscomp$343.PackRGBEx(b[0], b[1], b[2]));
        a = getIndexForEase(d);
        C3X$jscomp$49.RequireFiniteNumber(c);
        e = Object.assign({}, TWEEN_OPTS, e);
        "value" === h.type && C3X$jscomp$49.RequireNumber(e.startValue);
        ValidateTags$jscomp$1(e.tags, !0);
        let l;
        "one" === h.type || "color" === h.type ? l = f.CreateTween(NAMESPACE$jscomp$6.TweenArguments.OneProperty(f, e.tags, h.name, b, c, a, !!e.destroyOnComplete, !!e.loop, !!e.pingPong, e.repeatCount)) : "two" === h.type ? l = f.CreateTween(NAMESPACE$jscomp$6.TweenArguments.TwoProperties(f, e.tags, h.name, b[0], b[1], c, a, !!e.destroyOnComplete, !!e.loop, !!e.pingPong, e.repeatCount)) : "value" === h.type && (l = f.CreateTween(NAMESPACE$jscomp$6.TweenArguments.ValueProperty(f, e.tags, e.startValue, b, c, a, !!e.destroyOnComplete, !!e.loop, !!e.pingPong, e.repeatCount)));
        if (!l.Play())
            throw Error("failed to start tween");
        return l.GetITweenState(f, I_TWEEN_OPTS)
    }
    *allTweens() {
        const a = map$jscomp$39.get(this);
        for (const b of a.AllTweens())
            yield b.GetITweenState(a, I_TWEEN_OPTS)
    }
    *tweensByTags(a) {
        ValidateTags$jscomp$1(a);
        const b = map$jscomp$39.get(this);
        for (const c of b.GetTweens(a))
            yield c.GetITweenState(b, I_TWEEN_OPTS)
    }
    get isEnabled() {
        return map$jscomp$39.get(this).IsEnabled()
    }
    set isEnabled(a) {
        map$jscomp$39.get(this).SetEnabled(a)
    }
}
;
"use strict";
const C3$jscomp$344 = self.C3;
C3$jscomp$344.Behaviors.Rotate = class extends C3$jscomp$344.SDKBehaviorBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
}
;
const C3$jscomp$345 = self.C3;
C3$jscomp$345.Behaviors.Rotate.Type = class extends C3$jscomp$345.SDKBehaviorTypeBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
}
;
const C3$jscomp$346 = self.C3
  , C3X$jscomp$50 = self.C3X
  , IBehaviorInstance$jscomp$3 = self.IBehaviorInstance;
C3$jscomp$346.Behaviors.Rotate.Instance = class extends C3$jscomp$346.SDKBehaviorInstanceBase {
    constructor(a, b) {
        super(a);
        this._acceleration = this._speed = 0;
        this._isEnabled = !0;
        b && (this._speed = C3$jscomp$346.toRadians(b[0]),
        this._acceleration = C3$jscomp$346.toRadians(b[1]),
        this._isEnabled = b[2]);
        this._isEnabled && this._StartTicking()
    }
    Release() {
        super.Release()
    }
    _SetSpeed(a) {
        this._speed = a
    }
    _GetSpeed() {
        return this._speed
    }
    _SetAcceleration(a) {
        this._acceleration = a
    }
    _GetAcceleration() {
        return this._acceleration
    }
    SaveToJson() {
        return {
            s: this._speed,
            a: this._acceleration,
            e: this._isEnabled
        }
    }
    LoadFromJson(a) {
        this._speed = a.s;
        this._acceleration = a.a;
        this._SetEnabled(a.e)
    }
    Tick() {
        if (this._isEnabled) {
            var a = this._runtime.GetDt(this._inst);
            if (0 !== a && (0 !== this._acceleration && (this._speed += this._acceleration * a),
            0 !== this._speed)) {
                const b = this._inst.GetWorldInfo();
                b.SetAngle(b.GetAngle() + this._speed * a);
                b.SetBboxChanged()
            }
        }
    }
    GetPropertyValueByIndex(a) {
        switch (a) {
        case 0:
            return C3$jscomp$346.toDegrees(this._GetSpeed());
        case 1:
            return C3$jscomp$346.toDegrees(this._GetAcceleration());
        case 2:
            return this._IsEnabled()
        }
    }
    SetPropertyValueByIndex(a, b) {
        switch (a) {
        case 0:
            this._SetSpeed(C3$jscomp$346.toRadians(b));
            break;
        case 1:
            this._SetAcceleration(C3$jscomp$346.toRadians(b));
            break;
        case 2:
            this._SetEnabled(b)
        }
    }
    _SetEnabled(a) {
        (this._isEnabled = !!a) ? this._StartTicking() : this._StopTicking()
    }
    _IsEnabled() {
        return this._isEnabled
    }
    GetDebuggerProperties() {
        return [{
            title: "$" + this.GetBehaviorType().GetName(),
            properties: [{
                name: "behaviors.rotate.properties.speed.name",
                value: C3$jscomp$346.toDegrees(this._GetSpeed()),
                onedit: a => this._SetSpeed(C3$jscomp$346.toRadians(a))
            }, {
                name: "behaviors.rotate.properties.acceleration.name",
                value: C3$jscomp$346.toDegrees(this._GetAcceleration()),
                onedit: a => this._SetAcceleration(C3$jscomp$346.toRadians(a))
            }, {
                name: "behaviors.rotate.properties.enabled.name",
                value: this._IsEnabled(),
                onedit: a => this._SetEnabled(a)
            }]
        }]
    }
    GetScriptInterfaceClass() {
        return self.IRotateBehaviorInstance
    }
}
;
const map$jscomp$40 = new WeakMap;
self.IRotateBehaviorInstance = class extends IBehaviorInstance$jscomp$3 {
    constructor() {
        super();
        map$jscomp$40.set(this, IBehaviorInstance$jscomp$3._GetInitInst().GetSdkInstance())
    }
    set speed(a) {
        C3X$jscomp$50.RequireFiniteNumber(a);
        map$jscomp$40.get(this)._SetSpeed(a)
    }
    get speed() {
        return map$jscomp$40.get(this)._GetSpeed()
    }
    set acceleration(a) {
        C3X$jscomp$50.RequireFiniteNumber(a);
        map$jscomp$40.get(this)._SetAcceleration(a)
    }
    get acceleration() {
        return map$jscomp$40.get(this)._GetAcceleration()
    }
    get isEnabled() {
        return map$jscomp$40.get(this)._IsEnabled()
    }
    set isEnabled(a) {
        map$jscomp$40.get(this)._SetEnabled(a)
    }
}
;
self.C3.Behaviors.Rotate.Cnds = {
    IsEnabled() {
        return this._IsEnabled()
    }
};
const C3$jscomp$348 = self.C3;
C3$jscomp$348.Behaviors.Rotate.Acts = {
    SetSpeed(a) {
        this._SetSpeed(C3$jscomp$348.toRadians(a))
    },
    SetAcceleration(a) {
        this._SetAcceleration(C3$jscomp$348.toRadians(a))
    },
    SetEnabled(a) {
        this._SetEnabled(a)
    }
};
const C3$jscomp$349 = self.C3;
C3$jscomp$349.Behaviors.Rotate.Exps = {
    Speed() {
        return C3$jscomp$349.toDegrees(this._GetSpeed())
    },
    Acceleration() {
        return C3$jscomp$349.toDegrees(this._GetAcceleration())
    }
};
"use strict";
const C3$jscomp$350 = self.C3;
C3$jscomp$350.Behaviors.Bullet = class extends C3$jscomp$350.SDKBehaviorBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
}
;
const C3$jscomp$351 = self.C3;
C3$jscomp$351.Behaviors.Bullet.Type = class extends C3$jscomp$351.SDKBehaviorTypeBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
}
;
const C3$jscomp$352 = self.C3
  , C3X$jscomp$51 = self.C3X
  , IBehaviorInstance$jscomp$4 = self.IBehaviorInstance;
C3$jscomp$352.Behaviors.Bullet.Instance = class extends C3$jscomp$352.SDKBehaviorInstanceBase {
    constructor(a, b) {
        super(a);
        a = this.GetWorldInfo();
        this._g = this._acc = this._speed = 0;
        this._isStepping = this._setAngle = this._bounceOffSolid = !1;
        this._isEnabled = !0;
        this._dy = this._dx = 0;
        this._lastX = a.GetX();
        this._lastY = a.GetY();
        this._lastKnownAngle = a.GetAngle();
        this._travelled = 0;
        this._stepSize = Math.min(Math.abs(a.GetWidth()), Math.abs(a.GetHeight()) / 2);
        this._stopStepping = !1;
        b && (this._speed = b[0],
        this._acc = b[1],
        this._g = b[2],
        this._bounceOffSolid = !!b[3],
        this._setAngle = !!b[4],
        this._isStepping = !!b[5],
        this._isEnabled = !!b[6]);
        b = a.GetAngle();
        this._dx = Math.cos(b) * this._speed;
        this._dy = Math.sin(b) * this._speed;
        this._isEnabled && (this._StartTicking(),
        this._bounceOffSolid && this._StartPostTicking())
    }
    Release() {
        super.Release()
    }
    SaveToJson() {
        const a = {
            dx: this._dx,
            dy: this._dy,
            lx: this._lastX,
            ly: this._lastY,
            lka: this._lastKnownAngle,
            t: this._travelled
        };
        0 !== this._acc && (a.acc = this._acc);
        0 !== this._g && (a.g = this._g);
        this._isStepping && (a.st = this._isStepping);
        this._isEnabled || (a.e = this._isEnabled);
        this._bounceOffSolid && (a.bos = this._bounceOffSolid);
        this._setAngle && (a.sa = this._setAngle);
        return a
    }
    LoadFromJson(a) {
        this._dx = a.dx;
        this._dy = a.dy;
        this._lastX = a.lx;
        this._lastY = a.ly;
        this._lastKnownAngle = a.lka;
        this._travelled = a.t;
        this._acc = a.hasOwnProperty("acc") ? a.acc : 0;
        this._g = a.hasOwnProperty("g") ? a.g : 0;
        this._isStepping = a.hasOwnProperty("st") ? a.st : !1;
        this._bounceOffSolid = a.hasOwnProperty("bos") ? a.bos : !1;
        this._setAngle = a.hasOwnProperty("sa") ? a.sa : !1;
        this._SetEnabled(a.hasOwnProperty("e") ? a.e : !0)
    }
    Tick() {
        if (this._isEnabled) {
            var a = this._runtime.GetDt(this._inst)
              , b = this._inst.GetWorldInfo();
            if (b.GetAngle() !== this._lastKnownAngle) {
                var c = b.GetAngle();
                if (this._setAngle) {
                    var d = C3$jscomp$352.distanceTo(0, 0, this._dx, this._dy);
                    this._dx = Math.cos(c) * d;
                    this._dy = Math.sin(c) * d
                }
                this._lastKnownAngle = c
            }
            c = d = 0;
            if (0 !== this._acc) {
                let e = C3$jscomp$352.distanceTo(0, 0, this._dx, this._dy), f;
                f = 0 === this._dx && 0 === this._dy ? b.GetAngle() : C3$jscomp$352.angleTo(0, 0, this._dx, this._dy);
                e += this._acc * a;
                d = Math.cos(f) * this._acc;
                c = Math.sin(f) * this._acc;
                0 > e && (c = d = e = 0);
                this._dx = Math.cos(f) * e;
                this._dy = Math.sin(f) * e
            }
            0 !== this._g && (this._dy += this._g * a,
            c += this._g);
            this._lastX = b.GetX();
            this._lastY = b.GetY();
            if (0 !== this._dx || 0 !== this._dy)
                d = this._dx * a + .5 * d * a * a,
                a = this._dy * a + .5 * c * a * a,
                c = C3$jscomp$352.distanceTo(0, 0, d, a),
                this._MoveBy(d, a, c),
                this._travelled += c,
                !this._setAngle || 0 === d && 0 === a || (a = C3$jscomp$352.angleTo(0, 0, d, a),
                b.SetAngle(a),
                this._lastKnownAngle = b.GetAngle()),
                b.SetBboxChanged()
        }
    }
    _MoveBy(a, b, c) {
        const d = this.GetWorldInfo();
        if (!this._isStepping || c <= this._stepSize)
            d.OffsetXY(a, b),
            d.SetBboxChanged(),
            this._isStepping && this.Trigger(C3$jscomp$352.Behaviors.Bullet.Cnds.OnStep);
        else {
            this._stopStepping = !1;
            var e = d.GetX()
              , f = d.GetY()
              , h = e + a
              , l = f + b;
            b = C3$jscomp$352.angleTo(0, 0, a, b);
            a = Math.cos(b) * this._stepSize;
            b = Math.sin(b) * this._stepSize;
            c = Math.floor(c / this._stepSize);
            for (let m = 1; m <= c; ++m)
                if (d.SetXY(e + a * m, f + b * m),
                d.SetBboxChanged(),
                this.Trigger(C3$jscomp$352.Behaviors.Bullet.Cnds.OnStep),
                this._inst.IsDestroyed() || this._stopStepping)
                    return;
            d.SetXY(h, l);
            d.SetBboxChanged();
            this.Trigger(C3$jscomp$352.Behaviors.Bullet.Cnds.OnStep)
        }
    }
    PostTick() {
        if (this._isEnabled && this._bounceOffSolid && (0 !== this._dx || 0 !== this._dy)) {
            var a = this._runtime.GetDt(this._inst)
              , b = this._inst.GetWorldInfo()
              , c = this._runtime.GetCollisionEngine()
              , d = c.TestOverlapSolid(this._inst);
            if (d) {
                c.RegisterCollision(this._inst, d);
                d = C3$jscomp$352.distanceTo(0, 0, this._dx, this._dy);
                const e = c.CalculateBounceAngle(this._inst, this._lastX, this._lastY);
                this._dx = Math.cos(e) * d;
                this._dy = Math.sin(e) * d;
                b.OffsetXY(this._dx * a, this._dy * a);
                b.SetBboxChanged();
                this._setAngle && (b.SetAngle(e),
                this._lastKnownAngle = b.GetAngle(),
                b.SetBboxChanged());
                c.PushOutSolid(this._inst, this._dx / d, this._dy / d, Math.max(2.5 * d * a, 30)) || c.PushOutSolidNearest(this._inst, 100)
            }
        }
    }
    GetPropertyValueByIndex(a) {
        switch (a) {
        case 0:
            return this._GetSpeed();
        case 1:
            return this._GetAcceleration();
        case 2:
            return this._GetGravity();
        case 4:
            return this._setAngle;
        case 5:
            return this._isStepping;
        case 6:
            return this._IsEnabled()
        }
    }
    SetPropertyValueByIndex(a, b) {
        switch (a) {
        case 0:
            this._SetSpeed(b);
            break;
        case 1:
            this._acc = b;
            break;
        case 2:
            this._g = b;
            break;
        case 4:
            this._setAngle = !!b;
            break;
        case 5:
            this._isStepping = !!b;
            break;
        case 6:
            this._SetEnabled(!!b)
        }
    }
    _SetSpeed(a) {
        const b = C3$jscomp$352.angleTo(0, 0, this._dx, this._dy);
        this._dx = Math.cos(b) * a;
        this._dy = Math.sin(b) * a
    }
    _GetSpeed() {
        return C3$jscomp$352.roundToDp(C3$jscomp$352.distanceTo(0, 0, this._dx, this._dy), 6)
    }
    _SetAcceleration(a) {
        this._acc = a
    }
    _GetAcceleration() {
        return this._acc
    }
    _SetGravity(a) {
        this._g = a
    }
    _GetGravity() {
        return this._g
    }
    _SetAngleOfMotion(a) {
        const b = C3$jscomp$352.distanceTo(0, 0, this._dx, this._dy);
        this._dx = Math.cos(a) * b;
        this._dy = Math.sin(a) * b
    }
    _GetAngleOfMotion() {
        return C3$jscomp$352.angleTo(0, 0, this._dx, this._dy)
    }
    _SetBounceOffSolids(a) {
        a = !!a;
        this._bounceOffSolid !== a && (this._bounceOffSolid = a,
        this._isEnabled && (this._bounceOffSolid ? this._StartPostTicking() : this._StopPostTicking()))
    }
    _IsBounceOffSolids() {
        return this._bounceOffSolid
    }
    _SetDistanceTravelled(a) {
        this._travelled = a
    }
    _GetDistanceTravelled() {
        return this._travelled
    }
    _SetEnabled(a) {
        (this._isEnabled = !!a) ? (this._StartTicking(),
        this._bounceOffSolid && this._StartPostTicking()) : (this._StopTicking(),
        this._StopPostTicking())
    }
    _IsEnabled() {
        return this._isEnabled
    }
    GetDebuggerProperties() {
        return [{
            title: "$" + this.GetBehaviorType().GetName(),
            properties: [{
                name: "behaviors.bullet.debugger.vector-x",
                value: this._dx,
                onedit: a => this._dx = a
            }, {
                name: "behaviors.bullet.debugger.vector-y",
                value: this._dy,
                onedit: a => this._dy = a
            }, {
                name: "behaviors.bullet.properties.speed.name",
                value: this._GetSpeed(),
                onedit: a => this._SetSpeed(a)
            }, {
                name: "behaviors.bullet.debugger.angle-of-motion",
                value: C3$jscomp$352.toDegrees(this._GetAngleOfMotion())
            }, {
                name: "behaviors.bullet.properties.gravity.name",
                value: this._GetGravity(),
                onedit: a => this._SetGravity(a)
            }, {
                name: "behaviors.bullet.properties.acceleration.name",
                value: this._GetAcceleration(),
                onedit: a => this._SetAcceleration(a)
            }, {
                name: "behaviors.bullet.debugger.distance-travelled",
                value: this._GetDistanceTravelled()
            }, {
                name: "behaviors.bullet.properties.enabled.name",
                value: this._IsEnabled(),
                onedit: a => this._SetEnabled(a)
            }]
        }]
    }
    GetScriptInterfaceClass() {
        return self.IBulletBehaviorInstance
    }
}
;
const map$jscomp$41 = new WeakMap;
self.IBulletBehaviorInstance = class extends IBehaviorInstance$jscomp$4 {
    constructor() {
        super();
        map$jscomp$41.set(this, IBehaviorInstance$jscomp$4._GetInitInst().GetSdkInstance())
    }
    get speed() {
        return map$jscomp$41.get(this)._GetSpeed()
    }
    set speed(a) {
        C3X$jscomp$51.RequireFiniteNumber(a);
        map$jscomp$41.get(this)._SetSpeed(a)
    }
    get acceleration() {
        return map$jscomp$41.get(this)._GetAcceleration()
    }
    set acceleration(a) {
        C3X$jscomp$51.RequireFiniteNumber(a);
        map$jscomp$41.get(this)._SetAcceleration(a)
    }
    get gravity() {
        return map$jscomp$41.get(this)._GetGravity()
    }
    set gravity(a) {
        C3X$jscomp$51.RequireFiniteNumber(a);
        map$jscomp$41.get(this)._SetGravity(a)
    }
    get angleOfMotion() {
        return map$jscomp$41.get(this)._GetAngleOfMotion()
    }
    set angleOfMotion(a) {
        C3X$jscomp$51.RequireFiniteNumber(a);
        map$jscomp$41.get(this)._SetAngleOfMotion(a)
    }
    get bounceOffSolids() {
        return map$jscomp$41.get(this)._IsBounceOffSolids()
    }
    set bounceOffSolids(a) {
        map$jscomp$41.get(this)._SetBounceOffSolids(!!a)
    }
    get distanceTravelled() {
        return map$jscomp$41.get(this)._GetDistanceTravelled()
    }
    set distanceTravelled(a) {
        C3X$jscomp$51.RequireFiniteNumber(a);
        map$jscomp$41.get(this)._SetDistanceTravelled(a)
    }
    get isEnabled() {
        return map$jscomp$41.get(this)._IsEnabled()
    }
    set isEnabled(a) {
        map$jscomp$41.get(this)._SetEnabled(a)
    }
}
;
const C3$jscomp$353 = self.C3;
C3$jscomp$353.Behaviors.Bullet.Cnds = {
    CompareSpeed(a, b) {
        return C3$jscomp$353.compare(Math.hypot(this._dx, this._dy), a, b)
    },
    CompareTravelled(a, b) {
        return C3$jscomp$353.compare(this._GetDistanceTravelled(), a, b)
    },
    OnStep() {
        return !0
    },
    IsEnabled() {
        return this._IsEnabled()
    }
};
const C3$jscomp$354 = self.C3;
C3$jscomp$354.Behaviors.Bullet.Acts = {
    SetSpeed(a) {
        this._SetSpeed(a)
    },
    SetAcceleration(a) {
        this._SetAcceleration(a)
    },
    SetGravity(a) {
        this._SetGravity(a)
    },
    SetAngleOfMotion(a) {
        this._SetAngleOfMotion(C3$jscomp$354.toRadians(a))
    },
    Bounce(a) {
        if (a && (a = a.GetFirstPicked(this._inst))) {
            var b = this._inst.GetWorldInfo()
              , c = this._runtime.GetCollisionEngine()
              , d = this._runtime.GetDt(this._inst)
              , e = C3$jscomp$354.distanceTo(0, 0, this._dx, this._dy)
              , f = c.CalculateBounceAngle(this._inst, this._lastX, this._lastY, a);
            this._dx = Math.cos(f) * e;
            this._dy = Math.sin(f) * e;
            b.OffsetXY(this._dx * d, this._dy * d);
            b.SetBboxChanged();
            this._setAngle && (b.SetAngle(f),
            this._lastKnownAngle = b.GetAngle(),
            b.SetBboxChanged());
            0 !== e && (this._bounceOffSolid ? c.PushOutSolid(this._inst, this._dx / e, this._dy / e, Math.max(2.5 * e * d, 30)) || c.PushOutSolidNearest(this._inst, 100) : c.PushOut(this._inst, this._dx / e, this._dy / e, Math.max(2.5 * e * d, 30), a))
        }
    },
    SetBounceOffSolids(a) {
        this._SetBounceOffSolids(a)
    },
    SetDistanceTravelled(a) {
        this._SetDistanceTravelled(a)
    },
    SetEnabled(a) {
        this._SetEnabled(a)
    },
    StopStepping() {
        this._stopStepping = !0
    }
};
const C3$jscomp$355 = self.C3;
C3$jscomp$355.Behaviors.Bullet.Exps = {
    Speed() {
        return this._GetSpeed()
    },
    Acceleration() {
        return this._GetAcceleration()
    },
    AngleOfMotion() {
        return C3$jscomp$355.toDegrees(this._GetAngleOfMotion())
    },
    DistanceTravelled() {
        return this._GetDistanceTravelled()
    },
    Gravity() {
        return this._GetGravity()
    }
};
"use strict";
const C3$jscomp$356 = self.C3;
C3$jscomp$356.Behaviors.Fade = class extends C3$jscomp$356.SDKBehaviorBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
}
;
const C3$jscomp$357 = self.C3;
C3$jscomp$357.Behaviors.Fade.Type = class extends C3$jscomp$357.SDKBehaviorTypeBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
}
;
const C3$jscomp$358 = self.C3
  , C3X$jscomp$52 = self.C3X
  , IBehaviorInstance$jscomp$5 = self.IBehaviorInstance;
C3$jscomp$358.Behaviors.Fade.Instance = class extends C3$jscomp$358.SDKBehaviorInstanceBase {
    constructor(a, b) {
        super(a);
        this._fadeOutTime = this._waitTime = this._fadeInTime = 0;
        this._activeAtStart = this._destroy = !0;
        this._setMaxOpacity = !1;
        this._stage = 0;
        this._stageTime = C3$jscomp$358.New(C3$jscomp$358.KahanSum);
        this._maxOpacity = this._inst.GetWorldInfo().GetOpacity() || 1;
        b && (this._fadeInTime = b[0],
        this._waitTime = b[1],
        this._fadeOutTime = b[2],
        this._destroy = !!b[3],
        this._stage = (this._activeAtStart = !!b[4]) ? 0 : 3);
        this._activeAtStart && (0 === this._fadeInTime ? (this._stage = 1,
        0 === this._waitTime && (this._stage = 2)) : (this._inst.GetWorldInfo().SetOpacity(0),
        this._runtime.UpdateRender()));
        this._StartTicking()
    }
    Release() {
        super.Release()
    }
    SaveToJson() {
        return {
            fit: this._fadeInTime,
            wt: this._waitTime,
            fot: this._fadeOutTime,
            d: this._destroy,
            s: this._stage,
            st: this._stageTime.Get(),
            mo: this._maxOpacity
        }
    }
    LoadFromJson(a) {
        this._fadeInTime = a.fit;
        this._waitTime = a.wt;
        this._fadeOutTime = a.fot;
        this._destroy = a.d;
        this._stage = a.s;
        this._stageTime.Set(a.st);
        this._maxOpacity = a.mo;
        3 === this._stage ? this._StopTicking() : this._StartTicking()
    }
    Tick() {
        var a = this._runtime.GetDt(this._inst);
        this._stageTime.Add(a);
        a = this._inst.GetWorldInfo();
        0 === this._stage && (a.SetOpacity(this._stageTime.Get() / this._fadeInTime * this._maxOpacity),
        this._runtime.UpdateRender(),
        a.GetOpacity() >= this._maxOpacity && (a.SetOpacity(this._maxOpacity),
        this._stage = 1,
        this._stageTime.Reset(),
        this.DispatchScriptEvent("fadeinend"),
        this.Trigger(C3$jscomp$358.Behaviors.Fade.Cnds.OnFadeInEnd)));
        1 === this._stage && this._stageTime.Get() >= this._waitTime && (this._stage = 2,
        this._stageTime.Reset(),
        this.DispatchScriptEvent("waitend"),
        this.Trigger(C3$jscomp$358.Behaviors.Fade.Cnds.OnWaitEnd));
        2 === this._stage && (0 !== this._fadeOutTime ? (a.SetOpacity(this._maxOpacity - this._stageTime.Get() / this._fadeOutTime * this._maxOpacity),
        this._runtime.UpdateRender(),
        0 >= a.GetOpacity() && (this._stage = 3,
        this._stageTime.Reset(),
        this.DispatchScriptEvent("fadeoutend"),
        this.Trigger(C3$jscomp$358.Behaviors.Fade.Cnds.OnFadeOutEnd),
        this._destroy && this._runtime.DestroyInstance(this._inst))) : (this._stage = 3,
        this._stageTime.Reset()));
        3 === this._stage && this._StopTicking()
    }
    _StartFade() {
        this._activeAtStart || this._setMaxOpacity || (this._maxOpacity = this._inst.GetWorldInfo().GetOpacity() || 1,
        this._setMaxOpacity = !0);
        3 === this._stage && this.Start()
    }
    _RestartFade() {
        this.Start()
    }
    Start() {
        this._stage = 0;
        this._stageTime.Reset();
        0 === this._fadeInTime ? (this._stage = 1,
        0 === this._waitTime && (this._stage = 2)) : (this._inst.GetWorldInfo().SetOpacity(0),
        this._runtime.UpdateRender());
        this._StartTicking()
    }
    _SetFadeInTime(a) {
        this._fadeInTime = Math.max(a, 0)
    }
    _GetFadeInTime() {
        return this._fadeInTime
    }
    _SetWaitTime(a) {
        this._waitTime = Math.max(a, 0)
    }
    _GetWaitTime() {
        return this._waitTime
    }
    _SetFadeOutTime(a) {
        this._fadeOutTime = Math.max(a, 0)
    }
    _GetFadeOutTime() {
        return this._fadeOutTime
    }
    GetPropertyValueByIndex(a) {
        switch (a) {
        case 0:
            return this._GetFadeInTime();
        case 1:
            return this._GetWaitTime();
        case 2:
            return this._GetFadeOutTime();
        case 3:
            return this._destroy
        }
    }
    SetPropertyValueByIndex(a, b) {
        switch (a) {
        case 0:
            this._SetFadeInTime(b);
            break;
        case 1:
            this._SetWaitTime(b);
            break;
        case 2:
            this._SetFadeOutTime(b);
            break;
        case 3:
            this._destroy = !!b
        }
    }
    GetDebuggerProperties() {
        return [{
            title: "$" + this.GetBehaviorType().GetName(),
            properties: [{
                name: "behaviors.fade.properties.fade-in-time.name",
                value: this._GetFadeInTime(),
                onedit: a => this._SetFadeInTime(a)
            }, {
                name: "behaviors.fade.properties.wait-time.name",
                value: this._GetWaitTime(),
                onedit: a => this._SetWaitTime(a)
            }, {
                name: "behaviors.fade.properties.fade-out-time.name",
                value: this._GetFadeOutTime(),
                onedit: a => this._SetFadeOutTime(a)
            }, {
                name: "behaviors.fade.debugger.stage",
                value: ["behaviors.fade.debugger." + ["fade-in", "wait", "fade-out", "done"][this._stage]]
            }]
        }]
    }
    GetScriptInterfaceClass() {
        return self.IFadeBehaviorInstance
    }
}
;
const map$jscomp$42 = new WeakMap;
self.IFadeBehaviorInstance = class extends IBehaviorInstance$jscomp$5 {
    constructor() {
        super();
        map$jscomp$42.set(this, IBehaviorInstance$jscomp$5._GetInitInst().GetSdkInstance())
    }
    startFade() {
        map$jscomp$42.get(this)._StartFade()
    }
    restartFade() {
        map$jscomp$42.get(this)._RestartFade()
    }
    set fadeInTime(a) {
        C3X$jscomp$52.RequireFiniteNumber(a);
        map$jscomp$42.get(this)._SetFadeInTime(a)
    }
    get fadeInTime() {
        return map$jscomp$42.get(this)._GetFadeInTime()
    }
    set waitTime(a) {
        C3X$jscomp$52.RequireFiniteNumber(a);
        map$jscomp$42.get(this)._SetWaitTime(a)
    }
    get waitTime() {
        return map$jscomp$42.get(this)._GetWaitTime()
    }
    set fadeOutTime(a) {
        C3X$jscomp$52.RequireFiniteNumber(a);
        map$jscomp$42.get(this)._SetFadeOutTime(a)
    }
    get fadeOutTime() {
        return map$jscomp$42.get(this)._GetFadeOutTime()
    }
}
;
self.C3.Behaviors.Fade.Cnds = {
    OnFadeOutEnd() {
        return !0
    },
    OnFadeInEnd() {
        return !0
    },
    OnWaitEnd() {
        return !0
    }
};
self.C3.Behaviors.Fade.Acts = {
    StartFade() {
        this._StartFade()
    },
    RestartFade() {
        this._RestartFade()
    },
    SetFadeInTime(a) {
        this._SetFadeInTime(a)
    },
    SetWaitTime(a) {
        this._SetWaitTime(a)
    },
    SetFadeOutTime(a) {
        this._SetFadeOutTime(a)
    }
};
self.C3.Behaviors.Fade.Exps = {
    FadeInTime() {
        return this._GetFadeInTime()
    },
    WaitTime() {
        return this._GetWaitTime()
    },
    FadeOutTime() {
        return this._GetFadeOutTime()
    }
};
"use strict";
const C3$jscomp$362 = self.C3;
C3$jscomp$362.Behaviors.Flash = class extends C3$jscomp$362.SDKBehaviorBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
}
;
const C3$jscomp$363 = self.C3;
C3$jscomp$363.Behaviors.Flash.Type = class extends C3$jscomp$363.SDKBehaviorTypeBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
}
;
const C3$jscomp$364 = self.C3
  , C3X$jscomp$53 = self.C3X
  , IBehaviorInstance$jscomp$6 = self.IBehaviorInstance;
C3$jscomp$364.Behaviors.Flash.Instance = class extends C3$jscomp$364.SDKBehaviorInstanceBase {
    constructor(a, b) {
        super(a);
        this._timeLeft = this._stageTimeLeft = this._stage = this._offTime = this._onTime = 0;
        this._StartTicking()
    }
    Release() {
        super.Release()
    }
    _Flash(a, b, c) {
        this._onTime = a;
        this._offTime = b;
        this._stage = 1;
        this._stageTimeLeft = b;
        this._timeLeft = c;
        this._inst.GetWorldInfo().SetVisible(!1);
        this._runtime.UpdateRender()
    }
    _StopFlashing() {
        this._timeLeft = 0;
        this._inst.GetWorldInfo().SetVisible(!0);
        this._runtime.UpdateRender()
    }
    _IsFlashing() {
        return 0 < this._timeLeft
    }
    SaveToJson() {
        return {
            on: this._onTime,
            off: this._offTime,
            s: this._stage,
            stl: this._stageTimeLeft,
            tl: this._timeLeft
        }
    }
    LoadFromJson(a) {
        this._onTime = a.on;
        this._offTime = a.off;
        this._stage = a.s;
        this._stageTimeLeft = a.stl;
        this._timeLeft = null === a.tl ? Infinity : a.tl
    }
    Tick() {
        if (!(0 >= this._timeLeft)) {
            var a = this._runtime.GetDt(this._inst);
            this._timeLeft -= a;
            if (0 >= this._timeLeft)
                return this._timeLeft = 0,
                this._inst.GetWorldInfo().SetVisible(!0),
                this._runtime.UpdateRender(),
                this.DispatchScriptEvent("flashend"),
                this.DebugTrigger(C3$jscomp$364.Behaviors.Flash.Cnds.OnFlashEnded);
            this._stageTimeLeft -= a;
            0 >= this._stageTimeLeft && (0 === this._stage ? (this._inst.GetWorldInfo().SetVisible(!1),
            this._stage = 1,
            this._stageTimeLeft += this._offTime) : (this._inst.GetWorldInfo().SetVisible(!0),
            this._stage = 0,
            this._stageTimeLeft += this._onTime),
            this._runtime.UpdateRender())
        }
    }
    GetDebuggerProperties() {
        return [{
            title: "$" + this.GetBehaviorType().GetName(),
            properties: [{
                name: "behaviors.flash.debugger.on-time",
                value: this._onTime,
                onedit: a => this._onTime = a
            }, {
                name: "behaviors.flash.debugger.off-time",
                value: this._offTime,
                onedit: a => this._offTime = a
            }, {
                name: "behaviors.flash.debugger.is-flashing",
                value: 0 < this._timeLeft
            }, {
                name: "behaviors.flash.debugger.time-left",
                value: this._timeLeft
            }]
        }]
    }
    GetScriptInterfaceClass() {
        return self.IFlashBehaviorInstance
    }
}
;
const map$jscomp$43 = new WeakMap;
self.IFlashBehaviorInstance = class extends IBehaviorInstance$jscomp$6 {
    constructor() {
        super();
        map$jscomp$43.set(this, IBehaviorInstance$jscomp$6._GetInitInst().GetSdkInstance())
    }
    flash(a, b, c) {
        C3X$jscomp$53.RequireFiniteNumber(a);
        C3X$jscomp$53.RequireFiniteNumber(b);
        C3X$jscomp$53.RequireFiniteNumber(c);
        map$jscomp$43.get(this)._Flash(a, b, c)
    }
    stop() {
        map$jscomp$43.get(this)._StopFlashing()
    }
    get isFlashing() {
        return map$jscomp$43.get(this)._IsFlashing()
    }
}
;
self.C3.Behaviors.Flash.Cnds = {
    IsFlashing() {
        return this._IsFlashing()
    },
    OnFlashEnded() {
        return !0
    }
};
self.C3.Behaviors.Flash.Acts = {
    Flash(a, b, c) {
        this._Flash(a, b, c)
    },
    StopFlashing() {
        this._StopFlashing()
    }
};
self.C3.Behaviors.Flash.Exps = {};
"use strict";
const C3$jscomp$368 = self.C3;
C3$jscomp$368.Behaviors.LOS = class extends C3$jscomp$368.SDKBehaviorBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
}
;
const C3$jscomp$369 = self.C3;
C3$jscomp$369.Behaviors.LOS.Type = class extends C3$jscomp$369.SDKBehaviorTypeBase {
    constructor(a) {
        super(a);
        this._obstacleTypes = []
    }
    Release() {
        C3$jscomp$369.clearArray(this._obstacleTypes);
        super.Release()
    }
    OnCreate() {}
    AddObstacle(a) {
        if (!this._obstacleTypes.includes(a)) {
            for (const b of this._obstacleTypes)
                if (b.IsFamily() && b.FamilyHasMember(a))
                    return;
            this._obstacleTypes.push(a)
        }
    }
    ClearObstacles() {
        C3$jscomp$369.clearArray(this._obstacleTypes)
    }
    GetObstacleTypes() {
        return this._obstacleTypes
    }
    FindLOSBehavior(a) {
        const b = this.GetBehaviorType();
        for (const c of a.GetBehaviorInstances())
            if (c.GetBehaviorType() === b)
                return c.GetSdkInstance();
        return null
    }
}
;
const C3$jscomp$370 = self.C3
  , C3X$jscomp$54 = self.C3X
  , IBehaviorInstance$jscomp$7 = self.IBehaviorInstance
  , collisionCandidates = [];
C3$jscomp$370.Behaviors.LOS.Instance = class extends C3$jscomp$370.SDKBehaviorInstanceBase {
    constructor(a, b) {
        super(a);
        this._obstacleMode = 0;
        this._range = 1E4;
        this._cone = C3$jscomp$370.toRadians(360);
        this._useCollisionCells = !0;
        this._ray = new C3$jscomp$370.Ray;
        b && (this._obstacleMode = b[0],
        this._range = b[1],
        this._cone = C3$jscomp$370.toRadians(b[2]),
        this._useCollisionCells = b[3])
    }
    Release() {
        super.Release()
    }
    SaveToJson() {
        return {
            r: this._range,
            c: this._cone,
            om: this._obstacleMode,
            ucc: this._useCollisionCells,
            t: this.GetSdkType().GetObstacleTypes().map(a => a.GetSID())
        }
    }
    LoadFromJson(a) {
        this._range = a.r;
        this._cone = a.c;
        this._obstacleMode = a.om || 0;
        this._useCollisionCells = !!a.ucc;
        const b = this.GetSdkType().GetObstacleTypes();
        C3$jscomp$370.clearArray(b);
        for (const c of a.t)
            (a = this._runtime.GetObjectClassBySID(c)) && b.push(a)
    }
    HasLOSToInstance(a, b) {
        const c = a.GetUID()
          , [d,e] = a.GetImagePoint(b);
        return this.HasLOSTo(d, e) || this._ray.DidCollide() && this._ray.hitUid === c
    }
    HasLOSTo(a, b) {
        const c = this.GetWorldInfo();
        let d = c.GetAngle();
        0 > c.GetWidth() && (d += Math.PI);
        return this.HasLOSBetweenPositions(c.GetX(), c.GetY(), d, a, b)
    }
    HasLOSBetweenPositions(a, b, c, d, e) {
        this._ray.Reset();
        var f = this._range;
        if (C3$jscomp$370.distanceSquared(a, b, d, e) > f * f)
            return !1;
        f = C3$jscomp$370.angleTo(a, b, d, e);
        return C3$jscomp$370.angleDiff(c, f) > this._cone / 2 ? !1 : !this.CastRay(a, b, d, e, this._useCollisionCells).DidCollide()
    }
    _GetCollisionCandidates(a, b) {
        if (b) {
            b = this.GetWorldInfo().GetLayer();
            var c = this._runtime.GetCollisionEngine();
            0 === this._obstacleMode ? c.GetSolidCollisionCandidates(b, a.rect, collisionCandidates) : c.GetObjectClassesCollisionCandidates(b, this._GetObstacleTypes(), a.rect, collisionCandidates);
            return collisionCandidates
        }
        if (0 === this._obstacleMode)
            return (a = this._runtime.GetSolidBehavior()) ? a.GetInstances() : collisionCandidates;
        for (c of this._GetObstacleTypes())
            C3$jscomp$370.appendArray(collisionCandidates, c.GetInstances());
        return collisionCandidates
    }
    _GetObstacleTypes() {
        return this.GetSdkType().GetObstacleTypes()
    }
    CastRay(a, b, c, d, e) {
        a = this._ray.Set(a, b, c, d);
        e = this._GetCollisionCandidates(a, e);
        b = this._runtime.GetCollisionEngine();
        c = 0 === this._obstacleMode;
        d = this._inst;
        for (let f = 0, h = e.length; f < h; ++f) {
            const l = e[f];
            l !== d && (c && !b.IsSolidCollisionAllowed(l, d) || b.TestRayIntersectsInstance(l, a))
        }
        a.Complete();
        C3$jscomp$370.clearArray(collisionCandidates);
        return a
    }
    _GetRay() {
        return this._ray
    }
    _GetRayHitX() {
        const a = this._ray;
        return a.DidCollide() ? a.hitX : 0
    }
    _GetRayHitY() {
        const a = this._ray;
        return a.DidCollide() ? a.hitY : 0
    }
    _GetRayHitDistance() {
        const a = this._ray;
        return a.DidCollide() ? a.distance : 0
    }
    _GetRayHitUID() {
        const a = this._ray;
        return a.DidCollide() ? a.hitUid : -1
    }
    _GetRayNormalX(a) {
        const b = this._ray;
        return b.DidCollide() ? b.hitX + a * b.normalX : 0
    }
    _GetRayNormalY(a) {
        const b = this._ray;
        return b.DidCollide() ? b.hitY + a * b.normalY : 0
    }
    _GetRayNormalAngle() {
        const a = this._ray;
        return a.DidCollide() ? a.hitNormal : 0
    }
    _GetRayReflectionX(a) {
        const b = this._ray;
        return b.DidCollide() ? b.hitX + a * b.reflectionX : 0
    }
    _GetRayReflectionY(a) {
        const b = this._ray;
        return b.DidCollide() ? b.hitY + a * b.reflectionY : 0
    }
    _GetRayReflectionAngle() {
        const a = this._ray;
        return a.DidCollide() ? Math.atan2(a.reflectionY, a.reflectionX) : 0
    }
    _SetRange(a) {
        this._range = a
    }
    _GetRange() {
        return this._range
    }
    _SetConeOfView(a) {
        this._cone = a
    }
    _GetConeOfView() {
        return this._cone
    }
    GetPropertyValueByIndex(a) {
        switch (a) {
        case 0:
            return this._obstacleMode;
        case 1:
            return this._range;
        case 2:
            return C3$jscomp$370.toDegrees(this._cone);
        case 3:
            return this._useCollisionCells
        }
    }
    SetPropertyValueByIndex(a, b) {
        switch (a) {
        case 0:
            this._obstacleMode = b;
            break;
        case 1:
            this._range = b;
            break;
        case 2:
            this._cone = C3$jscomp$370.toRadians(b);
            break;
        case 3:
            this._useCollisionCells = !!b
        }
    }
    GetDebuggerProperties() {
        return [{
            title: "$" + this.GetBehaviorType().GetName(),
            properties: [{
                name: "behaviors.los.properties.range.name",
                value: this._GetRange(),
                onedit: a => this._SetRange(a)
            }, {
                name: "behaviors.los.properties.cone-of-view.name",
                value: C3$jscomp$370.toDegrees(this._GetConeOfView()),
                onedit: a => this._SetConeOfView(C3$jscomp$370.toRadians(a))
            }]
        }]
    }
    GetScriptInterfaceClass() {
        return self.ILOSBehaviorInstance
    }
}
;
const map$jscomp$44 = new WeakMap;
self.ILOSBehaviorInstance = class extends IBehaviorInstance$jscomp$7 {
    constructor() {
        super();
        const a = IBehaviorInstance$jscomp$7._GetInitInst().GetSdkInstance();
        map$jscomp$44.set(this, a);
        this.ray = new self.ILOSBehaviorRay(a)
    }
    set range(a) {
        C3X$jscomp$54.RequireFiniteNumber(a);
        map$jscomp$44.get(this)._SetRange(a)
    }
    get range() {
        return map$jscomp$44.get(this)._GetRange()
    }
    set coneOfView(a) {
        C3X$jscomp$54.RequireFiniteNumber(a);
        map$jscomp$44.get(this)._SetConeOfView(a)
    }
    get coneOfView() {
        return map$jscomp$44.get(this)._GetConeOfView()
    }
    hasLOStoPosition(a, b) {
        C3X$jscomp$54.RequireNumber(a);
        C3X$jscomp$54.RequireNumber(b);
        return map$jscomp$44.get(this).HasLOSTo(a, b)
    }
    hasLOSBetweenPositions(a, b, c, d, e) {
        C3X$jscomp$54.RequireNumber(a);
        C3X$jscomp$54.RequireNumber(b);
        C3X$jscomp$54.RequireNumber(c);
        C3X$jscomp$54.RequireNumber(d);
        C3X$jscomp$54.RequireNumber(e);
        return map$jscomp$44.get(this).HasLOSBetweenPositions(a, b, c, d, e)
    }
    castRay(a, b, c, d, e=!0) {
        C3X$jscomp$54.RequireNumber(a);
        C3X$jscomp$54.RequireNumber(b);
        C3X$jscomp$54.RequireNumber(c);
        C3X$jscomp$54.RequireNumber(d);
        map$jscomp$44.get(this).CastRay(a, b, c, d, e);
        return this.ray
    }
    addObstacle(a) {
        const b = map$jscomp$44.get(this);
        a = b.GetRuntime()._UnwrapIObjectClass(a);
        b.GetSdkType().AddObstacle(a)
    }
    clearObstacles() {
        map$jscomp$44.get(this).GetSdkType().ClearObstacles()
    }
}
;
self.ILOSBehaviorRay = class {
    constructor(a) {
        map$jscomp$44.set(this, a)
    }
    get didCollide() {
        return map$jscomp$44.get(this)._GetRay().DidCollide()
    }
    get hitX() {
        return map$jscomp$44.get(this)._GetRayHitX()
    }
    get hitY() {
        return map$jscomp$44.get(this)._GetRayHitY()
    }
    getHitPosition() {
        const a = map$jscomp$44.get(this);
        return [a._GetRayHitX(), a._GetRayHitY()]
    }
    get hitDistance() {
        return map$jscomp$44.get(this)._GetRayHitDistance()
    }
    get hitUid() {
        return map$jscomp$44.get(this)._GetRayHitUID()
    }
    getNormalX(a) {
        C3X$jscomp$54.RequireFiniteNumber(a);
        return map$jscomp$44.get(this)._GetRayNormalX(a)
    }
    getNormalY(a) {
        C3X$jscomp$54.RequireFiniteNumber(a);
        return map$jscomp$44.get(this)._GetRayNormalY(a)
    }
    getNormal(a) {
        C3X$jscomp$54.RequireFiniteNumber(a);
        const b = map$jscomp$44.get(this);
        return [b._GetRayNormalX(a), b._GetRayNormalY(a)]
    }
    get normalAngle() {
        return map$jscomp$44.get(this)._GetRayNormalAngle()
    }
    getReflectionX(a) {
        C3X$jscomp$54.RequireFiniteNumber(a);
        return map$jscomp$44.get(this)._GetRayReflectionX(a)
    }
    getReflectionY(a) {
        C3X$jscomp$54.RequireFiniteNumber(a);
        return map$jscomp$44.get(this)._GetRayReflectionY(a)
    }
    getReflection(a) {
        C3X$jscomp$54.RequireFiniteNumber(a);
        const b = map$jscomp$44.get(this);
        return [b._GetRayReflectionX(a), b._GetRayReflectionY(a)]
    }
    get reflectionAngle() {
        return map$jscomp$44.get(this)._GetRayReflectionAngle()
    }
}
;
const C3$jscomp$371 = self.C3
  , lToPick = new Set
  , rToPick$jscomp$1 = new Set;
C3$jscomp$371.Behaviors.LOS.Cnds = {
    HasLOSToPosition(a, b) {
        return this.HasLOSTo(a, b)
    },
    RayIntersected() {
        return this._ray.DidCollide()
    },
    HasLOSBetweenPositions(a, b, c, d, e) {
        return this.HasLOSBetweenPositions(a, b, C3$jscomp$371.toRadians(c), d, e)
    },
    HasLOSToObject(a, b) {
        if (!a)
            return !1;
        var c = this._runtime.GetCurrentCondition();
        const d = c.GetEventBlock().IsOrBlock();
        var e = c.GetRuntime();
        const f = c.GetObjectClass().GetCurrentSol();
        a = a.GetCurrentSol();
        let h = f.GetInstances()
          , l = a.GetInstances();
        f.IsSelectAll() ? C3$jscomp$371.clearArray(f._GetOwnElseInstances()) : d && (h = e.IsCurrentConditionFirst() && !f._GetOwnElseInstances().length && f._GetOwnInstances().length ? f._GetOwnInstances() : f._GetOwnElseInstances());
        a.IsSelectAll() ? C3$jscomp$371.clearArray(a._GetOwnElseInstances()) : d && (l = e.IsCurrentConditionFirst() && !a._GetOwnElseInstances().length && a._GetOwnInstances().length ? a._GetOwnInstances() : a._GetOwnElseInstances());
        c = c.IsInverted();
        e = this.GetSdkType();
        for (const m of h) {
            let p = !1;
            const r = e.FindLOSBehavior(m);
            if (0 === l.length)
                c && (p = !0);
            else
                for (const v of l)
                    m !== v && C3$jscomp$371.xor(r.HasLOSToInstance(v, b), c) && (p = !0,
                    rToPick$jscomp$1.add(v));
            p && lToPick.add(m)
        }
        d ? (h === f._GetOwnElseInstances() ? f.TransferElseInstancesToOwn(lToPick) : (f.AddElseInstances(lToPick, h),
        f.SetSetPicked(lToPick)),
        l === a._GetOwnElseInstances() ? a.TransferElseInstancesToOwn(rToPick$jscomp$1) : (a.AddElseInstances(rToPick$jscomp$1, l),
        a.SetSetPicked(rToPick$jscomp$1))) : (f.SetSetPicked(lToPick),
        a.SetSetPicked(rToPick$jscomp$1));
        lToPick.clear();
        rToPick$jscomp$1.clear();
        return f.HasAnyInstances()
    }
};
const C3$jscomp$372 = self.C3;
C3$jscomp$372.Behaviors.LOS.Acts = {
    SetRange(a) {
        this._SetRange(a)
    },
    SetCone(a) {
        this._SetConeOfView(C3$jscomp$372.toRadians(a))
    },
    CastRay(a, b, c, d, e) {
        this.CastRay(a, b, c, d, e)
    },
    AddObstacle(a) {
        this.GetSdkType().AddObstacle(a)
    },
    ClearObstacles() {
        this.GetSdkType().ClearObstacles()
    }
};
const C3$jscomp$373 = self.C3;
C3$jscomp$373.Behaviors.LOS.Exps = {
    Range() {
        return this._GetRange()
    },
    ConeOfView() {
        return C3$jscomp$373.toDegrees(this._GetConeOfView())
    },
    HitX() {
        return this._GetRayHitX()
    },
    HitY() {
        return this._GetRayHitY()
    },
    HitDistance() {
        return this._GetRayHitDistance()
    },
    HitUID() {
        return this._GetRayHitUID()
    },
    NormalX(a) {
        return this._GetRayNormalX(a)
    },
    NormalY(a) {
        return this._GetRayNormalY(a)
    },
    NormalAngle() {
        return C3$jscomp$373.toDegrees(this._GetRayNormalAngle())
    },
    ReflectionX(a) {
        return this._GetRayReflectionX(a)
    },
    ReflectionY(a) {
        return this._GetRayReflectionY(a)
    },
    ReflectionAngle() {
        return C3$jscomp$373.toDegrees(this._GetRayReflectionAngle())
    }
};
"use strict";
const C3$jscomp$374 = self.C3;
C3$jscomp$374.Behaviors.Sin = class extends C3$jscomp$374.SDKBehaviorBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
}
;
const C3$jscomp$375 = self.C3;
C3$jscomp$375.Behaviors.Sin.Type = class extends C3$jscomp$375.SDKBehaviorTypeBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
}
;
const C3$jscomp$376 = self.C3
  , C3X$jscomp$55 = self.C3X
  , IBehaviorInstance$jscomp$8 = self.IBehaviorInstance
  , _2pi = 2 * Math.PI
  , _pi_2 = Math.PI / 2
  , _3pi_2 = 3 * Math.PI / 2
  , MOVEMENT_LOOKUP = [0, 1, 8, 3, 4, 2, 5, 6, 9, 7];
C3$jscomp$376.Behaviors.Sin.Instance = class extends C3$jscomp$376.SDKBehaviorInstanceBase {
    constructor(a, b) {
        super(a);
        this._mag = this._period = this._wave = this._movement = this._i = 0;
        this._isEnabled = !0;
        this._ratio = this._lastKnownValue2 = this._lastKnownValue = this._initialValue2 = this._initialValue = this._magnitudeRandom = this._periodOffsetRandom = this._periodRandom = this._baseMag = this._basePeriodOffset = this._basePeriod = 0;
        b && (this._movement = MOVEMENT_LOOKUP[b[0]],
        this._wave = b[1],
        this._periodRandom = this._runtime.Random() * b[3],
        this._basePeriod = b[2],
        this._period = b[2],
        this._period += this._periodRandom,
        this._basePeriodOffset = b[4],
        0 !== this._period && (this._periodOffsetRandom = this._runtime.Random() * b[5],
        this._i = b[4] / this._period * _2pi,
        this._i += this._periodOffsetRandom / this._period * _2pi),
        this._magnitudeRandom = this._runtime.Random() * b[7],
        this._baseMag = b[6],
        this._mag = b[6],
        this._mag += this._magnitudeRandom,
        this._isEnabled = !!b[8]);
        5 === this._movement && (this._mag = C3$jscomp$376.toRadians(this._mag));
        this.Init();
        this._isEnabled && this._StartTicking()
    }
    Release() {
        super.Release()
    }
    SaveToJson() {
        return {
            i: this._i,
            e: this._isEnabled,
            mv: this._movement,
            w: this._wave,
            p: this._period,
            mag: this._mag,
            iv: this._initialValue,
            iv2: this._initialValue2,
            r: this._ratio,
            lkv: this._lastKnownValue,
            lkv2: this._lastKnownValue2
        }
    }
    LoadFromJson(a) {
        this._i = a.i;
        this._SetEnabled(a.e);
        this._movement = a.mv;
        this._wave = a.w;
        this._period = a.p;
        this._mag = a.mag;
        this._initialValue = a.iv;
        this._initialValue2 = a.iv2;
        this._ratio = a.r;
        this._lastKnownValue = a.lkv;
        this._lastKnownValue2 = a.lkv2
    }
    Init() {
        const a = this._inst.GetWorldInfo();
        switch (this._movement) {
        case 0:
            this._initialValue = a.GetX();
            break;
        case 1:
            this._initialValue = a.GetY();
            break;
        case 2:
            this._initialValue = a.GetWidth();
            this._ratio = a.GetHeight() / a.GetWidth();
            break;
        case 3:
            this._initialValue = a.GetWidth();
            break;
        case 4:
            this._initialValue = a.GetHeight();
            break;
        case 5:
            this._initialValue = a.GetAngle();
            break;
        case 6:
            this._initialValue = a.GetOpacity();
            break;
        case 7:
            this._initialValue = 0;
            break;
        case 8:
            this._initialValue = a.GetX();
            this._initialValue2 = a.GetY();
            break;
        case 9:
            this._initialValue = a.GetZElevation()
        }
        this._lastKnownValue = this._initialValue;
        this._lastKnownValue2 = this._initialValue2
    }
    WaveFunc(a) {
        a %= _2pi;
        switch (this._wave) {
        case 0:
            return Math.sin(a);
        case 1:
            return a <= _pi_2 ? a / _pi_2 : a <= _3pi_2 ? 1 - 2 * (a - _pi_2) / Math.PI : (a - _3pi_2) / _pi_2 - 1;
        case 2:
            return 2 * a / _2pi - 1;
        case 3:
            return -2 * a / _2pi + 1;
        case 4:
            return a < Math.PI ? -1 : 1
        }
        return 0
    }
    Tick() {
        const a = this._runtime.GetDt(this._inst);
        this._isEnabled && 0 !== a && (this._i = 0 === this._period ? 0 : (this._i + a / this._period * _2pi) % _2pi,
        this._UpdateFromPhase())
    }
    _UpdateFromPhase() {
        const a = this._inst.GetWorldInfo();
        switch (this._movement) {
        case 0:
            a.GetX() !== this._lastKnownValue && (this._initialValue += a.GetX() - this._lastKnownValue);
            a.SetX(this._initialValue + this.WaveFunc(this._i) * this._mag);
            this._lastKnownValue = a.GetX();
            break;
        case 1:
            a.GetY() !== this._lastKnownValue && (this._initialValue += a.GetY() - this._lastKnownValue);
            a.SetY(this._initialValue + this.WaveFunc(this._i) * this._mag);
            this._lastKnownValue = a.GetY();
            break;
        case 2:
            a.SetWidth(this._initialValue + this.WaveFunc(this._i) * this._mag);
            a.SetHeight(a.GetWidth() * this._ratio);
            break;
        case 3:
            a.SetWidth(this._initialValue + this.WaveFunc(this._i) * this._mag);
            break;
        case 4:
            a.SetHeight(this._initialValue + this.WaveFunc(this._i) * this._mag);
            break;
        case 5:
            a.GetAngle() !== this._lastKnownValue && (this._initialValue = C3$jscomp$376.clampAngle(this._initialValue + (a.GetAngle() - this._lastKnownValue)));
            a.SetAngle(this._initialValue + this.WaveFunc(this._i) * this._mag);
            this._lastKnownValue = a.GetAngle();
            break;
        case 6:
            a.SetOpacity(this._initialValue + this.WaveFunc(this._i) * this._mag / 100);
            break;
        case 8:
            a.GetX() !== this._lastKnownValue && (this._initialValue += a.GetX() - this._lastKnownValue);
            a.GetY() !== this._lastKnownValue2 && (this._initialValue2 += a.GetY() - this._lastKnownValue2);
            a.SetX(this._initialValue + Math.cos(a.GetAngle()) * this.WaveFunc(this._i) * this._mag);
            a.SetY(this._initialValue2 + Math.sin(a.GetAngle()) * this.WaveFunc(this._i) * this._mag);
            this._lastKnownValue = a.GetX();
            this._lastKnownValue2 = a.GetY();
            break;
        case 9:
            a.SetZElevation(this._initialValue + this.WaveFunc(this._i) * this._mag)
        }
        a.SetBboxChanged()
    }
    _OnSpriteFrameChanged(a, b) {}
    _SetPeriod(a) {
        this._period = a
    }
    _GetPeriod() {
        return this._period
    }
    _SetMagnitude(a) {
        this._mag = a
    }
    _SetMagnitude_ConvertAngle(a) {
        5 === this._movement && (a = C3$jscomp$376.toRadians(a));
        this._SetMagnitude(a)
    }
    _GetMagnitude() {
        return this._mag
    }
    _GetMagnitude_ConvertAngle() {
        let a = this._GetMagnitude();
        5 === this._movement && (a = C3$jscomp$376.toDegrees(a));
        return a
    }
    _SetMovement(a) {
        5 === this._movement && 5 !== a && (this._mag = C3$jscomp$376.toDegrees(this._mag));
        this._movement = a;
        this.Init()
    }
    _GetMovement() {
        return this._movement
    }
    _SetWave(a) {
        this._wave = a
    }
    _GetWave() {
        return this._wave
    }
    _SetPhase(a) {
        this._i = C3$jscomp$376.clamp(a, 0, 2 * Math.PI);
        this._UpdateFromPhase()
    }
    _GetPhase() {
        return this._i
    }
    _SetEnabled(a) {
        (this._isEnabled = !!a) ? this._StartTicking() : this._StopTicking()
    }
    _IsEnabled() {
        return this._isEnabled
    }
    GetPropertyValueByIndex(a) {
        switch (a) {
        case 0:
            return this._movement;
        case 1:
            return this._wave;
        case 2:
            return this._basePeriod;
        case 6:
            return this._baseMag;
        case 8:
            return this._isEnabled
        }
    }
    SetPropertyValueByIndex(a, b) {
        switch (a) {
        case 0:
            this._movement = MOVEMENT_LOOKUP[b];
            this.Init();
            break;
        case 1:
            this._wave = b;
            break;
        case 2:
            this._basePeriod = b;
            this._period = this._basePeriod + this._periodRandom;
            this._isEnabled || (0 !== this._period ? (this._i = this._basePeriodOffset / this._period * _2pi,
            this._i += this._periodOffsetRandom / this._period * _2pi) : this._i = 0);
            break;
        case 6:
            this._baseMag = b;
            this._mag = this._baseMag + this._magnitudeRandom;
            5 === this._movement && (this._mag = C3$jscomp$376.toRadians(this._mag));
            break;
        case 8:
            this._isEnabled = !!b
        }
    }
    GetDebuggerProperties() {
        return [{
            title: "$" + this.GetBehaviorType().GetName(),
            properties: [{
                name: "behaviors.sin.properties.enabled.name",
                value: this._IsEnabled(),
                onedit: a => this._SetEnabled(a)
            }, {
                name: "behaviors.sin.properties.period.name",
                value: this._GetPeriod(),
                onedit: a => this._SetPeriod(a)
            }, {
                name: "behaviors.sin.properties.magnitude.name",
                value: this._GetMagnitude_ConvertAngle(),
                onedit: a => this._SetMagnitude_ConvertAngle(a)
            }, {
                name: "behaviors.sin.debugger.value",
                value: this.WaveFunc(this._GetPhase()) * this._GetMagnitude_ConvertAngle()
            }]
        }]
    }
    GetScriptInterfaceClass() {
        return self.ISineBehaviorInstance
    }
}
;
const map$jscomp$45 = new WeakMap
  , VALID_MOVEMENTS = "horizontal vertical size width height angle opacity value-only forwards-backwards z-elevation".split(" ")
  , VALID_WAVES = ["sine", "triangle", "sawtooth", "reverse-sawtooth", "square"];
self.ISineBehaviorInstance = class extends IBehaviorInstance$jscomp$8 {
    constructor() {
        super();
        map$jscomp$45.set(this, IBehaviorInstance$jscomp$8._GetInitInst().GetSdkInstance())
    }
    set period(a) {
        C3X$jscomp$55.RequireFiniteNumber(a);
        map$jscomp$45.get(this)._SetPeriod(a)
    }
    get period() {
        return map$jscomp$45.get(this)._GetPeriod()
    }
    set magnitude(a) {
        C3X$jscomp$55.RequireFiniteNumber(a);
        map$jscomp$45.get(this)._SetMagnitude(a)
    }
    get magnitude() {
        return map$jscomp$45.get(this)._GetMagnitude()
    }
    set phase(a) {
        map$jscomp$45.get(this)._SetPhase(a)
    }
    get phase() {
        return map$jscomp$45.get(this)._GetPhase()
    }
    set movement(a) {
        C3X$jscomp$55.RequireString(a);
        a = VALID_MOVEMENTS.indexOf(a);
        if (-1 === a)
            throw Error("invalid movement");
        map$jscomp$45.get(this)._SetMovement(a)
    }
    get movement() {
        return VALID_MOVEMENTS[map$jscomp$45.get(this)._GetMovement()]
    }
    set wave(a) {
        C3X$jscomp$55.RequireString(a);
        a = VALID_WAVES.indexOf(a);
        if (-1 === a)
            throw Error("invalid wave");
        map$jscomp$45.get(this)._SetWave(a)
    }
    get wave() {
        return VALID_WAVES[map$jscomp$45.get(this)._GetWave()]
    }
    get value() {
        const a = map$jscomp$45.get(this);
        return a.WaveFunc(a._GetPhase()) * a._GetMagnitude()
    }
    updateInitialState() {
        map$jscomp$45.get(this).Init()
    }
    set isEnabled(a) {
        map$jscomp$45.get(this)._SetEnabled(!!a)
    }
    get isEnabled() {
        return map$jscomp$45.get(this)._IsEnabled()
    }
}
;
const C3$jscomp$377 = self.C3;
C3$jscomp$377.Behaviors.Sin.Cnds = {
    IsEnabled() {
        return this._IsEnabled()
    },
    CompareMovement(a) {
        return this._GetMovement() === a
    },
    ComparePeriod(a, b) {
        return C3$jscomp$377.compare(this._GetPeriod(), a, b)
    },
    CompareMagnitude(a, b) {
        return C3$jscomp$377.compare(this._GetMagnitude_ConvertAngle(), a, b)
    },
    CompareWave(a) {
        return this._GetWave() === a
    }
};
self.C3.Behaviors.Sin.Acts = {
    SetEnabled(a) {
        this._SetEnabled(0 !== a)
    },
    SetPeriod(a) {
        this._SetPeriod(a)
    },
    SetMagnitude(a) {
        this._SetMagnitude_ConvertAngle(a)
    },
    SetMovement(a) {
        this._SetMovement(a)
    },
    SetWave(a) {
        this._wave = a
    },
    SetPhase(a) {
        const b = 2 * Math.PI;
        this._SetPhase(a * b % b)
    },
    UpdateInitialState() {
        this.Init()
    }
};
self.C3.Behaviors.Sin.Exps = {
    CyclePosition() {
        return this._GetPhase() / (2 * Math.PI)
    },
    Period() {
        return this._GetPeriod()
    },
    Magnitude() {
        return this._GetMagnitude_ConvertAngle()
    },
    Value() {
        return this.WaveFunc(this._GetPhase()) * this._GetMagnitude_ConvertAngle()
    }
};
"use strict";
const C3$jscomp$380 = self.C3;
C3$jscomp$380.Behaviors.solid = class extends C3$jscomp$380.SDKBehaviorBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
}
;
const C3$jscomp$381 = self.C3;
C3$jscomp$381.Behaviors.solid.Type = class extends C3$jscomp$381.SDKBehaviorTypeBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
}
;
const C3$jscomp$382 = self.C3
  , C3X$jscomp$56 = self.C3X
  , IBehaviorInstance$jscomp$9 = self.IBehaviorInstance
  , EMPTY_SET = new Set;
C3$jscomp$382.Behaviors.solid.Instance = class extends C3$jscomp$382.SDKBehaviorInstanceBase {
    constructor(a, b) {
        super(a);
        this.SetEnabled(!0);
        b && (this.SetEnabled(b[0]),
        this.SetTags(b[1]))
    }
    Release() {
        super.Release()
    }
    SetEnabled(a) {
        this._inst._SetSolidEnabled(!!a)
    }
    IsEnabled() {
        return this._inst._IsSolidEnabled()
    }
    SetTags(a) {
        const b = this._inst.GetSavedDataMap();
        if (a.trim()) {
            var c = b.get("solidTags");
            c || (c = new Set,
            b.set("solidTags", c));
            c.clear();
            for (const d of a.split(" "))
                d && c.add(d.toLowerCase())
        } else
            b.delete("solidTags")
    }
    GetTags() {
        return this._inst.GetSavedDataMap().get("solidTags") || EMPTY_SET
    }
    _GetTagsString() {
        return [...this.GetTags()].join(" ")
    }
    SaveToJson() {
        return {
            e: this.IsEnabled()
        }
    }
    LoadFromJson(a) {
        this.SetEnabled(a.e)
    }
    GetPropertyValueByIndex(a) {
        switch (a) {
        case 0:
            return this.IsEnabled()
        }
    }
    SetPropertyValueByIndex(a, b) {
        switch (a) {
        case 0:
            this.SetEnabled(b)
        }
    }
    GetDebuggerProperties() {
        return [{
            title: "$" + this.GetBehaviorType().GetName(),
            properties: [{
                name: "behaviors.solid.properties.enabled.name",
                value: this.IsEnabled(),
                onedit: a => this.SetEnabled(a)
            }, {
                name: "behaviors.solid.properties.tags.name",
                value: this._GetTagsString(),
                onedit: a => this.SetTags(a)
            }]
        }]
    }
    GetScriptInterfaceClass() {
        return self.ISolidBehaviorInstance
    }
}
;
const map$jscomp$46 = new WeakMap;
self.ISolidBehaviorInstance = class extends IBehaviorInstance$jscomp$9 {
    constructor() {
        super();
        map$jscomp$46.set(this, IBehaviorInstance$jscomp$9._GetInitInst().GetSdkInstance())
    }
    set isEnabled(a) {
        map$jscomp$46.get(this).SetEnabled(!!a)
    }
    get isEnabled() {
        return map$jscomp$46.get(this).IsEnabled()
    }
    set tags(a) {
        C3X$jscomp$56.RequireString(a);
        map$jscomp$46.get(this).SetTags(a)
    }
    get tags() {
        return map$jscomp$46.get(this)._GetTagsString()
    }
}
;
self.C3.Behaviors.solid.Cnds = {
    IsEnabled() {
        return this.IsEnabled()
    }
};
self.C3.Behaviors.solid.Acts = {
    SetEnabled(a) {
        this.SetEnabled(a)
    },
    SetTags(a) {
        this.SetTags(a)
    }
};
self.C3.Behaviors.solid.Exps = {};
"use strict";
const C3$jscomp$386 = self.C3;
C3$jscomp$386.Behaviors.Timer = class extends C3$jscomp$386.SDKBehaviorBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
}
;
const C3$jscomp$387 = self.C3;
C3$jscomp$387.Behaviors.Timer.Type = class extends C3$jscomp$387.SDKBehaviorTypeBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
}
;
const C3$jscomp$388 = self.C3
  , C3X$jscomp$57 = self.C3X
  , IBehaviorInstance$jscomp$10 = self.IBehaviorInstance;
C3$jscomp$388.Behaviors.Timer.SingleTimer = class {
    constructor(a, b, c, d) {
        this._current = C3$jscomp$388.New(C3$jscomp$388.KahanSum);
        this._current.Set(a || 0);
        this._total = C3$jscomp$388.New(C3$jscomp$388.KahanSum);
        this._total.Set(b || 0);
        this._duration = c || 0;
        this._isRegular = !!d;
        this._isPaused = !1
    }
    GetCurrentTime() {
        return this._current.Get()
    }
    GetTotalTime() {
        return this._total.Get()
    }
    GetDuration() {
        return this._duration
    }
    SetPaused(a) {
        this._isPaused = !!a
    }
    IsPaused() {
        return this._isPaused
    }
    Add(a) {
        this._current.Add(a);
        this._total.Add(a)
    }
    HasFinished() {
        return this._current.Get() >= this._duration
    }
    Update() {
        if (this.HasFinished())
            if (this._isRegular)
                this._current.Subtract(this._duration);
            else
                return !0;
        return !1
    }
    SaveToJson() {
        return {
            c: this._current.Get(),
            t: this._total.Get(),
            d: this._duration,
            r: this._isRegular,
            p: this._isPaused
        }
    }
    LoadFromJson(a) {
        this._current.Set(a.c);
        this._total.Set(a.t);
        this._duration = a.d;
        this._isRegular = !!a.r;
        this._isPaused = !!a.p
    }
}
;
C3$jscomp$388.Behaviors.Timer.Instance = class extends C3$jscomp$388.SDKBehaviorInstanceBase {
    constructor(a, b) {
        super(a);
        this._timers = new Map
    }
    Release() {
        this._timers.clear();
        super.Release()
    }
    _StartTimer(a, b, c) {
        a = new C3$jscomp$388.Behaviors.Timer.SingleTimer(0,0,a,c);
        this._timers.set(b.toLowerCase(), a);
        this._UpdateTickState()
    }
    _StopTimer(a) {
        this._timers.delete(a.toLowerCase());
        this._UpdateTickState()
    }
    _StopAllTimers() {
        this._timers.clear();
        this._UpdateTickState()
    }
    _IsTimerRunning(a) {
        return this._timers.has(a.toLowerCase())
    }
    _GetTimerCurrentTime(a) {
        return (a = this._timers.get(a.toLowerCase())) ? a.GetCurrentTime() : 0
    }
    _GetTimerTotalTime(a) {
        return (a = this._timers.get(a.toLowerCase())) ? a.GetTotalTime() : 0
    }
    _GetTimerDuration(a) {
        return (a = this._timers.get(a.toLowerCase())) ? a.GetDuration() : 0
    }
    _HasTimerFinished(a) {
        return (a = this._timers.get(a.toLowerCase())) ? a.HasFinished() : !1
    }
    _SetTimerPaused(a, b) {
        (a = this._timers.get(a.toLowerCase())) && a.SetPaused(b)
    }
    _IsTimerPaused(a) {
        return (a = this._timers.get(a.toLowerCase())) ? a.IsPaused() : !1
    }
    _SetAllTimersPaused(a) {
        for (const b of this._timers.values())
            b.SetPaused(a)
    }
    _UpdateTickState() {
        0 < this._timers.size ? (this._StartTicking(),
        this._StartTicking2()) : (this._StopTicking(),
        this._StopTicking2())
    }
    SaveToJson() {
        const a = {};
        for (const [b,c] of this._timers.entries())
            a[b] = c.SaveToJson();
        return a
    }
    LoadFromJson(a) {
        this._timers.clear();
        for (const [b,c] of Object.entries(a))
            a = new C3$jscomp$388.Behaviors.Timer.SingleTimer,
            a.LoadFromJson(c),
            this._timers.set(b, a);
        this._UpdateTickState()
    }
    Tick() {
        const a = this._runtime.GetDt(this._inst);
        for (const [b,c] of this._timers)
            c.IsPaused() || (c.Add(a),
            c.HasFinished() && this.DispatchScriptEvent("timer", !1, {
                tag: b
            }))
    }
    Tick2() {
        for (const [a,b] of this._timers.entries())
            b.Update() && this._timers.delete(a)
    }
    GetDebuggerProperties() {
        return [{
            title: "behaviors.timer.debugger.timers",
            properties: [...this._timers.entries()].map(a => ({
                name: "$" + a[0],
                value: `${Math.round(10 * a[1].GetCurrentTime()) / 10} / ${Math.round(10 * a[1].GetDuration()) / 10}`
            }))
        }]
    }
    GetScriptInterfaceClass() {
        return self.ITimerBehaviorInstance
    }
}
;
const map$jscomp$47 = new WeakMap
  , VALID_TIMER_TYPES = ["once", "regular"];
self.ITimerBehaviorInstance = class extends IBehaviorInstance$jscomp$10 {
    constructor() {
        super();
        map$jscomp$47.set(this, IBehaviorInstance$jscomp$10._GetInitInst().GetSdkInstance())
    }
    startTimer(a, b, c="once") {
        C3X$jscomp$57.RequireFiniteNumber(a);
        C3X$jscomp$57.RequireString(b);
        c = VALID_TIMER_TYPES.indexOf(c);
        if (-1 === c)
            throw Error("invalid type");
        map$jscomp$47.get(this)._StartTimer(a, b, 1 === c)
    }
    setTimerPaused(a, b) {
        C3X$jscomp$57.RequireString(a);
        map$jscomp$47.get(this)._SetTimerPaused(a, !!b)
    }
    setAllTimersPaused(a) {
        map$jscomp$47.get(this)._SetAllTimersPaused(!!a)
    }
    stopTimer(a) {
        C3X$jscomp$57.RequireString(a);
        map$jscomp$47.get(this)._StopTimer(a)
    }
    stopAllTimers() {
        map$jscomp$47.get(this)._StopAllTimers()
    }
    isTimerRunning(a) {
        C3X$jscomp$57.RequireString(a);
        return map$jscomp$47.get(this)._IsTimerRunning(a)
    }
    isTimerPaused(a) {
        C3X$jscomp$57.RequireString(a);
        return map$jscomp$47.get(this)._IsTimerPaused(a)
    }
    getCurrentTime(a) {
        C3X$jscomp$57.RequireString(a);
        return map$jscomp$47.get(this)._GetTimerCurrentTime(a)
    }
    getTotalTime(a) {
        C3X$jscomp$57.RequireString(a);
        return map$jscomp$47.get(this)._GetTimerTotalTime(a)
    }
    getDuration(a) {
        C3X$jscomp$57.RequireString(a);
        return map$jscomp$47.get(this)._GetTimerDuration(a)
    }
    hasFinished(a) {
        C3X$jscomp$57.RequireString(a);
        return map$jscomp$47.get(this)._HasTimerFinished(a)
    }
}
;
self.C3.Behaviors.Timer.Cnds = {
    OnTimer(a) {
        return this._HasTimerFinished(a)
    },
    IsTimerRunning(a) {
        return this._IsTimerRunning(a)
    },
    IsTimerPaused(a) {
        return this._IsTimerPaused(a)
    }
};
self.C3.Behaviors.Timer.Acts = {
    StartTimer(a, b, c) {
        this._StartTimer(a, c, 1 === b)
    },
    StopTimer(a) {
        this._StopTimer(a)
    },
    StopAllTimers() {
        this._StopAllTimers()
    },
    PauseResumeTimer(a, b) {
        this._SetTimerPaused(a, 0 === b)
    },
    PauseResumeAllTimers(a) {
        this._SetAllTimersPaused(0 === a)
    }
};
self.C3.Behaviors.Timer.Exps = {
    CurrentTime(a) {
        return this._GetTimerCurrentTime(a)
    },
    TotalTime(a) {
        return this._GetTimerTotalTime(a)
    },
    Duration(a) {
        return this._GetTimerDuration(a)
    }
};
"use strict";
const C3$jscomp$392 = self.C3;
C3$jscomp$392.Behaviors.Platform = class extends C3$jscomp$392.SDKBehaviorBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
}
;
const C3$jscomp$393 = self.C3;
C3$jscomp$393.Behaviors.Platform.Type = class extends C3$jscomp$393.SDKBehaviorTypeBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
}
;
const C3$jscomp$394 = self.C3
  , C3X$jscomp$58 = self.C3X
  , IBehaviorInstance$jscomp$11 = self.IBehaviorInstance;
function accelerate(a, b, c, d, e) {
    return C3$jscomp$394.clamp(a * e + .5 * d * e * e, b * e, c * e)
}
C3$jscomp$394.Behaviors.Platform.Instance = class extends C3$jscomp$394.SDKBehaviorInstanceBase {
    constructor(a, b) {
        super(a);
        this._keyboardDisposables = null;
        this._simJump = this._simRight = this._simLeft = this._ignoreInput = this._canDoubleJump = this._doubleJumped = this._jumped = this._jumpKey = this._rightKey = this._leftKey = !1;
        this._lastFloorObject = null;
        this._loadFloorUid = -1;
        this._lastFloorY = this._lastFloorX = 0;
        this._wasOnFloor = this._floorIsJumpthru = !1;
        this._wasOverJumpthru = this._runtime.GetCollisionEngine().TestOverlapJumpthru(this._inst);
        this._loadJumpthruUid = -1;
        this._animMode = "stopped";
        this._fallThroughTime = -1;
        this._isFirstTick = !0;
        this._rightY = this._rightX = this._downY = this._downX = this._dy = this._dx = 0;
        this._g1 = this._g = 1500;
        this._ga = C3$jscomp$394.toRadians(90);
        this._maxSpeed = 330;
        this._dec = this._acc = 1500;
        this._jumpStrength = 650;
        this._maxFall = 1E3;
        this._enableDoubleJump = !1;
        this._sustainTime = this._jumpSustain = 0;
        this._defaultControls = !0;
        this._ceilingCollisionMode = 0;
        this._isEnabled = !0;
        b && (this._maxSpeed = b[0],
        this._acc = b[1],
        this._dec = b[2],
        this._jumpStrength = b[3],
        this._g = b[4],
        this._maxFall = b[5],
        this._enableDoubleJump = !!b[6],
        this._jumpSustain = b[7] / 1E3,
        this._defaultControls = !!b[8],
        this._isEnabled = !!b[9]);
        a = this._runtime.Dispatcher();
        this._disposables = new C3$jscomp$394.CompositeDisposable(C3$jscomp$394.Disposable.From(a, "instancedestroy", c => this._OnInstanceDestroyed(c.instance)),C3$jscomp$394.Disposable.From(a, "afterload", c => this._OnAfterLoad()));
        this._defaultControls && this._BindEvents();
        this._isEnabled && this._StartPostTicking();
        this._UpdateGravity()
    }
    Release() {
        this._keyboardDisposables && (this._keyboardDisposables.Release(),
        this._keyboardDisposables = null);
        this._wasOverJumpthru = this._lastFloorObject = null;
        super.Release()
    }
    _BindEvents() {
        if (!this._keyboardDisposables) {
            var a = this._runtime.Dispatcher();
            this._keyboardDisposables = new C3$jscomp$394.CompositeDisposable(C3$jscomp$394.Disposable.From(a, "keydown", b => this._OnKeyDown(b.data)),C3$jscomp$394.Disposable.From(a, "keyup", b => this._OnKeyUp(b.data)),C3$jscomp$394.Disposable.From(a, "window-blur", () => this._OnWindowOrKeyboardBlur()),C3$jscomp$394.Disposable.From(a, "keyboard-blur", () => this._OnWindowOrKeyboardBlur()))
        }
    }
    _UnBindEvents() {
        this._keyboardDisposables && (this._keyboardDisposables.Release(),
        this._keyboardDisposables = null)
    }
    _OnInstanceDestroyed(a) {
        this._lastFloorObject === a && (this._lastFloorObject = null);
        this._wasOverJumpthru === a && (this._wasOverJumpthru = null)
    }
    _OnKeyDown(a) {
        switch (a.key) {
        case "ArrowLeft":
            this._leftKey = !0;
            break;
        case "ArrowRight":
            this._rightKey = !0;
            break;
        case "ArrowUp":
            this._jumpKey = !0
        }
    }
    _OnKeyUp(a) {
        switch (a.key) {
        case "ArrowLeft":
            this._leftKey = !1;
            break;
        case "ArrowRight":
            this._rightKey = !1;
            break;
        case "ArrowUp":
            this._jumped = this._jumpKey = !1
        }
    }
    _OnWindowOrKeyboardBlur() {
        this._jumped = this._jumpKey = this._rightKey = this._leftKey = !1
    }
    SaveToJson() {
        return {
            ii: this._ignoreInput,
            lfx: this._lastFloorX,
            lfy: this._lastFloorY,
            lfo: this._lastFloorObject ? this._lastFloorObject.GetUID() : -1,
            am: this._animMode,
            en: this._isEnabled,
            fallt: this._fallThroughTime,
            ft: this._isFirstTick,
            dx: this._dx,
            dy: this._dy,
            ms: this._maxSpeed,
            acc: this._acc,
            dec: this._dec,
            js: this._jumpStrength,
            g: this._g,
            g1: this._g1,
            mf: this._maxFall,
            wof: this._wasOnFloor,
            woj: this._wasOverJumpthru ? this._wasOverJumpthru.GetUID() : -1,
            ga: this._ga,
            edj: this._enableDoubleJump,
            cdj: this._canDoubleJump,
            dj: this._doubleJumped,
            sus: this._jumpSustain,
            dc: this._defaultControls,
            cc: this._ceilingCollisionMode
        }
    }
    LoadFromJson(a) {
        this._ignoreInput = a.ii;
        this._lastFloorX = a.lfx;
        this._lastFloorY = a.lfy;
        this._loadFloorUid = a.lfo;
        this._animMode = a.am;
        const b = a.en;
        this._fallThroughTime = a.fallt || -1;
        this._isFirstTick = a.ft;
        this._dx = a.dx;
        this._dy = a.dy;
        this._maxSpeed = a.ms;
        this._acc = a.acc;
        this._dec = a.dec;
        this._jumpStrength = a.js;
        this._g = a.g;
        this._g1 = a.g1;
        this._maxFall = a.mf;
        this._wasOnFloor = a.wof;
        this._loadJumpthruUid = a.woj;
        this._ga = a.ga;
        this._enableDoubleJump = a.edj;
        this._canDoubleJump = a.cdj;
        this._doubleJumped = a.dj;
        this._jumpSustain = a.sus;
        this._defaultControls = a.dc;
        this._ceilingCollisionMode = a.cc || 0;
        this._simJump = this._simRight = this._simLeft = this._jumped = this._jumpKey = this._rightKey = this._leftKey = !1;
        this._sustainTime = 0;
        this._defaultControls ? this._BindEvents() : this._UnBindEvents();
        this._SetEnabled(b);
        this._UpdateGravity()
    }
    _OnAfterLoad() {
        this._lastFloorObject = -1 === this._loadFloorUid ? null : this._runtime.GetInstanceByUID(this._loadFloorUid);
        this._wasOverJumpthru = -1 === this._loadJumpthruUid ? null : this._runtime.GetInstanceByUID(this._loadJumpthruUid)
    }
    _SetLastFloorObject(a) {
        if (this._lastFloorObject = a)
            a = a.GetWorldInfo(),
            this._lastFloorX = a.GetX(),
            this._lastFloorY = a.GetY()
    }
    _IsFallThroughEnabled() {
        return this._runtime.GetGameTime() > this._fallThroughTime + .05
    }
    _UpdateGravity() {
        this._downX = Math.cos(this._ga);
        this._downY = Math.sin(this._ga);
        this._rightX = Math.cos(this._ga - Math.PI / 2);
        this._rightY = Math.sin(this._ga - Math.PI / 2);
        this._downX = C3$jscomp$394.roundToDp(this._downX, 6);
        this._downY = C3$jscomp$394.roundToDp(this._downY, 6);
        this._rightX = C3$jscomp$394.roundToDp(this._rightX, 6);
        this._rightY = C3$jscomp$394.roundToDp(this._rightY, 6);
        this._g1 = this._g;
        0 > this._g && (this._downX *= -1,
        this._downY *= -1,
        this._g = Math.abs(this._g))
    }
    _GetGDir() {
        return 0 > this._g ? -1 : 1
    }
    _IsOnFloor() {
        var a = this._inst.GetWorldInfo();
        const b = this._runtime.GetCollisionEngine()
          , c = this._inst;
        var d = this._lastFloorObject;
        const e = a.GetX()
          , f = a.GetY();
        a.OffsetXY(this._downX, this._downY);
        a.SetBboxChanged();
        if (!d || !b.TestOverlap(c, d) || d.GetObjectClass().HasSolidBehavior() && !b.IsSolidCollisionAllowed(d, c) || d.GetObjectClass().HasJumpthruBehavior() && !d._IsJumpthruEnabled()) {
            let h = b.TestOverlapSolid(c);
            d = null;
            !h && this._IsFallThroughEnabled() && (d = b.TestOverlapJumpthru(c, !0));
            a.SetXY(e, f);
            a.SetBboxChanged();
            if (h) {
                if (b.TestOverlap(c, h))
                    return null;
                this._floorIsJumpthru = !1;
                return h
            }
            if (d && d.length) {
                a = 0;
                for (let l = 0, m = d.length; l < m; ++l)
                    d[a] = d[l],
                    b.TestOverlap(c, d[l]) || ++a;
                if (1 <= a)
                    return this._floorIsJumpthru = !0,
                    d[0]
            }
            return null
        }
        a.SetXY(e, f);
        a.SetBboxChanged();
        return d
    }
    PostTick() {
        if (this._isEnabled) {
            var a = this._runtime.GetDt(this._inst);
            this._jumpKey || this._simJump || (this._jumped = !1);
            var b = this._leftKey || this._simLeft
              , c = this._rightKey || this._simRight
              , d = this._jumpKey || this._simJump
              , e = d && !this._jumped;
            this._simJump = this._simRight = this._simLeft = !1;
            this._ignoreInput && (e = d = c = b = !1);
            d || (this._sustainTime = 0);
            this._HandleFirstTick();
            var [f,,h] = this._TrackMovingPlatform()
              , l = this._IsOnFloor()
              , m = l && !this._wasOnFloor;
            [p,l] = this._MaybePushOutSolid(l);
            if (!p) {
                this._TrackFloor(l, h, f, d);
                e = this._HandleJump(l, e, d);
                l || this._HandleAirTime(e, d, a);
                this._wasOnFloor = !!l;
                d = this._CalculateHorizontalAcceleration(b, c);
                var p = !1;
                var r = 0;
                0 !== this._dx && ([p,l] = this._HandleHorizontalMovement(a, d, l, e));
                if (0 !== this._dy) {
                    const [v,x] = this._HandleVerticalMovement(a, l);
                    p = p || v;
                    r = x
                }
                !p && m && 0 > this._dy && 0 < r && (this._dy = 0,
                p = !0);
                this._ApplyHorizontalAcceleration(b, c, d, a);
                l && !e || p || (this._dy = Math.min(this._dy + this._g * a, this._maxFall));
                this._HandleAnimationTriggers(l, p, e);
                this._wasOverJumpthru = this._runtime.GetCollisionEngine().TestOverlapJumpthru(this._inst)
            }
        }
    }
    _HandleFirstTick() {
        if (this._isFirstTick) {
            var a = this._inst
              , b = this._runtime.GetCollisionEngine();
            (b.TestOverlapSolid(a) || b.TestOverlapJumpthru(a)) && b.PushOutSolid(a, -this._downX, -this._downY, 4, !0);
            this._isFirstTick = !1
        }
    }
    _TrackMovingPlatform() {
        var a = this._lastFloorObject
          , b = a ? a.GetWorldInfo() : null;
        let c = 0
          , d = 0;
        var e = !1;
        if (a && 0 === this._dy && (b.GetY() !== this._lastFloorY || b.GetX() !== this._lastFloorX)) {
            a = this._inst;
            e = a.GetWorldInfo();
            const f = this._runtime.GetCollisionEngine()
              , h = b.GetX();
            b = b.GetY();
            c = h - this._lastFloorX;
            d = b - this._lastFloorY;
            e.OffsetXY(c, d);
            e.SetBboxChanged();
            this._lastFloorX = h;
            this._lastFloorY = b;
            e = !0;
            if (b = f.TestOverlapSolid(a))
                f.RegisterCollision(a, b),
                f.PushOutSolid(a, -c, -d, 2.5 * Math.hypot(c, d))
        }
        return [c, d, e]
    }
    _MaybePushOutSolid(a) {
        let b = !1;
        const c = this._inst;
        var d = c.GetWorldInfo();
        const e = this._runtime.GetCollisionEngine()
          , f = e.TestOverlapSolid(c);
        if (!f)
            return [!1, a];
        const h = Math.abs(d.GetWidth());
        d = Math.abs(d.GetHeight());
        e.PushOutSolid(c, -this._downX, -this._downY, d / 8) ? (e.RegisterCollision(c, f),
        a = f,
        this._SetLastFloorObject(f),
        this._floorIsJumpthru = !1,
        this._dy = 0) : e.PushOutSolidAxis(c, this._rightX, this._rightY, h / 2) || e.PushOutSolidAxis(c, this._downX, this._downY, d / 2) || e.PushOutSolidNearest(c, Math.max(h, d) / 2) ? e.RegisterCollision(c, f) : b = !0;
        return [b, a]
    }
    _TrackFloor(a, b, c, d) {
        const e = this._inst
          , f = this._runtime.GetCollisionEngine();
        if (a) {
            d = this._downX;
            const h = this._downY
              , l = this._rightX
              , m = this._rightY;
            this._canDoubleJump = this._doubleJumped = !1;
            0 < this._dy && (this._wasOnFloor || (f.PushInFractional(e, -d, -h, a, 16),
            this._wasOnFloor = !0),
            this._dy = 0);
            this._lastFloorObject !== a ? (this._SetLastFloorObject(a),
            f.RegisterCollision(e, a)) : b && (a = f.TestOverlapSolid(e)) && (f.RegisterCollision(e, a),
            0 !== c && (0 < c ? f.PushOutSolid(e, -l, -m) : f.PushOutSolid(e, l, m)),
            f.PushOutSolid(e, -d, -h))
        } else
            d || (this._canDoubleJump = !0)
    }
    _HandleJump(a, b, c) {
        if (a && b || !a && this._enableDoubleJump && c && this._canDoubleJump && !this._doubleJumped) {
            b = this._inst;
            c = b.GetWorldInfo();
            const d = this._runtime.GetCollisionEngine()
              , e = c.GetX()
              , f = c.GetY();
            c.OffsetXY(-this._downX, -this._downY);
            c.SetBboxChanged();
            d.TestOverlapSolid(b) ? b = !1 : (this._sustainTime = this._jumpSustain,
            this.Trigger(C3$jscomp$394.Behaviors.Platform.Cnds.OnJump),
            this._animMode = "jumping",
            this._dy = -this._jumpStrength,
            b = !0,
            a ? this._jumped = !0 : this._doubleJumped = !0);
            c.SetXY(e, f);
            c.SetBboxChanged()
        }
        return b
    }
    _HandleAirTime(a, b, c) {
        b && 0 < this._sustainTime ? (this._dy = -this._jumpStrength,
        this._sustainTime -= c) : this._lastFloorObject = null;
        a && (this._jumped = !0)
    }
    _CalculateHorizontalAcceleration(a, b) {
        let c = 0;
        const d = this._acc
          , e = this._dec;
        a && !b && (c = 0 < this._dx ? -(d + e) : -d);
        b && !a && (c = 0 > this._dx ? d + e : d);
        return c
    }
    _ApplyHorizontalAcceleration(a, b, c, d) {
        const e = this._dec;
        a === b && (0 > this._dx ? this._dx = Math.min(this._dx + e * d, 0) : 0 < this._dx && (this._dx = Math.max(this._dx - e * d, 0)));
        this._dx = C3$jscomp$394.clamp(this._dx + c * d, -this._maxSpeed, this._maxSpeed);
        a = this._runtime.GetCollisionEngine();
        if (b = 0 > this._dx ? this._GetWallObstacle(0, 1, 1) : null)
            this._dx = 0,
            a.RegisterCollision(this._inst, b);
        else if (b = 0 < this._dx ? this._GetWallObstacle(1, 1, 1) : null)
            this._dx = 0,
            a.RegisterCollision(this._inst, b)
    }
    _HandleHorizontalMovement(a, b, c, d) {
        const e = this._inst
          , f = e.GetWorldInfo()
          , h = this._runtime.GetCollisionEngine()
          , l = this._downX
          , m = this._downY;
        var p = this._rightX;
        const r = this._rightY;
        var v = this._maxSpeed;
        let x = !1;
        var B = new Set(h.TestOverlapJumpthru(e, !0))
          , A = f.GetX();
        let D = f.GetY();
        var F = accelerate(this._dx, -v, v, b, a) * p;
        const I = accelerate(this._dx, -v, v, b, a) * r;
        f.OffsetXY(p * (1 < this._dx ? 1 : -1) - l, r * (1 < this._dx ? 1 : -1) - m);
        f.SetBboxChanged();
        b = !1;
        v = h.TestOverlapSolid(e);
        f.SetXY(A + F, D + I);
        f.SetBboxChanged();
        F = h.TestOverlapSolid(e);
        !F && c && this._floorIsJumpthru && (F = h.TestOverlapJumpthru(e),
        B.has(F) ? F = null : b = !0);
        F ? (B = Math.abs(this._dx * a) + 2,
        v || !h.PushOutSolid(e, -l, -m, B, b, F)) ? (h.RegisterCollision(e, F),
        B = Math.max(Math.abs(this._dx * a * 2.5), Math.floor(f.GetWidth())),
        h.PushOutSolid(e, p * (0 > this._dx ? 1 : -1), r * (0 > this._dx ? 1 : -1), B, !1) ? !c || b || this._floorIsJumpthru || (A = f.GetX(),
        D = f.GetY(),
        f.OffsetXY(l, m),
        h.TestOverlapSolid(e) ? h.PushOutSolid(e, -l, -m, 3, !1) || (f.SetXY(A, D),
        f.SetBboxChanged()) : (f.SetXY(A, D),
        f.SetBboxChanged())) : (f.SetXY(A, D),
        f.SetBboxChanged()),
        b || (this._dx = 0)) : !v && !d && Math.abs(this._dy) < Math.abs(this._jumpStrength / 4) && (this._dy = 0,
        c || (x = !0)) : (A = this._IsOnFloor(),
        c && !A ? (a = Math.ceil(Math.abs(this._dx * a)) + 2,
        A = f.GetX(),
        D = f.GetY(),
        f.OffsetXY(l * a, m * a),
        f.SetBboxChanged(),
        d = h.TestOverlapJumpthru(e),
        p = !1,
        d && !B.has(d) && h.PushOutSolid(e, -l, -m, a + 2, !0, d) && (c = d,
        this._SetLastFloorObject(d),
        p = this._floorIsJumpthru = !0),
        p || (h.TestOverlapSolid(e) ? h.PushOutSolid(e, -l, -m, a + 2, !1) : (f.SetXY(A, D),
        f.SetBboxChanged()))) : A && (!c && this._floorIsJumpthru && (this._SetLastFloorObject(A),
        this._dy = 0,
        x = !0),
        0 === this._dy && h.PushInFractional(e, -l, -m, A, 16)));
        return [x, c]
    }
    _HandleVerticalMovement(a, b) {
        const c = this._inst
          , d = c.GetWorldInfo()
          , e = this._runtime.GetCollisionEngine()
          , f = this._downX
          , h = this._downY;
        let l = !1
          , m = d.GetX()
          , p = d.GetY();
        const r = accelerate(this._dy, -Infinity, this._maxFall, this._g, a);
        d.OffsetXY(r * f, r * h);
        var v = d.GetX();
        const x = d.GetY();
        d.SetBboxChanged();
        let B = e.TestOverlapSolid(c);
        var A = !1;
        if (!B && 0 < this._dy && !b) {
            if ((A = this._IsFallThroughEnabled() ? e.TestOverlapJumpthru(c, !0) : null) && A.length) {
                if (this._wasOverJumpthru) {
                    d.SetXY(m, p);
                    d.SetBboxChanged();
                    b = 0;
                    for (let D = 0, F = A.length; D < F; ++D)
                        A[b] = A[D],
                        e.TestOverlap(c, A[D]) || ++b;
                    C3$jscomp$394.truncateArray(A, b);
                    d.SetXY(v, x);
                    d.SetBboxChanged()
                }
                1 <= A.length && (B = A[0])
            }
            A = !!B
        }
        if (B)
            if (e.RegisterCollision(c, B),
            this._sustainTime = 0,
            v = 1.1,
            A && !this._wasOverJumpthru && (v = 2),
            e.PushOutSolid(c, f * (0 > this._dy ? 1 : -1), h * (0 > this._dy ? 1 : -1), Math.max(Math.abs(this._dy * a * v), 2), A, B)) {
                this._SetLastFloorObject(B);
                this._floorIsJumpthru = A;
                0 < this._dy && (l = !0);
                if (0 < this._dy || 0 === this._ceilingCollisionMode)
                    this._dy = 0;
                0 > this._dy && 1 === this._ceilingCollisionMode && e.PushInFractional(c, f, h, B, 32)
            } else
                d.SetXY(m, p),
                d.SetBboxChanged(),
                this._wasOnFloor = !0,
                A || (this._dy = 0);
        return [l, r]
    }
    _HandleAnimationTriggers(a, b, c) {
        "falling" !== this._animMode && 0 < this._dy && !a && (this.Trigger(C3$jscomp$394.Behaviors.Platform.Cnds.OnFall),
        this._animMode = "falling");
        (a || b) && 0 <= this._dy && ("falling" === this._animMode || b || c && 0 === this._dy ? (this.Trigger(C3$jscomp$394.Behaviors.Platform.Cnds.OnLand),
        this._animMode = 0 === this._dx && 0 === this._dy ? "stopped" : "moving") : ("stopped" !== this._animMode && 0 === this._dx && 0 === this._dy && (this.Trigger(C3$jscomp$394.Behaviors.Platform.Cnds.OnStop),
        this._animMode = "stopped"),
        "moving" === this._animMode || 0 === this._dx && 0 === this._dy || c || (this.Trigger(C3$jscomp$394.Behaviors.Platform.Cnds.OnMove),
        this._animMode = "moving")))
    }
    _IsMoving() {
        return 0 !== this._GetVectorX() || 0 !== this._GetVectorY()
    }
    _CheckIfStandingOnFloor() {
        if (0 !== this._dy)
            return !1;
        const a = this._inst;
        var b = this.GetWorldInfo();
        const c = this._runtime.GetCollisionEngine()
          , d = b.GetX()
          , e = b.GetY();
        b.OffsetXY(this._downX, this._downY);
        b.SetBboxChanged();
        const f = c.TestOverlapSolid(a);
        let h = null;
        !f && this._IsFallThroughEnabled() && (h = c.TestOverlapJumpthru(a, !0));
        b.SetXY(d, e);
        b.SetBboxChanged();
        if (f)
            return !c.TestOverlap(a, f);
        if (h && h.length) {
            b = 0;
            for (let l = 0, m = h.length; l < m; ++l)
                h[b] = h[l],
                c.TestOverlap(a, h[l]) || b++;
            if (1 <= b)
                return !0
        }
        return !1
    }
    _IsByWall(a, b=2, c=3) {
        return !!this._GetWallObstacle(a, b, c)
    }
    _GetWallObstacle(a, b=2, c=3) {
        const d = this._inst
          , e = this.GetWorldInfo()
          , f = this._runtime.GetCollisionEngine()
          , h = e.GetX()
          , l = e.GetY();
        0 === a ? e.OffsetXY(-this._rightX * b, -this._rightY * b) : e.OffsetXY(this._rightX * b, this._rightY * b);
        e.SetBboxChanged();
        if (!f.TestOverlapSolid(d))
            return e.SetXY(h, l),
            e.SetBboxChanged(),
            null;
        e.OffsetXY(-this._downX * c, -this._downY * c);
        e.SetBboxChanged();
        a = f.TestOverlapSolid(d);
        e.SetXY(h, l);
        e.SetBboxChanged();
        return a
    }
    _FallThroughJumpThru() {
        const a = this.GetWorldInfo()
          , b = a.GetX()
          , c = a.GetY();
        a.OffsetXY(this._downX, this._downY);
        a.SetBboxChanged();
        const d = this._runtime.GetCollisionEngine().TestOverlapJumpthru(this._inst, !1);
        a.SetXY(b, c);
        a.SetBboxChanged();
        d && (this._fallThroughTime = this._runtime.GetGameTime(),
        this._lastFloorObject = null)
    }
    _ResetDoubleJump(a) {
        this._doubleJumped = !a
    }
    _GetSpeed() {
        return Math.hypot(this._dx, this._dy)
    }
    _GetMovingAngle() {
        return Math.atan2(this._dy, this._dx)
    }
    _IsJumping() {
        return 0 > this._dy
    }
    _IsFalling() {
        return 0 < this._dy
    }
    _SetMaxSpeed(a) {
        this._maxSpeed = Math.max(a, 0)
    }
    _GetMaxSpeed() {
        return this._maxSpeed
    }
    _SetAcceleration(a) {
        this._acc = Math.max(a, 0)
    }
    _GetAcceleration() {
        return this._acc
    }
    _SetDeceleration(a) {
        this._dec = Math.max(a, 0)
    }
    _GetDeceleration() {
        return this._dec
    }
    _SetJumpStrength(a) {
        this._jumpStrength = Math.max(a, 0)
    }
    _GetJumpStrength() {
        return this._jumpStrength
    }
    _SetMaxFallSpeed(a) {
        this._maxFall = Math.max(a, 0)
    }
    _GetMaxFallSpeed() {
        return this._maxFall
    }
    _SetGravity(a) {
        if (this._g1 !== a) {
            this._g = a;
            this._UpdateGravity();
            a = this._runtime.GetCollisionEngine();
            var b = this.GetWorldInfo();
            a.TestOverlapSolid(this._inst) && (a.PushOutSolid(this._inst, this._downX, this._downY, 10),
            b.OffsetXY(2 * this._downX, 2 * this._downY),
            b.SetBboxChanged());
            this._lastFloorObject = null
        }
    }
    _GetGravity() {
        return this._g
    }
    _SetGravityAngle(a) {
        a = C3$jscomp$394.clampAngle(a);
        this._ga !== a && (this._ga = a,
        this._UpdateGravity(),
        this._lastFloorObject = null)
    }
    _GetGravityAngle() {
        return this._ga
    }
    _SetDoubleJumpEnabled(a) {
        this._enableDoubleJump = !!a
    }
    _IsDoubleJumpEnabled() {
        return this._enableDoubleJump
    }
    _SetJumpSustain(a) {
        this._jumpSustain = a
    }
    _GetJumpSustain() {
        return this._jumpSustain
    }
    _SetCeilingCollisionMode(a) {
        this._ceilingCollisionMode = a
    }
    _GetCeilingCollisionMode() {
        return this._ceilingCollisionMode
    }
    _SetVectorX(a) {
        this._dx = a
    }
    _GetVectorX() {
        return this._dx
    }
    _SetVectorY(a) {
        this._dy = a
    }
    _GetVectorY() {
        return this._dy
    }
    _SimulateControl(a) {
        if (this._isEnabled)
            switch (a) {
            case 0:
                this._simLeft = !0;
                break;
            case 1:
                this._simRight = !0;
                break;
            case 2:
                this._simJump = !0
            }
    }
    _SetDefaultControls(a) {
        a = !!a;
        this._defaultControls !== a && ((this._defaultControls = a) ? this._BindEvents() : (this._UnBindEvents(),
        this._OnWindowOrKeyboardBlur()))
    }
    _IsDefaultControls() {
        return this._defaultControls
    }
    _SetIgnoreInput(a) {
        this._ignoreInput = !!a
    }
    _IsIgnoreInput() {
        return this._ignoreInput
    }
    _SetEnabled(a) {
        a = !!a;
        this._isEnabled !== a && ((this._isEnabled = a) ? this._StartPostTicking() : (this._StopPostTicking(),
        this._lastFloorObject = null,
        this._simJump = this._simRight = this._simLeft = !1))
    }
    _IsEnabled() {
        return this._isEnabled
    }
    GetPropertyValueByIndex(a) {
        switch (a) {
        case 0:
            return this._GetMaxSpeed();
        case 1:
            return this._GetAcceleration();
        case 2:
            return this._GetDeceleration();
        case 3:
            return this._GetJumpStrength();
        case 4:
            return this._GetGravity();
        case 5:
            return this._GetMaxFallSpeed();
        case 6:
            return this._IsDoubleJumpEnabled();
        case 7:
            return 1E3 * this._GetJumpSustain();
        case 8:
            return this._IsDefaultControls();
        case 9:
            return this._IsEnabled()
        }
    }
    SetPropertyValueByIndex(a, b) {
        switch (a) {
        case 0:
            this._SetMaxSpeed(b);
            break;
        case 1:
            this._SetAcceleration(b);
            break;
        case 2:
            this._SetDeceleration(b);
            break;
        case 3:
            this._SetJumpStrength(b);
            break;
        case 4:
            this._SetGravity(b);
            break;
        case 5:
            this._SetMaxFallSpeed(b);
            break;
        case 6:
            this._SetDoubleJumpEnabled(!!b);
            break;
        case 7:
            this._SetJumpSustain(b / 1E3);
            break;
        case 8:
            this._SetDefaultControls(!!b);
            break;
        case 9:
            this._SetEnabled(!!b)
        }
    }
    GetDebuggerProperties() {
        return [{
            title: "$" + this.GetBehaviorType().GetName(),
            properties: [{
                name: "behaviors.platform.debugger.vector-x",
                value: this._GetVectorX(),
                onedit: a => this._SetVectorX(a)
            }, {
                name: "behaviors.platform.debugger.vector-y",
                value: this._GetVectorY(),
                onedit: a => this._SetVectorY(a)
            }, {
                name: "behaviors.platform.properties.max-speed.name",
                value: this._GetMaxSpeed(),
                onedit: a => this._SetMaxSpeed(a)
            }, {
                name: "behaviors.platform.properties.acceleration.name",
                value: this._GetAcceleration(),
                onedit: a => this._SetAcceleration(a)
            }, {
                name: "behaviors.platform.properties.deceleration.name",
                value: this._GetDeceleration(),
                onedit: a => this._SetDeceleration(a)
            }, {
                name: "behaviors.platform.properties.jump-strength.name",
                value: this._GetJumpStrength(),
                onedit: a => this._SetJumpStrength(a)
            }, {
                name: "behaviors.platform.properties.gravity.name",
                value: this._GetGravity(),
                onedit: a => this._SetGravity(a)
            }, {
                name: "behaviors.platform.debugger.gravity-angle",
                value: C3$jscomp$394.toDegrees(this._GetGravityAngle()),
                onedit: a => this._SetGravityAngle(C3$jscomp$394.toRadians(a))
            }, {
                name: "behaviors.platform.properties.max-fall-speed.name",
                value: this._GetMaxFallSpeed(),
                onedit: a => this._SetMaxFallSpeed(a)
            }, {
                name: "behaviors.platform.properties.double-jump.name",
                value: this._IsDoubleJumpEnabled(),
                onedit: a => this._SetDoubleJumpEnabled(a)
            }, {
                name: "behaviors.platform.properties.jump-sustain.name",
                value: 1E3 * this._GetJumpSustain(),
                onedit: a => this._SetJumpSustain(a / 1E3)
            }, {
                name: "behaviors.platform.debugger.animation-mode",
                value: ["behaviors.platform.debugger.anim-" + this._animMode]
            }, {
                name: "behaviors.platform.properties.enabled.name",
                value: this._IsEnabled(),
                onedit: a => this._SetEnabled(a)
            }]
        }]
    }
    GetScriptInterfaceClass() {
        return self.IPlatformBehaviorInstance
    }
}
;
const map$jscomp$48 = new WeakMap
  , SIMULATE_CONTROL_MAP = new Map([["left", 0], ["right", 1], ["jump", 2]]);
self.IPlatformBehaviorInstance = class extends IBehaviorInstance$jscomp$11 {
    constructor() {
        super();
        map$jscomp$48.set(this, IBehaviorInstance$jscomp$11._GetInitInst().GetSdkInstance())
    }
    fallThrough() {
        map$jscomp$48.get(this)._FallThroughJumpThru()
    }
    resetDoubleJump(a) {
        map$jscomp$48.get(this)._ResetDoubleJump(!!a)
    }
    simulateControl(a) {
        C3X$jscomp$58.RequireString(a);
        a = SIMULATE_CONTROL_MAP.get(a);
        if ("number" !== typeof a)
            throw Error("invalid control");
        map$jscomp$48.get(this)._SimulateControl(a)
    }
    get speed() {
        return map$jscomp$48.get(this)._GetSpeed()
    }
    get maxSpeed() {
        return map$jscomp$48.get(this)._GetMaxSpeed()
    }
    set maxSpeed(a) {
        C3X$jscomp$58.RequireFiniteNumber(a);
        map$jscomp$48.get(this)._SetMaxSpeed(a)
    }
    get acceleration() {
        return map$jscomp$48.get(this)._GetAcceleration()
    }
    set acceleration(a) {
        C3X$jscomp$58.RequireFiniteNumber(a);
        map$jscomp$48.get(this)._SetAcceleration(a)
    }
    get deceleration() {
        return map$jscomp$48.get(this)._GetDeceleration()
    }
    set deceleration(a) {
        C3X$jscomp$58.RequireFiniteNumber(a);
        map$jscomp$48.get(this)._SetDeceleration(a)
    }
    get jumpStrength() {
        return map$jscomp$48.get(this)._GetJumpStrength()
    }
    set jumpStrength(a) {
        C3X$jscomp$58.RequireFiniteNumber(a);
        map$jscomp$48.get(this)._SetJumpStrength(a)
    }
    get maxFallSpeed() {
        return map$jscomp$48.get(this)._GetMaxFallSpeed()
    }
    set maxFallSpeed(a) {
        C3X$jscomp$58.RequireFiniteNumber(a);
        map$jscomp$48.get(this)._SetMaxFallSpeed(a)
    }
    get gravity() {
        return map$jscomp$48.get(this)._GetGravity()
    }
    set gravity(a) {
        C3X$jscomp$58.RequireFiniteNumber(a);
        map$jscomp$48.get(this)._SetGravity(a)
    }
    get gravityAngle() {
        return map$jscomp$48.get(this)._GetGravityAngle()
    }
    set gravityAngle(a) {
        C3X$jscomp$58.RequireFiniteNumber(a);
        map$jscomp$48.get(this)._SetGravityAngle(a)
    }
    get isDoubleJumpEnabled() {
        return map$jscomp$48.get(this)._IsDoubleJumpEnabled()
    }
    set isDoubleJumpEnabled(a) {
        map$jscomp$48.get(this)._SetDoubleJumpEnabled(!!a)
    }
    get jumpSustain() {
        return map$jscomp$48.get(this)._GetJumpSustain()
    }
    set jumpSustain(a) {
        C3X$jscomp$58.RequireFiniteNumber(a);
        map$jscomp$48.get(this)._SetJumpSustain(a)
    }
    get ceilingCollisionMode() {
        return 0 === map$jscomp$48.get(this)._GetCeilingCollisionMode() ? "stop" : "preserve-momentum"
    }
    set ceilingCollisionMode(a) {
        C3X$jscomp$58.RequireString(a);
        const b = map$jscomp$48.get(this);
        if ("stop" === a)
            b._SetCeilingCollisionMode(0);
        else if ("preserve-momentum" === a)
            b._SetCeilingCollisionMode(1);
        else
            throw Error("invalid mode");
    }
    get isOnFloor() {
        return map$jscomp$48.get(this)._CheckIfStandingOnFloor()
    }
    isByWall(a) {
        C3X$jscomp$58.RequireString(a);
        const b = map$jscomp$48.get(this);
        if ("left" === a)
            return b._IsByWall(0);
        if ("right" === a)
            return b._IsByWall(1);
        throw Error("invalid side");
    }
    get isMoving() {
        return map$jscomp$48.get(this)._IsMoving()
    }
    get isJumping() {
        return map$jscomp$48.get(this)._IsJumping()
    }
    get isFalling() {
        return map$jscomp$48.get(this)._IsFalling()
    }
    get vectorX() {
        return map$jscomp$48.get(this)._GetVectorX()
    }
    set vectorX(a) {
        C3X$jscomp$58.RequireFiniteNumber(a);
        map$jscomp$48.get(this)._SetVectorX(a)
    }
    get vectorY() {
        return map$jscomp$48.get(this)._GetVectorY()
    }
    set vectorY(a) {
        C3X$jscomp$58.RequireFiniteNumber(a);
        map$jscomp$48.get(this)._SetVectorY(a)
    }
    setVector(a, b) {
        C3X$jscomp$58.RequireFiniteNumber(a);
        C3X$jscomp$58.RequireFiniteNumber(b);
        const c = map$jscomp$48.get(this);
        c._SetVectorX(a);
        c._SetVectorY(b)
    }
    getVector() {
        const a = map$jscomp$48.get(this);
        return [a._GetVectorX(), a._GetVectorY()]
    }
    get isDefaultControls() {
        return map$jscomp$48.get(this)._IsDefaultControls()
    }
    set isDefaultControls(a) {
        map$jscomp$48.get(this)._SetDefaultControls(!!a)
    }
    get isIgnoringInput() {
        return map$jscomp$48.get(this)._IsIgnoreInput()
    }
    set isIgnoringInput(a) {
        map$jscomp$48.get(this)._SetIgnoreInput(!!a)
    }
    get isEnabled() {
        return map$jscomp$48.get(this)._IsEnabled()
    }
    set isEnabled(a) {
        map$jscomp$48.get(this)._SetEnabled(!!a)
    }
}
;
const C3$jscomp$395 = self.C3;
C3$jscomp$395.Behaviors.Platform.Cnds = {
    IsMoving() {
        return this._IsMoving()
    },
    CompareSpeed(a, b) {
        return C3$jscomp$395.compare(this._GetSpeed(), a, b)
    },
    IsOnFloor() {
        return this._CheckIfStandingOnFloor()
    },
    IsByWall(a) {
        return this._IsByWall(a)
    },
    IsJumping() {
        return this._IsJumping()
    },
    IsFalling() {
        return this._IsFalling()
    },
    IsDoubleJumpEnabled() {
        return this._IsDoubleJumpEnabled()
    },
    OnJump() {
        return !0
    },
    OnFall() {
        return !0
    },
    OnStop() {
        return !0
    },
    OnMove() {
        return !0
    },
    OnLand() {
        return !0
    },
    IsEnabled() {
        return this._IsEnabled()
    }
};
const C3$jscomp$396 = self.C3;
C3$jscomp$396.Behaviors.Platform.Acts = {
    SetMaxSpeed(a) {
        this._SetMaxSpeed(a)
    },
    SetAcceleration(a) {
        this._SetAcceleration(a)
    },
    SetDeceleration(a) {
        this._SetDeceleration(a)
    },
    SetJumpStrength(a) {
        this._SetJumpStrength(a)
    },
    SetMaxFallSpeed(a) {
        this._SetMaxFallSpeed(a)
    },
    SetGravity(a) {
        this._SetGravity(a)
    },
    SimulateControl(a) {
        this._SimulateControl(a)
    },
    SetIgnoreInput(a) {
        this._SetIgnoreInput(!!a)
    },
    SetVectorX(a) {
        this._SetVectorX(a)
    },
    SetVectorY(a) {
        this._SetVectorY(a)
    },
    SetGravityAngle(a) {
        this._SetGravityAngle(C3$jscomp$396.toRadians(a))
    },
    SetEnabled(a) {
        this._SetEnabled(0 !== a)
    },
    FallThrough() {
        this._FallThroughJumpThru()
    },
    SetDoubleJumpEnabled(a) {
        this._SetDoubleJumpEnabled(0 !== a)
    },
    SetJumpSustain(a) {
        this._SetJumpSustain(a / 1E3)
    },
    SetCeilingCollision(a) {
        this._SetCeilingCollisionMode(a)
    },
    SetDefaultControls(a) {
        this._SetDefaultControls(a)
    },
    ResetDoubleJump(a) {
        this._ResetDoubleJump(a)
    }
};
const C3$jscomp$397 = self.C3;
C3$jscomp$397.Behaviors.Platform.Exps = {
    Speed() {
        return this._GetSpeed()
    },
    MaxSpeed() {
        return this._GetMaxSpeed()
    },
    Acceleration() {
        return this._GetAcceleration()
    },
    Deceleration() {
        return this._GetDeceleration()
    },
    JumpStrength() {
        return this._GetJumpStrength()
    },
    Gravity() {
        return this._GetGravity()
    },
    GravityAngle() {
        return C3$jscomp$397.toDegrees(this._GetGravityAngle())
    },
    MaxFallSpeed() {
        return this._GetMaxFallSpeed()
    },
    MovingAngle() {
        return C3$jscomp$397.toDegrees(this._GetMovingAngle())
    },
    VectorX() {
        return this._GetVectorX()
    },
    VectorY() {
        return this._GetVectorY()
    },
    JumpSustain() {
        return 1E3 * this._GetJumpSustain()
    }
};
const C3$jscomp$398 = self.C3;
self.C3_GetObjectRefTable = function() {
    return [C3$jscomp$398.Plugins.Keyboard, C3$jscomp$398.Plugins.Touch, C3$jscomp$398.Plugins.Mouse, C3$jscomp$398.Plugins.Audio, C3$jscomp$398.Plugins.Browser, C3$jscomp$398.Plugins.AJAX, C3$jscomp$398.Plugins.PlatformInfo, C3$jscomp$398.Plugins.Timeline, C3$jscomp$398.Plugins.AdvancedRandom, C3$jscomp$398.Plugins.Eponesh_GameScore, C3$jscomp$398.Plugins.Arr, C3$jscomp$398.Plugins.Json, C3$jscomp$398.Plugins.Gritsenko_Spine, C3$jscomp$398.Plugins.Sprite, C3$jscomp$398.Behaviors.Tween, C3$jscomp$398.Plugins.TiledBg, C3$jscomp$398.Plugins.NinePatch, C3$jscomp$398.Plugins.Particles, C3$jscomp$398.Behaviors.Rotate, C3$jscomp$398.Behaviors.Bullet, C3$jscomp$398.Behaviors.Fade, C3$jscomp$398.Behaviors.Flash, C3$jscomp$398.Behaviors.LOS, C3$jscomp$398.Behaviors.Sin, C3$jscomp$398.Plugins.SVGPicture, C3$jscomp$398.Behaviors.solid, C3$jscomp$398.Behaviors.Timer, C3$jscomp$398.Behaviors.Platform, C3$jscomp$398.Plugins.Spritefont2, C3$jscomp$398.Plugins.DrawingCanvas, C3$jscomp$398.Plugins.System.Cnds.OnLayoutStart, C3$jscomp$398.Behaviors.Tween.Acts.StopAllTweens, C3$jscomp$398.Behaviors.Timer.Acts.StartTimer, C3$jscomp$398.Plugins.Json.Exps.Get, C3$jscomp$398.Plugins.AdvancedRandom.Acts.CreateProbabilityTableFromJSON, C3$jscomp$398.Plugins.Json.Acts.SetValue, C3$jscomp$398.Plugins.Sprite.Acts.Destroy, C3$jscomp$398.Plugins.System.Acts.SetLayerOpacity, C3$jscomp$398.Plugins.TiledBg.Acts.SetOpacity, C3$jscomp$398.Plugins.System.Acts.SetObjectTimescale, C3$jscomp$398.Plugins.System.Cnds.LayerNameExists, C3$jscomp$398.Plugins.System.Acts.RemoveLayer, C3$jscomp$398.Plugins.Json.Cnds.CompareValue, C3$jscomp$398.Plugins.System.Acts.SetGroupActive, C3$jscomp$398.Plugins.Sprite.Acts.SetAnimFrame, C3$jscomp$398.Plugins.System.Exps.int, C3$jscomp$398.Plugins.Json.Exps.ArraySize, C3$jscomp$398.Plugins.System.Acts.SetTimescale, C3$jscomp$398.Plugins.Spritefont2.Cnds.CompareInstanceVar, C3$jscomp$398.Plugins.Spritefont2.Acts.Destroy, C3$jscomp$398.Plugins.Sprite.Cnds.CompareInstanceVar, C3$jscomp$398.Plugins.NinePatch.Acts.SetX, C3$jscomp$398.Plugins.NinePatch.Exps.X, C3$jscomp$398.Plugins.NinePatch.Acts.SetWidth, C3$jscomp$398.Plugins.NinePatch.Exps.Width, C3$jscomp$398.Plugins.Sprite.Acts.SetX, C3$jscomp$398.Plugins.Sprite.Exps.X, C3$jscomp$398.Behaviors.solid.Acts.SetEnabled, C3$jscomp$398.Plugins.PlatformInfo.Cnds.IsOnAndroid, C3$jscomp$398.Plugins.System.Acts.SetCollisionCellSize, C3$jscomp$398.Plugins.System.Cnds.Compare, C3$jscomp$398.Plugins.System.Exps.layoutname, C3$jscomp$398.Plugins.Timeline.Acts.StopAllTimelines, C3$jscomp$398.Plugins.System.Acts.SetLayerVisible, C3$jscomp$398.Plugins.System.Acts.SetLayerInteractive, C3$jscomp$398.Plugins.System.Acts.SetLayerBackground, C3$jscomp$398.Plugins.System.Exps.rgbex255, C3$jscomp$398.Plugins.System.Acts.SetLayerTransparent, C3$jscomp$398.Plugins.System.Acts.CreateObject, C3$jscomp$398.Plugins.Sprite.Acts.SetOpacity, C3$jscomp$398.Plugins.System.Acts.AddLayer, C3$jscomp$398.Plugins.System.Cnds.IsGroupActive, C3$jscomp$398.Plugins.System.Cnds.Else, C3$jscomp$398.Plugins.Particles.Acts.Destroy, C3$jscomp$398.Plugins.Particles.Acts.FastForward, C3$jscomp$398.Plugins.Sprite.Cnds.IsOnLayer, C3$jscomp$398.Plugins.PlatformInfo.Cnds.IsOniOS, C3$jscomp$398.Plugins.Spritefont2.Acts.SetText, C3$jscomp$398.Plugins.Sprite.Cnds.OnCreated, C3$jscomp$398.Plugins.System.Acts.Wait, C3$jscomp$398.Plugins.System.Exps.dt, C3$jscomp$398.Plugins.Sprite.Acts.SetVisible, C3$jscomp$398.Plugins.System.Cnds.OnLayoutEnd, C3$jscomp$398.Plugins.Json.Acts.DeleteKey, C3$jscomp$398.Plugins.System.Acts.RestoreObjectTimescale, C3$jscomp$398.Plugins.Audio.Acts.Stop, C3$jscomp$398.Plugins.Audio.Acts.StopAll, C3$jscomp$398.Behaviors.Timer.Acts.StopAllTimers, C3$jscomp$398.Behaviors.Tween.Acts.StopTweens, C3$jscomp$398.Plugins.Touch.Cnds.OnTouchObject, C3$jscomp$398.Plugins.Sprite.Cnds.PickByUID, C3$jscomp$398.Plugins.Sprite.Cnds.IsBoolInstanceVarSet, C3$jscomp$398.Plugins.System.Acts.WaitForPreviousActions, C3$jscomp$398.Plugins.System.Acts.GoToLayout, C3$jscomp$398.Plugins.Audio.Acts.PlayByName, C3$jscomp$398.Behaviors.Timer.Acts.StopTimer, C3$jscomp$398.Plugins.System.Acts.RestartLayout, C3$jscomp$398.Plugins.Sprite.Acts.SetBoolInstanceVar, C3$jscomp$398.Plugins.System.Exps.viewportmidx, C3$jscomp$398.Plugins.System.Exps.viewportmidy, C3$jscomp$398.Behaviors.Timer.Cnds.IsTimerRunning, C3$jscomp$398.Plugins.Sprite.Acts.MoveToLayer, C3$jscomp$398.Plugins.System.Cnds.CompareBoolVar, C3$jscomp$398.Plugins.Arr.Cnds.CompareX, C3$jscomp$398.Plugins.Json.Cnds.ForEach, C3$jscomp$398.Plugins.Arr.Acts.Push, C3$jscomp$398.Plugins.Json.Exps.CurrentKey, C3$jscomp$398.Plugins.System.Cnds.CompareVar, C3$jscomp$398.Plugins.System.Cnds.TriggerOnce, C3$jscomp$398.Plugins.System.Exps.layoutwidth, C3$jscomp$398.Plugins.Sprite.Acts.SetY, C3$jscomp$398.Plugins.System.Acts.SetLayerScale, C3$jscomp$398.Plugins.System.Exps.layerscale, C3$jscomp$398.Behaviors.Tween.Acts.TweenOneProperty, C3$jscomp$398.Plugins.Audio.Acts.Seek, C3$jscomp$398.Plugins.Audio.Acts.FadeVolume, C3$jscomp$398.Behaviors.Timer.Cnds.OnTimer, C3$jscomp$398.Plugins.System.Acts.UnloadUnusedTextures, C3$jscomp$398.Plugins.Json.Acts.AddTo, C3$jscomp$398.Plugins.Arr.Exps.At, C3$jscomp$398.Plugins.Audio.Cnds.OnEnded, C3$jscomp$398.Plugins.System.Exps.fps, C3$jscomp$398.Plugins.Sprite.Acts.SetInstanceVar, C3$jscomp$398.Plugins.Gritsenko_Spine.Cnds.IsVisible, C3$jscomp$398.Plugins.Gritsenko_Spine.Acts.SetVisible, C3$jscomp$398.Plugins.Sprite.Exps.Y, C3$jscomp$398.Behaviors.Tween.Acts.TweenTwoProperties, C3$jscomp$398.Plugins.System.Cnds.LayerVisible, C3$jscomp$398.Behaviors.Tween.Cnds.IsPlaying, C3$jscomp$398.Plugins.Spritefont2.Acts.SetScale, C3$jscomp$398.Behaviors.Tween.Exps.Value, C3$jscomp$398.Plugins.Keyboard.Cnds.OnKey, C3$jscomp$398.Plugins.System.Acts.GoToLayoutByName, C3$jscomp$398.Plugins.Arr.Acts.Delete, C3$jscomp$398.Plugins.System.Exps.random, C3$jscomp$398.Plugins.TiledBg.Cnds.OnCreated, C3$jscomp$398.Plugins.TiledBg.Cnds.CompareInstanceVar, C3$jscomp$398.Plugins.TiledBg.Acts.AddInstanceVar, C3$jscomp$398.Plugins.TiledBg.Exps.X, C3$jscomp$398.Plugins.Spritefont2.Acts.SetVisible, C3$jscomp$398.Plugins.TiledBg.Acts.MoveToBottom, C3$jscomp$398.Plugins.System.Exps.timescale, C3$jscomp$398.Plugins.Spritefont2.Acts.SetHAlign, C3$jscomp$398.Plugins.Spritefont2.Acts.SetInstanceVar, C3$jscomp$398.Plugins.Sprite.Acts.AddChild, C3$jscomp$398.Plugins.Json.Cnds.HasKey, C3$jscomp$398.Plugins.Gritsenko_Spine.Cnds.OnAnimationFinished, C3$jscomp$398.Plugins.Gritsenko_Spine.Cnds.PickParent, C3$jscomp$398.Plugins.System.Exps.chooseindex, C3$jscomp$398.Behaviors.Platform.Acts.SetVectorY, C3$jscomp$398.Behaviors.Tween.Cnds.OnTweensFinished, C3$jscomp$398.Plugins.Sprite.Acts.MoveToTop, C3$jscomp$398.Plugins.Sprite.Acts.RemoveFromParent, C3$jscomp$398.Plugins.Sprite.Acts.SetPos, C3$jscomp$398.Plugins.Sprite.Exps.BBoxTop, C3$jscomp$398.Plugins.Sprite.Acts.SetFlipped, C3$jscomp$398.Plugins.Sprite.Acts.SetAngle, C3$jscomp$398.Plugins.Sprite.Exps.Width, C3$jscomp$398.Plugins.Sprite.Exps.Height, C3$jscomp$398.Plugins.Sprite.Acts.MoveToBottom, C3$jscomp$398.Behaviors.Tween.Acts.TweenValue, C3$jscomp$398.Plugins.System.Exps.loopindex, C3$jscomp$398.Plugins.Sprite.Acts.SetScale, C3$jscomp$398.Plugins.Sprite.Exps.Count, C3$jscomp$398.Plugins.Sprite.Cnds.PickChildren, C3$jscomp$398.Plugins.Gritsenko_Spine.Acts.SetOpacity, C3$jscomp$398.Plugins.Sprite.Cnds.OnCollision, C3$jscomp$398.Plugins.NinePatch.Acts.SetDefaultColor, C3$jscomp$398.Plugins.NinePatch.Cnds.PickChildren, C3$jscomp$398.Plugins.System.Acts.SetVar, C3$jscomp$398.Plugins.System.Exps.viewporttop, C3$jscomp$398.Plugins.Sprite.Exps.IID, C3$jscomp$398.Behaviors.Tween.Acts.SetEnabled, C3$jscomp$398.Plugins.Spritefont2.Exps.Y, C3$jscomp$398.Plugins.NinePatch.Acts.SetOpacity, C3$jscomp$398.Plugins.Spritefont2.Acts.SetSize, C3$jscomp$398.Plugins.Arr.Cnds.CompareXY, C3$jscomp$398.Plugins.System.Cnds.Repeat, C3$jscomp$398.Plugins.Sprite.Exps.LayerName, C3$jscomp$398.Plugins.System.Exps.viewportright, C3$jscomp$398.Plugins.NinePatch.Exps.BBoxRight, C3$jscomp$398.Plugins.NinePatch.Exps.BBoxTop, C3$jscomp$398.Behaviors.Platform.Acts.SetEnabled, C3$jscomp$398.Behaviors.Platform.Acts.SetGravity, C3$jscomp$398.Behaviors.Platform.Acts.SetMaxFallSpeed, C3$jscomp$398.Plugins.System.Cnds.PickAll, C3$jscomp$398.Plugins.System.Exps.uppercase, C3$jscomp$398.Plugins.Keyboard.Exps.StringFromKeyCode, C3$jscomp$398.Plugins.Spritefont2.Acts.SetWidth, C3$jscomp$398.Plugins.Spritefont2.Exps.TextWidth, C3$jscomp$398.Plugins.Spritefont2.Acts.SetX, C3$jscomp$398.Plugins.NinePatch.Exps.BBoxLeft, C3$jscomp$398.Plugins.Spritefont2.Exps.Width, C3$jscomp$398.Plugins.Sprite.Acts.SetCollisions, C3$jscomp$398.Plugins.Audio.Cnds.IsTagPlaying, C3$jscomp$398.Plugins.Gritsenko_Spine.Acts.Destroy, C3$jscomp$398.Behaviors.Bullet.Acts.SetAngleOfMotion, C3$jscomp$398.Behaviors.Bullet.Acts.SetSpeed, C3$jscomp$398.Behaviors.Bullet.Acts.SetGravity, C3$jscomp$398.Behaviors.Rotate.Acts.SetSpeed, C3$jscomp$398.Plugins.System.Exps.choose, C3$jscomp$398.Plugins.System.Exps.layertolayerx, C3$jscomp$398.Plugins.System.Exps.viewportleft, C3$jscomp$398.Plugins.Arr.Acts.SetSize, C3$jscomp$398.Plugins.Arr.Exps.Width, C3$jscomp$398.Plugins.Arr.Exps.Height, C3$jscomp$398.Plugins.Arr.Acts.SetX, C3$jscomp$398.Plugins.Sprite.Acts.SetHeight, C3$jscomp$398.Plugins.NinePatch.Cnds.CompareInstanceVar, C3$jscomp$398.Plugins.NinePatch.Cnds.IsVisible, C3$jscomp$398.Plugins.NinePatch.Acts.SetVisible, C3$jscomp$398.Plugins.Sprite.Cnds.IsVisible, C3$jscomp$398.Plugins.Sprite.Cnds.CompareOpacity, C3$jscomp$398.Plugins.Sprite.Exps.BBoxRight, C3$jscomp$398.Plugins.Sprite.Exps.BBoxLeft, C3$jscomp$398.Plugins.System.Acts.CreateObjectByName, C3$jscomp$398.Plugins.System.Cnds.PickLastCreated, C3$jscomp$398.Plugins.Gritsenko_Spine.Acts.SetInstanceVar, C3$jscomp$398.Plugins.PlatformInfo.Exps.TicksPerSecond, C3$jscomp$398.Plugins.Gritsenko_Spine.Acts.SetEffectEnabled, C3$jscomp$398.Plugins.Gritsenko_Spine.Acts.SetY, C3$jscomp$398.Plugins.Gritsenko_Spine.Exps.Y, C3$jscomp$398.Behaviors.Bullet.Cnds.CompareTravelled, C3$jscomp$398.Plugins.System.Acts.AddVar, C3$jscomp$398.Plugins.Sprite.Acts.SetSize, C3$jscomp$398.Plugins.System.Acts.SetFunctionReturnValue, C3$jscomp$398.Plugins.Sprite.Exps.PickedCount, C3$jscomp$398.Plugins.Spritefont2.Exps.CharacterScale, C3$jscomp$398.Plugins.Sprite.Acts.SetDefaultColor, C3$jscomp$398.Plugins.System.Exps.tokenat, C3$jscomp$398.Plugins.Arr.Acts.Clear, C3$jscomp$398.Plugins.Sprite.Acts.SetZElevation, C3$jscomp$398.Plugins.Sprite.Acts.SetMirrored, C3$jscomp$398.Plugins.System.Cnds.ForEach, C3$jscomp$398.Behaviors.Tween.Cnds.IsAnyPlaying, C3$jscomp$398.Plugins.NinePatch.Cnds.PickParent, C3$jscomp$398.Plugins.Keyboard.Cnds.OnAnyKey, C3$jscomp$398.Plugins.Touch.Cnds.OnTouchEnd, C3$jscomp$398.Plugins.Gritsenko_Spine.Acts.SetAnimationTime, C3$jscomp$398.Plugins.Gritsenko_Spine.Acts.MoveToLayer, C3$jscomp$398.Plugins.TiledBg.Cnds.CompareOpacity, C3$jscomp$398.Plugins.Spritefont2.Acts.SetEffect, C3$jscomp$398.Behaviors.LOS.Acts.SetRange, C3$jscomp$398.Plugins.Sprite.Cnds.PickParent, C3$jscomp$398.Plugins.System.Cnds.Every, C3$jscomp$398.Plugins.Json.Acts.SubtractFrom, C3$jscomp$398.Plugins.Spritefont2.Exps.X, C3$jscomp$398.Plugins.System.Acts.SetLayerParallax, C3$jscomp$398.Plugins.Spritefont2.Acts.MoveToBottom, C3$jscomp$398.Plugins.System.Exps.viewportbottom, C3$jscomp$398.Plugins.TiledBg.Acts.SetSize, C3$jscomp$398.Plugins.TiledBg.Cnds.IsOnLayer, C3$jscomp$398.Plugins.Gritsenko_Spine.Acts.SetEffectParam, C3$jscomp$398.Plugins.TiledBg.Acts.Destroy, C3$jscomp$398.Plugins.Gritsenko_Spine.Acts.SetAnimation, C3$jscomp$398.Plugins.Gritsenko_Spine.Acts.SetAnimationSpeed, C3$jscomp$398.Plugins.NinePatch.Acts.Destroy, C3$jscomp$398.Behaviors.Platform.Cnds.OnLand, C3$jscomp$398.Plugins.Gritsenko_Spine.Cnds.IsAnimationPlaying, C3$jscomp$398.Plugins.TiledBg.Acts.MoveToLayer, C3$jscomp$398.Plugins.TiledBg.Acts.SetDefaultColor, C3$jscomp$398.Plugins.TiledBg.Acts.SetPos, C3$jscomp$398.Plugins.TiledBg.Exps.LayerName, C3$jscomp$398.Plugins.Particles.Acts.SetSpraying, C3$jscomp$398.Plugins.Gritsenko_Spine.Acts.SetDefaultColor, C3$jscomp$398.Plugins.Gritsenko_Spine.Acts.MoveToTop, C3$jscomp$398.Plugins.TiledBg.Acts.SetAngle, C3$jscomp$398.Plugins.Sprite.Exps.Angle, C3$jscomp$398.Plugins.Sprite.Acts.SetWidth, C3$jscomp$398.Plugins.NinePatch.Cnds.IsOnLayer, C3$jscomp$398.Plugins.NinePatch.Acts.MoveToLayer, C3$jscomp$398.Plugins.NinePatch.Exps.Count, C3$jscomp$398.Plugins.TiledBg.Exps.Count, C3$jscomp$398.Plugins.TiledBg.Acts.SetImageOffsetX, C3$jscomp$398.Plugins.TiledBg.Exps.ImageOffsetX, C3$jscomp$398.Plugins.TiledBg.Exps.Angle, C3$jscomp$398.Plugins.TiledBg.Acts.SetImageOffsetY, C3$jscomp$398.Plugins.TiledBg.Exps.ImageOffsetY, C3$jscomp$398.Plugins.Sprite.Cnds.CompareY, C3$jscomp$398.Behaviors.Platform.Cnds.IsEnabled, C3$jscomp$398.Plugins.TiledBg.Acts.MoveToTop, C3$jscomp$398.Plugins.NinePatch.Acts.MoveToTop, C3$jscomp$398.Plugins.System.Exps.layoutheight, C3$jscomp$398.Plugins.System.Cnds.EveryTick, C3$jscomp$398.Plugins.System.Acts.ScrollY, C3$jscomp$398.Plugins.System.Acts.ScrollX, C3$jscomp$398.Plugins.Sprite.Cnds.CompareX, C3$jscomp$398.Plugins.Gritsenko_Spine.Acts.Flip, C3$jscomp$398.Plugins.System.Exps.viewportwidth, C3$jscomp$398.Plugins.TiledBg.Acts.SetX, C3$jscomp$398.Plugins.TiledBg.Acts.SetWidth, C3$jscomp$398.Plugins.TiledBg.Exps.Width, C3$jscomp$398.Plugins.TiledBg.Acts.SetHeight, C3$jscomp$398.Plugins.TiledBg.Exps.Y, C3$jscomp$398.Plugins.TiledBg.Exps.ImageScaleX, C3$jscomp$398.Plugins.System.Exps.scrolly, C3$jscomp$398.Plugins.System.Exps.scrollx, C3$jscomp$398.Plugins.Touch.Cnds.IsTouchingObject, C3$jscomp$398.Plugins.Touch.Exps.TouchID, C3$jscomp$398.Plugins.Touch.Exps.XForID, C3$jscomp$398.Plugins.Touch.Exps.YForID, C3$jscomp$398.Plugins.System.Exps.min, C3$jscomp$398.Plugins.Keyboard.Cnds.IsKeyCodeDown, C3$jscomp$398.Plugins.Keyboard.Exps.LastKeyCode, C3$jscomp$398.Plugins.System.Cnds.For, C3$jscomp$398.Plugins.Arr.Acts.Pop, C3$jscomp$398.Plugins.Arr.Acts.SetXY, C3$jscomp$398.Plugins.System.Exps.roundtodp, C3$jscomp$398.Plugins.System.Exps.time, C3$jscomp$398.Behaviors.Platform.Cnds.IsOnFloor, C3$jscomp$398.Plugins.AdvancedRandom.Exps.WeightedByName, C3$jscomp$398.Plugins.TiledBg.Acts.ZMoveToObject, C3$jscomp$398.Plugins.Gritsenko_Spine.Cnds.IsOnLayer, C3$jscomp$398.Plugins.Sprite.Cnds.OnAnimFinished, C3$jscomp$398.Plugins.Sprite.Acts.SetEffect, C3$jscomp$398.Plugins.Sprite.Cnds.OnAnyAnimFinished, C3$jscomp$398.Plugins.Sprite.Acts.SetAnim, C3$jscomp$398.Plugins.Sprite.Acts.AddInstanceVar, C3$jscomp$398.Plugins.Sprite.Cnds.IsOverlapping, C3$jscomp$398.Behaviors.Platform.Acts.SetVectorX, C3$jscomp$398.Plugins.Spritefont2.Acts.SetY, C3$jscomp$398.Behaviors.LOS.Cnds.HasLOSToObject, C3$jscomp$398.Behaviors.Bullet.Exps.AngleOfMotion, C3$jscomp$398.Plugins.TiledBg.Acts.SetInstanceVar, C3$jscomp$398.Behaviors.Bullet.Exps.Speed, C3$jscomp$398.Plugins.Sprite.Acts.SubInstanceVar, C3$jscomp$398.Plugins.Sprite.Acts.Spawn, C3$jscomp$398.Behaviors.Rotate.Exps.Speed, C3$jscomp$398.Plugins.Sprite.Cnds.IsOnScreen, C3$jscomp$398.Behaviors.Rotate.Acts.SetEnabled, C3$jscomp$398.Plugins.Sprite.Exps.AnimationSpeed, C3$jscomp$398.Plugins.Sprite.Acts.SetAnimSpeed, C3$jscomp$398.Behaviors.Platform.Acts.SetMaxSpeed, C3$jscomp$398.Behaviors.Platform.Acts.SetAcceleration, C3$jscomp$398.Behaviors.Platform.Acts.SetDeceleration, C3$jscomp$398.Plugins.Gritsenko_Spine.Acts.SetSize, C3$jscomp$398.Behaviors.Platform.Exps.VectorY, C3$jscomp$398.Plugins.System.Cnds.PickOverlappingPoint, C3$jscomp$398.Behaviors.Bullet.Acts.StopStepping, C3$jscomp$398.Plugins.Sprite.Exps.AnimationFrameCount, C3$jscomp$398.Plugins.Gritsenko_Spine.Exps.LayerName, C3$jscomp$398.Plugins.Gritsenko_Spine.Exps.X, C3$jscomp$398.Plugins.DrawingCanvas.Acts.SetEffectParam, C3$jscomp$398.Plugins.DrawingCanvas.Acts.SetSize, C3$jscomp$398.Plugins.Gritsenko_Spine.Exps.Width, C3$jscomp$398.Plugins.Gritsenko_Spine.Exps.Height, C3$jscomp$398.Plugins.DrawingCanvas.Acts.PasteObject, C3$jscomp$398.Plugins.DrawingCanvas.Acts.SetOpacity, C3$jscomp$398.Plugins.DrawingCanvas.Exps.X, C3$jscomp$398.Plugins.Sprite.Acts.SetEffectEnabled, C3$jscomp$398.Plugins.Gritsenko_Spine.Acts.ZMoveToObject, C3$jscomp$398.Plugins.Audio.Acts.SetPlaybackRate, C3$jscomp$398.Plugins.NinePatch.Acts.SetInstanceVar, C3$jscomp$398.Plugins.NinePatch.Acts.SetHeight, C3$jscomp$398.Plugins.NinePatch.Exps.Height, C3$jscomp$398.Plugins.NinePatch.Cnds.IsOnScreen, C3$jscomp$398.Plugins.NinePatch.Exps.Y, C3$jscomp$398.Plugins.NinePatch.Acts.SetAngle, C3$jscomp$398.Plugins.NinePatch.Cnds.OnDestroyed, C3$jscomp$398.Plugins.DrawingCanvas.Acts.SetEffect, C3$jscomp$398.Plugins.Gritsenko_Spine.Cnds.OnSkeletonLoaded, C3$jscomp$398.Plugins.Gritsenko_Spine.Acts.SetSkin, C3$jscomp$398.Plugins.Gritsenko_Spine.Exps.TextureWidth, C3$jscomp$398.Plugins.Gritsenko_Spine.Exps.TextureHeight, C3$jscomp$398.Plugins.Timeline.Cnds.OnKeyframeReached, C3$jscomp$398.Plugins.Gritsenko_Spine.Cnds.OnEvent, C3$jscomp$398.Plugins.Gritsenko_Spine.Exps.GetEventData, C3$jscomp$398.Plugins.AdvancedRandom.Exps.Permutation, C3$jscomp$398.Plugins.System.Exps.lowercase, C3$jscomp$398.Plugins.System.Acts.SetLayerForceOwnTexture, C3$jscomp$398.Plugins.Timeline.Acts.SetInstance, C3$jscomp$398.Plugins.Timeline.Acts.PlayTimeline, C3$jscomp$398.Plugins.Timeline.Acts.SetTimelinePlaybackRateByTags, C3$jscomp$398.Plugins.Gritsenko_Spine.Cnds.CompareInstanceVar, C3$jscomp$398.Plugins.Sprite.Acts.SetMeshSize, C3$jscomp$398.Plugins.TiledBg.Cnds.PickChildren, C3$jscomp$398.Plugins.TiledBg.Acts.SetMeshPoint, C3$jscomp$398.Plugins.TiledBg.Exps.Height, C3$jscomp$398.Plugins.TiledBg.Acts.SetMeshSize, C3$jscomp$398.Plugins.TiledBg.Exps.BBoxLeft, C3$jscomp$398.Plugins.TiledBg.Exps.BBoxTop, C3$jscomp$398.Plugins.TiledBg.Acts.AddChild, C3$jscomp$398.Plugins.TiledBg.Exps.IID, C3$jscomp$398.Plugins.Sprite.Exps.dt, C3$jscomp$398.Plugins.Sprite.Acts.SetMeshPoint, C3$jscomp$398.Plugins.Touch.Exps.Y, C3$jscomp$398.Plugins.Sprite.Exps.ImagePointY, C3$jscomp$398.Plugins.Json.Acts.SetJSON, C3$jscomp$398.Plugins.Json.Acts.PushValue, C3$jscomp$398.Plugins.Json.Acts.SetArray, C3$jscomp$398.Plugins.AdvancedRandom.Acts.CreatePermutationTable, C3$jscomp$398.Plugins.NinePatch.Acts.SetSize, C3$jscomp$398.Plugins.Sprite.Exps.AnimationFrame, C3$jscomp$398.Plugins.Sprite.Cnds.CompareFrame, C3$jscomp$398.Plugins.Sprite.Exps.ImageWidth, C3$jscomp$398.Plugins.Sprite.Exps.ImageHeight, C3$jscomp$398.Plugins.Spritefont2.Acts.SetOpacity, C3$jscomp$398.Plugins.Spritefont2.Cnds.PickByUID, C3$jscomp$398.Plugins.Spritefont2.Acts.AddChild, C3$jscomp$398.Plugins.Spritefont2.Exps.IID, C3$jscomp$398.Behaviors.Flash.Acts.Flash, C3$jscomp$398.Plugins.Spritefont2.Cnds.IsBoolInstanceVarSet, C3$jscomp$398.Plugins.System.Cnds.While, C3$jscomp$398.Plugins.System.Cnds.PickByEvaluate, C3$jscomp$398.Plugins.Spritefont2.Exps.TextHeight, C3$jscomp$398.Plugins.Spritefont2.Exps.Height, C3$jscomp$398.Plugins.Spritefont2.Cnds.OnCreated, C3$jscomp$398.Plugins.Sprite.Exps.UID, C3$jscomp$398.Plugins.Touch.Exps.X, C3$jscomp$398.Plugins.System.Cnds.PickByComparison, C3$jscomp$398.Plugins.AJAX.Acts.Request, C3$jscomp$398.Plugins.AJAX.Cnds.OnAnyError, C3$jscomp$398.Plugins.AJAX.Exps.Tag, C3$jscomp$398.Plugins.AJAX.Cnds.OnAnyComplete, C3$jscomp$398.Plugins.Json.Acts.Parse, C3$jscomp$398.Plugins.AJAX.Exps.LastData, C3$jscomp$398.Plugins.AJAX.Acts.RequestFile, C3$jscomp$398.Plugins.Eponesh_GameScore.Exps.Language, C3$jscomp$398.Plugins.AJAX.Cnds.OnComplete, C3$jscomp$398.Plugins.Eponesh_GameScore.Cnds.IsMobile, C3$jscomp$398.Plugins.TiledBg.Acts.SetVisible, C3$jscomp$398.Plugins.Spritefont2.Acts.MoveToLayer, C3$jscomp$398.Plugins.Spritefont2.Acts.RemoveFromParent, C3$jscomp$398.Plugins.Spritefont2.Exps.LayerName, C3$jscomp$398.Plugins.Spritefont2.Cnds.PickChildren, C3$jscomp$398.Plugins.Spritefont2.Acts.MoveToTop, C3$jscomp$398.Plugins.NinePatch.Acts.RemoveFromParent, C3$jscomp$398.Plugins.NinePatch.Acts.SetPos, C3$jscomp$398.Plugins.Keyboard.Cnds.OnKeyCode, C3$jscomp$398.Plugins.System.Acts.StopLoop, C3$jscomp$398.Plugins.Sprite.Cnds.PickTopBottom, C3$jscomp$398.Plugins.Touch.Cnds.IsInTouch, C3$jscomp$398.Plugins.TiledBg.Cnds.IsBoolInstanceVarSet, C3$jscomp$398.Plugins.NinePatch.Exps.LayerName, C3$jscomp$398.Plugins.System.Exps.max, C3$jscomp$398.Plugins.System.Cnds.EvaluateExpression, C3$jscomp$398.Plugins.Audio.Acts.Preload, C3$jscomp$398.Plugins.System.Exps.tokencount, C3$jscomp$398.Plugins.Sprite.Cnds.PickInstVarHiLow, C3$jscomp$398.Plugins.Touch.Cnds.OnTouchStart, C3$jscomp$398.Plugins.Mouse.Cnds.OnWheel, C3$jscomp$398.Plugins.Mouse.Exps.X, C3$jscomp$398.Plugins.Mouse.Exps.Y, C3$jscomp$398.Plugins.System.Exps.viewportheight, C3$jscomp$398.Plugins.Spritefont2.Acts.SetDefaultColor, C3$jscomp$398.Plugins.Eponesh_GameScore.Acts.GameplayStart, C3$jscomp$398.Plugins.Eponesh_GameScore.Acts.GameplayStop, C3$jscomp$398.Plugins.Eponesh_GameScore.Acts.AnalyticsGoal, C3$jscomp$398.ScriptsInEvents.Var_Event402_Act2, C3$jscomp$398.Plugins.Eponesh_GameScore.Acts.AdsShowFullscreen, C3$jscomp$398.Plugins.Eponesh_GameScore.Acts.AdsShowRewarded, C3$jscomp$398.Plugins.Eponesh_GameScore.Cnds.OnAdsFullscreenStart, C3$jscomp$398.Plugins.Eponesh_GameScore.Cnds.OnAdsPreloaderClose, C3$jscomp$398.Plugins.Eponesh_GameScore.Cnds.OnAdsFullscreenClose, C3$jscomp$398.Plugins.Eponesh_GameScore.Cnds.OnAdsRewardedStart, C3$jscomp$398.Plugins.Eponesh_GameScore.Cnds.OnAdsRewardedClose, C3$jscomp$398.Plugins.Audio.Acts.SetSilent, C3$jscomp$398.Plugins.Eponesh_GameScore.Cnds.OnAdsRewardedReward, C3$jscomp$398.Plugins.PlatformInfo.Exps.WindowInnerWidth, C3$jscomp$398.Plugins.PlatformInfo.Exps.WindowInnerHeight, C3$jscomp$398.Plugins.System.Acts.SetCanvasSize, C3$jscomp$398.Plugins.System.Acts.Signal, C3$jscomp$398.Plugins.Browser.Cnds.OnResize, C3$jscomp$398.Plugins.Eponesh_GameScore.Acts.PlayerSet, C3$jscomp$398.Plugins.Json.Exps.ToCompactString, C3$jscomp$398.Plugins.Eponesh_GameScore.Acts.PlayerSync, C3$jscomp$398.Plugins.Eponesh_GameScore.Exps.PlayerGet, C3$jscomp$398.ScriptsInEvents.ESelectCharacter_Event1_Act3, C3$jscomp$398.Plugins.System.Exps.layertolayery, C3$jscomp$398.Plugins.NinePatch.Acts.SetY, C3$jscomp$398.Plugins.System.Exps.projectversion, C3$jscomp$398.Plugins.System.Cnds.LayerInteractive, C3$jscomp$398.Plugins.Browser.Acts.GoToURLWindow, C3$jscomp$398.Plugins.Json.Acts.InsertValue, C3$jscomp$398.Plugins.Sprite.Exps.BBoxBottom, C3$jscomp$398.Plugins.System.Cnds.PickByHighestLowestValue, C3$jscomp$398.Plugins.NinePatch.Acts.SetBoolInstanceVar, C3$jscomp$398.Plugins.Audio.Acts.SetPaused, C3$jscomp$398.Plugins.NinePatch.Cnds.IsBoolInstanceVarSet, C3$jscomp$398.Plugins.TiledBg.Acts.SetY, C3$jscomp$398.Plugins.Spritefont2.Acts.SetHeight, C3$jscomp$398.Plugins.NinePatch.Acts.AddChild, C3$jscomp$398.Plugins.Sprite.Acts.LoadURL, C3$jscomp$398.Plugins.System.Exps.stringsub, C3$jscomp$398.Plugins.Sprite.Cnds.OnURLLoaded, C3$jscomp$398.Plugins.Spritefont2.Cnds.IsOnLayer, C3$jscomp$398.Plugins.Gritsenko_Spine.Exps.Count, C3$jscomp$398.Plugins.System.Acts.SetLayerZElevation, C3$jscomp$398.Plugins.System.Acts.SetLayerScroll, C3$jscomp$398.Plugins.System.Exps.layerscrolly, C3$jscomp$398.Plugins.System.Exps.layerscrollx, C3$jscomp$398.Plugins.TiledBg.Exps.BBoxBottom, C3$jscomp$398.Plugins.TiledBg.Acts.RemoveFromParent, C3$jscomp$398.Plugins.Sprite.Acts.SetEffectParam, C3$jscomp$398.Plugins.System.Exps.layerzelevation, C3$jscomp$398.Plugins.NinePatch.Exps.BBoxBottom, C3$jscomp$398.Plugins.Spritefont2.Acts.SetZElevation, C3$jscomp$398.ScriptsInEvents.ELoader_Event1_Act1]
}
;
self.C3_JsPropNameTable = [{
    Keyboard: 0
}, {
    Touch: 0
}, {
    Mouse: 0
}, {
    Audio: 0
}, {
    Browser: 0
}, {
    AJAX: 0
}, {
    PlatformInfo: 0
}, {
    TimelineController: 0
}, {
    AdvancedRandom: 0
}, {
    GamePush: 0
}, {
    InputBuffer: 0
}, {
    CharacterIndex: 0
}, {
    ListPlayerActions: 0
}, {
    BufferEnemy: 0
}, {
    IconFrameEnemyPop: 0
}, {
    EnemyDestroyArray: 0
}, {
    BufferComboIndex: 0
}, {
    UnlockedCharacterBuffer: 0
}, {
    ModeFightArrayAdvanced: 0
}, {
    JSON2: 0
}, {
    JSON: 0
}, {
    LANG: 0
}, {
    JSON_modifiers: 0
}, {
    id: 0
}, {
    characterID: 0
}, {
    sW: 0
}, {
    sH: 0
}, {
    skin: 0
}, {
    SpineContainer1: 0
}, {
    SpineContainer2: 0
}, {
    SpineContainer3: 0
}, {
    SpineContainer4: 0
}, {
    SpineContainer5: 0
}, {
    SpineContainer6: 0
}, {
    SpineContainer7: 0
}, {
    SpineContainer8: 0
}, {
    Tween: 0
}, {
    effect_01: 0
}, {
    effect_02: 0
}, {
    effect_breaker_01: 0
}, {
    effect_dust_01: 0
}, {
    effect_exp_01: 0
}, {
    effect_exp_2: 0
}, {
    effect_exp_3: 0
}, {
    effect_exp_4: 0
}, {
    effect_hit_01: 0
}, {
    effect_hit_02: 0
}, {
    effect_lazer_1: 0
}, {
    EffectBlock: 0
}, {
    EffectShadowDashTeleport: 0
}, {
    End_Round_TiledLine: 0
}, {
    fire: 0
}, {
    ID_target: 0
}, {
    LazerDarkLord_2: 0
}, {
    LazerDarkLord_3: 0
}, {
    Particles: 0
}, {
    ParticlesBlood: 0
}, {
    ParticlesSmoke: 0
}, {
    Rotate: 0
}, {
    Sprite16: 0
}, {
    Sprite18: 0
}, {
    num: 0
}, {
    BreakerSprite: 0
}, {
    blick_1: 0
}, {
    MotionBlurEffect: 0
}, {
    Whirlwind: 0
}, {
    blood: 0
}, {
    TiledBackground8: 0
}, {
    snowball: 0
}, {
    pattern_2: 0
}, {
    effect_exp_5: 0
}, {
    effect_exp_6: 0
}, {
    Sprite44: 0
}, {
    effect_exp_7: 0
}, {
    w: 0
}, {
    effect_exp_8: 0
}, {
    effect_exp_9: 0
}, {
    effect_exp_10: 0
}, {
    shadow_dust: 0
}, {
    TeleportSlamSpriteAnimation: 0
}, {
    Bullet: 0
}, {
    Bone: 0
}, {
    TeleportSlamBlendSprite: 0
}, {
    effect_exp_11: 0
}, {
    i: 0
}, {
    effect_exp_12: 0
}, {
    effect_exp_13: 0
}, {
    effect_meteor_exp: 0
}, {
    drag: 0
}, {
    defaultOffsetX: 0
}, {
    defaultOffsetY: 0
}, {
    dragName: 0
}, {
    anchorTag: 0
}, {
    tag: 0
}, {
    MAINTAG: 0
}, {
    enabled: 0
}, {
    select: 0
}, {
    sizeStartWidth: 0
}, {
    sizeStartHeight: 0
}, {
    value: 0
}, {
    touchID_: 0
}, {
    BorderCollision: 0
}, {
    tweenButtonActive: 0
}, {
    Button_1: 0
}, {
    Button1: 0
}, {
    IconAttack: 0
}, {
    ReadyTouch: 0
}, {
    TouchID: 0
}, {
    a: 0
}, {
    Joy: 0
}, {
    Stick: 0
}, {
    JoyCollision: 0
}, {
    PauseButton: 0
}, {
    Button2: 0
}, {
    Button3: 0
}, {
    Joy2_Education: 0
}, {
    Button4: 0
}, {
    braid_blur: 0
}, {
    Sprite21: 0
}, {
    Powerball: 0
}, {
    Sprite23: 0
}, {
    RedArrowImage: 0
}, {
    Sickle: 0
}, {
    Sickle_1: 0
}, {
    Fade: 0
}, {
    Ice_Axe_pieces: 0
}, {
    ice_creation_circle: 0
}, {
    speed: 0
}, {
    mirror: 0
}, {
    ice_image: 0
}, {
    ice_shard: 0
}, {
    Ice_Sword_pieces: 0
}, {
    Ice_Tackle_Frost1: 0
}, {
    Ice_Tackle_Frost2: 0
}, {
    Nunchucks: 0
}, {
    Sprite46: 0
}, {
    LordHammerSprite: 0
}, {
    MeteorImage: 0
}, {
    ID: 0
}, {
    n: 0
}, {
    type: 0
}, {
    CharacterIcon: 0
}, {
    players: 0
}, {
    Flash: 0
}, {
    CircleSelecter: 0
}, {
    "9patchHP_loy": 0
}, {
    turn: 0
}, {
    AvatarFonColor: 0
}, {
    barBorder: 0
}, {
    Sprite20: 0
}, {
    Sprite3: 0
}, {
    Sprite5: 0
}, {
    Sprite7: 0
}, {
    LineOfSight: 0
}, {
    LOS_Bots: 0
}, {
    main_tag: 0
}, {
    "9patch": 0
}, {
    LOS_BULLETS: 0
}, {
    XrayTiled: 0
}, {
    round: 0
}, {
    roundImage: 0
}, {
    shadowCharacter: 0
}, {
    shadowText: 0
}, {
    Sprite4: 0
}, {
    K_O: 0
}, {
    GradientsSprite: 0
}, {
    "9patch2": 0
}, {
    Sine: 0
}, {
    cloude_1: 0
}, {
    Sprite37: 0
}, {
    Sprite43: 0
}, {
    Sprite11: 0
}, {
    Sprite12: 0
}, {
    Sprite13: 0
}, {
    Sprite14: 0
}, {
    tbScene3: 0
}, {
    TiledBackground: 0
}, {
    InitialX: 0
}, {
    TiledBackground2: 0
}, {
    TiledBackground3: 0
}, {
    TiledBackground4: 0
}, {
    TiledBackground5: 0
}, {
    Stade: 0
}, {
    train_mask: 0
}, {
    SVGPicture: 0
}, {
    Sprite: 0
}, {
    Sprite45: 0
}, {
    Sprite47: 0
}, {
    Sprite48: 0
}, {
    Sprite49: 0
}, {
    Sprite50: 0
}, {
    Sprite51: 0
}, {
    stone: 0
}, {
    TiledBackground12: 0
}, {
    campfire: 0
}, {
    fire_campfire: 0
}, {
    light_fire_campfire: 0
}, {
    Sprite15: 0
}, {
    Sprite19: 0
}, {
    Sprite22: 0
}, {
    Sprite24: 0
}, {
    XX: 0
}, {
    YY: 0
}, {
    Sprite25: 0
}, {
    Sprite8: 0
}, {
    TiledBackground7: 0
}, {
    "9patch3": 0
}, {
    ParticlesSnow: 0
}, {
    dy: 0
}, {
    vy: 0
}, {
    sy: 0
}, {
    Column: 0
}, {
    pIID: 0
}, {
    isStatic: 0
}, {
    isTiled: 0
}, {
    WaterNode: 0
}, {
    Points: 0
}, {
    isEdgeBound: 0
}, {
    k: 0
}, {
    d: 0
}, {
    k2: 0
}, {
    d2: 0
}, {
    WaterTiled: 0
}, {
    Sprite28: 0
}, {
    Sprite29: 0
}, {
    Sprite30: 0
}, {
    Sprite31: 0
}, {
    TiledBackground9: 0
}, {
    Sprite32: 0
}, {
    Sprite33: 0
}, {
    Sprite34: 0
}, {
    Sprite35: 0
}, {
    Sprite36: 0
}, {
    Sprite38: 0
}, {
    Sprite39: 0
}, {
    Sprite40: 0
}, {
    Sprite41: 0
}, {
    Sprite42: 0
}, {
    Sprite27: 0
}, {
    tbScene5: 0
}, {
    TiledBackground10: 0
}, {
    TiledBackground13: 0
}, {
    Sprite2: 0
}, {
    Sprite9: 0
}, {
    Sprite10: 0
}, {
    Sprite52: 0
}, {
    Sprite53: 0
}, {
    TiledBackground14: 0
}, {
    BlendMaskScene6: 0
}, {
    TiledBackground15: 0
}, {
    Sprite54: 0
}, {
    Sprite55: 0
}, {
    Sprite56: 0
}, {
    TiledBackground16: 0
}, {
    Sprite57: 0
}, {
    Sprite58: 0
}, {
    Sprite59: 0
}, {
    Sprite60: 0
}, {
    TiledBackground17: 0
}, {
    Sprite67: 0
}, {
    Sprite71: 0
}, {
    Sprite72: 0
}, {
    Sprite74: 0
}, {
    Sprite63: 0
}, {
    Sprite64: 0
}, {
    Sprite65: 0
}, {
    Sprite66: 0
}, {
    resize: 0
}, {
    TiledBackground6: 0
}, {
    Sprite68: 0
}, {
    Sprite69: 0
}, {
    Sprite70: 0
}, {
    moved: 0
}, {
    Solid: 0
}, {
    GROUND: 0
}, {
    srt: 0
}, {
    Timer: 0
}, {
    GameManager: 0
}, {
    Anchor: 0
}, {
    CheckCollision: 0
}, {
    playerID: 0
}, {
    SelectCharacterID: 0
}, {
    HP: 0
}, {
    HP_MAX: 0
}, {
    energy: 0
}, {
    NameAnimation: 0
}, {
    TypeAnimation: 0
}, {
    CharacterStatus: 0
}, {
    SubTagSystem: 0
}, {
    endTimeAnimation: 0
}, {
    AllowInput: 0
}, {
    ComboPlay: 0
}, {
    AirComboPlay: 0
}, {
    ComboGroopNum: 0
}, {
    combo_index: 0
}, {
    maxComboCount: 0
}, {
    damageSystem: 0
}, {
    DamageTag: 0
}, {
    force_impulse: 0
}, {
    moved_impulse: 0
}, {
    backward_repulsion_force: 0
}, {
    LockCombo: 0
}, {
    Fatigue: 0
}, {
    XrayCountXp: 0
}, {
    MovedStartTrigger: 0
}, {
    StartXray: 0
}, {
    unlock_xray: 0
}, {
    enemy_comboIndex: 0
}, {
    SpecialName: 0
}, {
    ComboBlockHitSystem: 0
}, {
    BounceHitCount: 0
}, {
    BlockSystem: 0
}, {
    StadeBreakerAndXray: 0
}, {
    BotPlayer: 0
}, {
    BotLevel: 0
}, {
    BotStadeName: 0
}, {
    BotStadeNum: 0
}, {
    CountBreaker: 0
}, {
    BreakerStart: 0
}, {
    mirrorSpecial: 0
}, {
    Jump_Moved: 0
}, {
    Special_ID: 0
}, {
    SpecialMirror: 0
}, {
    JumpCount: 0
}, {
    ComboStartPlayer: 0
}, {
    ConsumptionCombo: 0
}, {
    Setting_ActiveXRay: 0
}, {
    rand_ComboPlayer: 0
}, {
    sound_tag: 0
}, {
    type_attack_special_name: 0
}, {
    ShowEffect_SpecialAttack: 0
}, {
    BotStageMode: 0
}, {
    size_character: 0
}, {
    Armor: 0
}, {
    flight_leg_boolean: 0
}, {
    LosActive: 0
}, {
    blockInput: 0
}, {
    HP_MAX_MF: 0
}, {
    limiter_damage: 0
}, {
    Platform: 0
}, {
    Timer2: 0
}, {
    Player: 0
}, {
    bg_tiled: 0
}, {
    langName: 0
}, {
    color: 0
}, {
    tag_main: 0
}, {
    autoSize: 0
}, {
    Text: 0
}, {
    text_box: 0
}, {
    damage: 0
}, {
    Pin: 0
}, {
    tag_mode: 0
}, {
    blockDamage: 0
}, {
    num_combo: 0
}, {
    destroy: 0
}, {
    AnimationNameDamage: 0
}, {
    airCombo: 0
}, {
    force: 0
}, {
    yesDamage: 0
}, {
    specialName: 0
}, {
    attackName: 0
}, {
    damage_radius: 0
}, {
    cam: 0
}, {
    name: 0
}, {
    check: 0
}, {
    bounce: 0
}, {
    ModeFight: 0
}, {
    BulletWeapons: 0
}, {
    weapons_tag: 0
}, {
    damage_radius_weapons: 0
}, {
    BOX_TOTAL_DAMAGE: 0
}, {
    COMBO_DAMAGE_HIT: 0
}, {
    active_radius_special: 0
}, {
    CharacterTrack: 0
}, {
    loader_box: 0
}, {
    index_load_character_progress_bar: 0
}, {
    Pattern_7: 0
}, {
    start_pos: 0
}, {
    c: 0
}, {
    r: 0
}, {
    CharacterMarkerSelectTween: 0
}, {
    Fade_1: 0
}, {
    Blick_5: 0
}, {
    Fade_2: 0
}, {
    ButtonSetting: 0
}, {
    Patern_Button: 0
}, {
    Sprite61: 0
}, {
    lord_hammer_effect1: 0
}, {
    StartW: 0
}, {
    StartH: 0
}, {
    open: 0
}, {
    Panel: 0
}, {
    TiledBackground11: 0
}, {
    ButtonSetting2: 0
}, {
    tb_fon: 0
}, {
    LockedSprite: 0
}, {
    Sprite6: 0
}, {
    "9patch4": 0
}, {
    Sprite26: 0
}, {
    Sprite62: 0
}, {
    TiledBackground18: 0
}, {
    name_: 0
}, {
    startPos: 0
}, {
    j: 0
}, {
    layerName_: 0
}, {
    yesScrollingItem: 0
}, {
    toX: 0
}, {
    toY: 0
}, {
    rf_but: 0
}, {
    BlendTiled: 0
}, {
    LoaderSprite: 0
}, {
    Sprite73: 0
}, {
    Sprite75: 0
}, {
    "9patch5": 0
}, {
    "9patchBorder": 0
}, {
    TiledEducation: 0
}, {
    posX: 0
}, {
    plus: 0
}, {
    player: 0
}, {
    EducationBox: 0
}, {
    PosY: 0
}, {
    confetti: 0
}, {
    Sprite76: 0
}, {
    Sprite77: 0
}, {
    stade: 0
}, {
    time_chance_frame: 0
}, {
    EDUCATION_POINTER: 0
}, {
    TiledFonPause: 0
}, {
    Sprite78: 0
}, {
    Sprite79: 0
}, {
    CharacterPreview: 0
}, {
    LineBlickSprite: 0
}, {
    LineBlickGroup: 0
}, {
    blick_mini: 0
}, {
    Sprite80: 0
}, {
    TiledBackground19: 0
}, {
    Sprite81: 0
}, {
    TiledBackground20: 0
}, {
    TiledBackground21: 0
}, {
    Sprite82: 0
}, {
    Sprite83: 0
}, {
    Sprite84: 0
}, {
    Sprite85: 0
}, {
    Sprite86: 0
}, {
    Sprite17: 0
}, {
    Sprite87: 0
}, {
    "9patch6": 0
}, {
    TiledBackground22: 0
}, {
    Sprite88: 0
}, {
    Sprite89: 0
}, {
    Sprite90: 0
}, {
    Sprite91: 0
}, {
    Sprite92: 0
}, {
    TowersQualityMask: 0
}, {
    Sprite93: 0
}, {
    TowersPlayerPanel: 0
}, {
    progressBarTowers_border: 0
}, {
    progressBarTowers_bar: 0
}, {
    TiledBackground23: 0
}, {
    leverLightEffect: 0
}, {
    mode_fight_slot: 0
}, {
    lever: 0
}, {
    startH: 0
}, {
    lever_tween: 0
}, {
    mode_fight_bg_fade: 0
}, {
    mode_fight_border_big: 0
}, {
    mode_fight_border: 0
}, {
    mode_fight_icon: 0
}, {
    mode_fight_blend: 0
}, {
    active: 0
}, {
    mainID: 0
}, {
    frame: 0
}, {
    mainFrame: 0
}, {
    mode_fight_icon_box: 0
}, {
    MODE_FIGHT_TEXT_BOX: 0
}, {
    effect_exp_poison_1: 0
}, {
    TiledBackground24: 0
}, {
    GameManagerMode: 0
}, {
    targetPlayer: 0
}, {
    shadow_text_UI: 0
}, {
    poisonIcon: 0
}, {
    shadow_text_UI_2: 0
}, {
    healBox: 0
}, {
    healImage: 0
}, {
    healImage2: 0
}, {
    countBounce: 0
}, {
    Coins: 0
}, {
    Sprite94: 0
}, {
    CharacterTrackFrost: 0
}, {
    Effect_cricle_1: 0
}, {
    Sprite95: 0
}, {
    Sprite96: 0
}, {
    ButtonControl: 0
}, {
    ButtonSprite: 0
}, {
    TiledLayer: 0
}, {
    ObjectLayerXray: 0
}, {
    SpineObject: 0
}, {
    Objects: 0
}, {
    tiled_collision_layer: 0
}, {
    tb_scene_all: 0
}, {
    Patern: 0
}, {
    PlayersFamilies: 0
}, {
    BulletMask: 0
}, {
    ScrollObject: 0
}, {
    MODE_FIGHT_ITEM: 0
}, {
    restart: 0
}, {
    layer: 0
}, {
    OPEN: 0
}, {
    POSX: 0
}, {
    Dust: 0
}, {
    time_: 0
}, {
    timer: 0
}, {
    offsetY: 0
}, {
    offsetX: 0
}, {
    down: 0
}, {
    jump_W_A: 0
}, {
    jump_W: 0
}, {
    jump_W_D: 0
}, {
    jump_DASH: 0
}, {
    dash_down: 0
}, {
    block: 0
}, {
    attack: 0
}, {
    uppercut: 0
}, {
    special_1: 0
}, {
    special_2: 0
}, {
    breaker: 0
}, {
    str_text: 0
}, {
    back_name: 0
}, {
    invers_color: 0
}, {
    code: 0
}, {
    lastX_bbox: 0
}, {
    step_item: 0
}, {
    width_: 0
}, {
    create: 0
}, {
    tag_anchor: 0
}, {
    bbox: 0
}, {
    x: 0
}, {
    y: 0
}, {
    bufferValue: 0
}, {
    bufferValue2: 0
}, {
    skinID: 0
}, {
    coins: 0
}, {
    count: 0
}, {
    count_round: 0
}, {
    count_timer: 0
}, {
    index_: 0
}, {
    botPlayer: 0
}, {
    botLevel: 0
}, {
    minValue: 0
}, {
    coins_add: 0
}, {
    b_level_: 0
}, {
    WinID: 0
}, {
    type_end: 0
}, {
    mirrorCharacter: 0
}, {
    win: 0
}, {
    offset: 0
}, {
    targetScale: 0
}, {
    inp: 0
}, {
    ang: 0
}, {
    CheckXrayMoment: 0
}, {
    movedCheckFun: 0
}, {
    InputType: 0
}, {
    delay: 0
}, {
    scale: 0
}, {
    mirrorPlayer: 0
}, {
    tag_damage: 0
}, {
    spawn: 0
}, {
    force_spine: 0
}, {
    comboNum: 0
}, {
    block_active: 0
}, {
    damage_id: 0
}, {
    physicOn: 0
}, {
    size: 0
}, {
    forceY: 0
}, {
    PosX: 0
}, {
    size_max: 0
}, {
    defaultSize: 0
}, {
    Speed: 0
}, {
    speedAnimation: 0
}, {
    forceJump: 0
}, {
    forceJumpAirBreaker: 0
}, {
    jump_player: 0
}, {
    Dash: 0
}, {
    SpecialActive_: 0
}, {
    offsetTweenY: 0
}, {
    special_ID: 0
}, {
    sec: 0
}, {
    grav: 0
}, {
    sizeSmileStart: 0
}, {
    playerMirrorParam: 0
}, {
    waitSpecialAttack: 0
}, {
    danger: 0
}, {
    reset: 0
}, {
    step_: 0
}, {
    sub: 0
}, {
    fast: 0
}, {
    checkSpecial: 0
}, {
    x_: 0
}, {
    opacity: 0
}, {
    time_dash: 0
}, {
    max_size: 0
}, {
    posY: 0
}, {
    VectorSpeed: 0
}, {
    Combo_number: 0
}, {
    index: 0
}, {
    i2: 0
}, {
    Name: 0
}, {
    ActionsName: 0
}, {
    min_stadeModeHP: 0
}, {
    input: 0
}, {
    key: 0
}, {
    adv_index: 0
}, {
    side_: 0
}, {
    side: 0
}, {
    sizeW: 0
}, {
    sizeH: 0
}, {
    iconAdvancedCreate: 0
}, {
    startLayer: 0
}, {
    wMax: 0
}, {
    hMax: 0
}, {
    main: 0
}, {
    min_: 0
}, {
    max_: 0
}, {
    UID: 0
}, {
    sound: 0
}, {
    step: 0
}, {
    ymID: 0
}, {
    Load_JSON: 0
}, {
    Load_JSON2: 0
}, {
    Load_LANG: 0
}, {
    speed_: 0
}, {
    top_: 0
}, {
    bottom_: 0
}, {
    left_: 0
}, {
    right_: 0
}, {
    layer_: 0
}, {
    lang: 0
}, {
    symbol: 0
}, {
    layerStart: 0
}, {
    createTitle: 0
}, {
    size_: 0
}, {
    str_name: 0
}, {
    path: 0
}, {
    totalGames: 0
}, {
    performanceScore: 0
}, {
    normalizedScore: 0
}, {
    weightWinMore50: 0
}, {
    weightWinLess50: 0
}, {
    weightFail: 0
}, {
    currentLevel: 0
}, {
    fail: 0
}, {
    win_more_50_hp: 0
}, {
    win_less_50_hp: 0
}, {
    CHARACTER_ID: 0
}, {
    AddLevelBots: 0
}, {
    sn_: 0
}, {
    ValuePos_: 0
}, {
    lerp_: 0
}, {
    scroll_name: 0
}, {
    on: 0
}, {
    s_: 0
}, {
    s_old: 0
}, {
    r_: 0
}, {
    destoy: 0
}, {
    timescale_0: 0
}, {
    enable: 0
}, {
    lang_name: 0
}, {
    resize_def_width: 0
}, {
    resize_def_height: 0
}, {
    view_canv_w: 0
}, {
    view_canv_h: 0
}, {
    resize_scale: 0
}, {
    resize_canv_w: 0
}, {
    resize_canv_h: 0
}, {
    save: 0
}, {
    countPlayers: 0
}, {
    colorHex: 0
}, {
    one_open: 0
}, {
    path_main: 0
}, {
    mc: 0
}, {
    mr: 0
}, {
    turnid: 0
}, {
    row: 0
}, {
    maxRow: 0
}, {
    total: 0
}, {
    current: 0
}, {
    center: 0
}, {
    maxColumn: 0
}, {
    count_players: 0
}, {
    h: 0
}, {
    turn_ID: 0
}, {
    twoPlayers: 0
}, {
    offsetTextLeftBox: 0
}, {
    offsetTextRightBox: 0
}, {
    w_: 0
}, {
    count_total_coins: 0
}, {
    maxCount: 0
}, {
    max_zoom_layer: 0
}, {
    start_zoom_layer: 0
}, {
    t_: 0
}, {
    start_animation: 0
}, {
    loopindex_: 0
}, {
    coins_value: 0
}, {
    coins_value2: 0
}, {
    pos: 0
}];
self.InstanceType = {
    Keyboard: class extends self.IInstance {
    }
    ,
    Touch: class extends self.IInstance {
    }
    ,
    Mouse: class extends self.IInstance {
    }
    ,
    Audio: class extends self.IInstance {
    }
    ,
    Browser: class extends self.IInstance {
    }
    ,
    AJAX: class extends self.IInstance {
    }
    ,
    PlatformInfo: class extends self.IInstance {
    }
    ,
    TimelineController: class extends self.IInstance {
    }
    ,
    AdvancedRandom: class extends self.IInstance {
    }
    ,
    GamePush: class extends self.C3.Plugins.Eponesh_GameScore.Instance {
    }
    ,
    InputBuffer: class extends self.IArrayInstance {
    }
    ,
    CharacterIndex: class extends self.IArrayInstance {
    }
    ,
    ListPlayerActions: class extends self.IArrayInstance {
    }
    ,
    BufferEnemy: class extends self.IArrayInstance {
    }
    ,
    IconFrameEnemyPop: class extends self.IArrayInstance {
    }
    ,
    EnemyDestroyArray: class extends self.IArrayInstance {
    }
    ,
    BufferComboIndex: class extends self.IArrayInstance {
    }
    ,
    UnlockedCharacterBuffer: class extends self.IArrayInstance {
    }
    ,
    ModeFightArrayAdvanced: class extends self.IArrayInstance {
    }
    ,
    JSON2: class extends self.IJSONInstance {
    }
    ,
    JSON: class extends self.IJSONInstance {
    }
    ,
    LANG: class extends self.IJSONInstance {
    }
    ,
    JSON_modifiers: class extends self.IJSONInstance {
    }
    ,
    SpineContainer1: class extends self.IWorldInstance {
    }
    ,
    SpineContainer2: class extends self.IWorldInstance {
    }
    ,
    SpineContainer3: class extends self.IWorldInstance {
    }
    ,
    SpineContainer4: class extends self.IWorldInstance {
    }
    ,
    SpineContainer5: class extends self.IWorldInstance {
    }
    ,
    SpineContainer6: class extends self.IWorldInstance {
    }
    ,
    SpineContainer7: class extends self.IWorldInstance {
    }
    ,
    SpineContainer8: class extends self.IWorldInstance {
    }
    ,
    effect_01: class extends self.ISpriteInstance {
    }
    ,
    effect_02: class extends self.ISpriteInstance {
    }
    ,
    effect_breaker_01: class extends self.ISpriteInstance {
    }
    ,
    effect_dust_01: class extends self.ISpriteInstance {
    }
    ,
    effect_exp_01: class extends self.ISpriteInstance {
    }
    ,
    effect_exp_2: class extends self.ISpriteInstance {
    }
    ,
    effect_exp_3: class extends self.ISpriteInstance {
    }
    ,
    effect_exp_4: class extends self.ISpriteInstance {
    }
    ,
    effect_hit_01: class extends self.ISpriteInstance {
    }
    ,
    effect_hit_02: class extends self.ISpriteInstance {
    }
    ,
    effect_lazer_1: class extends self.ISpriteInstance {
    }
    ,
    EffectBlock: class extends self.ISpriteInstance {
    }
    ,
    EffectShadowDashTeleport: class extends self.ISpriteInstance {
    }
    ,
    End_Round_TiledLine: class extends self.ITiledBackgroundInstance {
    }
    ,
    fire: class extends self.ISpriteInstance {
    }
    ,
    LazerDarkLord_2: class extends self.IWorldInstance {
    }
    ,
    LazerDarkLord_3: class extends self.IWorldInstance {
    }
    ,
    Particles: class extends self.IParticlesInstance {
    }
    ,
    ParticlesBlood: class extends self.IParticlesInstance {
    }
    ,
    ParticlesSmoke: class extends self.IParticlesInstance {
    }
    ,
    Sprite16: class extends self.ISpriteInstance {
    }
    ,
    Sprite18: class extends self.ISpriteInstance {
    }
    ,
    BreakerSprite: class extends self.ISpriteInstance {
    }
    ,
    blick_1: class extends self.ISpriteInstance {
    }
    ,
    MotionBlurEffect: class extends self.ISpriteInstance {
    }
    ,
    Whirlwind: class extends self.ISpriteInstance {
    }
    ,
    blood: class extends self.ISpriteInstance {
    }
    ,
    TiledBackground8: class extends self.ITiledBackgroundInstance {
    }
    ,
    snowball: class extends self.ISpriteInstance {
    }
    ,
    pattern_2: class extends self.ISpriteInstance {
    }
    ,
    effect_exp_5: class extends self.ISpriteInstance {
    }
    ,
    effect_exp_6: class extends self.ISpriteInstance {
    }
    ,
    Sprite44: class extends self.ISpriteInstance {
    }
    ,
    effect_exp_7: class extends self.ISpriteInstance {
    }
    ,
    effect_exp_8: class extends self.ISpriteInstance {
    }
    ,
    effect_exp_9: class extends self.ISpriteInstance {
    }
    ,
    effect_exp_10: class extends self.ISpriteInstance {
    }
    ,
    shadow_dust: class extends self.ISpriteInstance {
    }
    ,
    TeleportSlamSpriteAnimation: class extends self.ISpriteInstance {
    }
    ,
    Bone: class extends self.ISpriteInstance {
    }
    ,
    TeleportSlamBlendSprite: class extends self.ISpriteInstance {
    }
    ,
    effect_exp_11: class extends self.ISpriteInstance {
    }
    ,
    effect_exp_12: class extends self.ISpriteInstance {
    }
    ,
    effect_exp_13: class extends self.ISpriteInstance {
    }
    ,
    effect_meteor_exp: class extends self.ISpriteInstance {
    }
    ,
    Button_1: class extends self.ISpriteInstance {
    }
    ,
    Button1: class extends self.ISpriteInstance {
    }
    ,
    IconAttack: class extends self.ISpriteInstance {
    }
    ,
    Joy: class extends self.ISpriteInstance {
    }
    ,
    Stick: class extends self.ISpriteInstance {
    }
    ,
    JoyCollision: class extends self.ISpriteInstance {
    }
    ,
    PauseButton: class extends self.ISpriteInstance {
    }
    ,
    Button2: class extends self.ISpriteInstance {
    }
    ,
    Button3: class extends self.ISpriteInstance {
    }
    ,
    Joy2_Education: class extends self.ISpriteInstance {
    }
    ,
    Button4: class extends self.ISpriteInstance {
    }
    ,
    braid_blur: class extends self.ISpriteInstance {
    }
    ,
    Sprite21: class extends self.ISpriteInstance {
    }
    ,
    Powerball: class extends self.ISpriteInstance {
    }
    ,
    Sprite23: class extends self.ISpriteInstance {
    }
    ,
    RedArrowImage: class extends self.ISpriteInstance {
    }
    ,
    Sickle: class extends self.ISpriteInstance {
    }
    ,
    Sickle_1: class extends self.ISpriteInstance {
    }
    ,
    Ice_Axe_pieces: class extends self.ISpriteInstance {
    }
    ,
    ice_creation_circle: class extends self.ISpriteInstance {
    }
    ,
    ice_image: class extends self.ITiledBackgroundInstance {
    }
    ,
    ice_shard: class extends self.ISpriteInstance {
    }
    ,
    Ice_Sword_pieces: class extends self.ISpriteInstance {
    }
    ,
    Ice_Tackle_Frost1: class extends self.IWorldInstance {
    }
    ,
    Ice_Tackle_Frost2: class extends self.IWorldInstance {
    }
    ,
    Nunchucks: class extends self.ISpriteInstance {
    }
    ,
    Sprite46: class extends self.ISpriteInstance {
    }
    ,
    LordHammerSprite: class extends self.ISpriteInstance {
    }
    ,
    MeteorImage: class extends self.ISpriteInstance {
    }
    ,
    CharacterIcon: class extends self.ISpriteInstance {
    }
    ,
    CircleSelecter: class extends self.ISpriteInstance {
    }
    ,
    _9patchHP_loy: class extends self.IWorldInstance {
    }
    ,
    AvatarFonColor: class extends self.ISpriteInstance {
    }
    ,
    barBorder: class extends self.IWorldInstance {
    }
    ,
    Sprite20: class extends self.ISpriteInstance {
    }
    ,
    Sprite3: class extends self.ISpriteInstance {
    }
    ,
    Sprite5: class extends self.ISpriteInstance {
    }
    ,
    Sprite7: class extends self.ISpriteInstance {
    }
    ,
    LOS_Bots: class extends self.ISpriteInstance {
    }
    ,
    _9patch: class extends self.IWorldInstance {
    }
    ,
    LOS_BULLETS: class extends self.ISpriteInstance {
    }
    ,
    XrayTiled: class extends self.ITiledBackgroundInstance {
    }
    ,
    roundImage: class extends self.ISpriteInstance {
    }
    ,
    shadowCharacter: class extends self.ISpriteInstance {
    }
    ,
    shadowText: class extends self.ISpriteInstance {
    }
    ,
    Sprite4: class extends self.ISpriteInstance {
    }
    ,
    K_O: class extends self.ISpriteInstance {
    }
    ,
    GradientsSprite: class extends self.ISpriteInstance {
    }
    ,
    _9patch2: class extends self.IWorldInstance {
    }
    ,
    cloude_1: class extends self.ISpriteInstance {
    }
    ,
    Sprite37: class extends self.ISpriteInstance {
    }
    ,
    Sprite43: class extends self.ISpriteInstance {
    }
    ,
    Sprite11: class extends self.ISpriteInstance {
    }
    ,
    Sprite12: class extends self.ISpriteInstance {
    }
    ,
    Sprite13: class extends self.ISpriteInstance {
    }
    ,
    Sprite14: class extends self.ISpriteInstance {
    }
    ,
    tbScene3: class extends self.ITiledBackgroundInstance {
    }
    ,
    TiledBackground: class extends self.ITiledBackgroundInstance {
    }
    ,
    TiledBackground2: class extends self.ITiledBackgroundInstance {
    }
    ,
    TiledBackground3: class extends self.ITiledBackgroundInstance {
    }
    ,
    TiledBackground4: class extends self.ITiledBackgroundInstance {
    }
    ,
    TiledBackground5: class extends self.ITiledBackgroundInstance {
    }
    ,
    train_mask: class extends self.ISpriteInstance {
    }
    ,
    SVGPicture: class extends self.ISVGPictureInstance {
    }
    ,
    Sprite: class extends self.ISpriteInstance {
    }
    ,
    Sprite45: class extends self.ISpriteInstance {
    }
    ,
    Sprite47: class extends self.ISpriteInstance {
    }
    ,
    Sprite48: class extends self.ISpriteInstance {
    }
    ,
    Sprite49: class extends self.ISpriteInstance {
    }
    ,
    Sprite50: class extends self.ISpriteInstance {
    }
    ,
    Sprite51: class extends self.ISpriteInstance {
    }
    ,
    stone: class extends self.ISpriteInstance {
    }
    ,
    TiledBackground12: class extends self.ITiledBackgroundInstance {
    }
    ,
    campfire: class extends self.ISpriteInstance {
    }
    ,
    fire_campfire: class extends self.ISpriteInstance {
    }
    ,
    light_fire_campfire: class extends self.ISpriteInstance {
    }
    ,
    Sprite15: class extends self.ISpriteInstance {
    }
    ,
    Sprite19: class extends self.ISpriteInstance {
    }
    ,
    Sprite22: class extends self.ISpriteInstance {
    }
    ,
    Sprite24: class extends self.ISpriteInstance {
    }
    ,
    Sprite25: class extends self.ISpriteInstance {
    }
    ,
    Sprite8: class extends self.ISpriteInstance {
    }
    ,
    TiledBackground7: class extends self.ITiledBackgroundInstance {
    }
    ,
    _9patch3: class extends self.IWorldInstance {
    }
    ,
    ParticlesSnow: class extends self.IParticlesInstance {
    }
    ,
    WaterNode: class extends self.ISpriteInstance {
    }
    ,
    WaterTiled: class extends self.ITiledBackgroundInstance {
    }
    ,
    Sprite28: class extends self.ISpriteInstance {
    }
    ,
    Sprite29: class extends self.ISpriteInstance {
    }
    ,
    Sprite30: class extends self.ISpriteInstance {
    }
    ,
    Sprite31: class extends self.ISpriteInstance {
    }
    ,
    TiledBackground9: class extends self.ITiledBackgroundInstance {
    }
    ,
    Sprite32: class extends self.ISpriteInstance {
    }
    ,
    Sprite33: class extends self.ISpriteInstance {
    }
    ,
    Sprite34: class extends self.ISpriteInstance {
    }
    ,
    Sprite35: class extends self.ISpriteInstance {
    }
    ,
    Sprite36: class extends self.ISpriteInstance {
    }
    ,
    Sprite38: class extends self.ISpriteInstance {
    }
    ,
    Sprite39: class extends self.ISpriteInstance {
    }
    ,
    Sprite40: class extends self.ISpriteInstance {
    }
    ,
    Sprite41: class extends self.ISpriteInstance {
    }
    ,
    Sprite42: class extends self.ISpriteInstance {
    }
    ,
    Sprite27: class extends self.ISpriteInstance {
    }
    ,
    tbScene5: class extends self.ITiledBackgroundInstance {
    }
    ,
    TiledBackground10: class extends self.ITiledBackgroundInstance {
    }
    ,
    TiledBackground13: class extends self.ITiledBackgroundInstance {
    }
    ,
    Sprite2: class extends self.ISpriteInstance {
    }
    ,
    Sprite9: class extends self.ISpriteInstance {
    }
    ,
    Sprite10: class extends self.ISpriteInstance {
    }
    ,
    Sprite52: class extends self.ISpriteInstance {
    }
    ,
    Sprite53: class extends self.ISpriteInstance {
    }
    ,
    TiledBackground14: class extends self.ITiledBackgroundInstance {
    }
    ,
    BlendMaskScene6: class extends self.ISpriteInstance {
    }
    ,
    TiledBackground15: class extends self.ITiledBackgroundInstance {
    }
    ,
    Sprite54: class extends self.ISpriteInstance {
    }
    ,
    Sprite55: class extends self.ISpriteInstance {
    }
    ,
    Sprite56: class extends self.ISpriteInstance {
    }
    ,
    TiledBackground16: class extends self.ITiledBackgroundInstance {
    }
    ,
    Sprite57: class extends self.ISpriteInstance {
    }
    ,
    Sprite58: class extends self.ISpriteInstance {
    }
    ,
    Sprite59: class extends self.ISpriteInstance {
    }
    ,
    Sprite60: class extends self.ISpriteInstance {
    }
    ,
    TiledBackground17: class extends self.ITiledBackgroundInstance {
    }
    ,
    Sprite67: class extends self.ISpriteInstance {
    }
    ,
    Sprite71: class extends self.ISpriteInstance {
    }
    ,
    Sprite72: class extends self.ISpriteInstance {
    }
    ,
    Sprite74: class extends self.ISpriteInstance {
    }
    ,
    Sprite63: class extends self.ISpriteInstance {
    }
    ,
    Sprite64: class extends self.ISpriteInstance {
    }
    ,
    Sprite65: class extends self.ISpriteInstance {
    }
    ,
    Sprite66: class extends self.ISpriteInstance {
    }
    ,
    TiledBackground6: class extends self.ITiledBackgroundInstance {
    }
    ,
    Sprite68: class extends self.ISpriteInstance {
    }
    ,
    Sprite69: class extends self.ISpriteInstance {
    }
    ,
    Sprite70: class extends self.ISpriteInstance {
    }
    ,
    GROUND: class extends self.ISpriteInstance {
    }
    ,
    GameManager: class extends self.ISpriteInstance {
    }
    ,
    Anchor: class extends self.ISpriteInstance {
    }
    ,
    Player: class extends self.ISpriteInstance {
    }
    ,
    bg_tiled: class extends self.ITiledBackgroundInstance {
    }
    ,
    Text: class extends self.ISpriteFontInstance {
    }
    ,
    text_box: class extends self.ISpriteInstance {
    }
    ,
    damage_radius: class extends self.ISpriteInstance {
    }
    ,
    cam: class extends self.ISpriteInstance {
    }
    ,
    BulletWeapons: class extends self.ISpriteInstance {
    }
    ,
    damage_radius_weapons: class extends self.ISpriteInstance {
    }
    ,
    BOX_TOTAL_DAMAGE: class extends self.ISpriteInstance {
    }
    ,
    COMBO_DAMAGE_HIT: class extends self.ISpriteInstance {
    }
    ,
    active_radius_special: class extends self.ISpriteInstance {
    }
    ,
    CharacterTrack: class extends self.IDrawingCanvasInstance {
    }
    ,
    loader_box: class extends self.ISpriteInstance {
    }
    ,
    index_load_character_progress_bar: class extends self.ITiledBackgroundInstance {
    }
    ,
    Pattern_7: class extends self.ITiledBackgroundInstance {
    }
    ,
    CharacterMarkerSelectTween: class extends self.ISpriteInstance {
    }
    ,
    Fade_1: class extends self.ISpriteInstance {
    }
    ,
    Blick_5: class extends self.ISpriteInstance {
    }
    ,
    Fade_2: class extends self.ITiledBackgroundInstance {
    }
    ,
    ButtonSetting: class extends self.ISpriteInstance {
    }
    ,
    Patern_Button: class extends self.ITiledBackgroundInstance {
    }
    ,
    Sprite61: class extends self.ISpriteInstance {
    }
    ,
    lord_hammer_effect1: class extends self.ISpriteInstance {
    }
    ,
    Panel: class extends self.IWorldInstance {
    }
    ,
    TiledBackground11: class extends self.ITiledBackgroundInstance {
    }
    ,
    ButtonSetting2: class extends self.ISpriteInstance {
    }
    ,
    tb_fon: class extends self.ITiledBackgroundInstance {
    }
    ,
    LockedSprite: class extends self.ISpriteInstance {
    }
    ,
    Sprite6: class extends self.ISpriteInstance {
    }
    ,
    _9patch4: class extends self.IWorldInstance {
    }
    ,
    Sprite26: class extends self.ISpriteInstance {
    }
    ,
    Sprite62: class extends self.ISpriteInstance {
    }
    ,
    TiledBackground18: class extends self.ITiledBackgroundInstance {
    }
    ,
    rf_but: class extends self.ISpriteInstance {
    }
    ,
    BlendTiled: class extends self.ITiledBackgroundInstance {
    }
    ,
    LoaderSprite: class extends self.ISpriteInstance {
    }
    ,
    Sprite73: class extends self.ISpriteInstance {
    }
    ,
    Sprite75: class extends self.ISpriteInstance {
    }
    ,
    _9patch5: class extends self.IWorldInstance {
    }
    ,
    _9patchBorder: class extends self.IWorldInstance {
    }
    ,
    TiledEducation: class extends self.ITiledBackgroundInstance {
    }
    ,
    plus: class extends self.ISpriteInstance {
    }
    ,
    EducationBox: class extends self.ISpriteInstance {
    }
    ,
    confetti: class extends self.ISpriteInstance {
    }
    ,
    Sprite76: class extends self.ISpriteInstance {
    }
    ,
    Sprite77: class extends self.ISpriteInstance {
    }
    ,
    EDUCATION_POINTER: class extends self.ISpriteInstance {
    }
    ,
    TiledFonPause: class extends self.ITiledBackgroundInstance {
    }
    ,
    Sprite78: class extends self.ISpriteInstance {
    }
    ,
    Sprite79: class extends self.ISpriteInstance {
    }
    ,
    CharacterPreview: class extends self.ISpriteInstance {
    }
    ,
    LineBlickSprite: class extends self.ISpriteInstance {
    }
    ,
    LineBlickGroup: class extends self.ISpriteInstance {
    }
    ,
    blick_mini: class extends self.ISpriteInstance {
    }
    ,
    Sprite80: class extends self.ISpriteInstance {
    }
    ,
    TiledBackground19: class extends self.ITiledBackgroundInstance {
    }
    ,
    Sprite81: class extends self.ISpriteInstance {
    }
    ,
    TiledBackground20: class extends self.ITiledBackgroundInstance {
    }
    ,
    TiledBackground21: class extends self.ITiledBackgroundInstance {
    }
    ,
    Sprite82: class extends self.ISpriteInstance {
    }
    ,
    Sprite83: class extends self.ISpriteInstance {
    }
    ,
    Sprite84: class extends self.ISpriteInstance {
    }
    ,
    Sprite85: class extends self.ISpriteInstance {
    }
    ,
    Sprite86: class extends self.ISpriteInstance {
    }
    ,
    Sprite17: class extends self.ISpriteInstance {
    }
    ,
    Sprite87: class extends self.ISpriteInstance {
    }
    ,
    _9patch6: class extends self.IWorldInstance {
    }
    ,
    TiledBackground22: class extends self.ITiledBackgroundInstance {
    }
    ,
    Sprite88: class extends self.ISpriteInstance {
    }
    ,
    Sprite89: class extends self.ISpriteInstance {
    }
    ,
    Sprite90: class extends self.ISpriteInstance {
    }
    ,
    Sprite91: class extends self.ISpriteInstance {
    }
    ,
    Sprite92: class extends self.ISpriteInstance {
    }
    ,
    TowersQualityMask: class extends self.ISpriteInstance {
    }
    ,
    Sprite93: class extends self.ISpriteInstance {
    }
    ,
    TowersPlayerPanel: class extends self.ISpriteInstance {
    }
    ,
    progressBarTowers_border: class extends self.IWorldInstance {
    }
    ,
    progressBarTowers_bar: class extends self.IWorldInstance {
    }
    ,
    TiledBackground23: class extends self.ITiledBackgroundInstance {
    }
    ,
    leverLightEffect: class extends self.ISpriteInstance {
    }
    ,
    mode_fight_slot: class extends self.IWorldInstance {
    }
    ,
    lever: class extends self.ISpriteInstance {
    }
    ,
    lever_tween: class extends self.ISpriteInstance {
    }
    ,
    mode_fight_bg_fade: class extends self.ISpriteInstance {
    }
    ,
    mode_fight_border_big: class extends self.IWorldInstance {
    }
    ,
    mode_fight_border: class extends self.IWorldInstance {
    }
    ,
    mode_fight_icon: class extends self.ISpriteInstance {
    }
    ,
    mode_fight_blend: class extends self.ISpriteInstance {
    }
    ,
    mode_fight_icon_box: class extends self.ISpriteInstance {
    }
    ,
    MODE_FIGHT_TEXT_BOX: class extends self.ISpriteInstance {
    }
    ,
    effect_exp_poison_1: class extends self.ISpriteInstance {
    }
    ,
    TiledBackground24: class extends self.ITiledBackgroundInstance {
    }
    ,
    GameManagerMode: class extends self.ISpriteInstance {
    }
    ,
    targetPlayer: class extends self.ISpriteInstance {
    }
    ,
    shadow_text_UI: class extends self.ISpriteInstance {
    }
    ,
    poisonIcon: class extends self.ISpriteInstance {
    }
    ,
    shadow_text_UI_2: class extends self.ISpriteInstance {
    }
    ,
    healBox: class extends self.ISpriteInstance {
    }
    ,
    healImage: class extends self.ISpriteInstance {
    }
    ,
    healImage2: class extends self.ISpriteInstance {
    }
    ,
    Coins: class extends self.ISpriteInstance {
    }
    ,
    Sprite94: class extends self.ISpriteInstance {
    }
    ,
    CharacterTrackFrost: class extends self.IDrawingCanvasInstance {
    }
    ,
    Effect_cricle_1: class extends self.ISpriteInstance {
    }
    ,
    Sprite95: class extends self.ISpriteInstance {
    }
    ,
    Sprite96: class extends self.ISpriteInstance {
    }
    ,
    ButtonControl: class extends self.ISpriteInstance {
    }
    ,
    ButtonSprite: class extends self.ISpriteInstance {
    }
    ,
    TiledLayer: class extends self.ITiledBackgroundInstance {
    }
    ,
    ObjectLayerXray: class extends self.ISpriteInstance {
    }
    ,
    Bullet: class extends self.ISpriteInstance {
    }
    ,
    SpineObject: class extends self.IWorldInstance {
    }
    ,
    Objects: class extends self.ISpriteInstance {
    }
    ,
    tiled_collision_layer: class extends self.ITiledBackgroundInstance {
    }
    ,
    tb_scene_all: class extends self.ITiledBackgroundInstance {
    }
    ,
    Patern: class extends self.ITiledBackgroundInstance {
    }
    ,
    PlayersFamilies: class extends self.ISpriteInstance {
    }
    ,
    BulletMask: class extends self.ISpriteInstance {
    }
    ,
    ScrollObject: class extends self.ISpriteInstance {
    }
    ,
    MODE_FIGHT_ITEM: class extends self.ISpriteInstance {
    }
};
const C3$jscomp$399 = self.C3;
function unaryminus(a) {
    return "number" === typeof a ? -a : a
}
function bothNumbers(a, b) {
    return "number" === typeof a && "number" === typeof b
}
function add$jscomp$4(a, b) {
    return bothNumbers(a, b) ? a + b : a
}
function subtract$jscomp$1(a, b) {
    return bothNumbers(a, b) ? a - b : a
}
function multiply$jscomp$1(a, b) {
    return bothNumbers(a, b) ? a * b : a
}
function divide$jscomp$1(a, b) {
    return bothNumbers(a, b) ? a / b : a
}
function mod$jscomp$1(a, b) {
    return bothNumbers(a, b) ? a % b : a
}
function pow$jscomp$1(a, b) {
    return bothNumbers(a, b) ? Math.pow(a, b) : a
}
function and(a, b) {
    return "string" === typeof a || "string" === typeof b ? ("number" === typeof a ? (Math.round(1E10 * a) / 1E10).toString() : a) + ("number" === typeof b ? (Math.round(1E10 * b) / 1E10).toString() : b) : a && b ? 1 : 0
}
function or(a, b) {
    return bothNumbers(a, b) ? a || b ? 1 : 0 : a
}
self.C3_ExpressionFuncs = [a => {
    const b = a._GetNode(0);
    return () => "pc" === b.ExpObject("device") ? .1 : .5
}
, () => "restart_wait", () => "randomComboPlayer", () => "[\n[50,1],[50,2]\n]", () => "game_config.start_ui_show", () => 1, () => "load_player", () => 0, () => "game_config.towers_scene_on", () => "game_config.add_boss_damage", () => "towers_room.boss_effect", () => "FADE_LAYER", () => 100, () => "lastRoom", () => "Fight", () => "game_config.coins_add_games", () => "CONTROL_LAYER", () => "mode_games", () => "Mode_fight", () => "MODE_FIGHT", () => "MF_FUNCTION", () => "SpineAnimationModeFight", () => "Education", () => "EDUCATION ACTIVE", () => "Towers", () => "towers.select", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4)
      , h = a._GetNode(5)
      , l = a._GetNode(6);
    return () => b.ExpObject("towers_room.win") > c(d.ExpObject(and("towers_array.", e.ExpObject("towers.select"))) - 2) ? Math.ceil(multiply$jscomp$1(divide$jscomp$1(f.ExpObject("towers_room.win"), h.ExpObject(and("towers_array.", l.ExpObject("towers.select")))), 40)) : 0
}
, () => "towers_room.win", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject(and("towers_array.", c.ExpObject("towers.select")))
}
, () => "OpenAds", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("game_config.timescale")
}
, () => "one_launcher", () => "device", () => "mobile", () => "PC_KEY_HELP", () => "TIPS", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() + 2.5
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() - 370
}
, () => "SETTING", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() + 185
}
, () => 256, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b()
}
, () => "Scene 6", () => "BG MAP LAYER TOP", () => "PAUSE", () => "GUI", () => "GUI_FRONT", () => "BUTTON_MOBILE", () => "BUTTOM_GUI", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(0, 0, 0)
}
, () => "BG_TOP", () => -100, () => "", () => "End Round", () => "EndRoundLayer", () => "EFFECT_LAYER", () => "LAYOUT GROUPS", () => "Scene 2", () => "Scene 3", () => "Scene 4", () => 2, () => "BG_BUTTOM2", () => "Scene 5", () => "Scene 7", () => "timer", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("sync_frame_loader_scene")
}
, () => "game_config.timescale", () => "world.gravity", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("world.gravityDefault")
}
, () => "world.fallspeed", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("world.fallspeedDefault")
}
, () => "UID_touch", () => "pause", () => "game_config.end_round_disabled", () => "game_config.create_end_button_next", () => "game_config.fail_player", () => "game_config.end_no_time", () => "EducationBufferInput", () => "education.game.time_stop", () => "start_game", () => "game_config.skipXray", () => "music", () => "EndRound", () => "parametr", () => "MODE_FIGHT_BG", () => "MODE_FIGHT_BLEND", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("UID_touch")
}
, () => "training_end_home", () => "end_round", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("pause")
}
, () => "nextEducation", () => "setting.sound", () => "Menu/ButClick_09", () => "sound", () => "KeySpriteEnd", () => "SOUND", () => "save_yes", a => {
    const b = a._GetNode(0);
    return () => subtract$jscomp$1(1, b.ExpObject("setting.sound"))
}
, () => "MUSIC", () => "setting.music", a => {
    const b = a._GetNode(0);
    return () => subtract$jscomp$1(1, b.ExpObject("setting.music"))
}
, () => "BLOOD_MODE", () => "setting.blood_mode", a => {
    const b = a._GetNode(0);
    return () => subtract$jscomp$1(1, b.ExpObject("setting.blood_mode"))
}
, () => "setting.key_help", a => {
    const b = a._GetNode(0);
    return () => subtract$jscomp$1(1, b.ExpObject("setting.key_help"))
}
, () => "RETURN", () => "Menu/ButClick_07", () => "RESTART", () => "EXIT", () => "towers_room.select_button", () => "towers_room.one_create", () => "EXIT_FAIL", () => "REWARN_END_FAIL_RESTART_ROUND", () => "player_continue_game", () => "NEXT_GAME", () => "CONTROL", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("PAUSE")
}
, () => "game", () => -5, () => "SAVE_CONTROL", () => "Menu/ButClick_08", () => "RESET_CONTROL", () => "Menu/ButClick_06_unlock", () => "CHANCE_CONTROL_PLAYER_MODE", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("LayerOpen.Control_Player")
}
, () => "Menu/ButClick_11", () => "LayerOpen.Control_Player", a => {
    const b = a._GetNode(0);
    return () => b.ExpInstVar_Family()
}
, () => "x_ray.value", () => "game_config.skipStart", () => 4, () => "game_config.dead_heat", () => "Wait_click_skip", () => "skip_animation_win", () => .05, a => {
    const b = a._GetNode(0).GetVar();
    return () => b.GetValue()
}
, () => "Bot Config", () => "Scene 1", () => "character", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject()
}
, () => "none", () => "game_config.total_scene", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod();
    return () => "pc" === b.ExpObject("device") ? c() : .5
}
, () => "StartCreateCharacterGames", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2).GetBoundMethod();
    return () => 1 === b.ExpObject("game_config.round") ? c() / 2 : d() / 2 - 1E3
}
, a => {
    const b = a._GetNode(0);
    return () => "pc" === b.ExpObject("device") ? 653 : 703.9
}
, () => -1, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("setting.bots_level_analysis.win")
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("setting.bots_level_analysis.fail")
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("setting.bots_level_analysis.win_more_50_hp")
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("setting.bots_level_analysis.win_less_50_hp")
}
, () => "OffEffect_4_hits", () => "breaker_active", () => "x_ray.id", () => "x_ray.stade", () => "special_active", () => 99, a => {
    const b = a._GetNode(0);
    return () => "pc" === b.ExpObject("device") ? .8 : 1
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("GUI")
}
, () => "index_sound_punch_hit", () => "First_blood", () => "index_sound_body_fall", () => "danger_active_1", () => "danger_active_2", () => "x_ray.active", () => "game_config.comboPlayID", () => "game_config.index_character_array", () => "game_config.round", () => "X", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b() / 2
}
, () => .5, () => "game_config.players", () => "game_config.musicID", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject(and("game_config.musicIndex.", subtract$jscomp$1(c.ExpObject("game_config.scene_select"), 1)) + ".0")
}
, () => "game_config.musicDB", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject(and("game_config.musicIndex.", subtract$jscomp$1(c.ExpObject("game_config.scene_select"), 1)) + ".1")
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject(and("game_config.musicIndex.", 7) + ".0")
}
, a => {
    const b = a._GetNode(0);
    return () => and("music/bg_music_", b.ExpObject("game_config.musicID"))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => "Education" !== b.ExpObject("mode_games") ? C3$jscomp$399.clamp(c.ExpObject("game_config.musicDB"), -40, -17) : C3$jscomp$399.clamp(d.ExpObject("game_config.musicDB"), -40, 20)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => ("Education" !== b.ExpObject("mode_games") ? C3$jscomp$399.clamp(c.ExpObject("game_config.musicDB"), -40, -17) : C3$jscomp$399.clamp(d.ExpObject("game_config.musicDB"), -40, 20)) - 10
}
, () => .3, () => -300, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("select_character.player_1")
}
, a => {
    const b = a._GetNode(0);
    return () => 0 === b.ExpObject("game_config.players") ? 1 : 0
}
, () => 5, () => "CreateCharacter Timer", () => "education.index", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("select_character.player_2")
}
, a => {
    const b = a._GetNode(0);
    return () => 2 === b.ExpObject("game_config.players") ? 0 : 1
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4)
      , h = a._GetNode(5)
      , l = a._GetNode(6);
    return () => "Education" === b.ExpObject("mode_games") ? 0 : C3$jscomp$399.clamp(0 === c.ExpObject("game_config.players") ? 5 : 0 === d.ExpObject("setting.level_bots") ? add$jscomp$4(e.ExpObject("setting.bots_level_analysis.level_bots"), "Towers" === f.ExpObject("mode_games") ? h.ExpObject(0, 1) : 0) : l.ExpObject("setting.level_bots"), 1, 5)
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("game_config.musicDB")
}
, () => "game_config.max_fps", () => "RestartCreateCharacterGames", () => "game_config.timer", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("game_config.timer_count_max")
}
, () => "parametr.short_round.0", () => "parametr.short_round.1", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("parametr.short_round.0")
}
, () => "visible_button_pause", () => "setting.feedback_review.win", () => "EvE", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => and("bot_level_", 0 === b.ExpObject("setting.level_bots") ? c.ExpObject("setting.bots_level_analysis.level_bots") : d.ExpObject("setting.level_bots"))
}
, () => "game_config.photo_mod", () => "pc", a => {
    const b = a._GetNode(0);
    return () => and("parametr.invisible_fighters.", b.ExpInstVar_Family() - 1)
}
, () => "round_text", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() - 100
}
, () => .2, () => "scaleText", a => {
    const b = a._GetNode(0);
    return () => b.ExpBehavior("scaleText")
}
, a => {
    const b = a._GetNode(0);
    return () => subtract$jscomp$1(1, b.ExpObject("pause"))
}
, () => "game_config.scene_select", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => b.ExpObject("game_config.scene_select") > c.ExpObject("game_config.scene_select_max") ? 1 : add$jscomp$4(d.ExpObject("game_config.scene_select"), 1)
}
, a => {
    const b = a._GetNode(0);
    return () => and("Scene ", b.ExpObject("game_config.scene_select"))
}
, () => "ChanceCharacterMoment", () => "game_config.round_win.0", () => "game_config.round_win.1", a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4);
    return () => b.GetValue() ? c.ExpObject("game_config.scene_select") : d.ExpObject("game_config.scene_select") > e.ExpObject("game_config.scene_select_max") ? 1 : add$jscomp$4(f.ExpObject("game_config.scene_select"), 1)
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject(and("game_config.musicIndex.", 7) + ".1")
}
, () => "PvE", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => 0 === b.ExpObject("one_launcher") ? "2" : c(1, subtract$jscomp$1(d.ExpObject("select_character.max_character"), 1)).toString()
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b(c.ExpObject())
}
, () => 50, () => .1, a => {
    const b = a._GetNode(0);
    return () => "mobile" === b.ExpObject("device") ? 1.1 : 1
}
, () => "waitClickModeFight", () => "EDUCATION SYSTEM", () => "left_top", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() + 800
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() + 100
}
, () => "EDUCATION_NAME_GAME", () => "EDUCATION_NAME_EVENT", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4);
    return () => and(and(and("[color=#" + b.ExpInstVar() + "]", add$jscomp$4(c.ExpObject("education.index"), 1)) + "/", d.ExpObject("education.max")) + " ", e.ExpObject(and("EDUCATION_NAME_ARRAY.", f.ExpObject("education.index")))) + "[/color]"
}
, () => "education.game.KeyboardON", () => "Menu/Fin", a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3);
    return () => C3$jscomp$399.distanceTo(b.GetValue(), c.ExpObject(), d.ExpObject(), e.ExpObject()) / 3E3
}
, () => "GRADIENT_LAYER", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() - 300
}
, () => "Character_create", () => "education_complete", () => "education.game.completeWin", () => "education.game.stade", a => {
    const b = a._GetNode(0);
    return () => subtract$jscomp$1(b.ExpObject("education.max"), 1)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => add$jscomp$4(b() / 2, c(d.ExpInstVar() - 1, -500, 500))
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpInstVar()
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => add$jscomp$4(b() / 2, c(d.ExpInstVar() - 1, 500, -500))
}
, () => "End_Education", a => {
    const b = a._GetNode(0);
    return () => and("training_", add$jscomp$4(b.ExpObject("education.index"), 1))
}
, () => "HELP_KEY_HOLD", () => "EducationBotAttackSpecial_1", () => "EducationHelpKeyBreaker", () => "KEY_A+S+D", () => "KEY_JUMP", () => "down_start", () => "idle", () => "CREATE_CHARACTER_EDUCATION", () => .15, () => "right", () => "KEY_ATTACK", () => 3, () => "SPECIAL_1", () => "SPECIAL_2", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => add$jscomp$4(b() / 2, c(d.ExpInstVar() - 1, -300, 300))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => add$jscomp$4(b() / 2, c(d.ExpInstVar() - 1, 300, -300))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => add$jscomp$4(b() / 2, c(d.ExpInstVar() - 1, 900, -900))
}
, () => "BLOCK", () => "UPPERCAT", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => add$jscomp$4(b() / 2, c(d.ExpInstVar() - 1, -200, 200))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => add$jscomp$4(b() / 2, c(d.ExpInstVar() - 1, 100, -100))
}
, () => "BREAKER", () => .25, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => add$jscomp$4(b() / 2, c(d.ExpInstVar() - 1, -180, 180))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => add$jscomp$4(b() / 2, c(d.ExpInstVar() - 1, 180, -180))
}
, () => "AIR_COMBO_START", () => "MOBILE_ANIMATION", () => "Special_2_1", () => "Special_2_2", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() - 200
}
, () => "PosX", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() - 180
}
, () => .4, () => "specialbutton", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() + 50
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() - 80
}
, () => "Special_2_4", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() - 50
}
, () => 105, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() - 25
}
, () => 90, () => "Coll", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpInstVar() + c.ExpInstVar() / 5
}
, () => "start", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b() / 5
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() + 200
}
, () => "MOVED", () => "Moved_D_1", () => "Moved_D_2", () => "Moved_D_2_Loop", () => .6, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() + 180
}
, () => "JUMP", () => "JUMP_W+D_1", () => 15, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() + 160
}
, () => "PosY", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() - 160
}
, () => "A+A", () => "A+A_Start", () => "A+A_Start_1", () => .17, () => "A+A_Start_2", () => "block_active", () => "block_active_1", () => 1.5, () => "uppercut_hit", () => "uppercut_hit_1", () => "attack", () => "uppercut_hit_2", () => 1.3, () => "KEY_D", () => "distPlayerPlayer", () => 650, () => "W+D", () => "Shake", a => {
    const b = a._GetNode(0);
    return () => "[color=#" + b.ExpInstVar() + "]J[/color]"
}
, () => "HELP_KEY_HOLD_PLAYER", () => "EducationBufferInput.W+D", () => "EducationBufferInput.A+A", () => "EducationBufferInput.block_active", () => "EducationBufferInput.uppercut_hit", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() + 150
}
, () => "shake", () => "education.game.Maxcount", a => {
    const b = a._GetNode(0);
    return () => "mobile" === b.ExpObject("device") ? -70 : 0
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("GUI_FRONT") - 150
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar();
    return () => b("GUI_FRONT") + 300 + c.GetValue()
}
, () => "KEY_EDUCATION", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() + 500
}
, () => "left", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => "[color=#" + b.ExpInstVar() + "]" + ("pc" === c.ExpObject("device") ? "A" : "\u26bd") + "[/color]"
}
, a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1);
    return () => b.GetValue() + c.ExpObject() / 10
}
, () => "center_top", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("GUI_FRONT")
}
, () => "block", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => "[color=#" + b.ExpInstVar() + "]" + ("pc" === c.ExpObject("device") ? "S" : "\u231b") + "[/color]"
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("GUI_FRONT") + 150
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => "[color=#" + b.ExpInstVar() + "]" + ("pc" === c.ExpObject("device") ? "D" : "\ud83d\udd78") + "[/color]"
}
, () => "EducationBufferInput.D", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetVar();
    return () => b("GUI_FRONT") - (365 + ("pc" === c.ExpObject("device") ? 0 : 5)) + d.GetValue()
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() + ("pc" === c.ExpObject("device") ? 50 : 60)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => "[color=#" + b.ExpInstVar() + "]" + ("pc" === c.ExpObject("device") ? "A+A" : "\u26bd+\u26bd") + "[/color]"
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar();
    return () => b("GUI_FRONT") - 170 + c.GetValue()
}
, () => "W+A", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => "[color=#" + b.ExpInstVar() + "]" + ("pc" === c.ExpObject("device") ? "A+W" : "\u2705") + "[/color]"
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar();
    return () => b("GUI_FRONT") + c.GetValue()
}
, () => "W", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => "[color=#" + b.ExpInstVar() + "]" + ("pc" === c.ExpObject("device") ? "W" : "\u269b") + "[/color]"
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar();
    return () => b("GUI_FRONT") + 170 + c.GetValue()
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => "[color=#" + b.ExpInstVar() + "]" + ("pc" === c.ExpObject("device") ? "D+W" : "\u274e") + "[/color]"
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() + 320
}
, () => 1.2, () => "combo_4", () => "EDUCATION_NAME", () => "damage_special_1", a => {
    const b = a._GetNode(0);
    return () => "[color=#" + b.ExpInstVar() + "]K[/color]"
}
, () => "damage_special_2", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() + 60
}
, a => {
    const b = a._GetNode(0);
    return () => "[color=#" + b.ExpInstVar() + "]A+K[/color]"
}
, a => {
    const b = a._GetNode(0);
    return () => "[color=#" + b.ExpInstVar() + "]S[/color]"
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => and("[color=#" + b.ExpInstVar() + "]", c.ExpObject("HOLD")) + "[/color]"
}
, () => "SelfY", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() - 20
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar();
    return () => b("GUI_FRONT") - 150 + c.GetValue()
}
, a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1);
    return () => b.GetValue() + c.ExpObject() / 5
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar();
    return () => b("GUI_FRONT") + 150 + c.GetValue()
}
, () => "ATTACK_BOT", () => "breaker_sprite", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() + 230
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() - 70
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() + 70
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("GUI_FRONT") + 530
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("GUI_FRONT") + 180
}
, () => "00FFFF", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => and("[color=#" + b.ExpInstVar() + "]", c.ExpObject("BREAKER_DESC")) + "[/color]"
}
, () => 1500, () => 500, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() - 550
}
, () => "start2", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() + 250
}
, a => {
    const b = a._GetNode(0);
    return () => "[color=#" + b.ExpInstVar() + "]D+W[/color]"
}
, () => "shake_one", () => .7, a => {
    const b = a._GetNode(0);
    return () => subtract$jscomp$1(b.ExpObject("education.open"), 1)
}
, () => "education.open", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => C3$jscomp$399.clamp(add$jscomp$4(b.ExpObject("education.open"), 1), 0, add$jscomp$4(c.ExpObject("education.max"), 1))
}
, a => {
    const b = a._GetNode(0);
    return () => and("education.completed.", subtract$jscomp$1(b.ExpObject("education.open"), 1))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => C3$jscomp$399.clamp(add$jscomp$4(b.ExpObject("education.index"), 1), 0, subtract$jscomp$1(c.ExpObject("education.max"), 1))
}
, () => "coins", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject(and("education.reward.", c.ExpObject("education.index")))
}
, () => "stop_moved", () => "A", () => "HELP_KEY_FAST_AA", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() - 35
}
, a => {
    const b = a._GetNode(0);
    return () => "mobile" === b.ExpObject("device") ? 400 : 600
}
, () => "combo_1", () => "combo_2", () => "combo_3", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3)
      , f = a._GetNode(4)
      , h = a._GetNode(5).GetBoundMethod()
      , l = a._GetNode(6);
    return () => C3$jscomp$399.clamp(subtract$jscomp$1(b(c.ExpInstVar()), multiply$jscomp$1(300, d(e.ExpInstVar(), 1, -1))), f.ExpObject() / 2, h() - l.ExpObject() / 2)
}
, () => 300, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(142, 255, 128)
}
, () => "not_block", () => 400, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3)
      , f = a._GetNode(4)
      , h = a._GetNode(5).GetBoundMethod()
      , l = a._GetNode(6)
      , m = a._GetNode(7)
      , p = a._GetNode(8).GetBoundMethod()
      , r = a._GetNode(9)
      , v = a._GetNode(10);
    return () => C3$jscomp$399.distanceTo(C3$jscomp$399.clamp(subtract$jscomp$1(b(c.ExpInstVar()), multiply$jscomp$1(300, d(e.ExpInstVar(), 1, -1))), f.ExpObject() / 2, h() - l.ExpObject() / 2), m.ExpObject(), p(r.ExpInstVar()), v.ExpObject()) / 2E3
}
, () => "idle_bot", () => "damage", () => "enemy_combo_2", () => "enemy_combo_3", () => "EducationStopTime", () => "enemy_combo_1", () => "enemy_combo_4", () => "Menu/GetItems", () => 20, () => "education.game.count", a => {
    const b = a._GetNode(0);
    return () => "mobile" === b.ExpObject("device") ? -70 : 150
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("GUI") - 250
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar();
    return () => b("GUI") + 350 + c.GetValue()
}
, () => "inaction", () => 2.5, () => "right_top", () => "ENEMY_JUMP", () => "aircombo_fail", () => "aircombo_1", () => "aircombo_4", a => {
    const b = a._GetNode(0).GetVar();
    return () => "EducationBufferInput." + b.GetValue()
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() + 5
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("education.game.Maxcount")
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => b.ExpObject(and("character.", c.ExpObject(d.ExpInstVar() - 1)) + ".param.fatigue.special_1")
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => and("[color=#" + b.ExpInstVar() + "]", c.ExpObject("KEY_FAST")) + "[/color]"
}
, () => "CheckNextStade", () => "jump_up", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("world.gravity")
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("world.fallspeed")
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() - 500
}
, a => {
    const b = a._GetNode(0);
    return () => .3 + b.ExpObject() / 15
}
, () => "education.game.blocked.moved", () => "education.game.blocked.jump_W_A", () => "education.game.blocked.jump_W", () => "education.game.blocked.jump_W_D", () => "education.game.blocked.jump_DASH", () => "education.game.blocked.dash_down", () => "education.game.blocked.attack", () => "education.game.blocked.special_1", () => "education.game.blocked.special_2", () => "education.game.blocked.breaker", () => "education.game.blocked.block", () => "education.game.blocked.down", () => "education.game.blocked.uppercut", () => "mobile_control", () => "education.game.camera_player", () => "KEY_HELP_CREATE_FIGHT", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4)
      , h = a._GetNode(5).GetVar();
    return () => b.ExpObject(and(and(and("setting.control.button_", c.ExpObject("game_config.players")) + "_player.", d.ExpObject(and("key_help.", e(f.ExpInstVar(), 1, 3)))) + ".", h.GetValue() - 1))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2).GetVar();
    return () => b(c(d.GetValue()))
}
, a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4).GetVar();
    return () => b.GetValue() + "+" + c(d.ExpObject(and(and("setting.control.button_", e.ExpObject("game_config.players")) + "_player.specialbutton.", f.GetValue() - 1)))
}
, a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3)
      , f = a._GetNode(4)
      , h = a._GetNode(5).GetVar();
    return () => b.GetValue() + "+" + c(d(e.ExpObject(and(and("setting.control.button_", f.ExpObject("game_config.players")) + "_player.specialbutton.", h.GetValue() - 1))))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2).GetVar();
    return () => and("[color=#", b(c.GetValue(), "FFFFFF", "FFFFFF")) + "]" + d.GetValue() + "[/color]"
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetVar();
    return () => b.ExpObject() - c.GetValue()
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("key_help")
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4).GetVar();
    return () => b.ExpObject(and(and(and("setting.control.button_", c.ExpObject("game_config.players")) + "_player.", d.ExpObject(and("key_help.", e()))) + ".", f.GetValue() - 1))
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("key_help") - 1
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4).GetVar()
      , h = a._GetNode(5).GetVar()
      , l = a._GetNode(6).GetVar();
    return () => b.ExpObject() - c(d.ExpObject("key_help") / 2) + e() * (f.GetValue() + h.GetValue() + l.GetValue())
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod();
    return () => b.ExpObject(and("key_help.", c()))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3).GetBoundMethod();
    return () => b(c.GetValue(), d(0, 0, 0), e(254, 88, 168))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => C3$jscomp$399.clamp(b.ExpObject() + 35, 128, c.ExpObject() + 35)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4).GetVar();
    return () => b(c.GetValue() + d.ExpObject() / 2) + (3 < e() ? 3 * f.GetValue() : 0)
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("key_help") - 2
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetVar();
    return () => b(c.ExpObject() + d.GetValue())
}
, a => {
    const b = a._GetNode(0);
    return () => "keyboard.x." + b.ExpInstVar()
}
, a => {
    const b = a._GetNode(0);
    return () => "keyboard.w." + b.ExpInstVar()
}
, () => "EDICATION_HELP_TEXT", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => and("[color=#" + b.ExpInstVar() + "]", c.ExpObject(and("HELP_NAME.", 0))) + "[/color]"
}
, () => 550, () => 150, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => b.ExpObject() + c.ExpObject() / 2 + d.ExpObject() / 2 - 45
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => and("[color=#" + b.ExpInstVar() + "]", c.ExpObject(and("HELP_NAME.", 1))) + "[/color]"
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => b.ExpObject() + c.ExpObject() / 2 + d.ExpObject() / 2 - 145
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetVar();
    return () => b.ExpObject(and(and(and("setting.control.button_", c.ExpObject("game_config.players")) + "_player.", d.ExpObject(and("key_help.", 0))) + ".", e.GetValue() - 1))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3);
    return () => divide$jscomp$1(add$jscomp$4(subtract$jscomp$1(b.ExpObject("keyboard.x.A"), divide$jscomp$1(c.ExpObject("keyboard.w.A"), 2)), add$jscomp$4(d.ExpObject("keyboard.x.D"), divide$jscomp$1(e.ExpObject("keyboard.w.D"), 2))), 2)
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() - 190
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject(and("key_help.", 0))
}
, () => "YellowBoxTweenAnimation", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() + 10
}
, () => "TOWER_SYSTEM", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject(0, 0)
}
, a => {
    const b = a._GetNode(0);
    return () => 1200 - ("pc" === b.ExpObject("device") ? 350 : 200)
}
, () => "combo", () => "VOICE", () => "NICE", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() - c.ExpObject() / 2
}
, a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1).GetBoundMethod();
    return () => b.GetValue() + c(50, -50)
}
, a => {
    const b = a._GetNode(0).GetVar();
    return () => b.GetValue() - 100
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => 270 - b(35, -35)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(1E3, 2500)
}
, a => {
    const b = a._GetNode(0);
    return () => subtract$jscomp$1(b.ExpObject("world.gravity"), 1500)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(350, -350)
}
, () => 10, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(1, 2)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4).GetBoundMethod()
      , h = a._GetNode(5).GetBoundMethod()
      , l = a._GetNode(6)
      , m = a._GetNode(7).GetBoundMethod();
    return () => C3$jscomp$399.clamp(b("GUI", "GRADIENT_LAYER", c(d.ExpInstVar()) > e() / 2 ? f("GUI") : h("GUI"), l.ExpObject()), 0, m())
}
, () => 977, () => "CreateNewCharacter", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject(0)
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() + 1
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() - 1
}
, () => 430, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject(0, add$jscomp$4(c.ExpObject("game_config.index_character_array"), 2))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetVar();
    return () => b.ExpObject(and("character.", c.ExpObject(d.GetValue() - 1)) + ".param.consumption_combo")
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4).GetVar()
      , h = a._GetNode(5)
      , l = a._GetNode(6)
      , m = a._GetNode(7).GetVar();
    return () => C3$jscomp$399.clamp(multiply$jscomp$1(divide$jscomp$1(b.ExpInstVar() + 2, c.ExpObject("game_config.max_level_bot")), d.ExpObject(and("character.", e.ExpObject(f.GetValue() - 1)) + ".param.hp")), 0, h.ExpObject(and("character.", l.ExpObject(m.GetValue() - 1)) + ".param.hp"))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => b.ExpInstVar() - c(d.ExpInstVar() / 3)
}
, a => {
    const b = a._GetNode(0).GetVar();
    return () => b.GetValue() - 1
}
, () => "hp", () => 30, () => "O", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod();
    return () => b.ExpObject(c(), 0)
}
, () => "name_character", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetVar()
      , f = a._GetNode(4).GetVar();
    return () => and("[color=#" + b.ExpInstVar() + "]", c.ExpObject(and("character.", d.ExpObject(e.GetValue() - 1)) + ".name." + f.GetValue())) + "[/color]"
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => 1 === b.ExpInstVar() ? c.ExpObject() : d.ExpObject()
}
, a => {
    const b = a._GetNode(0).GetVar();
    return () => and("SpineContainer", b.GetValue())
}
, () => "COLLISION", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() - c.ExpObject() / 2 - 80
}
, a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetVar()
      , e = a._GetNode(3)
      , f = a._GetNode(4)
      , h = a._GetNode(5).GetVar()
      , l = a._GetNode(6).GetVar();
    return () => 2 === b.GetValue() ? and(c.ExpObject("select_character.player_1") === d.GetValue() ? 1 : 0, e.ExpObject("players_skin.player_1") === f.ExpObject("players_skin.player_2") ? 1 : 0) ? 0 : h.GetValue() : l.GetValue()
}
, a => {
    const b = a._GetNode(0);
    return () => 0 === b.ExpObject("one_launcher") ? 0 : 50
}
, () => "BetterOutline", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() - 10
}
, () => 8, () => 7, () => -700, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3);
    return () => C3$jscomp$399.clamp(b.ExpObject(), c.ExpObject() / 2, d() - e.ExpObject() / 2)
}
, () => "Ignor_ShadowBall_Activate", () => "TimeBlock", () => "start_time", () => 2E3, () => "REWARD_TOWERS", () => "towers_room.player_end_towers", () => "towers.progress.win", () => "towers.progress.select", a => {
    const b = a._GetNode(0);
    return () => add$jscomp$4(50, multiply$jscomp$1(25, b.ExpObject("towers.select")))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => 2 < b.ExpObject("setting.level_bots") ? multiply$jscomp$1(25, subtract$jscomp$1(c.ExpObject("setting.level_bots"), 2)) : 0
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("towers_array") - 2
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => and("character_unlocked.", b.ExpObject(add$jscomp$4(c.ExpObject("towers.select"), 2)))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject(add$jscomp$4(c.ExpObject("towers.select"), 2))
}
, a => {
    const b = a._GetNode(0);
    return () => add$jscomp$4(b.ExpObject("towers.select"), 3)
}
, () => "lord", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => and("buy_", b.ExpObject(add$jscomp$4(c.ExpObject("towers.select"), 2)))
}
, a => {
    const b = a._GetNode(0);
    return () => and("towers.open.", b.ExpObject("towers.select"))
}
, a => {
    const b = a._GetNode(0);
    return () => and("unlocked_towers_", b.ExpObject("towers.select"))
}
, a => {
    const b = a._GetNode(0);
    return () => and("towers.open.", add$jscomp$4(b.ExpObject("towers.select"), 1))
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("towers_array")
}
, () => "Total Damage", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => and("statistics.number_hits.", b())
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => and("statistics.total_damage.", b())
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => and("statistics.start_damage_hp.", b())
}
, a => {
    const b = a._GetNode(0);
    return () => and("statistics.number_hits.", b.ExpInstVar() - 1)
}
, a => {
    const b = a._GetNode(0);
    return () => and("statistics.total_damage.", b.ExpInstVar() - 1)
}
, a => {
    const b = a._GetNode(0);
    return () => and("statistics.start_damage_hp.", b.ExpInstVar() - 1)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar();
    return () => b(c.GetValue(), "center_right", "center_left")
}
, () => "destroyTextUICameraDebug", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2).GetVar();
    return () => subtract$jscomp$1(b.ExpObject(), multiply$jscomp$1(600, c(d.GetValue(), -1, 1)))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() - ("pc" === c.ExpObject("device") ? 400 : 300)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar();
    return () => and("BOX_TOTAL_DAMAGE_", b(c.GetValue(), 2, 1))
}
, a => {
    const b = a._GetNode(0);
    return () => "pc" === b.ExpObject("device") ? 2.8 : 5.5
}
, () => "Destroy", () => 25, () => "DAMAGE_COMBO", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar();
    return () => b(c.GetValue(), 2, 1)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetVar();
    return () => and(and("[color=#" + b.ExpInstVar() + "]", c.ExpObject(d.ExpInstVar())) + ": [/color][color=#FF3333]", e.GetValue()) + "%[/color]"
}
, () => .01, () => "StartTotalTween", () => "HIT_COMBO", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetVar();
    return () => and(and("[color=#" + b.ExpInstVar() + "]", c.ExpObject(d.ExpInstVar())) + ": [/color][color=#66CCFF]", e.GetValue()) + "[/color]"
}
, a => {
    const b = a._GetNode(0).GetVar();
    return () => and("statistics.number_hits.", b.GetValue())
}
, a => {
    const b = a._GetNode(0).GetVar();
    return () => and("statistics.total_damage.", b.GetValue())
}
, a => {
    const b = a._GetNode(0).GetVar();
    return () => and("statistics.start_damage_hp.", b.GetValue())
}
, a => {
    const b = a._GetNode(0);
    return () => and("X", b.ExpInstVar())
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3)
      , f = a._GetNode(4).GetBoundMethod()
      , h = a._GetNode(5);
    return () => b(c.ExpInstVar() - 1, d("GUI") + (e.ExpObject() / 3 - 100), f("GUI") - (h.ExpObject() / 3 - 100))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3)
      , f = a._GetNode(4).GetBoundMethod()
      , h = a._GetNode(5);
    return () => b(c.ExpInstVar() - 1, d("GUI") + (e.ExpObject() / 2 + 25), f("GUI") - (h.ExpObject() / 2 + 25))
}
, a => {
    const b = a._GetNode(0);
    return () => and("waitMovePL", b.ExpInstVar())
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3)
      , f = a._GetNode(4).GetBoundMethod()
      , h = a._GetNode(5);
    return () => b(c.ExpInstVar() - 1, d("GUI") - (e.ExpObject() + 25), f("GUI") + (h.ExpObject() + 25))
}
, a => {
    const b = a._GetNode(0);
    return () => "pc" === b.ExpObject("device") ? .5 : .7
}
, () => "End Total Damage", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b(c.ExpInstVar())
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpInstVar() - 1
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject(and("statistics.number_hits.", c.ExpInstVar() - 1))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4);
    return () => b(multiply$jscomp$1(divide$jscomp$1(c.ExpObject(and("statistics.total_damage.", d.ExpInstVar() - 1)), e.ExpObject(and("statistics.start_damage_hp.", f.ExpInstVar() - 1))), 100))
}
, a => {
    const b = a._GetNode(0).GetVar();
    return () => and("statistics.start_damage_hp.", b.GetValue() - 1)
}
, a => {
    const b = a._GetNode(0).GetVar();
    return () => and("statistics.number_hits.", b.GetValue() - 1)
}
, a => {
    const b = a._GetNode(0).GetVar();
    return () => and("statistics.total_damage.", b.GetValue() - 1)
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("CenterPLPL")
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4);
    return () => b.ExpObject() < c(d.ExpObject()) ? e.ExpObject() + 150 : f.ExpObject()
}
, () => "Fade", () => "Pos", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetVar()
      , e = a._GetNode(3);
    return () => C3$jscomp$399.clamp(b.ExpObject(and("combo_hit.scale.", C3$jscomp$399.clamp(c.ExpObject(and("statistics.number_hits.", d.GetValue() - 1)), 0, 6))), .9, 2) / ("pc" === e.ExpObject("device") ? 1.5 : 1)
}
, () => "Scale", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetVar()
      , e = a._GetNode(3);
    return () => divide$jscomp$1(b.ExpObject(and("combo_hit.scale.", C3$jscomp$399.clamp(c.ExpObject(and("statistics.number_hits.", d.GetValue() - 1)), 0, 6) - 1)), "pc" === e.ExpObject("device") ? 1.5 : 1)
}
, () => "COMBO_DAMAGE_HIT", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetVar()
      , e = a._GetNode(3)
      , f = a._GetNode(4)
      , h = a._GetNode(5).GetVar()
      , l = a._GetNode(6)
      , m = a._GetNode(7)
      , p = a._GetNode(8).GetVar()
      , r = a._GetNode(9)
      , v = a._GetNode(10);
    return () => and(and(and(and(and("[color=#", b.ExpObject(and("combo_hit.color.", C3$jscomp$399.clamp(c.ExpObject(and("statistics.number_hits.", d.GetValue() - 1)), 0, 5)))) + "][offsetY=15][scale=", e.ExpObject() + .4) + "]", f.ExpObject(and("statistics.number_hits.", h.GetValue() - 1))) + "[/color][/scale][/offsetY][color=#", l.ExpObject(and("combo_hit.color.", C3$jscomp$399.clamp(m.ExpObject(and("statistics.number_hits.", p.GetValue() - 1)), 0, 6) - 1))) + "] ", r.ExpObject(v.ExpInstVar())) + "[/color]"
}
, () => "UI_PLAYER", () => "game_config.round_count_max", () => "game_config.timer_count_max", () => "count_load_UI", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2).GetBoundMethod();
    return () => "pc" === b.ExpObject("device") ? c() / 25 : d() / 10
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => and("Create UI Player_", b() + 1)
}
, () => "Create UI Player_1", a => {
    const b = a._GetNode(0).GetVar();
    return () => and("Player_", b.GetValue())
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3).GetVar();
    return () => add$jscomp$4(b.ExpObject(), multiply$jscomp$1(c.ExpObject() / 2 + 25, d(e.GetValue() - 1, 1, -1)))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() + (c.ExpObject() / 2 + 30)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3)
      , f = a._GetNode(4)
      , h = a._GetNode(5)
      , l = a._GetNode(6).GetVar()
      , m = a._GetNode(7).GetBoundMethod()
      , p = a._GetNode(8).GetBoundMethod()
      , r = a._GetNode(9)
      , v = a._GetNode(10)
      , x = a._GetNode(11)
      , B = a._GetNode(12).GetVar()
      , A = a._GetNode(13).GetBoundMethod()
      , D = a._GetNode(14).GetBoundMethod()
      , F = a._GetNode(15)
      , I = a._GetNode(16)
      , K = a._GetNode(17)
      , M = a._GetNode(18).GetVar();
    return () => b(c(d(e.ExpObject(and("character.", f.ExpObject(subtract$jscomp$1(h.ExpObject(and("select_character.player_", l.GetValue())), 1))) + ".color_fon"), 0, ",")), m(p(r.ExpObject(and("character.", v.ExpObject(subtract$jscomp$1(x.ExpObject(and("select_character.player_", B.GetValue())), 1))) + ".color_fon"), 1, ",")), A(D(F.ExpObject(and("character.", I.ExpObject(subtract$jscomp$1(K.ExpObject(and("select_character.player_", M.GetValue())), 1))) + ".color_fon"), 2, ",")))
}
, a => {
    const b = a._GetNode(0);
    return () => subtract$jscomp$1(b.ExpObject("select_character.player_1"), 1)
}
, () => 70, () => "fatigue_bar", () => "fatigue_help", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("game_config.round_count_max")
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4).GetVar();
    return () => and("[color=#" + b.ExpInstVar() + "]", c.ExpObject(and("character.", d.ExpObject(subtract$jscomp$1(e.ExpObject(and("select_character.player_", 1)), 1))) + ".name." + f.GetValue())) + "[/color]"
}
, () => "Create UI Player_2", a => {
    const b = a._GetNode(0);
    return () => subtract$jscomp$1(b.ExpObject("select_character.player_2"), 1)
}
, a => {
    const b = a._GetNode(0);
    return () => subtract$jscomp$1(b.ExpObject(0, 0), 1)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetBoundMethod();
    return () => b.ExpObject() + c.ExpObject() + 140 + 110 * d()
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod();
    return () => subtract$jscomp$1(b.ExpObject(0, 3 + c()), 1)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b() + 1
}
, () => "hpText", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3).GetVar()
      , f = a._GetNode(4).GetBoundMethod()
      , h = a._GetNode(5).GetVar()
      , l = a._GetNode(6)
      , m = a._GetNode(7);
    return () => and(and("[color=#" + (b.ExpInstVar() <= c.ExpInstVar() / 4 ? d(e.GetValue(), 1, "|") : f(h.GetValue(), 0, "|")) + "]", l.ExpInstVar()) + "[/color]/", m.ExpInstVar()) + "[/color]"
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpInstVar() / 4
}
, () => "w", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => 75 + C3$jscomp$399.clamp(b.ExpInstVar() / c.ExpInstVar() * 597, 0, 597)
}
, () => "hp_sub", () => "wait_subW", () => "S start", () => 1.1, () => .65, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() + 15
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() - 15
}
, () => "wait", () => "S end", () => .29999999999999993, () => "UpdateHpText", () => 1.9, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => 1 === b.ExpInstVar() ? c.ExpObject() + 240 : d.ExpObject() - 240
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4)
      , h = a._GetNode(5).GetVar();
    return () => and("[color=#" + b.ExpInstVar() + "]", c.ExpObject(and("character.", d.ExpObject(subtract$jscomp$1(e.ExpObject(and("select_character.player_", f.ExpInstVar())), 1))) + ".name." + h.GetValue())) + "[/color]"
}
, () => 672, () => "fatigue", () => 448, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => and(and(b.ExpInstVar(), "/"), c.ExpInstVar())
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => and(and(b(c.ExpBehavior("UpdateHpText")), "/"), d.ExpInstVar())
}
, () => "ROUND_SYSTEM", a => {
    const b = a._GetNode(0).GetVar();
    return () => and("game_config.round_win.", b.GetValue())
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod();
    return () => b.ExpObject(and("game_config.round_win.", c()))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(4, 255, 0)
}
, () => "game_config.start_character", () => "select_character.player_2", () => "select_character.player_1", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => b(c(1, add$jscomp$4(d.ExpObject("select_character.max_character"), 1)))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => 3 <= b.ExpObject("game_config.round") ? 1 : add$jscomp$4(c.ExpObject("game_config.round"), 1)
}
, () => "PvP", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject(and("towers_array.", c.ExpObject("towers.select"))) + 1
}
, () => "ROUND_START_ANIMATION", () => "electro_start", () => "electro_hit", () => "grom_voice", () => "LordHahaStart", () => "Skip_system", () => "FadeBGROUND", () => "W1", () => 600, () => "S", () => "round", a => {
    const b = a._GetNode(0);
    return () => and("ROUND_", b.ExpObject("game_config.round"))
}
, () => -9, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() - 150
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => and(and("[offsetY=-30][color=#" + b.ExpInstVar() + "]", c.ExpObject("ROUND")) + "[/offsetY][/color] [offsetY=-5][scale=1.4][color=#FFFFFF]", d.ExpObject("game_config.round")) + "[/color]"
}
, () => "RoundEnd", a => {
    const b = a._GetNode(0);
    return () => "Mode_fight" === b.ExpObject("mode_games") ? .4 : 1
}
, () => "OpacityFade", a => {
    const b = a._GetNode(0);
    return () => 1 === b.ExpObject("game_config.skipStart") ? .4 : .8
}
, () => 140, () => "W2", () => 700, () => 200, () => .45, () => "parametr.invisible_fighters.0", () => "parametr.invisible_fighters.1", () => "Nunchucks_Whoosh", () => "FIGHT", () => -7, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => and("[color=#" + b.ExpInstVar() + "]", c.ExpObject("FIGHT")) + "[/color]"
}
, () => "Create Character", () => "Player", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject(and("x_ray.xray_character.", c.ExpInstVar() - 1))
}
, a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4).GetVar()
      , h = a._GetNode(5)
      , l = a._GetNode(6)
      , m = a._GetNode(7).GetVar();
    return () => C3$jscomp$399.clamp(multiply$jscomp$1(divide$jscomp$1(b.GetValue() + 2, c.ExpObject("game_config.max_level_bot")), d.ExpObject(and("character.", e.ExpObject(f.GetValue() - 1)) + ".param.hp")), 0, h.ExpObject(and("character.", l.ExpObject(m.GetValue() - 1)) + ".param.hp"))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3)
      , f = a._GetNode(4).GetBoundMethod()
      , h = a._GetNode(5).GetBoundMethod()
      , l = a._GetNode(6);
    return () => "Mode_fight" !== b.ExpObject("mode_games") ? add$jscomp$4(c() / 2, d(e.ExpInstVar() - 1, -500, 500)) : add$jscomp$4(f() / 2, h(l.ExpInstVar() - 1, -1150, 1150))
}
, a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2).GetBoundMethod();
    return () => 1 === b.GetValue() ? c(65, 255, 51) : d(255, 102, 102)
}
, a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2).GetBoundMethod();
    return () => 1 === b.GetValue() ? c(65, 255, 51) : d(255, 51, 51)
}
, a => {
    const b = a._GetNode(0).GetVar();
    return () => 1 === b.GetValue() ? 1.5 : 1
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetVar();
    return () => b.ExpObject(and("character.", c.ExpObject(d.GetValue() - 1)) + ".param.hp")
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => b.ExpInstVar() - c(d.ExpInstVar() / 5)
}
, () => 35, () => 250, a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4)
      , h = a._GetNode(5).GetVar()
      , l = a._GetNode(6).GetVar();
    return () => 2 === b.GetValue() ? and(c.ExpObject("select_character.player_1") === d.ExpObject("select_character.player_2") ? 1 : 0, e.ExpObject("players_skin.player_1") === f.ExpObject("players_skin.player_2") ? 1 : 0) ? 0 : h.GetValue() : l.GetValue()
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() + 25
}
, () => 1E3, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("defense", "attack")
}
, () => "center_button", () => 1150, () => -150, a => {
    const b = a._GetNode(0);
    return () => "Education" === b.ExpObject("mode_games") ? .1 : .7
}
, () => "TIMER", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3).GetVar()
      , f = a._GetNode(4).GetBoundMethod()
      , h = a._GetNode(5).GetVar()
      , l = a._GetNode(6)
      , m = a._GetNode(7);
    return () => and("[color=#" + (b.ExpObject("game_config.timer") > c.GetValue() ? d(e.GetValue(), 0, "|") : f(h.GetValue(), mod$jscomp$1(l.ExpObject("game_config.timer"), 2), "|")) + "]", m.ExpObject("game_config.timer")) + "[/color]"
}
, () => "EndGameNoTime", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(2)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(1)
}
, () => "END PANEL DEAD HEAT", () => "DRAW", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("GUI_FRONT") + 200
}
, () => "FLAWLESS_VICTORY", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => and("[color=#" + b.ExpInstVar() + "]", c.ExpObject("DRAW")) + "[/color]"
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() + c.ExpObject() / 2
}
, () => "GameSound/Character/Hero/Lord/lord_haha_start_2", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => and("[color=#" + b.ExpInstVar() + "]", c.ExpObject("RESTART_FIGHT")) + "[/color]"
}
, () => "Menu/ButClick_01", () => "NextRound End ver", () => "END PANEL WIN", () => "REWARD_END_FIGHT", () => "COINS_LAYER", () => "Menu/Coins_2", () => "COINS_ITEM", a => {
    const b = a._GetNode(0).GetVar();
    return () => b.GetValue() - 220
}
, () => 110, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetVar();
    return () => and("[color=#" + b.ExpInstVar() + "]+", c.GetValue()) + "[/color]"
}
, () => "UpdateCoins", () => "WIN", () => "CREATE_NEXT_BUTTON", a => {
    const b = a._GetNode(0).GetVar();
    return () => 0 === b.GetValue() ? .1 : .7
}
, a => {
    const b = a._GetNode(0).GetVar();
    return () => 0 === b.GetValue() ? .1 : .9
}
, () => "NextRound", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("GUI_FRONT") - 230
}
, () => "right_button", () => "Menu/Clean_1", () => "Menu/Coins_1", () => -2, () => "OpenCoinsPanel", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("PAUSE") - 50
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("PAUSE") - 150
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("game_config.coins_add_games")
}
, () => "END PANEL FAIL", () => "OpenPanelFail", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("End Round")
}
, a => {
    const b = a._GetNode(0).GetVar();
    return () => b.GetValue() + 25
}
, () => 75, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("End Round") + 200
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => and("[color=#" + b.ExpInstVar() + "]", c.ExpObject("CONTINUE_DESC")) + "[/color]"
}
, () => "FAIL", () => .8, () => "REWARN_END_FAIL_RESTART_ROUND_CREATE", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("End Round") + 250
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b("End Round") - ("mobile" === c.ExpObject("device") ? 150 : 0)
}
, () => "ARROW_CHECK", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() + 30
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3)
      , f = a._GetNode(4);
    return () => b("COLLISION", "End Round", add$jscomp$4(c.ExpObject(), multiply$jscomp$1(50, d(e.ExpInstVar(), 1, -1))), f.ExpObject())
}
, () => "draw_reward_ad", () => "PLAYER_CONTINUE_START", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() - 450
}
, () => "Brightness", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => add$jscomp$4(b.ExpObject(), multiply$jscomp$1(75, c(d.ExpInstVar(), 1, -1)))
}
, () => 4.5, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => (b.ExpObject_InstExpr(0) + c.ExpObject_InstExpr(1)) / 2
}
, () => "zoom2", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("COLLISION")
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("COLLISION") - .1
}
, a => {
    const b = a._GetNode(0);
    return () => C3$jscomp$399.clamp(b.ExpObject(), 0, 978)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3);
    return () => C3$jscomp$399.clamp(add$jscomp$4(b.ExpObject("setting.bots_level_analysis.level_bots"), "Towers" === c.ExpObject("mode_games") ? d.ExpObject(0, 1) : 0), 1, e.ExpInstVar())
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b(c.ExpInstVar() - 1, 2, 1)
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() - 250
}
, () => "UP+D", () => "SPAWN", () => "flight", () => "punch", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b(c.ExpInstVar() / 2)
}
, () => "jump_front", () => "jump_back", () => -1E3, a => {
    const b = a._GetNode(0);
    return () => C3$jscomp$399.clamp(b.ExpObject("game_config.musicDB"), -40, 20)
}
, () => "END Round", () => "System Reset Idle", () => "StopForwardDash", () => "StopSpecial", () => "StartAnimationWin", () => "win", () => "PLAYERCHECKENDROUND", () => "CreateWinText", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetVar();
    return () => and("PvP" !== b.ExpObject("mode_games") ? 1 : 0, "EvE" !== c.ExpObject("mode_games") ? 1 : 0) ? "Towers" === d.ExpObject("mode_games") ? 10 : e.GetValue() ? 2 : 5 : 0
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(227, 57, 36)
}
, a => {
    const b = a._GetNode(0).GetVar();
    return () => b.GetValue() + 50
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => and("PvP" !== b.ExpObject("mode_games") ? 1 : 0, "EvE" !== c.ExpObject("mode_games") ? 1 : 0) ? (d.ExpObject("mode_games"),
    5) : 0
}
, () => "fail", () => "start_time_end_round", a => {
    const b = a._GetNode(0).GetVar();
    return () => b.GetValue() ? 1 : 1.4
}
, () => "WinText", () => "gradientGame4", () => -20, () => -30, a => {
    const b = a._GetNode(0).GetVar();
    return () => b.GetValue() + 500
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar();
    return () => b(c.GetValue(), 15, 345)
}
, () => "K.O", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => add$jscomp$4(b.ExpObject(), multiply$jscomp$1(950, c(d.ExpInstVar(), 1, -1)))
}
, () => "win_text", a => {
    const b = a._GetNode(0);
    return () => 1.5 * b.ExpObject()
}
, () => 2.1, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => add$jscomp$4(b.ExpObject(), multiply$jscomp$1(700, c(d.ExpInstVar(), 1, -1)))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => and("[color=#" + b.ExpInstVar() + "]", c.ExpObject("WIN")) + "[/color]"
}
, () => "max", () => "BG_BUTTOM", () => "GameSound/Character/End_Round/End_Round_1", () => -10, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3).GetBoundMethod();
    return () => b.ExpObject() + (345 === c.ExpObject() ? 7 - Math.pow(.1, d()) : -(7 - Math.pow(.1, e())))
}
, () => .03, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod();
    return () => b.ExpObject() - c(50, -50)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(255, 255, 255)
}
, () => 970, () => "gradientGame2", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("COLLISION") + .3
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => add$jscomp$4(b.ExpObject(), multiply$jscomp$1(200, c(d.ExpInstVar(), 1, -1)))
}
, () => "PosEnemyCam", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() + 1500
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("towers_room.win")
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b(c.ExpInstVar() / 1.5)
}
, () => "setting.bots_level_analysis.fail_count", () => "ShakeCount.X", () => "ShakeCount.Y", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b() / 2 + ("pc" === c.ExpObject("device") ? 0 : 100)
}
, () => "min", () => "ShakeY", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2)
      , e = a._GetNode(3);
    return () => b.ExpObject() - c(d.ExpInstVar() - 40, -(e.ExpInstVar() - 40))
}
, () => "ShakeX", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2)
      , e = a._GetNode(3);
    return () => b.ExpObject() + c(d.ExpInstVar(), -e.ExpInstVar())
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => (b.ExpObject_InstExpr(0) + c.ExpObject_InstExpr(1)) / 2 - ("pc" === d.ExpObject("device") ? 200 : 100)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2)
      , e = a._GetNode(3);
    return () => b.ExpObject() + c(d.ExpInstVar() - 40, -(e.ExpInstVar() - 40))
}
, () => "Camera", a => {
    const b = a._GetNode(0);
    return () => "pc" === b.ExpObject("device") ? -100 : 50
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetVar();
    return () => b.ExpObject() + c.GetValue()
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => b.ExpObject_InstExpr(c(d.ExpObject(), 1, 2)) + 25
}
, () => "Immobilized", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => b.ExpObject_InstExpr(c(d.ExpObject(), 1, 2)) - 25
}
, () => "back_specialbutton", () => "CenterPLPL", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4);
    return () => b(C3$jscomp$399.distanceTo(c.ExpObject_InstExpr(0), d.ExpObject_InstExpr(0), e.ExpObject_InstExpr(1), f.ExpObject_InstExpr(1)))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => (b.ExpObject_InstExpr(0) + c.ExpObject_InstExpr(1)) / 2 - ("pc" === d.ExpObject("device") ? 350 : 300)
}
, () => "Sprite And Tiled Pos/Size", () => "gradientGame", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b(c.ExpObject()) + 100
}
, () => "bg_image", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4);
    return () => b.ExpObject() / 2 - c("GUI", "COLLISION", d("GUI"), e("GUI")) - f.ExpInstVar()
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetBoundMethod();
    return () => C3$jscomp$399.distanceTo(b.ExpObject(), c.ExpObject(), d.ExpObject(), e("COLLISION"))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4);
    return () => b.ExpObject() / 2 + c("GUI", "COLLISION", d("GUI"), e("GUI")) + f.ExpInstVar()
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4)
      , h = a._GetNode(5);
    return () => (b.ExpObject() / 2 - c("GUI", "COLLISION", d("GUI"), e("GUI")) - f.ExpInstVar()) / (h.ExpObject() / 100)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetVar()
      , f = a._GetNode(4);
    return () => b("GUI", "GRADIENT_LAYER", c("GUI") - (d.ExpObject() / 2 - e.GetValue()), f.ExpObject())
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetVar()
      , f = a._GetNode(4);
    return () => b("GUI", "GRADIENT_LAYER", c("GUI") + (d.ExpObject() / 2 - e.GetValue()), f.ExpObject())
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetVar()
      , e = a._GetNode(3).GetBoundMethod();
    return () => C3$jscomp$399.lerp(b(), c.ExpObject() + d.GetValue(), 1 - Math.pow(.01, e()))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetBoundMethod();
    return () => C3$jscomp$399.lerp(b(), c.ExpObject(), 1 - Math.pow(.01, d()))
}
, () => "zoom", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4)
      , h = a._GetNode(5)
      , l = a._GetNode(6);
    return () => .5 > b.ExpObject("start_game") ? .85 : 0 === c.ExpObject("game_config.photo_mod") ? "mobile" === d.ExpObject("device") ? or(or(or(7 === e.ExpObject("select_character.player_1") ? 1 : 0, 8 === f.ExpObject("select_character.player_1") ? 1 : 0), 7 === h.ExpObject("select_character.player_2") ? 1 : 0), 8 === l.ExpObject("select_character.player_2") ? 1 : 0) ? .7 : .85 : .65 : 1.25
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4)
      , h = a._GetNode(5);
    return () => 0 === b.ExpObject("game_config.photo_mod") ? "mobile" === c.ExpObject("device") ? or(or(or(7 === d.ExpObject("select_character.player_1") ? 1 : 0, 8 === e.ExpObject("select_character.player_1") ? 1 : 0), 7 === f.ExpObject("select_character.player_2") ? 1 : 0), 8 === h.ExpObject("select_character.player_2") ? 1 : 0) ? .7 : .85 : .65 : 1.25
}
, () => "mode_fight_slot.start", () => "BG_BUTTOM3", () => "BG_BUTTOM4", () => "BG_BUTTOM5", () => "TeleportSlam_Layer_1", () => "TeleportSlam_Layer_2", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2).GetBoundMethod();
    return () => C3$jscomp$399.lerp(b("BG MAP LAYER TOP"), c.GetValue(), 1 - Math.pow(.01, d()))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2).GetBoundMethod();
    return () => C3$jscomp$399.lerp(b("BG_TOP"), c.GetValue(), 1 - Math.pow(.01, d()))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2).GetBoundMethod();
    return () => C3$jscomp$399.lerp(b("COLLISION"), c.GetValue(), 1 - Math.pow(.01, d()))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2).GetBoundMethod();
    return () => C3$jscomp$399.lerp(b("GRADIENT_LAYER"), c.GetValue(), 1 - Math.pow(.01, d()))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2).GetBoundMethod();
    return () => C3$jscomp$399.lerp(b("BG_BUTTOM"), c.GetValue(), 1 - Math.pow(.01, d()))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2).GetBoundMethod();
    return () => C3$jscomp$399.lerp(b("BG_BUTTOM2"), c.GetValue(), 1 - Math.pow(.01, d()))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2).GetBoundMethod();
    return () => C3$jscomp$399.lerp(b("BG_BUTTOM3"), c.GetValue(), 1 - Math.pow(.01, d()))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2).GetBoundMethod();
    return () => C3$jscomp$399.lerp(b("BG_BUTTOM4"), c.GetValue(), 1 - Math.pow(.01, d()))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2).GetBoundMethod();
    return () => C3$jscomp$399.lerp(b("BG_BUTTOM5"), c.GetValue(), 1 - Math.pow(.01, d()))
}
, () => "targetScale", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2).GetBoundMethod();
    return () => C3$jscomp$399.lerp(b("TeleportSlam_Layer_1"), c.GetValue(), 1 - Math.pow(.01, d()))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2).GetBoundMethod();
    return () => C3$jscomp$399.lerp(b("TeleportSlam_Layer_2"), c.GetValue(), 1 - Math.pow(.01, d()))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2).GetBoundMethod();
    return () => C3$jscomp$399.lerp(b("EFFECT_LAYER"), c.GetValue(), 1 - Math.pow(.01, d()))
}
, () => "jump", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("COLLISION") - .05
}
, () => "fall", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("targetScale")
}
, a => {
    const b = a._GetNode(0);
    return () => subtract$jscomp$1(b.ExpObject("targetScale"), .1)
}
, a => {
    const b = a._GetNode(0);
    return () => add$jscomp$4(b.ExpObject("targetScale"), .1)
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("game_config.max_fps")
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("game_config.limit_fps")
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpBehavior("zoom")
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpBehavior("zoom2")
}
, () => "Pos_Hit", () => "Pos_Character", () => "Joy(control)", () => "pos", () => "BreakerShake", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(214, 214, 214)
}
, () => "Drag", () => "end", () => "xray", () => 65, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3);
    return () => C3$jscomp$399.distanceTo(b.ExpObject(), c.ExpObject(), d.ExpObject(), e.ExpObject())
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() / 4
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3);
    return () => C3$jscomp$399.toDegrees(C3$jscomp$399.angleTo(b.ExpObject(), c.ExpObject(), d.ExpObject(), e.ExpObject()))
}
, () => "InputOld_ID", a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2).GetVar();
    return () => Math.floor((0 > b.GetValue() ? c.GetValue() + 360 + 22.5 : d.GetValue() + 22.5) / 45) % 8
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4)
      , h = a._GetNode(5).GetBoundMethod()
      , l = a._GetNode(6)
      , m = a._GetNode(7).GetBoundMethod()
      , p = a._GetNode(8)
      , r = a._GetNode(9)
      , v = a._GetNode(10).GetBoundMethod()
      , x = a._GetNode(11)
      , B = a._GetNode(12).GetBoundMethod()
      , A = a._GetNode(13)
      , D = a._GetNode(14);
    return () => b.ExpObject() + Math.cos(C3$jscomp$399.toRadians(C3$jscomp$399.toDegrees(C3$jscomp$399.angleTo(c.ExpObject(), d.ExpObject(), e(f.ExpInstVar(), "BUTTON_MOBILE"), h(l.ExpInstVar(), "BUTTON_MOBILE"))))) * m(C3$jscomp$399.distanceTo(p.ExpObject(), r.ExpObject(), v(x.ExpInstVar(), "BUTTON_MOBILE"), B(A.ExpInstVar(), "BUTTON_MOBILE")), D.ExpObject() / 2 - 25)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4)
      , h = a._GetNode(5).GetBoundMethod()
      , l = a._GetNode(6)
      , m = a._GetNode(7).GetBoundMethod()
      , p = a._GetNode(8)
      , r = a._GetNode(9)
      , v = a._GetNode(10).GetBoundMethod()
      , x = a._GetNode(11)
      , B = a._GetNode(12).GetBoundMethod()
      , A = a._GetNode(13)
      , D = a._GetNode(14);
    return () => b.ExpObject() + Math.sin(C3$jscomp$399.toRadians(C3$jscomp$399.toDegrees(C3$jscomp$399.angleTo(c.ExpObject(), d.ExpObject(), e(f.ExpInstVar(), "BUTTON_MOBILE"), h(l.ExpInstVar(), "BUTTON_MOBILE"))))) * m(C3$jscomp$399.distanceTo(p.ExpObject(), r.ExpObject(), v(x.ExpInstVar(), "BUTTON_MOBILE"), B(A.ExpInstVar(), "BUTTON_MOBILE")), D.ExpObject() / 2 - 25)
}
, () => "JoyInputTimer", () => "D", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4).GetBoundMethod();
    return () => 0 === b.ExpObject("setting.speed_animation") ? or(7 === c.ExpInstVar() ? 1 : 0, 8 === d.ExpInstVar() ? 1 : 0) ? 2700 : 2400 : add$jscomp$4(2E3, multiply$jscomp$1(divide$jscomp$1(e.ExpObject("distPlayerPlayer"), f()), 1E3))
}
, () => 6, () => "Input Buffer", a => {
    const b = a._GetNode(0);
    return () => and("setting.control.button_", b.ExpObject("game_config.players")) + "_player"
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => and("setting.control.buttonID.", b.ExpObject(and("setting.control.button_", c.ExpObject("game_config.players")) + "_player." + d.ExpObject() + ".0"))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => and("setting.control.buttonID.", b.ExpObject(and("setting.control.button_", c.ExpObject("game_config.players")) + "_player." + d.ExpObject() + ".1"))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject(and(and("setting.control.button_", c.ExpObject("game_config.players")) + "_player.S.", 0))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject(and(and("setting.control.button_", c.ExpObject("game_config.players")) + "_player.S.", 1))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod();
    return () => b.ExpObject(and("setting.control.buttonID.", c()))
}
, () => "ForwardDashPlayer", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3).GetVar()
      , f = a._GetNode(4).GetBoundMethod()
      , h = a._GetNode(5);
    return () => b.ExpObject(and(and("setting.control.button_", c.ExpObject("game_config.players")) + "_player." + d(e.GetValue(), f(), "-") + ".", h.ExpInstVar() - 1))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2).GetBoundMethod();
    return () => b(c.GetValue(), d(), "-")
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => b.ExpObject(and(and("setting.control.button_", c.ExpObject("game_config.players")) + "_player.specialbutton.", d.ExpInstVar() - 1))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject(and(and("setting.control.button_", c.ExpObject("game_config.players")) + "_player.attack.", 0))
}
, () => .04, a => {
    const b = a._GetNode(0);
    return () => 1 > b.ExpInstVar() ? 1E3 : 100
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject(and(and("setting.control.button_", 2) + "_player.attack.", 1))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => b.ExpObject(and(and("setting.control.button_", c.ExpObject("game_config.players")) + "_player.W.", d.ExpInstVar() - 1))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => b.ExpObject(and(and("setting.control.button_", c.ExpObject("game_config.players")) + "_player.A.", d.ExpInstVar() - 1))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => b.ExpObject(and(and("setting.control.button_", c.ExpObject("game_config.players")) + "_player.D.", d.ExpInstVar() - 1))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => b.ExpObject(and(and("setting.control.button_", c.ExpObject("game_config.players")) + "_player.attack.", d.ExpInstVar() - 1))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => b.ExpObject(and(and("setting.control.button_", c.ExpObject("game_config.players")) + "_player.specialbutton.", d.ExpInstVar() - 1))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => b.ExpObject(and(and("setting.control.button_", c.ExpObject("game_config.players")) + "_player.breaker.", d.ExpInstVar() - 1))
}
, () => "breaker", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => b.ExpObject(and(and("setting.control.button_", c.ExpObject("game_config.players")) + "_player.S.", d.ExpInstVar() - 1))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod();
    return () => b(c(), 5)
}
, a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetVar()
      , f = a._GetNode(4).GetBoundMethod()
      , h = a._GetNode(5)
      , l = a._GetNode(6).GetVar();
    return () => "D" === b.GetValue() ? c(d.ExpInstVar(), "front", "back") : "A" === e.GetValue() ? f(h.ExpInstVar(), "back", "front") : l.GetValue()
}
, () => "AllowInputBlock", a => {
    const b = a._GetNode(0);
    return () => and("parametr.no_attacks.", b.ExpInstVar() - 1)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("randomComboPlayer")
}
, () => "Wait Air Attack", () => "Wait Active Breaker", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => subtract$jscomp$1(b.ExpObject(0, 1), c.ExpObject(1, 1))
}
, () => 900, () => "blockComboHitSystemPos", () => 3E3, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => subtract$jscomp$1(b(), c.ExpObject(0, 1))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => subtract$jscomp$1(b(), c.ExpObject(1, 1))
}
, () => .35, () => "back", a => {
    const b = a._GetNode(0);
    return () => "A" === b.ExpObject(0, 0) ? "W+A+DASH" : "W+D+DASH"
}
, () => "Damage System", () => "Effect Dust", a => {
    const b = a._GetNode(0).GetVar();
    return () => and("wait_create_dust_", b.GetValue())
}
, a => {
    const b = a._GetNode(0).GetVar();
    return () => b.GetValue() - 10
}
, () => "Animation 1", () => "Effect Damage", a => {
    const b = a._GetNode(0).GetVar();
    return () => b.GetValue() - 50
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(255, 244, 94)
}
, () => 64, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() - 200 * Math.cos(C3$jscomp$399.toRadians(c.ExpObject()))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() - 200 * Math.sin(C3$jscomp$399.toRadians(c.ExpObject()))
}
, () => "Pos1", a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1);
    return () => b.GetValue() + 200 * Math.cos(C3$jscomp$399.toRadians(c.ExpObject()))
}
, a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1);
    return () => b.GetValue() + 200 * Math.sin(C3$jscomp$399.toRadians(c.ExpObject()))
}
, () => "Size", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(300, 712)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(50, 70)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2).GetVar()
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4).GetVar()
      , h = a._GetNode(5).GetBoundMethod()
      , l = a._GetNode(6).GetBoundMethod();
    return () => add$jscomp$4(b(c(d.GetValue() - 1, 2, 1)), e(f.GetValue(), -h(30, 70), l(30, 70)))
}
, a => {
    const b = a._GetNode(0).GetVar();
    return () => b.GetValue() - 45
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(1.5, 3)
}
, a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2).GetVar()
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4).GetBoundMethod();
    return () => add$jscomp$4(b.GetValue(), c(d.GetValue(), -e(0, 50), f(0, 50)))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2).GetVar();
    return () => multiply$jscomp$1(b.ExpObject(), c(d.GetValue(), -1, 1))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(3, 5)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2).GetVar();
    return () => add$jscomp$4(b.ExpObject(), multiply$jscomp$1(50, c(d.GetValue(), -1, 1)))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2).GetVar();
    return () => add$jscomp$4(b.ExpObject(), multiply$jscomp$1(200, c(d.GetValue(), -1, 1)))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2).GetVar()
      , e = a._GetNode(3).GetBoundMethod();
    return () => b(c(d.GetValue() - 1, 2, 1)) + e(-30, 30)
}
, a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1).GetBoundMethod();
    return () => b.GetValue() + c(-30, 30)
}
, () => "Effect Spark", () => "Effect DamageBlock", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod();
    return () => b(c(360))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(.7, 1)
}
, () => "Effect_Line_", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod();
    return () => b(c(), 31, 331, 236, 205, 135)
}
, a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1).GetVar();
    return () => b.GetValue() + 10 * Math.cos(C3$jscomp$399.toRadians(c.GetValue()))
}
, a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1).GetVar();
    return () => b.GetValue() + 10 * Math.sin(C3$jscomp$399.toRadians(c.GetValue()))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3)
      , f = a._GetNode(4).GetVar()
      , h = a._GetNode(5).GetBoundMethod()
      , l = a._GetNode(6).GetBoundMethod()
      , m = a._GetNode(7).GetBoundMethod()
      , p = a._GetNode(8)
      , r = a._GetNode(9).GetVar()
      , v = a._GetNode(10).GetBoundMethod()
      , x = a._GetNode(11).GetBoundMethod()
      , B = a._GetNode(12).GetBoundMethod()
      , A = a._GetNode(13)
      , D = a._GetNode(14).GetVar()
      , F = a._GetNode(15).GetBoundMethod();
    return () => b(c(d(e.ExpObject(and(and("effect_color_line.", f.GetValue()) + ".", h())), 0, ",")) + 17, l(m(p.ExpObject(and(and("effect_color_line.", r.GetValue()) + ".", v())), 1, ",")) + 17, x(B(A.ExpObject(and(and("effect_color_line.", D.GetValue()) + ".", F())), 2, ",")) + 17)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() + 1E3 * Math.cos(C3$jscomp$399.toRadians(c.ExpObject()))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() + 1E3 * Math.sin(C3$jscomp$399.toRadians(c.ExpObject()))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4)
      , h = a._GetNode(5);
    return () => C3$jscomp$399.distanceTo(b.ExpObject(), c.ExpObject(), d.ExpObject() + 1E3 * Math.cos(C3$jscomp$399.toRadians(e.ExpObject())), f.ExpObject() + 1E3 * Math.sin(C3$jscomp$399.toRadians(h.ExpObject()))) / 1500
}
, () => 1100, () => "H", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod();
    return () => multiply$jscomp$1(b(c(), 64, 160, 256, 128, 320), 2)
}
, () => "blockComboHitSystem", () => "Off blockComboHitSystem", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar();
    return () => b(c.GetValue())
}
, a => {
    const b = a._GetNode(0).GetVar();
    return () => 2.5 * b.GetValue()
}
, () => 512, () => "AirHit", () => "BounceHit", () => "head", () => "Reset_backward_repulsion_force", () => "PosXattack", () => "ForwardDashStart", () => "ForwardDashStartAir", () => "Shadow Dash End", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3);
    return () => add$jscomp$4(b(c.ExpInstVar()), multiply$jscomp$1(150, d(e.ExpInstVar(), -1, 1)))
}
, () => "ShadowDash", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4).GetBoundMethod()
      , h = a._GetNode(5);
    return () => C3$jscomp$399.clamp(add$jscomp$4(b.ExpObject(), multiply$jscomp$1(100, c(d.ExpInstVar(), -1, 1))), e.ExpObject() / 2, f() - h.ExpObject() / 2)
}
, () => "ForwardDash", () => "TeleportSlam", a => {
    const b = a._GetNode(0);
    return () => 950 > b.ExpObject() ? 1E3 : 2200
}
, a => {
    const b = a._GetNode(0);
    return () => 950 > b.ExpObject() ? "launcher" : "torsion"
}
, () => "torsion", a => {
    const b = a._GetNode(0);
    return () => 0 === b.ExpObject("speed_animation") ? .6 : .4
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4)
      , h = a._GetNode(5)
      , l = a._GetNode(6).GetBoundMethod()
      , m = a._GetNode(7);
    return () => C3$jscomp$399.clamp(add$jscomp$4(b.ExpObject(), multiply$jscomp$1(c.GetValue() + (7 === d.ExpInstVar() ? 800 : 550), e(f.ExpInstVar(), -1, 1))), h.ExpObject() / 2, l() - m.ExpObject() / 2)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4).GetBoundMethod()
      , h = a._GetNode(5)
      , l = a._GetNode(6)
      , m = a._GetNode(7).GetBoundMethod()
      , p = a._GetNode(8);
    return () => C3$jscomp$399.clamp(add$jscomp$4(b.ExpObject(), multiply$jscomp$1((c.GetValue() + (7 === d.ExpInstVar() ? 300 : 100) + e.ExpInstVar()) / 12, f(h.ExpInstVar(), -1, 1))), l.ExpObject() / 2 * 2, m() - p.ExpObject() / 2 * 2)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => add$jscomp$4(b.ExpObject(), multiply$jscomp$1(550, c(d.ExpInstVar(), -1, 1)))
}
, a => {
    const b = a._GetNode(0);
    return () => .9 + b.ExpInstVar() / 600 * .4
}
, a => {
    const b = a._GetNode(0);
    return () => C3$jscomp$399.clamp(b.ExpInstVar(), 0, 700)
}
, a => {
    const b = a._GetNode(0);
    return () => .8 + b.ExpInstVar() / 600 * .4
}
, a => {
    const b = a._GetNode(0);
    return () => C3$jscomp$399.clamp(b.ExpInstVar(), 0, 800)
}
, () => .9666666666666667, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetVar()
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4)
      , h = a._GetNode(5).GetVar()
      , l = a._GetNode(6).GetVar()
      , m = a._GetNode(7)
      , p = a._GetNode(8).GetBoundMethod()
      , r = a._GetNode(9);
    return () => C3$jscomp$399.clamp(add$jscomp$4(b(c.ExpInstVar()), multiply$jscomp$1(d.GetValue(), e(f.ExpInstVar(), -1 * h.GetValue(), 1 * l.GetValue()))), m.ExpObject(), p() - r.ExpObject())
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3)
      , f = a._GetNode(4)
      , h = a._GetNode(5).GetBoundMethod()
      , l = a._GetNode(6);
    return () => C3$jscomp$399.clamp(add$jscomp$4(b.ExpObject(), multiply$jscomp$1(c.GetValue(), d(e.ExpInstVar(), -1, 1))), f.ExpObject() / 2, h() - l.ExpObject() / 2)
}
, () => "BlockVectorX", a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetVar();
    return () => C3$jscomp$399.clamp(b.GetValue() - c.ExpInstVar(), 450, d.GetValue())
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b(c.ExpInstVar(), -1, 1)
}
, a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1).GetVar();
    return () => -(b.GetValue() + c.GetValue() / 3)
}
, a => {
    const b = a._GetNode(0).GetVar();
    return () => -b.GetValue()
}
, () => "UP+D+min", a => {
    const b = a._GetNode(0).GetVar();
    return () => -(1.5 * b.GetValue())
}
, () => "launcher", a => {
    const b = a._GetNode(0).GetVar();
    return () => -(1.8 * b.GetValue())
}
, () => "mini_launcher", () => "revers", a => {
    const b = a._GetNode(0).GetVar();
    return () => -(b.GetValue() / 2)
}
, () => "BounceHitOnlyY", () => "BounceHitOnlyY2", () => "lazer", a => {
    const b = a._GetNode(0).GetVar();
    return () => -(b.GetValue() + 200)
}
, () => "NONE", () => "coup", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b() - 500
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4);
    return () => C3$jscomp$399.clamp(b.ExpObject() - 600 * (0 === c.ExpInstVar() ? 1 : -1), d.ExpObject(), e() - f.ExpObject())
}
, a => {
    const b = a._GetNode(0);
    return () => 2 * b.ExpInstVar()
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpInstVar() / 1.1 * c.ExpInstVar()
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpInstVar() / 2 * c.ExpInstVar()
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpInstVar() / 2 * -c.ExpInstVar()
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpInstVar() / 2.5 * c.ExpInstVar()
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpInstVar() / 4 * c.ExpInstVar()
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => 1.5 * b.ExpInstVar() * c.ExpInstVar()
}
, () => "damage/damage_flight", () => "damage/damage_launcher", () => "damage/damage_torsion", () => "damage/damage_coup", () => "damage/damage_flight_landed", () => 130, () => 120, () => 1700, () => 2200, a => {
    const b = a._GetNode(0);
    return () => b.ExpInstVar() / 3
}
, () => 950, () => "end_round_flight", () => "end_round_floor", () => "floor", () => "waitCheckGround", () => "fall_up", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => add$jscomp$4(b.ExpObject("CenterPLPL"), c.ExpObject() / 2)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => subtract$jscomp$1(b.ExpObject("CenterPLPL"), c.ExpObject() / 2)
}
, () => "sound_hit", a => {
    const b = a._GetNode(0);
    return () => and("GameSound/Character/Punch_Hit/Punch_Hit_", add$jscomp$4(b.ExpObject("index_sound_punch_hit"), 1))
}
, () => "PunchWhoosh", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod();
    return () => and("GameSound/Character/Punch_Whoosh/Punch_Whoosh_", b(c(1, 22)))
}
, () => "Punch_Whoosh", () => "metal", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3).GetBoundMethod();
    return () => b(and("GameSound/Character/Punch_Hit/Punch_Hit_", add$jscomp$4(c.ExpObject("index_sound_punch_hit"), 1)), and("GameSound/Character/Metal_Hit/Metal_Hit_", d(e(1, 6))))
}
, () => "sword", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod();
    return () => and("GameSound/Character/Sword_Hit/Sword_Hit_", b(c(1, 4)))
}
, () => "Sword_Hit", () => "powerball", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod();
    return () => and("GameSound/Character/Hero/Red_Omega/Powerball_hit_", b(c(1, 3)))
}
, () => "Powerball_hit", () => "sickle", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => and("GameSound/Character/Hero/Lumis/Sickle_hit_", b(1, 2))
}
, () => -15, () => "Sickle_hit", () => "sicklehit", () => "ice", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => and("GameSound/Character/Hero/Frost/Hit/hit_ice_", b(1, 2, 3))
}
, () => "Ice_hit", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => 5 <= b.ExpObject("index_sound_punch_hit") ? 0 : add$jscomp$4(c.ExpObject("index_sound_punch_hit"), 1)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2).GetVar();
    return () => add$jscomp$4(b.ExpObject(), multiply$jscomp$1(400, c(d.GetValue() - 1, 1, -1)))
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() + 75
}
, () => "DANGER_", () => "Danger", () => "GameSound/Danger/dangerCoin", () => -13, () => "GameSound/Danger/danger_voice", a => {
    const b = a._GetNode(0).GetVar();
    return () => and("danger_active_", b.GetValue())
}
, () => "Start Bot Move", () => "Start Bot Attack", () => "Start Bot jump", () => "block_moved_bots", () => "PosY1", a => {
    const b = a._GetNode(0);
    return () => b.ExpBehavior() - 180
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(255, 77, 77)
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpBehavior()
}
, a => {
    const b = a._GetNode(0).GetVar();
    return () => b.GetValue() - 180
}
, a => {
    const b = a._GetNode(0).GetVar();
    return () => 180 === b.GetValue() ? 0 : 1
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetVar();
    return () => b.ExpObject() - (180 === c.GetValue() ? 134 : -134)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => subtract$jscomp$1(b.ExpObject(), multiply$jscomp$1(250, c(d.ExpInstVar(), -1, 1)))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => multiply$jscomp$1(90, b(c.ExpInstVar(), -1, 1))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => multiply$jscomp$1(b.ExpObject(), c(d.ExpInstVar(), 1, -1))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => and("GameSound/Character/Electro/electro_", b(1, 2, 3))
}
, () => "ElectroAttack", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(1, 0)
}
, () => "uppercut_start", () => "Ignor_Animation_Damage", () => "impact protection", () => "StopShadow_dust", a => {
    const b = a._GetNode(0);
    return () => and("parametr.no_block.", b.ExpInstVar() - 1)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4)
      , h = a._GetNode(5).GetBoundMethod()
      , l = a._GetNode(6)
      , m = a._GetNode(7)
      , p = a._GetNode(8);
    return () => 0 === b.ExpInstVar() ? 5 < c.ExpObject(and("statistics.number_hits.", d.ExpInstVar() - 1)) ? e(f.ExpInstVar() / 7) : h(l.ExpInstVar() / 3) : 8 === m.ExpObject(and("select_character.player_", p.ExpInstVar())) ? 25 : 5
}
, a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1);
    return () => add$jscomp$4(b.GetValue(), c.ExpObject("game_config.add_boss_damage"))
}
, a => {
    const b = a._GetNode(0);
    return () => and("danger_active_", b.ExpInstVar())
}
, () => "HammerAttack", () => 800, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(254, 15, 6)
}
, () => 978, () => 1400, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b() - 250
}
, () => 350, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3)
      , f = a._GetNode(4)
      , h = a._GetNode(5).GetBoundMethod()
      , l = a._GetNode(6);
    return () => C3$jscomp$399.clamp(add$jscomp$4(b(c.ExpInstVar()), multiply$jscomp$1(350, d(e.ExpInstVar(), -1, 1))), f.ExpObject(), h() - l.ExpObject())
}
, () => "PosY_airCombo", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() - 5
}
, () => .02, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3)
      , f = a._GetNode(4)
      , h = a._GetNode(5).GetBoundMethod()
      , l = a._GetNode(6);
    return () => C3$jscomp$399.clamp(add$jscomp$4(b(c.ExpInstVar()), multiply$jscomp$1(310, d(e.ExpInstVar(), -1, 1))), f.ExpObject(), h() - l.ExpObject())
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b(c.ExpInstVar()) - 115
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => 8 !== b.ExpObject(and("select_character.player_", c.ExpInstVar())) ? 1 : 4
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3);
    return () => 2 > b.ExpInstVar() ? C3$jscomp$399.clamp(13 * c.ExpInstVar(), 1300, 13 * d.ExpInstVar()) : e.ExpInstVar()
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4);
    return () => C3$jscomp$399.toDegrees(C3$jscomp$399.angleTo(b.ExpObject(), c.ExpObject(), d.ExpObject(), e.ExpObject() - f.ExpObject() / 2)) + 20
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod();
    return () => and("GameSound/Character/Punch_Block/Punch_Block_", b(c(1, 7)))
}
, () => "damage_block_timer", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => C3$jscomp$399.clamp(b.ExpInstVar(), 0, c.ExpInstVar())
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(1, 2, 3, 4)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() - c.ExpObject() / 1.2
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4)
      , h = a._GetNode(5).GetBoundMethod()
      , l = a._GetNode(6);
    return () => 0 === b.ExpInstVar() ? 5 < c.ExpObject(and("statistics.number_hits.", d.ExpInstVar() - 1)) ? e(f.ExpInstVar() / 7) : h(l.ExpInstVar() / 3) : 5
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => 2 > b.ExpInstVar() ? 13 * c.ExpInstVar() : d.ExpInstVar()
}
, () => "ReaperBraid", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => and("Braid_attack_", b(c.ExpInstVar() - 1, 2, 1))
}
, a => {
    const b = a._GetNode(0);
    return () => 2 * b.ExpBehavior()
}
, () => "RedArrow", () => "RedArrow_attack", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => b.ExpObject() * (c.ExpObject() > d.ExpObject() ? -1 : 1)
}
, () => "RubyReverse", () => "Powerball_attack", () => "Sickle", a => {
    const b = a._GetNode(0);
    return () => b.ExpBehavior() / 2
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => b.ExpObject() > c.ExpObject() ? d.ExpBehavior() - 55 : 230
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => b.ExpBehavior() / 2 * (c.ExpObject() > d.ExpObject() ? -1 : 1)
}
, () => 5500, () => "Nunchucks", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => multiply$jscomp$1(b.ExpBehavior(), c(d.ExpInstVar(), -1, 1))
}
, () => "ElectroBullets", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => subtract$jscomp$1(b.ExpObject(), multiply$jscomp$1(150, c(d.ExpInstVar(), -1, 1)))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => multiply$jscomp$1(b.ExpObject(), c(d.ExpInstVar(), -1, 1))
}
, () => "Meteor", a => {
    const b = a._GetNode(0);
    return () => C3$jscomp$399.clamp(b.ExpObject() + 100, 0, 978)
}
, () => "meteor_loop", () => "meteor_attack", () => "explosion", () => "GameSound/Character/Explosion/explosion_1", () => "main", () => "No damage Breaker", () => "GromDamageEnemy", () => "LordDamageEnemy", () => "IceBall", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(1, 1, 0)
}
, () => "ShadowBall", () => "Lumis_S_2_start", () => "Lumis_S_2_hit", () => "GameSound/Character/Hero/Lumis/Lumis_S_2_hit", () => "ForwardDashLumis", () => "WaitStartForwardDash", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => or(7 === b.ExpInstVar() ? 1 : 0, 8 === c.ExpInstVar() ? 1 : 0) ? 1.72 : 1.42
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => b.ExpObject() * (c.ExpObject() > d.ExpObject() ? 1 : -1)
}
, () => "blockSystemTimer", () => "ICE_SOUND_END", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => subtract$jscomp$1(b.ExpObject(), multiply$jscomp$1(20, c(d.ExpInstVar(), 1, -1)))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => and("GameSound/Character/Hero/Frost/Ice_hit_", b(1, 2))
}
, () => "ice_sound", () => "AddColor", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(0, 133, 199)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => add$jscomp$4(b.ExpObject(), multiply$jscomp$1(100, c(d.ExpInstVar(), 1, -1)))
}
, () => "nox_special_1_hit", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => and("GameSound/Character/Hero/Nox/nox_special_1_hit_", b(1, 2))
}
, () => "GameSound/Character/Hero/Nox/nox_special_1_puff", () => 80, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2);
    return () => 2 > b.ExpInstVar() ? 13 * c.GetValue() : d.ExpInstVar()
}
, () => "ElectroFlight", () => "wait_start_damage", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => C3$jscomp$399.clamp(b.ExpObject() + c.ExpObject() / 2, 0, 978)
}
, () => "LordHammer", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => subtract$jscomp$1(b.ExpBehavior(), c(d.ExpInstVar(), 180, 0))
}
, () => 1800, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => 200 * (b.ExpObject() > c.ExpObject() ? -1 : 1)
}
, () => 7E3, () => "StopForwardDashSpeed", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b(c.ExpBehavior("StopForwardDashSpeed"))
}
, () => "Player Movement", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar();
    return () => b(c.GetValue() / 1.65)
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() - 295
}
, () => "DamageSystem", () => "wait_active_teases", () => "StopTeases", () => "X_rayTime", () => "wait_jump_W", () => "MovedStartRight", () => "MovedStartLeft", () => "end_combo", () => "LockComboValue", () => "offDownBot", () => "EndDownSystem", () => "grom_voice_damage", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => and("GameSound/Character/Hero/Grom/grom_voice_", b(3, 5))
}
, () => "Breaker OFF", () => "body_electroflight", () => "head_damage", a => {
    const b = a._GetNode(0).GetVar();
    return () => "damage/damage_" + b.GetValue()
}
, () => "damage/damage_body", () => "damage/damage_head", () => 976, () => "wait_start_damage2", () => "BlockSystem", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => "down_start" !== b.ExpInstVar() ? "idle" : c.ExpInstVar()
}
, () => 4E3, () => "PosXX", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2).GetVar()
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4)
      , h = a._GetNode(5)
      , l = a._GetNode(6).GetBoundMethod()
      , m = a._GetNode(7);
    return () => C3$jscomp$399.clamp(add$jscomp$4(b.ExpObject(), multiply$jscomp$1(C3$jscomp$399.clamp(c.GetValue(), 150, d.GetValue()), e(f.ExpInstVar(), -1, 1))), h.ExpObject() / 2, l() - m.ExpObject() / 2)
}
, () => "block_stand", () => "block_sits", () => "wait_start_block", a => {
    const b = a._GetNode(0);
    return () => "down_start" === b.ExpInstVar() ? "block_sits" : "block_stand"
}
, () => "End_Block", () => "block_sits_idle_down", () => "block_sits_idle", () => "block_stand_idle", () => "Custom Function Player", () => "wait_end_combo_cooldown", () => "PressA", () => "PressD", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b() - (c.ExpObject() / 2 + 10)
}
, () => "ForwardDashMoved", () => "moved_right", () => "moveR", () => "moveL", () => 8E3, a => {
    const b = a._GetNode(0);
    return () => and("parametr.accelerated_step.", b.ExpInstVar() - 1)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetBoundMethod();
    return () => 0 === b.ExpObject("setting.speed_animation") ? 1 : add$jscomp$4(.7, multiply$jscomp$1(divide$jscomp$1(c.ExpObject("distPlayerPlayer"), d()), 2))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod();
    return () => add$jscomp$4(1.5, multiply$jscomp$1(divide$jscomp$1(b.ExpObject("distPlayerPlayer"), c()), 2))
}
, () => "move", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() / 2 + 10
}
, () => "moved_left", () => "special", a => {
    const b = a._GetNode(0);
    return () => and("parametr.no_jump.", b.ExpInstVar() - 1)
}
, () => "jump_action", () => "CheckComboTimer", () => 9999, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => add$jscomp$4(2550, multiply$jscomp$1(500, b.ExpObject(and("parametr.jump_boost.", c.ExpInstVar() - 1))))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => add$jscomp$4(2350, multiply$jscomp$1(500, b.ExpObject(and("parametr.jump_boost.", c.ExpInstVar() - 1))))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => add$jscomp$4(1250, multiply$jscomp$1(500, b.ExpObject(and("parametr.jump_boost.", c.ExpInstVar() - 1))))
}
, a => {
    const b = a._GetNode(0);
    return () => 1 - b.ExpInstVar()
}
, a => {
    const b = a._GetNode(0);
    return () => add$jscomp$4(multiply$jscomp$1(1.4E-4, b.ExpObject("world.gravity")), .425)
}
, () => "special_ground", () => "special_air", () => "jumpAirComboLeft", () => "jumpAirComboRight", () => "BreakerLeft", () => "BreakerRight", a => {
    const b = a._GetNode(0).GetVar();
    return () => b.GetValue() - .5
}
, () => "W+D+DASH", () => "jump_front+DASH", () => 1.25, () => "W+A+DASH", () => -2200, () => "flight_leg", () => "flight_leg2", () => "jump_back+DASH", () => "Wait_flight_leg", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => b.ExpObject_InstExpr(c(d.ExpObject(), 1, 2))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b(c.ExpInstVar(), "flight_leg", "flight_leg2")
}
, () => "Bubble_Effect", a => {
    const b = a._GetNode(0);
    return () => b.ExpInstVar_Family() + 300
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpInstVar_Family() - 100
}
, () => "uppercut", () => "flight_hand", () => 1.05, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => or(7 === b.ExpInstVar() ? 1 : 0, 8 === c.ExpInstVar() ? 1 : 0) ? 1200 : 1E3
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => -(or(7 === b.ExpInstVar() ? 1 : 0, 8 === c.ExpInstVar() ? 1 : 0) ? 1200 : 1E3)
}
, () => -2E3, () => "jumpStartBotStageMoment", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("special 1", "special 2")
}
, () => "special 1", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => and("character.", b.ExpObject(c.ExpInstVar() - 1)) + ".param.special_air.special_1"
}
, () => "special 2", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => b.ExpObject(and("character.", c.ExpObject(d.ExpInstVar() - 1)) + ".param.fatigue.special_2")
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => and("character.", b.ExpObject(c.ExpInstVar() - 1)) + ".param.special_air.special_2"
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("game_config.comboPlayID")
}
, () => "Afk bot", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod();
    return () => and("GameSound/Character/Punch_Hit/Punch_Hit_", b(c(1, 7)))
}
, () => "Punch_Hit", () => "fall_up_landed", a => {
    const b = a._GetNode(0).GetVar();
    return () => "down_" + b.GetValue()
}
, a => {
    const b = a._GetNode(0);
    return () => 0 === b.ExpInstVar() ? 1.5 : 1
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(2, 0, 0, 0, 1, 0, 0)
}
, () => "Special Attack", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3)
      , f = a._GetNode(4);
    return () => b.ExpObject(and(and(and("setting.control.button_", c.ExpObject("game_config.players")) + "_player.", d(e.ExpInstVar(), "A", "D")) + ".", f.ExpInstVar() - 1))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b(c.ExpInstVar(), 4, 0)
}
, () => "Special 1", a => {
    const b = a._GetNode(0);
    return () => and("parametr.no_specials.", b.ExpInstVar() - 1)
}
, () => "unlock_special_attack", () => "GameSound/Character/Special/unlock_special_attack", () => -12, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => 90 + C3$jscomp$399.clamp(multiply$jscomp$1(divide$jscomp$1(b.ExpObject(and("character.", c.ExpObject(d.ExpInstVar() - 1)) + ".param.fatigue.special_1"), 100), 355), 0, 355)
}
, () => "WaitSpecialAttack", () => "special/special_2_ground", () => "special/special_1_ground", () => "special/special_2_air", () => "special/special_1_air", () => "ScytheThrow", a => {
    const b = a._GetNode(0).GetVar();
    return () => and("special/special_", b.GetValue()) + "_ground"
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => multiply$jscomp$1(2E3, b(c.ExpInstVar(), -1, 1))
}
, () => -200, a => {
    const b = a._GetNode(0).GetVar();
    return () => and("special/special_", b.GetValue()) + "_air"
}
, () => -400, () => "LordAttack", () => "GameSound/Character/Hero/Lord/lord_attack_1", () => "special_1", a => {
    const b = a._GetNode(0).GetVar();
    return () => 0 === b.GetValue() ? 2E3 : -2E3
}
, () => 45, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() - 350
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() / 2.5
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() + 600
}
, a => {
    const b = a._GetNode(0);
    return () => -b.ExpObject()
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() - 60
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() / 1.5
}
, () => 1200, () => "Sickle_whoosh", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => and("GameSound/Character/Hero/Lumis/Sickle_whoosh_", b(1, 2))
}
, () => "Ice_Ball", a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1);
    return () => b.GetValue() / c.ExpInstVar()
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() + 120 * Math.cos(C3$jscomp$399.toRadians(c.ExpObject()))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() + 120 * Math.sin(C3$jscomp$399.toRadians(c.ExpObject()))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() - 300 * Math.cos(C3$jscomp$399.toRadians(c.ExpObject()))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() - 300 * Math.sin(C3$jscomp$399.toRadians(c.ExpObject()))
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() / 2
}
, () => "spawn_effect", () => "end_size", () => "end_size_offsetX", a => {
    const b = a._GetNode(0).GetVar();
    return () => -b.GetValue() + 218
}
, () => "destroy", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod();
    return () => b.ExpObject() + c(10, -10)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod();
    return () => b.ExpObject() + c(70, -70)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => multiply$jscomp$1(300, b(c.ExpInstVar(), -1, 1))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => b(c(0, d.ExpObject() + 1))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3).GetBoundMethod();
    return () => b(c.ExpInstVar(), d(280, 360), e(180, 265))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(400, 800)
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpBehavior("end_size_offsetX")
}
, () => "GameSound/Character/Hero/Frost/Ice_end", () => "ice_end", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3).GetBoundMethod();
    return () => b(c.ExpInstVar(), d(21, 11, 43), e(191, 139, 255))
}
, a => {
    const b = a._GetNode(0).GetVar();
    return () => 0 === b.GetValue() ? 3E3 : -3E3
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2).GetVar()
      , e = a._GetNode(3);
    return () => C3$jscomp$399.distanceTo(b.ExpObject(), c(d.GetValue()), e.ExpObject(), 978) - 200
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetVar();
    return () => 1.4 * b.ExpObject() * c.GetValue()
}
, () => .13, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetVar()
      , e = a._GetNode(3).GetVar();
    return () => C3$jscomp$399.distanceTo(b.ExpObject(), c.ExpObject(), d.GetValue(), e.GetValue())
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetVar();
    return () => b.ExpObject() + 1700 * -c.GetValue()
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetVar();
    return () => b.ExpObject() * c.GetValue()
}
, () => 1010, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod();
    return () => multiply$jscomp$1(b.ExpObject(), c(1, -1))
}
, a => {
    const b = a._GetNode(0).GetVar();
    return () => C3$jscomp$399.clamp(100, 0, b.GetValue())
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetVar();
    return () => b.ExpObject() * (0 === c.GetValue() ? 1 : -1)
}
, a => {
    const b = a._GetNode(0).GetVar();
    return () => 0 === b.GetValue() ? 1500 : -1500
}
, a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1).GetVar();
    return () => b.GetValue() + 100 * (0 === c.GetValue() ? 1 : -1)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar();
    return () => C3$jscomp$399.clamp(70, 0, b(c.GetValue() / 3))
}
, () => "Special 2", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => 90 + C3$jscomp$399.clamp(multiply$jscomp$1(divide$jscomp$1(b.ExpObject(and("character.", c.ExpObject(d.ExpInstVar() - 1)) + ".param.fatigue.special_2"), 100), 355), 0, 355)
}
, () => "Special_Active", () => "IceClone", () => "SomersaultLeg", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4);
    return () => C3$jscomp$399.clamp(b.ExpObject() - 300 * (0 === c.ExpInstVar() ? 1 : -1), 3 * d.ExpObject(), e() - 3 * f.ExpObject())
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4)
      , h = a._GetNode(5).GetBoundMethod()
      , l = a._GetNode(6)
      , m = a._GetNode(7);
    return () => C3$jscomp$399.distanceTo(b.ExpObject(), c.ExpObject(), C3$jscomp$399.clamp(d.ExpObject() - 300 * (0 === e.ExpInstVar() ? 1 : -1), 3 * f.ExpObject(), h() - 3 * l.ExpObject()), m.ExpObject()) / 2500
}
, () => "LordRam", () => "special_2", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2).GetVar()
      , e = a._GetNode(3);
    return () => b(c(d.GetValue(), e.ExpInstVar() - 1, ","))
}
, () => "IceDashMoved", () => "IceDashMoved_Effect", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => add$jscomp$4(b.ExpObject(), multiply$jscomp$1(150, c(d.ExpInstVar(), 1, -1)))
}
, () => "DestroyIceClone", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() + 125
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3)
      , f = a._GetNode(4)
      , h = a._GetNode(5)
      , l = a._GetNode(6).GetBoundMethod()
      , m = a._GetNode(7).GetBoundMethod()
      , p = a._GetNode(8)
      , r = a._GetNode(9)
      , v = a._GetNode(10)
      , x = a._GetNode(11).GetBoundMethod()
      , B = a._GetNode(12).GetBoundMethod()
      , A = a._GetNode(13)
      , D = a._GetNode(14)
      , F = a._GetNode(15);
    return () => b(c(d(e.ExpObject(and("character.", f.ExpObject(h.ExpInstVar() - 1)) + ".color_track"), 0, ",")), l(m(p.ExpObject(and("character.", r.ExpObject(v.ExpInstVar() - 1)) + ".color_track"), 1, ",")), x(B(A.ExpObject(and("character.", D.ExpObject(F.ExpInstVar() - 1)) + ".color_track"), 2, ",")))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() - c.ExpObject() / 4
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() - c.ExpObject() / 8
}
, () => -1600, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b() / 10
}
, () => "GameSound/Character/Hero/Frost/Hit/ice_new_2", () => "TeleportSlam_dashUp", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => b(c.ExpInstVar()) - 20 * (0 === d.ExpInstVar() ? 1 : -1)
}
, () => "TeleportSlam_start", () => 1600, () => "LumisSpecial2Air", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4).GetBoundMethod()
      , h = a._GetNode(5);
    return () => C3$jscomp$399.clamp(add$jscomp$4(b.ExpObject(), multiply$jscomp$1(1300, c(d.ExpInstVar(), 1, -1))), e.ExpObject() / 2, f() - h.ExpObject() / 2)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4)
      , h = a._GetNode(5)
      , l = a._GetNode(6).GetBoundMethod()
      , m = a._GetNode(7)
      , p = a._GetNode(8);
    return () => C3$jscomp$399.distanceTo(b.ExpObject(), c.ExpObject(), C3$jscomp$399.clamp(add$jscomp$4(d.ExpObject(), multiply$jscomp$1(1300, e(f.ExpInstVar(), 1, -1))), h.ExpObject() / 2, l() - m.ExpObject() / 2), p.ExpObject()) / 1850
}
, () => "ForwardDashStartAirStop", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4)
      , h = a._GetNode(5)
      , l = a._GetNode(6).GetBoundMethod()
      , m = a._GetNode(7)
      , p = a._GetNode(8);
    return () => C3$jscomp$399.distanceTo(b.ExpObject(), c.ExpObject(), C3$jscomp$399.clamp(add$jscomp$4(d.ExpObject(), multiply$jscomp$1(1300, e(f.ExpInstVar(), 1, -1))), h.ExpObject() / 2, l() - m.ExpObject() / 2), p.ExpObject()) / 4E3
}
, () => "SetColor", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => multiply$jscomp$1(117, b(c.ExpInstVar(), 1, -1))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => multiply$jscomp$1(838, b(c.ExpInstVar(), 1, -1))
}
, () => .145, () => "GameSound/Character/Hero/Lumis/Sickle_whoosh_1", () => -8, () => "Sickle_whoosh_1", () => "GameSound/Character/Hero/Lumis/Lumis_S_2_start", () => "OtherBullets", () => "LazerEyes", a => {
    const b = a._GetNode(0).GetVar();
    return () => b.GetValue() - 4
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => add$jscomp$4(b.ExpObject(), multiply$jscomp$1(120, c(d.ExpInstVar(), 1, -1)))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() - c.ExpObject() / 1.3
}
, () => 1300, () => "GameSound/Character/Hero/Red_Omega/lazer_attack", () => "lazer_attack", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4)
      , h = a._GetNode(5);
    return () => C3$jscomp$399.distanceTo(b.ExpObject(), c.ExpObject(), subtract$jscomp$1(d.ExpObject(), multiply$jscomp$1(150, e(f.ExpInstVar(), -1, 1))), h.ExpObject())
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4);
    return () => C3$jscomp$399.toDegrees(C3$jscomp$399.angleTo(b.ExpObject(), c.ExpObject(), d.ExpObject(), e.ExpObject() - f.ExpObject() / 1.3))
}
, () => 750, () => "MeteorAttack", () => "meteor", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3);
    return () => C3$jscomp$399.clamp(b.ExpObject(), c.ExpObject(), d() - e.ExpObject())
}
, () => "Menu/meteor_attack", () => "Shadow Dash End Damage Enemy", () => "Start Platformer", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b(c.ExpInstVar(), "jumpAirComboRight", "jumpAirComboLeft")
}
, () => "electroFlight", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => and("GameSound/Character/Electro/electroFlight_", b(1, 2))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() - 50 * (0 === c.ExpInstVar() ? -1 : 1)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => subtract$jscomp$1(b.ExpObject(), multiply$jscomp$1(450, c(d.ExpInstVar(), -1, 1)))
}
, () => 1.6, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() - 250 * (0 === c.ExpInstVar() ? -1 : 1)
}
, () => "PosEndSpecialAir", a => {
    const b = a._GetNode(0);
    return () => and("special/special_", b.ExpInstVar()) + "_air_idle"
}
, a => {
    const b = a._GetNode(0);
    return () => and("special_", b.ExpInstVar())
}
, () => "special/special_1_ground_idle", () => "special/special_2_ground_idle", () => "special/special_1_air_idle", () => "special/special_2_air_idle", () => "Breaker", () => "start_time_breaker", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("breaker_active")
}
, () => "BreakerYesActive", a => {
    const b = a._GetNode(0);
    return () => and("parametr.infinite_breakers.", b.ExpInstVar() - 1)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => add$jscomp$4(b.ExpObject(), c(d.ExpInstVar(), 110, -110))
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() + 20
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => add$jscomp$4(b.ExpObject(), c(d.ExpInstVar(), 120, -120))
}
, () => "S_Breaker", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => 2 * b()
}
, () => "BREAKER_VOICE", () => -3, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b(c.ExpInstVar(), "BreakerLeft", "BreakerRight")
}
, () => "O_Breaker", a => {
    const b = a._GetNode(0).GetVar();
    return () => b.GetValue() + 1
}
, () => .76, () => "ShowEffect_SpecialAttack", a => {
    const b = a._GetNode(0);
    return () => and("track_posX.", b.ExpInstVar() - 1)
}
, a => {
    const b = a._GetNode(0);
    return () => and("track_posY.", b.ExpInstVar() - 1)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetVar();
    return () => add$jscomp$4(b.ExpObject(and("track_posX.", c.ExpInstVar() - 1)), d.GetValue())
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetVar();
    return () => subtract$jscomp$1(b.ExpObject(and("track_posX.", c.ExpInstVar() - 1)), d.GetValue())
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetVar();
    return () => add$jscomp$4(b.ExpObject(and("track_posY.", c.ExpInstVar() - 1)), d.GetValue())
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetVar();
    return () => subtract$jscomp$1(b.ExpObject(and("track_posY.", c.ExpInstVar() - 1)), d.GetValue())
}
, () => 180, a => {
    const b = a._GetNode(0);
    return () => b.ExpBehavior("Brightness")
}
, () => "Fatigue", a => {
    const b = a._GetNode(0);
    return () => and("parametr.infinite_fatigue.", b.ExpInstVar() - 1)
}
, () => "Fatigue_reset", () => "Fatigue_add", a => {
    const b = a._GetNode(0);
    return () => 90 + C3$jscomp$399.clamp(b.ExpInstVar() / 100 * 355, 0, 355)
}
, a => {
    const b = a._GetNode(0);
    return () => -1 === b.ExpObject("special_active") ? .65 : 1
}
, () => "O end", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => -1 === b.ExpObject("special_active") ? 100 : 60 <= c.ExpInstVar() ? d.ExpInstVar() : 60
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b(c.ExpBehavior("Fatigue_add"))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b() - (c.ExpObject() + 100)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3);
    return () => C3$jscomp$399.clamp(b.ExpObject() + 250, c.ExpObject() / 2, d() - e.ExpObject() / 2)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3);
    return () => C3$jscomp$399.clamp(b.ExpObject() - 250, c.ExpObject() / 2, d() - e.ExpObject() / 2)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b() - (c.ExpObject() + 50)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4);
    return () => C3$jscomp$399.clamp(b.ExpObject() - (c.ExpObject() + 20), d.ExpObject() / 2, e() - f.ExpObject() / 2)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4);
    return () => C3$jscomp$399.clamp(b.ExpObject() + (c.ExpObject() + 20), d.ExpObject() / 2, e() - f.ExpObject() / 2)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b(c.ExpInstVar()) - 25
}
, () => "body", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3)
      , f = a._GetNode(4)
      , h = a._GetNode(5).GetBoundMethod()
      , l = a._GetNode(6);
    return () => C3$jscomp$399.clamp(add$jscomp$4(b(c.ExpInstVar()), multiply$jscomp$1(200, d(e.ExpInstVar(), -1, 1))), f.ExpObject() / 2, h() - l.ExpObject() / 2)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b(c.ExpInstVar()) - 150
}
, () => "Other", () => "end_flash", a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1).GetBoundMethod();
    return () => b.GetValue() + c(70, -70)
}
, a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3).GetVar();
    return () => -1 === b.GetValue() ? c(-300, 300) : multiply$jscomp$1(300, d(e.GetValue(), -1, 1))
}
, a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3).GetVar()
      , f = a._GetNode(4).GetBoundMethod()
      , h = a._GetNode(5).GetBoundMethod();
    return () => -1 === b.GetValue() ? c(180, 360) : d(e.GetValue(), f(180, 265), h(280, 360))
}
, a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2).GetBoundMethod();
    return () => -1 === b.GetValue() ? c(300, 700) : d(700, 1100)
}
, () => "Sparks_Sickle", () => "Body_Fall", () => "Cloth", () => "metal_hit", () => "punch_hit", () => "SPINE CONTAINER", a => {
    const b = a._GetNode(0);
    return () => and("skin_", b.ExpInstVar_Family())
}
, () => "CaptureBody", () => "combo1", () => "DOWN", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4).GetBoundMethod()
      , h = a._GetNode(5);
    return () => C3$jscomp$399.clamp(subtract$jscomp$1(b.ExpObject(), multiply$jscomp$1(350, c(d.ExpInstVar(), -1, 1))), e.ExpObject() / 2, f() - h.ExpObject() / 2)
}
, () => .5666666666666667, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4).GetBoundMethod()
      , h = a._GetNode(5);
    return () => C3$jscomp$399.clamp(add$jscomp$4(b.ExpObject(), multiply$jscomp$1(250, c(d.ExpInstVar(), -1, 1))), e.ExpObject() / 2, f() - h.ExpObject() / 2)
}
, () => .4666666666666667, a => {
    const b = a._GetNode(0).GetVar();
    return () => "capture_body_angle_" + b.GetValue()
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetVar()
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4)
      , h = a._GetNode(5).GetBoundMethod()
      , l = a._GetNode(6)
      , m = a._GetNode(7)
      , p = a._GetNode(8).GetBoundMethod()
      , r = a._GetNode(9);
    return () => C3$jscomp$399.clamp(add$jscomp$4(b(c.ExpInstVar()), "UP" === d.GetValue() ? e(f.ExpInstVar(), 350, -350) : h(l.ExpInstVar(), 700, -700)), m.ExpObject() / 2, p() - r.ExpObject() / 2)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetVar();
    return () => b(c.ExpInstVar()) - ("UP" === d.GetValue() ? 460 : 0)
}
, a => {
    const b = a._GetNode(0).GetVar();
    return () => "UP" === b.GetValue() ? .205 : .1
}
, () => "combo2", a => {
    const b = a._GetNode(0).GetVar();
    return () => "GromCombo2_" + b.GetValue()
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetVar()
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4)
      , h = a._GetNode(5).GetBoundMethod()
      , l = a._GetNode(6)
      , m = a._GetNode(7)
      , p = a._GetNode(8).GetBoundMethod()
      , r = a._GetNode(9);
    return () => C3$jscomp$399.clamp(add$jscomp$4(b(c.ExpInstVar()), "UP" === d.GetValue() ? e(f.ExpInstVar(), -270, 270) : h(l.ExpInstVar(), -300, 300)), m.ExpObject() / 2, p() - r.ExpObject() / 2)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetVar();
    return () => b(c.ExpInstVar()) - ("UP" === d.GetValue() ? 0 : -25)
}
, a => {
    const b = a._GetNode(0).GetVar();
    return () => (b.GetValue(),
    .1)
}
, () => "combo3", () => "PIN", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3)
      , f = a._GetNode(4)
      , h = a._GetNode(5).GetBoundMethod()
      , l = a._GetNode(6);
    return () => C3$jscomp$399.clamp(subtract$jscomp$1(b(c.ExpInstVar()), multiply$jscomp$1(550, d(e.ExpInstVar(), 1, -1))), f.ExpObject() / 2, h() - l.ExpObject() / 2)
}
, () => "EnemyYGround1", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() + 120
}
, () => "EnemyYGround2", () => "EnemyYGroundEnd", () => "capture_body_angle_DOWN", () => "SOUND_TAG", () => "Sound_Snow_Hit", () => "GameSound/Character/Hero/Frost/Snow_Hit", () => "sound_tag", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("string")
}
, () => "VOICEee", () => "VOICE_EEE", () => "PunchWhoosh_Tag", () => "Metal_Whoosh", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod();
    return () => and("GameSound/Character/Metal_Whoosh/Metal_Whoosh_", b(c(1, 6)))
}
, () => "Metal_Hit", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod();
    return () => and("GameSound/Character/Metal_Hit/Metal_Hit_", b(c(1, 6)))
}
, () => "bone_hit", () => "Punch_Xray", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => and("GameSound/Character/Punch_Xray/Punch_Xray_", b(c.ExpObject("index_sound_bone_Xray")) + 1)
}
, () => "index_sound_bone_Xray", () => "body_fall", () => "Sword_Whoosh", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod();
    return () => and("GameSound/Character/Sword_Whoosh/Sword_Whoosh_", b(c(1, 6)))
}
, () => "sword_hit", () => "cloth", () => "xray_effect_1", () => "GameSound/Character/Xray/xray_effect_1", () => "lazer_start", () => "lazer_end", () => "GameSound/Character/Hero/Red_Omega/lazer_end", () => "sickle_hit", () => "sickle_end", () => "Sickle_end", () => "GameSound/Character/Hero/Lumis/Sickle_end", () => "sickle_whoosh_end", () => "Sickle_whoosh_end", () => "GameSound/Character/Hero/Lumis/Sickle_whoosh_end", () => "laughter", () => "Laughter_Lumis", () => "GameSound/Character/Hero/Lumis/Laughter_Lumis", () => "ice_startXray", () => "GameSound/Character/Hero/Frost/ice_startXray", () => "ice_start", () => "GameSound/Character/Hero/Frost/Ice_start", () => "Hit_Ground", a => {
    const b = a._GetNode(0);
    return () => and("GameSound/Character/Hit_Ground/Hit_Ground_", add$jscomp$4(b.ExpObject("index_sound_body_fall"), 1))
}
, () => -18, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => 1 <= b.ExpObject("index_sound_body_fall") ? 0 : add$jscomp$4(c.ExpObject("index_sound_body_fall"), 1)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod();
    return () => and("GameSound/Character/Cloth/Cloth_", b(c(1, 4)))
}
, () => -25, () => "registerPos", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b(c.ExpObject("string"), 8, "_")
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => b(c(d.ExpObject("string"), 1, "_"))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => b(c(d.ExpObject("string"), 0, "_"))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => b(c.ExpInstVar()) - d.ExpObject() / 2
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2)
      , e = a._GetNode(3);
    return () => C3$jscomp$399.clamp(b(c(d.ExpObject("string"), 5, "_")), 0, e.ExpInstVar())
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => b(c(d.ExpObject("string"), 2, "_"))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b(c.ExpObject("string"), 3, "_")
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b(c.ExpObject("string"), 4, "_")
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => 1 === b.ExpInstVar() ? c.ExpInstVar() : -1
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => b(c(d.ExpObject("string"), 6, "_"))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => 0 === b(c.ExpInstVar()) ? 1 : 0
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => b(c(d.ExpObject("string"), 7, "_"))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3)
      , f = a._GetNode(4);
    return () => b.ExpObject() + (c(d(e.ExpObject("string"), 1, "_")) - 50) * (0 === f.ExpInstVar() ? 1 : -1)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3);
    return () => b.ExpObject() + 350 - c(d(e.ExpObject("string"), 0, "_"))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3)
      , f = a._GetNode(4);
    return () => b.ExpObject() + (c(d(e.ExpObject("string"), 1, "_")) - 50) * ((0 === f.ExpInstVar() ? 1 : -1) / 1.5)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3);
    return () => b.ExpObject() + 400 - c(d(e.ExpObject("string"), 0, "_")) / 1.5
}
, () => "CreateEventName", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() + 100 * (0 === c.ExpInstVar() ? 1 : -1)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() + (c.ExpObject(),
    25)
}
, a => {
    const b = a._GetNode(0);
    return () => 0 === b.ExpInstVar() ? 0 : 180
}
, () => 3500, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3);
    return () => b.ExpObject(and(and("character.", c.ExpObject(d.ExpInstVar() - 1)) + ".param.fatigue.special_", e.ExpInstVar()))
}
, () => "GameSound/Character/Hero/Reaper/Braid_attack", a => {
    const b = a._GetNode(0);
    return () => and("Braid_attack_", b.ExpInstVar())
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() + 250 * (0 === c.ExpInstVar() ? 1 : -1)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() + (977 < c.ExpObject() ? 60 : -60)
}
, () => 3700, () => "GameSound/Character/Hero/Red_Omega/RedArrow_attack", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() + 50 * (0 === c.ExpInstVar() ? 1 : -1)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() + (977 < c.ExpObject() ? 60 : 0)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => 977 < b.ExpObject() ? 0 === c.ExpInstVar() ? 0 : 180 : 0 === d.ExpInstVar() ? 20 : 160
}
, a => {
    const b = a._GetNode(0);
    return () => 977 < b.ExpObject() ? 1700 : 2200
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod();
    return () => and("GameSound/Character/Hero/Red_Omega/Powerball_attack_", b(c(1, 4)))
}
, () => -14, () => "Sickle_1", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() + 200 * (0 === c.ExpInstVar() ? 1 : -1)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() + (977 < c.ExpObject() ? -45 : -75)
}
, () => "Sickle_2", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() + 300 * (0 === c.ExpInstVar() ? 1 : -1)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() + (c.ExpObject(),
    0)
}
, () => 4500, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b(c.ExpObject("string"), 2, "_")
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3)
      , f = a._GetNode(4).GetBoundMethod()
      , h = a._GetNode(5);
    return () => subtract$jscomp$1(b.ExpObject(), multiply$jscomp$1(c(d(e.ExpObject("string"), 1, "_")) - 100, f(h.ExpInstVar(), -1, 1)))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3);
    return () => b.ExpObject() - c(d(e.ExpObject("string"), 0, "_")) + 200
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b(c.ExpInstVar(), 0, 180)
}
, () => "DamageFlightPos", () => "DestroyLazerEyes", () => "Y", () => "IceBallCreate", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() - 30 * (0 === c.ExpInstVar() ? 1 : -1)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() + (977 < c.ExpObject() ? 195 : 25)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() * (0 === c.ExpInstVar() ? 1 : -1)
}
, () => "IceBallStart", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => b.ExpObject() + (150 + (977 < c.ExpObject() ? 0 : -70)) * (0 === d.ExpInstVar() ? 1 : -1)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() + (977 < c.ExpObject() ? 75 : -105)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => b.ExpObject() + (310 - (977 < c.ExpObject() ? 0 : 55)) * (0 === d.ExpInstVar() ? 1 : -1)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() - (125 - (977 < c.ExpObject() ? 0 : 15))
}
, () => .14, () => -11, () => "IceBallStartAirCombo", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() + (c.ExpObject(),
    75)
}
, () => "StartTackleFrost", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4)
      , h = a._GetNode(5)
      , l = a._GetNode(6).GetBoundMethod()
      , m = a._GetNode(7)
      , p = a._GetNode(8);
    return () => C3$jscomp$399.distanceTo(b.ExpObject(), c.ExpObject(), C3$jscomp$399.clamp(add$jscomp$4(d.ExpObject(), multiply$jscomp$1(1300, e(f.ExpInstVar(), 1, -1))), h.ExpObject() / 2, l() - m.ExpObject() / 2), p.ExpObject()) / 2700
}
, a => {
    const b = a._GetNode(0).GetVar();
    return () => b.GetValue() - .33
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4).GetBoundMethod()
      , h = a._GetNode(5);
    return () => C3$jscomp$399.clamp(add$jscomp$4(b.ExpObject(), multiply$jscomp$1(1100, c(d.ExpInstVar(), 1, -1))), e.ExpObject() / 2, f() - h.ExpObject() / 2)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => multiply$jscomp$1(1600, b(c.ExpInstVar(), 1, -1))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b() - c.ExpObject() / 2
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3)
      , f = a._GetNode(4);
    return () => C3$jscomp$399.distanceTo(b.ExpObject(), c.ExpObject(), d() - e.ExpObject() / 2, f.ExpObject())
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => -C3$jscomp$399.distanceTo(b.ExpObject(), c.ExpObject(), 0, d.ExpObject())
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() - 200 * (0 === c.ExpInstVar() ? 1 : -1)
}
, () => 208, a => {
    const b = a._GetNode(0).GetVar();
    return () => b.GetValue() / 1.5
}
, () => "StopTackleFrost", () => "NoxSpecial2_start", () => "GameSound/Character/Hero/Nox/nox_special_2_start", () => "nox_special_2_start", a => {
    const b = a._GetNode(0);
    return () => and("TeleportSlam_Layer_", b.ExpInstVar())
}
, () => "NoxSpecial2_moved_is_up", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3);
    return () => C3$jscomp$399.distanceTo(b.ExpObject(), c.ExpObject(), d.ExpObject(), e.ExpObject() + 600) / 2E3
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => subtract$jscomp$1(b.ExpObject(), multiply$jscomp$1(15, c(d.ExpInstVar(), 1, -1)))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => subtract$jscomp$1(b.ExpObject(), multiply$jscomp$1(40, c(d.ExpInstVar(), 1, -1)))
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() + 300
}
, () => "NoxSpecial2_moved_is_down", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => C3$jscomp$399.distanceTo(b.ExpObject(), c.ExpObject(), d.ExpObject(), 950) / 1500
}
, () => "GameSound/Character/Hero/Nox/nox_special_2_end", () => "nox_special_2_end", a => {
    const b = a._GetNode(0).GetVar();
    return () => b.GetValue() - 5
}
, () => "NoxSpecial2_end", () => "ShakeCamera", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() + 150 * (0 === c.ExpInstVar() ? 1 : -1)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() + (977 < c.ExpObject() ? 40 : -40)
}
, () => 2700, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => and("GameSound/Character/Hero/Nox/nox_special_1_attack_", b(1, 2))
}
, () => "nox_special_1_attack", () => "ActivateSpecial_1", () => "ActivateSpecial_2", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b(c.ExpObject("string"), 0, "&")
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => b(c(d.ExpObject("string"), 1, "&"))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => b(c(d.ExpObject("string"), 1, "&")) / 10
}
, () => "mirror", () => "not_mirror", () => "CreateNox_Effect_hit_1", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(2, 3)
}
, a => {
    const b = a._GetNode(0);
    return () => 0 === b.ExpInstVar() ? 300 : 240
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() * (0 === c.ExpInstVar() ? -1 : 1)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() - 15 * (0 === c.ExpInstVar() ? 1 : -1)
}
, () => "CreateNox_Effect_hit_2", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => b.ExpObject() + (100 + 100 * c()) * (0 === d.ExpInstVar() ? 1 : -1)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod();
    return () => b.ExpObject() - 200 - c(0, 100)
}
, () => "CreateNox_Effect_hit_6", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod();
    return () => b.ExpObject() - 300 - c(0, 100)
}
, a => {
    const b = a._GetNode(0);
    return () => 0 === b.ExpInstVar() ? 50 : 130
}
, a => {
    const b = a._GetNode(0);
    return () => 0 === b.ExpInstVar() ? 80 : 100
}
, () => "CreateNox_Effect_AirHit_4", () => "NinjaStadeSpecial2_1", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4)
      , h = a._GetNode(5)
      , l = a._GetNode(6)
      , m = a._GetNode(7).GetBoundMethod()
      , p = a._GetNode(8);
    return () => C3$jscomp$399.clamp(900 > b.ExpObject("distPlayerPlayer") ? c(d.ExpInstVar()) - 100 * (0 === e.ExpInstVar() ? 1 : -1) : f.ExpObject() + 900 * (0 === h.ExpInstVar() ? 1 : -1), l.ExpObject() / 2, m() - p.ExpObject() / 2)
}
, () => 3600, () => "GameSound/Character/Hero/Ninja/Nunchucks_Whoosh", () => "NinjaStadeSpecial2_2", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4)
      , h = a._GetNode(5)
      , l = a._GetNode(6)
      , m = a._GetNode(7).GetBoundMethod()
      , p = a._GetNode(8);
    return () => C3$jscomp$399.clamp(400 > b.ExpObject("distPlayerPlayer") ? c(d.ExpInstVar()) + 450 * (0 === e.ExpInstVar() ? 1 : -1) : f.ExpObject() + 1200 * (0 === h.ExpInstVar() ? 1 : -1), l.ExpObject() / 2, m() - p.ExpObject() / 2)
}
, () => "capture_body_1", () => "capture_body_active", () => "UP", () => "capture_body_2", () => "capture_body_3", () => "GromStartElectroSpecial_1", () => "GromCreateEffectSpesial1_Bullet", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() + 350 * (0 === c.ExpInstVar() ? 1 : -1)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() + (977 < c.ExpObject() ? 25 : -50)
}
, () => "GromCreateSpesial1_ElectroBall", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4);
    return () => C3$jscomp$399.clamp(b.ExpObject() - 400 * (0 === c.ExpInstVar() ? 1 : -1), d.ExpObject() / 2, e() - f.ExpObject() / 2)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() + 180 * (0 === c.ExpInstVar() ? 1 : -1)
}
, () => "GromStartMovedSpecial2", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4);
    return () => C3$jscomp$399.clamp(b.ExpObject() + 2100 * (0 === c.ExpInstVar() ? 1 : -1), 3 * d.ExpObject(), e() - 3 * f.ExpObject())
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4)
      , h = a._GetNode(5).GetBoundMethod()
      , l = a._GetNode(6)
      , m = a._GetNode(7);
    return () => C3$jscomp$399.distanceTo(b.ExpObject(), c.ExpObject(), C3$jscomp$399.clamp(d.ExpObject() + 2100 * (0 === e.ExpInstVar() ? 1 : -1), 3 * f.ExpObject(), h() - 3 * l.ExpObject()), m.ExpObject()) / 4500
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() + 115
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() - 700 * (0 === c.ExpInstVar() ? -1 : 1)
}
, a => {
    const b = a._GetNode(0);
    return () => 90 * (0 === b.ExpInstVar() ? -1 : 1)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(0, 1)
}
, a => {
    const b = a._GetNode(0);
    return () => 2 * b.ExpObject()
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() + 130
}
, () => "GromDamageEnemy_1", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => C3$jscomp$399.clamp(15, 0, b(c.ExpInstVar() / 6))
}
, () => "GromDamageEnemy_End", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b(c.ExpInstVar() - 1, 1, 2)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b(c.ExpInstVar()) - 300
}
, a => {
    const b = a._GetNode(0);
    return () => C3$jscomp$399.clamp(70, 0, b.ExpInstVar())
}
, () => 2300, () => "gromPosEnemy_1", () => "gromPosEnemy_2", () => "LordSpecial1Start", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4)
      , h = a._GetNode(5)
      , l = a._GetNode(6)
      , m = a._GetNode(7)
      , p = a._GetNode(8)
      , r = a._GetNode(9).GetBoundMethod()
      , v = a._GetNode(10);
    return () => C3$jscomp$399.clamp(1500 > b.ExpObject("distPlayerPlayer") ? c(d.ExpInstVar()) - (1 === e(f.ExpInstVar()) ? 400 : 200) * (0 === h.ExpInstVar() ? 1 : -1) : l.ExpObject() + 1500 * (0 === m.ExpInstVar() ? 1 : -1), p.ExpObject() / 2, r() - v.ExpObject() / 2)
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() - 650
}
, () => "LordSpecial1End", () => "LordSpecial1AirCreateHammer", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => b.ExpObject() + (977 < c.ExpObject() ? 100 : 300) * (0 === d.ExpInstVar() ? 1 : -1)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() + (977 < c.ExpObject() ? -100 : -120)
}
, () => 5E3, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4).GetBoundMethod()
      , h = a._GetNode(5);
    return () => C3$jscomp$399.clamp(subtract$jscomp$1(b.ExpObject(), multiply$jscomp$1(200, c(d.ExpInstVar(), 1, -1))), e.ExpObject() / 2, f() - h.ExpObject() / 2)
}
, () => "LordSpecial2RamStart", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4)
      , h = a._GetNode(5)
      , l = a._GetNode(6)
      , m = a._GetNode(7)
      , p = a._GetNode(8)
      , r = a._GetNode(9).GetBoundMethod()
      , v = a._GetNode(10);
    return () => C3$jscomp$399.clamp(1300 > b.ExpObject("distPlayerPlayer") ? c(d.ExpInstVar()) + (1 === e(f.ExpInstVar()) ? 300 : 600) * (0 === h.ExpInstVar() ? 1 : -1) : l.ExpObject() + 1300 * (0 === m.ExpInstVar() ? 1 : -1), p.ExpObject() / 2, r() - v.ExpObject() / 2)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetVar()
      , e = a._GetNode(3);
    return () => C3$jscomp$399.distanceTo(b.ExpObject(), c.ExpObject(), d.GetValue(), e.ExpObject()) / 2500
}
, () => "LordHaAttack", () => "GameSound/Character/Hero/Lord/lord_ha_2", () => "LordSpecial2RamAirStart", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4)
      , h = a._GetNode(5)
      , l = a._GetNode(6)
      , m = a._GetNode(7)
      , p = a._GetNode(8)
      , r = a._GetNode(9).GetBoundMethod()
      , v = a._GetNode(10);
    return () => C3$jscomp$399.clamp(1300 > b.ExpObject("distPlayerPlayer") ? c(d.ExpInstVar()) + (e(f.ExpInstVar()),
    400) * (0 === h.ExpInstVar() ? 1 : -1) : l.ExpObject() + 1300 * (0 === m.ExpInstVar() ? 1 : -1), p.ExpObject() / 2, r() - v.ExpObject() / 2)
}
, () => "capture_body_4", () => "LordDamageEnemy_1", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => C3$jscomp$399.clamp(45, 0, b(c.ExpInstVar() / 3))
}
, () => "LordDamageEnemy_2", () => "LordDamageEnemy_3", a => {
    const b = a._GetNode(0);
    return () => C3$jscomp$399.clamp(100, 0, b.ExpInstVar())
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4).GetBoundMethod()
      , h = a._GetNode(5);
    return () => C3$jscomp$399.clamp(subtract$jscomp$1(b.ExpObject(), multiply$jscomp$1(500, c(d.ExpInstVar(), 1, -1))), e.ExpObject() / 2, f() - h.ExpObject() / 2)
}
, () => "createEffects", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("x_ray.id")
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3);
    return () => b.ExpObject() + 400 - c(d(e.ExpObject("string"), 0, "_"))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(360)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => add$jscomp$4(b.ExpObject(), multiply$jscomp$1(60, c(d.ExpInstVar(), 1, -1)))
}
, () => "impactProtection", () => "destoyDamageSprite", () => "xRayMoment", () => "REAPER", () => "StartMoveReaperSpecial2", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => subtract$jscomp$1(b.ExpObject(), multiply$jscomp$1(100, c(d.ExpInstVar(), -1, 1)))
}
, () => "Shadow", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4).GetBoundMethod()
      , h = a._GetNode(5);
    return () => C3$jscomp$399.clamp(add$jscomp$4(b.ExpObject(), multiply$jscomp$1(500, c(d.ExpInstVar(), 1, -1))), e.ExpObject() / 2, f() - h.ExpObject() / 2)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4)
      , h = a._GetNode(5)
      , l = a._GetNode(6).GetBoundMethod()
      , m = a._GetNode(7)
      , p = a._GetNode(8);
    return () => C3$jscomp$399.distanceTo(b.ExpObject(), c.ExpObject(), C3$jscomp$399.clamp(add$jscomp$4(d.ExpObject(), multiply$jscomp$1(500, e(f.ExpInstVar(), 1, -1))), h.ExpObject() / 2, l() - m.ExpObject() / 2), p.ExpObject()) / 2500
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4)
      , h = a._GetNode(5)
      , l = a._GetNode(6).GetBoundMethod()
      , m = a._GetNode(7)
      , p = a._GetNode(8);
    return () => C3$jscomp$399.distanceTo(b.ExpObject(), c.ExpObject(), C3$jscomp$399.clamp(add$jscomp$4(d.ExpObject(), multiply$jscomp$1(1300, e(f.ExpInstVar(), 1, -1))), h.ExpObject() / 2, l() - m.ExpObject() / 2), p.ExpObject()) / 2500
}
, () => "GameSound/Character/Hero/Reaper/Reaper_S_2_start", () => "LUMIS", () => "LumisFinishMoved", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => subtract$jscomp$1(b.ExpObject(), multiply$jscomp$1(150, c(d.ExpInstVar(), 1, -1)))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("COLLISION") - .7
}
, () => "CreateIskraSpecial2", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => add$jscomp$4(b.ExpObject(), multiply$jscomp$1(30, c(d.ExpInstVar(), 1, -1)))
}
, () => "StartMoveSpecial2Character3", () => "CreateEffectIskraStartCharacter3", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => subtract$jscomp$1(b.ExpObject(), multiply$jscomp$1(120, c(d.ExpInstVar(), 1, -1)))
}
, () => "Xpos", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => add$jscomp$4(b.ExpObject(), multiply$jscomp$1(250, c(d.ExpInstVar(), 1, -1)))
}
, () => "CreateSplash_1", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => add$jscomp$4(b.ExpObject(), multiply$jscomp$1(235, c(d.ExpInstVar(), 1, -1)))
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() - 170
}
, () => "FROST", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b(c.ExpObject("string"), 0, "_")
}
, () => "IceBreaking", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b(c.ExpObject("string"), 1, "_")
}
, () => "Axe", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3)
      , f = a._GetNode(4);
    return () => b.ExpObject() + c(d(e.ExpObject("string"), 4, "_")) * (0 === f.ExpInstVar() ? 1 : -1)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3);
    return () => b.ExpObject() - c(d(e.ExpObject("string"), 3, "_")) + 150
}
, a => {
    const b = a._GetNode(0);
    return () => 1 === b.ExpInstVar() ? "Axe_lite" : "Axe"
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => b(c(d.ExpObject("string"), 5, "_"))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3);
    return () => b.ExpObject() * c(d(e.ExpObject("string"), 5, "_"))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4)
      , h = a._GetNode(5).GetBoundMethod()
      , l = a._GetNode(6).GetBoundMethod()
      , m = a._GetNode(7);
    return () => b(c.ExpInstVar(), d(e(f.ExpObject("string"), 2, "_")), 180 - h(l(m.ExpObject("string"), 2, "_")))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(1E3, 1500)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(180, 360)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3);
    return () => b(500, 1E3) * c(d(e.ExpObject("string"), 5, "_"))
}
, () => "Sword", () => "Stop_Frame_Enemy", () => "FrostMovedDash_AirCombo", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => subtract$jscomp$1(b.ExpObject(), multiply$jscomp$1(100, c(d.ExpInstVar(), 1, -1)))
}
, () => "Damage_Animation_reset", () => "snowball_create", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => add$jscomp$4(b.ExpObject(), multiply$jscomp$1(350, c(d.ExpInstVar(), 1, -1)))
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() - 75
}
, () => "snowball", () => "body_1", () => "body_2", () => 1.7, () => "NOX", () => "StartAnimationPortalOpen", () => "CharacterVisible", () => "StartAnimationPortalMoved", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => C3$jscomp$399.distanceTo(b.ExpObject(), c.ExpObject(), d.ExpObject(), 976) / 3500
}
, () => "StartAnimationPortalClosed", () => "DARK_LORD", () => "DarkLordCreateAnimationObjectSound_1", () => "DarkLordCreateAnimationObject", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => subtract$jscomp$1(b.ExpObject(), multiply$jscomp$1(115, c(d.ExpInstVar(), 1, -1)))
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() - 460
}
, () => "DarkLordClosedAnimationObject", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => subtract$jscomp$1(b.ExpObject(), multiply$jscomp$1(80, c(d.ExpInstVar(), 1, -1)))
}
, () => "NINJA", () => "AnimationFireAttackLegNinja", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => add$jscomp$4(b.ExpObject(), multiply$jscomp$1(50, c(d.ExpInstVar(), 1, -1)))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() - (c.ExpObject() / 2 - 50)
}
, () => "fire_hit", () => "GameSound/Character/Fire/fire_hit", () => "AnimationFireAttackAirHit4Ninja", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() - (c.ExpObject() / 2 + 150)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b(c.ExpInstVar(), 78, 282)
}
, () => "AnimationFireAttackAirLegNinja", () => "AnimationFireStartGameNinja", () => "NinjaSoundRollNunchucks", () => "AnimationFireNinjaLegWin", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => subtract$jscomp$1(b.ExpObject(), multiply$jscomp$1(50, c(d.ExpInstVar(), 1, -1)))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() - (c.ExpObject() / 2 + 50)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b(c.ExpInstVar(), 270, 90)
}
, () => "GROMOGIL", () => "gromogil_StartCreate_Electro", () => 2.2, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() - 680
}
, () => "GameSound/Character/Electro/electro_start", () => .26, () => "gromogil_StartDestroy_Electro", () => "MirrorToEnemy", () => "GromVoice_1", () => "GameSound/Character/Hero/Grom/grom_voice_2", () => "GromVoice_2", () => "GameSound/Character/Hero/Grom/grom_voice_5", () => "LORD", () => "GameSound/Character/Hero/Lord/lord_haha_start_1", () => "LordTeasesEnd", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2).GetBoundMethod();
    return () => 1 === b.ExpObject("start_game") ? c(1, 2, 3, 4) : d(1, 2, 3)
}
, a => {
    const b = a._GetNode(0).GetVar();
    return () => and("GameSound/Character/Hero/Lord/lord_teases_", b.GetValue())
}
, () => .83, () => "down_end", () => "Start Animation Round", () => "Combo Control", () => 1.4, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4)
      , h = a._GetNode(5);
    return () => 0 === b.ExpInstVar() ? 8 !== c.ExpInstVar() ? d.ExpInstVar() : 1 > e.ExpInstVar() ? 1 : f.ExpInstVar() : h.ExpInstVar()
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpInstVar() + 1
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4);
    return () => b.ExpObject(and(and(and("character.", c.ExpObject(d.ExpInstVar() - 1)) + ".combo.combo_", e.ExpInstVar()) + ".", f.ExpInstVar() - 1))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => 0 === b.ExpInstVar() ? and("combo_", c.ExpInstVar()) : and("aircombo_", d.ExpInstVar())
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => 0 === b.ExpInstVar() ? and("enemy_combo_", c.ExpInstVar()) : and("enemy_aircombo_", d.ExpInstVar())
}
, a => {
    const b = a._GetNode(0);
    return () => 0 === b.ExpObject("setting.speed_animation") ? 1 : 1.25
}
, a => {
    const b = a._GetNode(0);
    return () => .75 + (4 - (4 - b.ExpInstVar())) / 4 * .75
}
, () => "reaper", () => "reaper Combo Main", () => "combo_1/hit_1", a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => multiply$jscomp$1(1.5 * b.GetValue(), c(d.ExpInstVar(), 1, -1))
}
, () => "combo_1/hit_2", a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => multiply$jscomp$1(b.GetValue(), c(d.ExpInstVar(), 1, -1))
}
, () => "combo_1/hit_3", () => "combo_1/hit_4", () => "combo_1/hit_5", () => "combo_1/hit_6", () => "combo_1/hit_7", () => "dark_lord", () => "dark_lord Combo Main", () => "combo_1/hit_8", () => "lumis", () => "lumis Combo Main", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => multiply$jscomp$1(1300, b(c.ExpInstVar(), 1, -1))
}
, () => "frost", () => "frost Combo Main", a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => multiply$jscomp$1(2 * b.GetValue(), c(d.ExpInstVar(), 1, -1))
}
, () => "nox", () => "nox Combo Main", () => "ninja", () => "ninja Combo Main", () => "gromogil", () => "gromogil Combo Main", () => "lord Combo Main", a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => multiply$jscomp$1(3 * b.GetValue(), c(d.ExpInstVar(), 1, -1))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b() - c.ExpObject()
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3)
      , f = a._GetNode(4)
      , h = a._GetNode(5).GetBoundMethod()
      , l = a._GetNode(6)
      , m = a._GetNode(7)
      , p = a._GetNode(8)
      , r = a._GetNode(9)
      , v = a._GetNode(10).GetBoundMethod()
      , x = a._GetNode(11);
    return () => C3$jscomp$399.clamp(b.ExpObject() + (0 === c.ExpInstVar() ? C3$jscomp$399.clamp(d(e.ExpInstVar()) - f.ExpObject(), 0, 300) : C3$jscomp$399.clamp(h(l.ExpInstVar()) - m.ExpObject(), -300, 0)) - 100 * (0 === p.ExpInstVar() ? 1 : -1), r.ExpObject(), v() - x.ExpObject())
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetBoundMethod();
    return () => b.ExpInstVar() >= c.ExpInstVar() ? .03 : d()
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => 4 > b.ExpInstVar() ? C3$jscomp$399.clamp(c.ExpInstVar() / 10, .1, .25) : .1
}
, () => "time_comp_", () => "End 4 combo", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => 0 === b.ExpInstVar() ? 0 === c.ExpInstVar() ? 550 : 600 : 0 === d.ExpInstVar() ? 500 : 600
}
, a => {
    const b = a._GetNode(0);
    return () => and("parametr.no_combos.", b.ExpInstVar() - 1)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4);
    return () => 1 === b.ExpInstVar() ? 1 === c.ExpInstVar() ? 0 : 2 === d.ExpInstVar() ? 1 : 3 === e.ExpInstVar() ? 2 : 4 === f.ExpInstVar() ? 3 : 4 : 4
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => b(subtract$jscomp$1(c(), d.ExpObject(0, 1)), 3)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3);
    return () => 0 === b.ExpInstVar() ? 0 === c.ExpInstVar() ? "pc" === d.ExpObject("device") ? .17 : .2 : 3 > e.ExpInstVar() ? .22 : 1 : .3
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => 0 === b.ExpInstVar() ? 0 : 3 > c.ExpInstVar() ? d.ExpInstVar() : 0
}
, a => {
    const b = a._GetNode(0);
    return () => C3$jscomp$399.clamp(b.ExpInstVar() + 1, 1, 4)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => 90 + C3$jscomp$399.clamp((0 === b.ExpInstVar() ? 0 : 3 > c.ExpInstVar() ? d.ExpInstVar() : 0) / 100 * 355, 0, 355)
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpInstVar() + "_idle"
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => 0 === b.ExpInstVar() ? c.ExpInstVar() / 30 : .1
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => b.ExpObject(and(and("setting.control.button_", c.ExpObject("game_config.players")) + "_player.attack.", d.ExpInstVar() - 1))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => 4 > b.ExpInstVar() ? 0 === c.ExpInstVar() ? C3$jscomp$399.clamp(d.ExpInstVar() / 10, .1, .25) : .3 : .1
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4).GetBoundMethod()
      , h = a._GetNode(5);
    return () => C3$jscomp$399.clamp(b(c.ExpInstVar()) - 300 * (0 === d.ExpInstVar() ? 1 : -1), e.ExpObject(), f() - h.ExpObject())
}
, () => "BufferComboIndex", a => {
    const b = a._GetNode(0).GetVar();
    return () => and("select_character.player_", b.GetValue())
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() - 2
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() - 3
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(0, 0, 0, 1, 0, 0, 0, 0)
}
, () => "Bot Moved", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(1, 3)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3);
    return () => 1 >= b.ExpInstVar() ? .9 : 2 === c.ExpInstVar() ? .5 : 3 === d.ExpInstVar() ? .3 : 4 === e.ExpInstVar() ? .15 : .1
}
, () => "Bot LoS object bullets", () => 450, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b(c.ExpInstVar(), "W+A", "W+D")
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b(c.ExpInstVar(), "W+D", "W+A")
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => and("character.", b.ExpObject(c.ExpInstVar() - 1)) + ".bot.special.evasion"
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b(c.ExpInstVar(), "A", "D")
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(0, 0, 1, 2)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4);
    return () => b(c(d.ExpInstVar(), "W+A", "W+D"), e(f.ExpInstVar(), "W+D", "W+A"))
}
, () => "Bot Attack Floor", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(.35, .7)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(.15, .3)
}
, () => "Bot Attack Air", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b(c.ExpInstVar(), "D", "A")
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4);
    return () => b(c(d.ExpInstVar(), "W+D", "W+A"), e(f.ExpInstVar(), "W+A", "W+D"))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(1, 2, 2, 2)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4)
      , h = a._GetNode(5)
      , l = a._GetNode(6);
    return () => b(c.ExpObject(and("character.", d.ExpObject(e.ExpInstVar() - 1)) + ".param.fatigue.special_1"), f.ExpObject(and("character.", h.ExpObject(l.ExpInstVar() - 1)) + ".param.fatigue.special_2"))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("special 1", "special 2", "jump", "jump", "jump", "jump", "jump", "uppercut", "afk", "special 1", "special 2")
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("special 1", "special 2", "special 1", "jump", "special 1", "special 1", "jump", "jump", "uppercut", "jump", "afk", "afk")
}
, () => "afk", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4)
      , h = a._GetNode(5).GetBoundMethod()
      , l = a._GetNode(6)
      , m = a._GetNode(7).GetBoundMethod()
      , p = a._GetNode(8).GetBoundMethod();
    return () => 1 === b.ExpInstVar() ? c(1.7, 1.9) : 2 === d.ExpInstVar() ? e(1.3, 1.7) : 3 === f.ExpInstVar() ? h(1.1, 1.3) : 4 === l.ExpInstVar() ? m(.7, .9) : p(.1, .2)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("special 1", "miss", "miss", "jump")
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("special random", "special 1", "special 2", "miss", "uppercut", "afk", "special 1", "special 1", "special 1")
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("special random", "special 1", "special 2", "miss", "uppercut", "afk", "afk")
}
, () => "special random", () => "miss", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4)
      , h = a._GetNode(5).GetBoundMethod()
      , l = a._GetNode(6)
      , m = a._GetNode(7).GetBoundMethod()
      , p = a._GetNode(8).GetBoundMethod();
    return () => 1 === b.ExpInstVar() ? c(2.7, 2.9) : 2 === d.ExpInstVar() ? e(2.3, 2.7) : 3 === f.ExpInstVar() ? h(1.8, 2) : 4 === l.ExpInstVar() ? m(1.7, 1.9) : p(.4, .7)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("miss", "special 1", "special 2", "special 1", "special 2")
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("miss", "miss", "miss", "miss", "jump", "moved", "miss", "jump W", "miss", "miss")
}
, () => "moved", () => "jump W", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3)
      , f = a._GetNode(4).GetBoundMethod()
      , h = a._GetNode(5);
    return () => b(c.ExpInstVar(), d(e.ExpInstVar(), "W+A", "W+D"), f(h.ExpInstVar(), "W+D", "W+A"))
}
, () => "attack_action", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("miss", "miss")
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4)
      , h = a._GetNode(5).GetBoundMethod()
      , l = a._GetNode(6);
    return () => b(c(d.ExpInstVar(), "D", "A"), e(f.ExpInstVar(), "D", "A"), h(l.ExpInstVar(), "A", "D"))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3);
    return () => 1 >= b.ExpInstVar() ? .9 : 2 === c.ExpInstVar() ? .5 : 3 === d.ExpInstVar() ? .15 : (e.ExpInstVar(),
    .1)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(.5, 1)
}
, () => "Scene Config", () => "PosMesh", () => -.05, () => "Ang", () => "a", a => {
    const b = a._GetNode(0);
    return () => .5 + b.ExpObject() / 15
}
, () => "Gerry_Scene_5", () => "BattleStickman_Scene_7_1", () => "BattleStickman_Scene_7_2", () => "StartMoveRight", () => "TimerShake", () => "BlockShake", () => "Pos R", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b(c.ExpObject()) + 3500
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3)
      , f = a._GetNode(4);
    return () => C3$jscomp$399.distanceTo(b.ExpObject(), c.ExpObject(), d(e.ExpObject()) + 3500, f.ExpObject()) / 1E3
}
, () => "StartOpacity 0", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3)
      , f = a._GetNode(4);
    return () => C3$jscomp$399.distanceTo(b.ExpObject(), c.ExpObject(), d(e.ExpObject()) + 3500, f.ExpObject()) / 1050
}
, () => "Pos L", () => "StartMoveLeft", () => "StartBlockShake", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b(c.ExpObject()) - 3500
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3);
    return () => C3$jscomp$399.distanceTo(b.ExpObject(), c.ExpObject(), d() / 2, e.ExpObject()) / 1E3
}
, () => "pos 1", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4);
    return () => C3$jscomp$399.toDegrees(C3$jscomp$399.angleTo(b.ExpObject(), c.ExpObject(), (d.ExpObject_InstExpr(1) + e.ExpObject_InstExpr(2)) / 2, f.ExpObject()))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpInstVar() + 3 * Math.cos(C3$jscomp$399.toRadians(c.ExpObject()))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpInstVar() + 3 * Math.sin(C3$jscomp$399.toRadians(c.ExpObject()))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(0, 2)
}
, () => "pos 2", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(.4, 1)
}
, () => "pos 3", () => "pos 4", () => "Water - Mesh Distortion", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4);
    return () => C3$jscomp$399.unlerp(b.ExpObject() - c.ExpObject() / 2, d.ExpObject() + e.ExpObject() / 2, f.ExpObject())
}
, () => "p", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2)
      , e = a._GetNode(3);
    return () => b.ExpObject() + c("p") * (d.ExpObject() / e.ExpInstVar())
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("p")
}
, () => "Water - Nodes", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4)
      , h = a._GetNode(5)
      , l = a._GetNode(6)
      , m = a._GetNode(7)
      , p = a._GetNode(8);
    return () => -b.ExpObject() * (c.ExpInstVar() * d.ExpInstVar_InstExpr(e.ExpInstVar()) + 2 * f.ExpInstVar() * Math.sqrt(h.ExpInstVar_InstExpr(l.ExpInstVar())) * m.ExpInstVar_InstExpr(p.ExpInstVar()))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4)
      , h = a._GetNode(5)
      , l = a._GetNode(6)
      , m = a._GetNode(7)
      , p = a._GetNode(8)
      , r = a._GetNode(9)
      , v = a._GetNode(10)
      , x = a._GetNode(11)
      , B = a._GetNode(12)
      , A = a._GetNode(13)
      , D = a._GetNode(14)
      , F = a._GetNode(15)
      , I = a._GetNode(16);
    return () => b.ExpInstVar_InstExpr(c.ExpObject() - 1) === d.ExpInstVar_InstExpr(e.ExpObject()) ? -f.ExpObject() * ((h.ExpInstVar() - l.ExpInstVar_InstExpr(m.ExpObject() - 1)) * p.ExpInstVar_InstExpr(r.ExpInstVar()) + 2 * (v.ExpInstVar() - x.ExpInstVar_InstExpr(B.ExpObject() - 1)) * Math.sqrt(A.ExpInstVar_InstExpr(D.ExpInstVar())) * F.ExpInstVar_InstExpr(I.ExpInstVar())) : 0
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4)
      , h = a._GetNode(5)
      , l = a._GetNode(6)
      , m = a._GetNode(7)
      , p = a._GetNode(8)
      , r = a._GetNode(9)
      , v = a._GetNode(10)
      , x = a._GetNode(11)
      , B = a._GetNode(12)
      , A = a._GetNode(13)
      , D = a._GetNode(14)
      , F = a._GetNode(15)
      , I = a._GetNode(16);
    return () => b.ExpInstVar_InstExpr(c.ExpObject() + 1) === d.ExpInstVar_InstExpr(e.ExpObject()) ? -f.ExpObject() * ((h.ExpInstVar() - l.ExpInstVar_InstExpr(m.ExpObject() + 1)) * p.ExpInstVar_InstExpr(r.ExpInstVar()) + 2 * (v.ExpInstVar() - x.ExpInstVar_InstExpr(B.ExpObject() + 1)) * Math.sqrt(A.ExpInstVar_InstExpr(D.ExpInstVar())) * F.ExpInstVar_InstExpr(I.ExpInstVar())) : 0
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpInstVar() * c.ExpObject()
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpInstVar() + c.ExpInstVar()
}
, () => "Water - Collisions", () => -1500, () => "rand_jump", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod();
    return () => b.ExpObject() - c(20, 40)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod();
    return () => b(c(2, 3))
}
, a => {
    const b = a._GetNode(0);
    return () => -b.ExpBehavior("PosMesh") / 2
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpBehavior("PosMesh") / 2
}
, () => "mode_fight_slot_ENDBUTTON", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("GUI_FRONT") + 130
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("game_config.players")
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("GUI") + 400
}
, () => "StartModeFight", () => "MODE_FIGHT_TEXT", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject(1)
}
, () => "StartH", a => {
    const b = a._GetNode(0);
    return () => -(b.ExpInstVar() - 40)
}
, a => {
    const b = a._GetNode(0).GetVar();
    return () => "mode_fight_slot.slot_param." + b.GetValue()
}
, a => {
    const b = a._GetNode(0).GetVar();
    return () => "mode_fight_slot.slot_incompatible." + b.GetValue()
}
, () => "mode_fight_slot", () => '{\n"start" : 0,\n"id" : -1,\n"count_item_all" : 24,\n"speed" : 0.08,\n"speed_stop" : 0.02,\n"pos" : {"top" : 0, "buttom" : 0},\n"slot_character_player_1" : [],\n"slot_character_player_2" : [],\n"slot_param" : {},\n"slot_incompatible" : {},\n"item_end" : [],\n"item_end_name" : [],\n"item_end_index" : 0,\n"item_end_frame_pacifiers" : [],\n"item_array_player_1" : [],\n"item_array_player_2" : []\n}', a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod();
    return () => and("character_unlocked.", b.ExpObject(c()))
}
, () => "mode_fight_slot.slot_character_player_1", () => "mode_fight_slot.slot_character_player_2", () => "modifiers", a => {
    const b = a._GetNode(0);
    return () => "parametr." + b.ExpObject()
}
, () => "mode_fight_slot.item_end_index", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("mode_fight_slot.count_slot")
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("mode_fight_slot.item_end_index")
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetVar();
    return () => b.ExpObject(and("mode_fight_slot.slot_character_player_", c.GetValue() + 1))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(0)
}
, a => {
    const b = a._GetNode(0).GetVar();
    return () => and("select_character.player_", b.GetValue() + 1)
}
, () => "mode_fight_slot.item_end", () => "mode_fight_slot.item_end_name", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetVar();
    return () => b.ExpObject(c.GetValue())
}
, a => {
    const b = a._GetNode(0).GetVar();
    return () => and("parametr.player_", b.GetValue() + 1)
}
, () => "mode_fight_slot.item_end_frame_pacifiers", a => {
    const b = a._GetNode(0).GetVar();
    return () => and("mode_fight_slot.side.player_", b.GetValue() + 1)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetVar();
    return () => and("modifiers.", b.ExpObject(c.GetValue(), 0)) + ".incompatible"
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetVar();
    return () => b.ExpObject(and("modifiers.", c.ExpObject(d.GetValue(), 0)) + ".incompatible")
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetVar()
      , e = a._GetNode(3).GetBoundMethod();
    return () => b.ExpObject(and(and("modifiers.", c.ExpObject(d.GetValue(), 0)) + ".incompatible.", e()))
}
, () => "luck_bonus", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetVar();
    return () => b.ExpObject(c.GetValue(), 0)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetVar();
    return () => b.ExpObject(and("modifiers.", c.ExpObject(d.GetValue(), 0)) + ".frame")
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetBoundMethod();
    return () => b.ExpObject(and("modifiers.", c.ExpObject(d(1), 0)) + ".frame")
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetBoundMethod();
    return () => b.ExpObject(and("modifiers.", c.ExpObject(d(2), 0)) + ".frame")
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetVar()
      , e = a._GetNode(3)
      , f = a._GetNode(4)
      , h = a._GetNode(5).GetVar()
      , l = a._GetNode(6).GetBoundMethod()
      , m = a._GetNode(7)
      , p = a._GetNode(8)
      , r = a._GetNode(9).GetVar();
    return () => and(-1 !== b.ExpObject(and("modifiers.", c.ExpObject(d.GetValue(), 0)) + ".side") ? 1 : 0, 1 !== e.ExpObject(and("modifiers.", f.ExpObject(h.GetValue(), 0)) + ".side") ? 1 : 0) ? l(-1, 1, 2) : m.ExpObject(and("modifiers.", p.ExpObject(r.GetValue(), 0)) + ".side")
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetVar();
    return () => and("mode_fight_slot.side.", b.ExpObject(c.GetValue(), 0))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetVar();
    return () => and(and("parametr.", b.ExpObject(c.GetValue(), 0)) + ".", 0)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetVar();
    return () => b.ExpObject(and("modifiers.", c.ExpObject(d.GetValue(), 0)) + ".value")
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetVar();
    return () => and(and("parametr.", b.ExpObject(c.GetValue(), 0)) + ".", 1)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2).GetVar();
    return () => and(and("parametr.", b.ExpObject(c.GetValue(), 0)) + ".", d.GetValue() - 1)
}
, () => "mode_fight_slot.item_array_player_1", () => "mode_fight_slot.item_array_player_2", a => {
    const b = a._GetNode(0);
    return () => "mode_fight_slot.slot_param." + b.ExpObject()
}
, a => {
    const b = a._GetNode(0);
    return () => "mode_fight_slot.slot_incompatible." + b.ExpObject()
}
, () => .75, a => {
    const b = a._GetNode(0).GetVar();
    return () => b.GetValue() + "_BG"
}
, a => {
    const b = a._GetNode(0).GetVar();
    return () => b.GetValue() + "_BLEND"
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar();
    return () => b(c.GetValue()) - 230
}
, () => "mode_fight_slot.x", () => "mode_fight_slot.y", a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1).GetVar();
    return () => b.GetValue() * c.GetValue() + 25
}
, () => "slot", a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2).GetVar()
      , e = a._GetNode(3).GetVar()
      , f = a._GetNode(4).GetVar()
      , h = a._GetNode(5).GetBoundMethod();
    return () => b.GetValue() - c.GetValue() * (d.GetValue() / 2) + e.GetValue() / 2 + f.GetValue() * h()
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod();
    return () => b.ExpObject(and("mode_fight_slot.slot_character_player_", c() + 1))
}
, () => "CharacterIcon", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3).GetBoundMethod();
    return () => b.ExpObject(and(and("mode_fight_slot.slot_character_player_", c("slot") + 1) + ".", d(e())))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3);
    return () => b.ExpObject() - (c.ExpObject() - d.ExpObject()) - e.ExpObject() / 2
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetVar()
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4)
      , h = a._GetNode(5).GetVar()
      , l = a._GetNode(6).GetVar();
    return () => b.ExpObject() - (c.ExpObject() + d.GetValue()) / 2 + e() * (f.ExpObject() + h.GetValue()) - l.GetValue() / 2
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("slot")
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3).GetVar();
    return () => b.ExpObject() - (150 + c.GetValue()) + d() * (150 + e.GetValue())
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("mode_fight_slot.count_item_all")
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2).GetBoundMethod();
    return () => b(3 * (c("slot") - 2) + d())
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetVar()
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4)
      , h = a._GetNode(5).GetVar();
    return () => b.ExpObject() - (c.ExpObject() + d.GetValue()) + e() * (f.ExpObject() + h.GetValue())
}
, () => "effect", () => "mode_fight_lever", a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2).GetVar();
    return () => b.GetValue() + 5 + c.GetValue() * (d.GetValue() / 2)
}
, () => 40, () => "leverArrow", a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2).GetVar();
    return () => b.GetValue() - 5 - c.GetValue() * (d.GetValue() / 2)
}
, a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1).GetVar();
    return () => b.GetValue() - c.GetValue() / 2
}
, a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1).GetVar();
    return () => b.GetValue() * c.GetValue() + 50
}
, () => "mode_fight_slot.pos.top", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetVar();
    return () => b.ExpObject() + c.GetValue() / 4.5 - 25
}
, a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1).GetVar();
    return () => b.GetValue() + c.GetValue() / 2
}
, () => "mode_fight_slot.pos.buttom", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetVar();
    return () => b.ExpObject() - c.GetValue() / 4.5 - 15
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetVar()
      , f = a._GetNode(4);
    return () => b(c.GetValue() / d.ExpObject(), e.GetValue() / f.ExpObject())
}
, () => "Menu/modeFightEffect_roll_start", () => "modeFightEffect_roll_start", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => and("Menu/swoosh", b(1, 2, 3))
}
, () => "modeFightEffect_roll", a => {
    const b = a._GetNode(0);
    return () => b.ExpInstVar() / 30
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("mode_fight_slot.pos.buttom")
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("mode_fight_slot.pos.top")
}
, () => "secSoundRoll", () => "Menu/resultscreen_spin_loop", () => 12, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3);
    return () => b.ExpObject() === c.ExpObject(and("mode_fight_slot.slot_character_player_", add$jscomp$4(d.ExpObject("mode_fight_slot.id"), 2))) - 1 ? 0 : e.ExpObject() + 1
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => b.ExpObject() === c.ExpObject() - 1 ? 0 : d.ExpObject() + 1
}
, () => "mode_fight_slot.speed", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => C3$jscomp$399.clamp(subtract$jscomp$1(b.ExpObject("mode_fight_slot.speed"), .01), c.ExpObject("mode_fight_slot.speed_stop"), 1)
}
, () => "StartY_1", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() - 41.25
}
, a => {
    const b = a._GetNode(0);
    return () => .5 - b.ExpInstVar() / 50
}
, () => "StartY", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() + 55
}
, () => .08, () => .85, () => "StopItemModeFight", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("mode_fight_slot.id")
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => add$jscomp$4(subtract$jscomp$1(b.ExpObject("mode_fight_slot.y"), 165), 165 * c.ExpInstVar())
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() - 165
}
, () => "EndY", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() + 165
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("mode_fight_slot.y")
}
, a => {
    const b = a._GetNode(0);
    return () => subtract$jscomp$1(b.ExpObject("mode_fight_slot.y"), 200)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject(and("mode_fight_slot.item_end.", c.ExpObject("mode_fight_slot.id")))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject(and("mode_fight_slot.item_end_frame_pacifiers.", multiply$jscomp$1(c.ExpObject("mode_fight_slot.id"), 2)))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject(and("mode_fight_slot.item_end_frame_pacifiers.", add$jscomp$4(multiply$jscomp$1(c.ExpObject("mode_fight_slot.id"), 2), 1)))
}
, () => "mode_fight_slot.id", a => {
    const b = a._GetNode(0);
    return () => subtract$jscomp$1(b.ExpObject("mode_fight_slot.count_slot"), 1)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4)
      , h = a._GetNode(5);
    return () => 1 === b.ExpObject("mode_fight_slot.start") ? c.ExpObject("mode_fight_slot.speed") : d.ExpInstVar() <= e.ExpObject("mode_fight_slot.id") ? f.ExpObject("mode_fight_slot.speed_stop") : h.ExpObject("mode_fight_slot.speed")
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject(and("mode_fight_slot.item_end_name.", c.ExpObject("mode_fight_slot.id")))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => b.ExpObject(and("mode_fight_slot.side.", c.ExpObject(and("mode_fight_slot.item_end_name.", d.ExpObject("mode_fight_slot.id")))))
}
, () => .55, () => "End", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("MODE_FIGHT")
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b("MODE_FIGHT") + ("pc" === c.ExpObject("device") ? 200 : 300)
}
, () => "Menu/Show", () => "lord_haha_start_2", () => "GameSound/Character/Punch_Whoosh/Punch_Whoosh_1", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("mode_fight_slot.item_array_player_1")
}
, () => "parametr.hide_hp_bar.0", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetBoundMethod();
    return () => b.ExpObject() + c.ExpObject() / 2 + 50 + 100 * d()
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() + c.ExpObject() / 2 - 20
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod();
    return () => b.ExpObject(and("mode_fight_slot.item_array_player_1.", c()))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod();
    return () => b.ExpObject() + 100 + 100 * c()
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("mode_fight_slot.item_array_player_2")
}
, () => "parametr.hide_hp_bar.1", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetBoundMethod();
    return () => b.ExpObject() - c.ExpObject() / 2 - 50 - 100 * d()
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod();
    return () => b.ExpObject(and("mode_fight_slot.item_array_player_2.", c()))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod();
    return () => b.ExpObject() - 100 - 100 * c()
}
, () => "mode_fight_slot.speed_stop", () => "EFFECT_MODE_FIGHT", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(210, 255, 37)
}
, () => 155, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => .1 + b() / 10
}
, () => 316, () => "FFE564", () => "61FF00", a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4)
      , h = a._GetNode(5);
    return () => and("[color=#" + b.GetValue() + "]", "mobile" === c.ExpObject("device") ? d.ExpObject("MODE_FIGHT_START_TEXT") : and(and(and(and(e.ExpObject("MODE_FIGHT_START_TEXT"), " "), f.ExpObject("ELSE")), " "), h.ExpObject("SPACE"))) + "[/color]"
}
, a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4).GetBoundMethod();
    return () => 0 === b.GetValue() ? 1 === c.GetValue() ? d(255, 36, 36) : e(210, 255, 37) : f(255, 255, 255)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetVar()
      , e = a._GetNode(3).GetVar()
      , f = a._GetNode(4).GetVar();
    return () => b.ExpObject() + C3$jscomp$399.clamp(c.ExpObject() / 2 + 80, d.GetValue(), e.GetValue()) * f.GetValue()
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("mode_fight_slot.x")
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetVar();
    return () => add$jscomp$4(add$jscomp$4(b.ExpObject("mode_fight_slot.y"), c.GetValue()), 75)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetVar()
      , f = a._GetNode(4)
      , h = a._GetNode(5).GetVar()
      , l = a._GetNode(6).GetVar();
    return () => and("[color=#" + b.ExpInstVar() + "]", "effect" === c.GetValue() ? d.ExpObject(and("modifiers." + e.GetValue() + ".name.", 0)) : f.ExpObject("character." + h.GetValue() + ".name." + l.GetValue())) + "[/color]"
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b(c.ExpObject() % 2, -2, 2)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2).GetVar();
    return () => C3$jscomp$399.clamp(b.ExpObject() + 50, c.GetValue(), d.GetValue())
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2)
      , e = a._GetNode(3);
    return () => add$jscomp$4(subtract$jscomp$1(b(c.GetValue()), divide$jscomp$1(multiply$jscomp$1(208, d.ExpObject("mode_fight_slot.count_slot")), 2)), e.ExpObject() / 2)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(30, 255, 0)
}
, a => {
    const b = a._GetNode(0);
    return () => add$jscomp$4(multiply$jscomp$1(208, b.ExpObject("mode_fight_slot.count_slot")), 300)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2)
      , e = a._GetNode(3);
    return () => subtract$jscomp$1(add$jscomp$4(b(c.GetValue()), divide$jscomp$1(multiply$jscomp$1(208, d.ExpObject("mode_fight_slot.count_slot")), 2)), e.ExpObject() / 2)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(255, 36, 36)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => and("Menu/ButClick_0", b(3, 4))
}
, a => {
    const b = a._GetNode(0);
    return () => multiply$jscomp$1(208, b.ExpObject("mode_fight_slot.count_slot"))
}
, () => "hide_hp_bar", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => add$jscomp$4(b.ExpObject(), c(d.ExpInstVar() - 1, 200, -200))
}
, () => "Menu/effect_poof", () => "hp_100", a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1);
    return () => and("parametr." + b.GetValue() + ".", c.ExpInstVar() - 1)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() - c.ExpObject()
}
, () => "hp_1", () => "hp_700", () => "heal", () => "MF_heal", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod();
    return () => b.ExpObject() + c(150, -150)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetBoundMethod();
    return () => b.ExpObject() - c.ExpObject() / 2 + d(200, -200)
}
, () => "Health", () => "Menu/Health", () => "reflect_projectiles", () => "poison", () => "MF_poison", a => {
    const b = a._GetNode(0);
    return () => and("parametr.poison.", b.ExpInstVar() - 1)
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() - 90
}
, () => "Menu/modeFightEffect_potion", () => "low_gravity", a => {
    const b = a._GetNode(0);
    return () => subtract$jscomp$1(b.ExpObject("world.gravityDefault"), 1750)
}
, a => {
    const b = a._GetNode(0);
    return () => subtract$jscomp$1(b.ExpObject("world.fallspeedDefault"), 1750)
}
, () => "invisible_fighters", a => {
    const b = a._GetNode(0);
    return () => and("parametr.invisible_fighters.", b.ExpInstVar() - 1)
}
, () => "MF_meteor", () => "freeze_strike", () => "MF_freeze_strike", () => "reverse_ball", () => "MF_reverse_ball", () => "lightning_strike", () => "MF_lightning_strike", () => "ball_lightning", () => 2.7, () => "MF_ball_lightning", () => "health_drop", () => "MF_health_drop", () => "no_attacks", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => b.ExpObject(and(and("character.", c.ExpObject(d.ExpInstVar() - 1)) + ".combo.combo_2.", 1))
}
, () => .9, () => "no_combos", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => b.ExpObject(and(and("character.", c.ExpObject(d.ExpInstVar() - 1)) + ".combo.combo_1.", 1))
}
, () => "no_specials", () => "Menu/swoosh1", () => "no_block", () => "no_jump", () => "PosY_StartModeFight", () => "Menu/swoosh2", () => "jump_boost", () => "accelerated_step", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("parametr.luck_bonus.0")
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod();
    return () => add$jscomp$4(b.ExpObject("CenterPLPL"), c(100, -100))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => 800 - b(0, 100)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => 270 + b(20, -20)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(2200, 2700)
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpBehavior() - 300
}
, a => {
    const b = a._GetNode(0);
    return () => and("parametr.heal.", b.ExpInstVar() - 1)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3);
    return () => C3$jscomp$399.clamp(add$jscomp$4(b.ExpInstVar(), c.ExpObject(and("parametr.heal.", d.ExpInstVar() - 1))), 0, e.ExpInstVar())
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(1, 2.5)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3);
    return () => C3$jscomp$399.clamp(subtract$jscomp$1(b.ExpInstVar(), c.ExpObject(and("parametr.poison.", d.ExpInstVar() - 1))), 0, e.ExpInstVar())
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(0, 1, 2, 3)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(1.3, 2)
}
, a => {
    const b = a._GetNode(0);
    return () => and("parametr.meteor.", b.ExpInstVar() - 1)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(55, 255, 0)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3)
      , f = a._GetNode(4).GetBoundMethod()
      , h = a._GetNode(5).GetBoundMethod()
      , l = a._GetNode(6);
    return () => b(c("GUI", "GRADIENT_LAYER", d("GUI") + 200, e.ExpObject()), f("GUI", "GRADIENT_LAYER", h("GUI") - 200, l.ExpObject()))
}
, () => 920, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod();
    return () => b(200, c() - 200)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(2.5, 5)
}
, a => {
    const b = a._GetNode(0);
    return () => and("parametr.health_drop.", b.ExpInstVar() - 1)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2).GetBoundMethod();
    return () => add$jscomp$4(b.ExpObject(), multiply$jscomp$1(200, c(d(), 1, -1)))
}
, () => "pos1", () => "pos2", () => "Menu/ButClick_02", () => 135, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3);
    return () => C3$jscomp$399.clamp(add$jscomp$4(b.ExpInstVar(), c.ExpObject(and("parametr.health_drop.", d.ExpInstVar() - 1))), 0, e.ExpInstVar())
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => and("[color=#48FF00]+", b.ExpObject(and("parametr.health_drop.", c.ExpInstVar() - 1))) + "[/color]"
}
, () => "target_system", () => "color", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(255, 0, 0)
}
, () => "Menu/meteor_loop", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod();
    return () => C3$jscomp$399.clamp(b.ExpObject(), 150, c() - 150)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("COLLISION") + 50
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => 90 + b(40, -40)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => 90 + b(45, -45)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3);
    return () => b.ExpObject(and(and("character.", c.ExpObject(subtract$jscomp$1(d.ExpObject(and("select_character.player_", e.ExpInstVar_Family())), 1))) + ".combo.combo_2.", 1))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3);
    return () => and(b.ExpObject(and(and("character.", c.ExpObject(subtract$jscomp$1(d.ExpObject(and("select_character.player_", e.ExpInstVar_Family())), 1))) + ".combo.combo_2.", 1)), "_idle")
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3);
    return () => b.ExpObject(and(and("character.", c.ExpObject(subtract$jscomp$1(d.ExpObject(and("select_character.player_", e.ExpInstVar_Family())), 1))) + ".combo.combo_1.", 1))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3);
    return () => and(b.ExpObject(and(and("character.", c.ExpObject(subtract$jscomp$1(d.ExpObject(and("select_character.player_", e.ExpInstVar_Family())), 1))) + ".combo.combo_1.", 1)), "_idle")
}
, () => "Text", () => "text", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => and("[color=#" + b.ExpInstVar() + "]", c.ExpObject(d.ExpInstVar())) + "[/color]"
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2);
    return () => b.ExpObject() + c.GetValue() < d.ExpObject() ? 1 : 0
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2);
    return () => b.ExpObject() + c.GetValue() > d.ExpObject() ? 1 : 0
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() - .1
}
, () => "Button Sprite", () => "button_border.top", () => "button_border.bottom", () => "button_border.left", () => "button_border.right", () => "EndSize", () => "OnTouch", () => "StartSize", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpInstVar_Family() - c.ExpInstVar_Family() / 15
}
, () => "NoTouch", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpInstVar_Family() + c.ExpInstVar_Family() / 30
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => 0 === b.ExpObject("button_border.left") ? c("Layer 0") : d.ExpObject("button_border.left")
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => 0 === b.ExpObject("button_border.right") ? c("Layer 0") : d.ExpObject("button_border.right")
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => 0 === b.ExpObject("button_border.top") ? c("Layer 0") : d.ExpObject("button_border.top")
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => 0 === b.ExpObject("button_border.bottom") ? c("Layer 0") : d.ExpObject("button_border.bottom")
}
, () => "Language", a => {
    const b = a._GetNode(0).GetVar();
    return () => "lang_" + b.GetValue()
}
, a => {
    const b = a._GetNode(0).GetVar();
    return () => "lang/" + b.GetValue() + ".json"
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod();
    return () => b(c(), 0, "_")
}
, () => "lang", () => "lang_en", () => "lang/en.json", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod();
    return () => b(c(), 1, "_")
}
, () => "AJAX", () => "json2", () => "json", () => "world.gravityDefault", () => 6E3, () => "world.fallspeedDefault", () => 9E3, () => "ButtonDragUID", () => "ButtonDragOffset.x", () => "ButtonDragOffset.y", () => "setting.level_bots", () => '{\n"count_slot" : 6\n}', () => "first_launch", () => "Setting Control Button", () => "setting.control.button_1_player", () => '{\n\t"W" : [87],\n\t"A" : [65],\n\t"S" : [83],\n\t"D" : [68],\n\t"attack" : [74],\n\t"specialbutton" : [75]\n}', () => "setting.control.button_2_player", () => '{\n\t"W" : [87,73],\n\t"A" : [65,74],\n\t"S" : [83,75],\n\t"D" : [68,76],\n\t"attack" : [70,186],\n\t"specialbutton" : [71,222]\n}', () => "reset", () => "LayerOpen.Control", () => "LayerOpen.Control_SelectID", () => "LayerOpen.Control_Index", () => "LayerOpen.Control_IndexPlayer", () => "LayerOpen.Control_ID_count", () => "LayerOpen.Name", () => 222, () => "'", () => 32, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("KEYCODE_NAME.0")
}
, () => 16, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("KEYCODE_NAME.1")
}
, () => 38, () => "\u269b", () => 37, () => "\u26bd", () => "\u231b", () => 39, () => "\ud83d\udd78", () => "Control_Layer", a => {
    const b = a._GetNode(0);
    return () => "mobile" === b.ExpObject("device") ? 1 : 1.2
}
, a => {
    const b = a._GetNode(0).GetVar();
    return () => b.GetValue() + "_UI"
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(76, 76, 109)
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() + 90
}
, () => "CONTROL_TEXT_PLAYER", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(34, 255, 5)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => and("[color=#" + b.ExpInstVar() + "]", c.ExpObject("CONTROL")) + "[/color]"
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b(c.ExpObject()) + 75
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() - 270
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b(c.ExpObject()) - 120
}
, () => "left_button", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() + 270
}
, () => "KeyControlSelect", () => "CONTROL_TEXT_KEY_PRESS", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() + "_UI"
}
, () => "CHANCE_CONTROL_PLAYER_MODE_1", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(0, 255, 85)
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() + 105
}
, () => "CHANCE_CONTROL_PLAYER_MODE_2", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() + 225
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("LayerOpen.Name")
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar();
    return () => b(c.GetValue()) - 255
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar();
    return () => b(c.GetValue()) - 380
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar();
    return () => b(c.GetValue()) + 420
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4).GetVar();
    return () => b(c.ExpObject(and(and(and("setting.control.button_", add$jscomp$4(d.ExpObject("LayerOpen.Control_Player"), 1)) + "_player.", e.ExpObject(and("key_help.", 1))) + ".", f.GetValue() - 1)))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4).GetVar();
    return () => b.ExpObject(and(and(and("setting.control.button_", add$jscomp$4(c.ExpObject("LayerOpen.Control_Player"), 1)) + "_player.", d.ExpObject(and("key_help.", e()))) + ".", f.GetValue() - 1))
}
, a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4).GetVar()
      , h = a._GetNode(5).GetVar()
      , l = a._GetNode(6).GetVar();
    return () => b.GetValue() - c(d.ExpObject("key_help") / 2) + e() * (f.GetValue() + h.GetValue() + l.GetValue())
}
, a => {
    const b = a._GetNode(0).GetVar();
    return () => b.GetValue() - 250
}
, a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2).GetBoundMethod();
    return () => b.GetValue() + c.GetValue() * d()
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("LayerOpen.Control_ID_count")
}
, () => "KEY_NAME_DESC", a => {
    const b = a._GetNode(0);
    return () => add$jscomp$4(b.ExpObject("LayerOpen.Control_ID_count"), 1)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetBoundMethod();
    return () => and("[color=#" + b.ExpInstVar() + "]", c.ExpObject(and("KEYCODE_NAME_DESC.", d()))) + "[/color]"
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() + 35
}
, () => "ControlButtonSelectKey", () => -500, () => "MobileStick", () => "MobileAttack", () => "MobileSpecial", () => "WaitChanceKeyControl", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("LayerOpen.Control_SelectID")
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b(c.ExpObject()) + 270
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => and("[color=#" + b.ExpInstVar() + "]", c.ExpObject("ENTER_NEW_KEY")) + "[/color]"
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => b(c(), add$jscomp$4(d.ExpObject("LayerOpen.Control_Player"), 1))
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() + 7
}
, () => .07, a => {
    const b = a._GetNode(0);
    return () => and("[color=#FF0000]", b.ExpObject("ALREADY_SUCH_KEY")) + "[/color]"
}
, () => "ALREADY_SUCH_KEY_END", a => {
    const b = a._GetNode(0);
    return () => add$jscomp$4(b.ExpObject("LayerOpen.Control_Player"), 1)
}
, () => "scale", a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => and(and("setting.control.button_", b.GetValue()) + "_player." + c.ExpInstVar() + ".", subtract$jscomp$1(d.ExpObject("LayerOpen.Control_IndexPlayer"), 1))
}
, a => {
    const b = a._GetNode(0).GetVar();
    return () => "[color=#FFFFFF]" + b.GetValue() + "[/color]"
}
, a => {
    const b = a._GetNode(0);
    return () => C3$jscomp$399.clamp(b.ExpObject() + 35, 90, 512)
}
, () => "x", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetVar()
      , e = a._GetNode(3)
      , f = a._GetNode(4).GetBoundMethod();
    return () => b(c.ExpObject(and(and("setting.control.button_", d.GetValue()) + "_player.", e.ExpObject(and("key_help.", f("x")))) + ".0"))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetVar()
      , e = a._GetNode(3)
      , f = a._GetNode(4).GetBoundMethod();
    return () => b(c.ExpObject(and(and("setting.control.button_", d.GetValue()) + "_player.", e.ExpObject(and("key_help.", f("x")))) + ".1"))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() - c.ExpInstVar_Family()
}
, a => {
    const b = a._GetNode(0);
    return () => "setting.control.offset." + b.ExpInstVar_Family() + ".0"
}
, a => {
    const b = a._GetNode(0);
    return () => "setting.control.offset." + b.ExpInstVar_Family() + ".1"
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => subtract$jscomp$1(b.ExpObject(), c.ExpObject("setting.control.offset." + d.ExpInstVar_Family() + ".0"))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => subtract$jscomp$1(b.ExpObject(), c.ExpObject("setting.control.offset." + d.ExpInstVar_Family() + ".1"))
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("ButtonDragUID")
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => subtract$jscomp$1(b(), c.ExpObject("ButtonDragOffset.x"))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => subtract$jscomp$1(b(), c.ExpObject("ButtonDragOffset.y"))
}
, () => "Character Buy", a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2).GetVar();
    return () => b.GetValue() + "." + c(d.GetValue())
}
, () => "Position", a => {
    const b = a._GetNode(0).GetVar();
    return () => b.GetValue() + 150
}
, a => {
    const b = a._GetNode(0).GetVar();
    return () => b.GetValue() + 3500
}
, a => {
    const b = a._GetNode(0).GetVar();
    return () => b.GetValue() + 2500
}
, a => {
    const b = a._GetNode(0).GetVar();
    return () => b.GetValue() + 1500
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetBoundMethod();
    return () => C3$jscomp$399.distanceTo(b.ExpObject(), c.ExpObject(), d.ExpObject(), e("BG")) + 1500
}
, a => {
    const b = a._GetNode(0).GetVar();
    return () => b.GetValue() + 600
}
, () => "center_center", () => "center_left", () => "center_right", () => "Menu", () => "COINS", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b(c.ExpObject()) - 25
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b(c.ExpObject()) - 100
}
, () => "ADS_COINS", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() - (c.ExpObject() / 2 + 20)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b(c.ExpObject()) - 107
}
, () => "Bots Level Config", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2).GetVar();
    return () => b(1, c.GetValue() + d.GetValue())
}
, a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2).GetVar()
      , e = a._GetNode(3).GetVar()
      , f = a._GetNode(4).GetVar()
      , h = a._GetNode(5).GetVar();
    return () => b.GetValue() * c.GetValue() + d.GetValue() * e.GetValue() + f.GetValue() * h.GetValue()
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3).GetVar()
      , f = a._GetNode(4).GetVar();
    return () => b(0, c.GetValue() / (2 * d(1, e.GetValue() + f.GetValue())))
}
, a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1).GetVar();
    return () => and(4 <= b.GetValue() ? 1 : 0, .3 <= c.GetValue() ? 1 : 0)
}
, a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1).GetVar();
    return () => and(6 <= b.GetValue() ? 1 : 0, .5 <= c.GetValue() ? 1 : 0)
}
, a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1).GetVar();
    return () => and(8 <= b.GetValue() ? 1 : 0, .6 <= c.GetValue() ? 1 : 0)
}
, a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1).GetVar();
    return () => and(10 <= b.GetValue() ? 1 : 0, .7 <= c.GetValue() ? 1 : 0)
}
, () => "setting.bots_level_analysis.level_bots", () => "setting.bots_level_analysis.win", () => "setting.bots_level_analysis.fail", () => "setting.bots_level_analysis.win_more_50_hp", () => "setting.bots_level_analysis.win_less_50_hp", () => "Preloader Sound", () => "BUFFER ENEMY", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2).GetVar();
    return () => b(c(d.GetValue(), ","))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b() + 2
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2).GetVar()
      , e = a._GetNode(3).GetBoundMethod();
    return () => b(c(d.GetValue(), e(), ","))
}
, () => "Scroll", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("scrollName")
}
, a => {
    const b = a._GetNode(0).GetVar();
    return () => "scroll_" + b.GetValue() + ".scrollS"
}
, a => {
    const b = a._GetNode(0).GetVar();
    return () => "scroll_" + b.GetValue() + ".orientation"
}
, () => "ver", a => {
    const b = a._GetNode(0).GetVar();
    return () => "scroll_" + b.GetValue() + ".scroll"
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2).GetVar()
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4)
      , h = a._GetNode(5).GetVar();
    return () => subtract$jscomp$1(b.ExpObject("scroll_" + c.GetValue() + ".scroll"), d.GetValue() - e(f.ExpObject("scroll_" + h.GetValue() + ".layerName")))
}
, () => "Pobj", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetVar();
    return () => b.ExpObject("scroll_" + c.GetValue() + ".scroll")
}
, a => {
    const b = a._GetNode(0);
    return () => and("scroll_", b.ExpObject("scrollName")) + ".scroll"
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpBehavior("Pobj")
}
, a => {
    const b = a._GetNode(0);
    return () => and("scroll_", b.ExpObject("scrollName")) + ".orientation"
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3)
      , f = a._GetNode(4)
      , h = a._GetNode(5).GetBoundMethod()
      , l = a._GetNode(6)
      , m = a._GetNode(7);
    return () => C3$jscomp$399.clamp(b.ExpObject(and("scroll_", c.ExpObject("scrollName")) + ".scroll"), -1 * d(subtract$jscomp$1(e.ExpObject(and("scroll_", f.ExpObject("scrollName")) + ".scrollM"), h(l.ExpObject(and("scroll_", m.ExpObject("scrollName")) + ".layerName"))), 0), 0)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetVar();
    return () => b.ExpObject("scroll_" + c.GetValue() + ".layerName")
}
, a => {
    const b = a._GetNode(0).GetVar();
    return () => "scroll_" + b.GetValue() + ".scrollM"
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4).GetVar();
    return () => add$jscomp$4(b.ExpObject() + c.ExpObject() - d.ExpObject() / 2, e.ExpObject("scroll_" + f.GetValue() + ".offset.buttom"))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4).GetVar()
      , h = a._GetNode(5)
      , l = a._GetNode(6).GetVar();
    return () => add$jscomp$4(add$jscomp$4(b.ExpObject() + c.ExpObject() - d.ExpObject() / 2, e.ExpObject("scroll_" + f.GetValue() + ".offset.right")), h.ExpObject("scroll_" + l.GetValue() + ".offset.left"))
}
, () => "SystemStopScrolling", a => {
    const b = a._GetNode(0).GetVar();
    return () => "scroll_" + b.GetValue() + ".scrollOld"
}
, a => {
    const b = a._GetNode(0).GetVar();
    return () => "scroll_" + b.GetValue() + ".scrollC"
}
, a => {
    const b = a._GetNode(0);
    return () => and("scroll_", b.ExpObject("scrollName")) + ".scrollOld"
}
, () => "scrollName", () => "towers", a => {
    const b = a._GetNode(0).GetVar();
    return () => "scroll_" + b.GetValue() + ".ScrollActive"
}
, () => "InertiaOff", a => {
    const b = a._GetNode(0);
    return () => and("scroll_", b.ExpObject("scrollName")) + ".scrollS"
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpBehavior("InertiaOff")
}
, a => {
    const b = a._GetNode(0);
    return () => and("scroll_", b.ExpObject("scrollName")) + ".ScrollActive"
}
, a => {
    const b = a._GetNode(0);
    return () => and("scroll_", b.ExpObject("scrollName")) + ".speedScrollMouseWheel"
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject(and("scroll_", c.ExpObject("scrollName")) + ".scroll")
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject(and("scroll_", c.ExpObject("scrollName")) + ".scrollS")
}
, a => {
    const b = a._GetNode(0);
    return () => and("scroll_", b.ExpObject("scrollName")) + ".one_tap"
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3)
      , f = a._GetNode(4);
    return () => 0 === b.ExpObject(and("scroll_", c.ExpObject("scrollName")) + ".border.0") ? d("Layer 0") : e.ExpObject(and("scroll_", f.ExpObject("scrollName")) + ".border.0")
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3)
      , f = a._GetNode(4);
    return () => 0 === b.ExpObject(and("scroll_", c.ExpObject("scrollName")) + ".border.1") ? d("Layer 0") : e.ExpObject(and("scroll_", f.ExpObject("scrollName")) + ".border.1")
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3)
      , f = a._GetNode(4);
    return () => 0 === b.ExpObject(and("scroll_", c.ExpObject("scrollName")) + ".border.2") ? d("Layer 0") : e.ExpObject(and("scroll_", f.ExpObject("scrollName")) + ".border.2")
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3)
      , f = a._GetNode(4);
    return () => 0 === b.ExpObject(and("scroll_", c.ExpObject("scrollName")) + ".border.3") ? d("Layer 0") : e.ExpObject(and("scroll_", f.ExpObject("scrollName")) + ".border.3")
}
, a => {
    const b = a._GetNode(0);
    return () => and("scroll_", b.ExpObject("scrollName")) + ".centerScrollStart"
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => 600 * (1 - Math.pow(1E-4, b()))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => 150 * (1 - Math.pow(1E-4, b()))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject(and("scroll_", c.ExpObject("scrollName")) + ".speedScrollMouseWheel")
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => unaryminus(b.ExpObject(and("scroll_", c.ExpObject("scrollName")) + ".speedScrollMouseWheel"))
}
, a => {
    const b = a._GetNode(0);
    return () => and("scroll_", b.ExpObject("scrollName")) + ".touch_border"
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => subtract$jscomp$1(b(), c.ExpObject(and("scroll_", d.ExpObject("scrollName")) + ".scrollC"))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => Math.abs(b.ExpObject(and("scroll_", c.ExpObject("scrollName")) + ".scroll"))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => Math.abs(b.ExpObject(and("scroll_", c.ExpObject("scrollName")) + ".scrollOld"))
}
, a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1).GetVar();
    return () => b.GetValue() + c.GetValue()
}
, a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1).GetVar();
    return () => b.GetValue() - c.GetValue()
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4).GetBoundMethod()
      , h = a._GetNode(5)
      , l = a._GetNode(6)
      , m = a._GetNode(7).GetBoundMethod()
      , p = a._GetNode(8)
      , r = a._GetNode(9)
      , v = a._GetNode(10)
      , x = a._GetNode(11)
      , B = a._GetNode(12).GetBoundMethod()
      , A = a._GetNode(13)
      , D = a._GetNode(14)
      , F = a._GetNode(15).GetBoundMethod();
    return () => C3$jscomp$399.lerp(b.ExpObject(and("scroll_", c.ExpObject("scrollName")) + ".scroll"), C3$jscomp$399.lerp(C3$jscomp$399.clamp(d.ExpObject(and("scroll_", e.ExpObject("scrollName")) + ".scroll"), -1 * f(subtract$jscomp$1(h.ExpObject(and("scroll_", l.ExpObject("scrollName")) + ".scrollM"), m(p.ExpObject(and("scroll_", r.ExpObject("scrollName")) + ".layerName"))), 0), 0), v.ExpObject(and("scroll_", x.ExpObject("scrollName")) + ".scroll"), 10 * B()), Math.exp(multiply$jscomp$1(unaryminus(A.ExpObject(and("scroll_", D.ExpObject("scrollName")) + ".overEdgeResponce")), F())))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4).GetBoundMethod();
    return () => C3$jscomp$399.lerp(b.ExpObject(and("scroll_", c.ExpObject("scrollName")) + ".scrollS"), 0, subtract$jscomp$1(1, pow$jscomp$1(d.ExpObject(and("scroll_", e.ExpObject("scrollName")) + ".sensibility"), f())))
}
, a => {
    const b = a._GetNode(0);
    return () => and("scroll_", b.ExpObject("scrollName")) + ".scrollM"
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("Layer 0") / 1.5
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject(and("scroll_", c.ExpObject("scrollName")) + ".layerName")
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4).GetBoundMethod();
    return () => C3$jscomp$399.lerp(b.ExpObject(), add$jscomp$4(c.ExpInstVar(), d.ExpObject(and("scroll_", e.ExpObject("scrollName")) + ".scroll")), 1.1 - Math.pow(1E-4, f()))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => add$jscomp$4(b.ExpInstVar(), c.ExpObject(and("scroll_", d.ExpObject("scrollName")) + ".scroll"))
}
, () => "CoinsShake", a => {
    const b = a._GetNode(0);
    return () => b.ExpInstVar() - 30
}
, () => "CoinsColor", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(150, 0, 0)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => and(and("[offsetY=-7][color=#" + b.ExpInstVar() + "]", c.ExpObject("coins")) + "[/offsetY][/color][scale=", d.ExpObject() + .05) + "]\u2600\ufe0f[/scale]"
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() + 80
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("sdk.adRewardCoinsMenu")
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => and(and("[offsetY=-7][color=#" + b.ExpInstVar() + "]", c.ExpInstVar()) + "[/offsetY][/color][scale=", d.ExpObject() + .05) + "]\u2600\ufe0f[/scale]"
}
, () => "CONFETTI", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2).GetVar()
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4).GetVar();
    return () => b(c(d.GetValue()) + 100, e(f.GetValue()) - 100)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2).GetBoundMethod();
    return () => b(c.GetValue()) + d(0, 1E3)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetBoundMethod();
    return () => b(c.ExpObject()) - d(700, -800)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2);
    return () => b(c(0, d.ExpObject()))
}
, () => "PosUp", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3);
    return () => C3$jscomp$399.distanceTo(b.ExpObject(), c.ExpObject(), d.ExpObject(), e.ExpInstVar()) / 2500
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod();
    return () => b.ExpObject() + c(300, -300)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(.5, 2)
}
, () => "Menu/Open", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => -(b.ExpObject() - c.ExpObject() / 4)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(.3, .7)
}
, () => "PosDown", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetBoundMethod();
    return () => b(c.ExpObject()) + 300 + d(0, 500)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4)
      , h = a._GetNode(5).GetBoundMethod();
    return () => C3$jscomp$399.distanceTo(b.ExpObject(), c.ExpObject(), d.ExpObject(), e(f.ExpObject()) + 300 + h(0, 500)) / 1E3
}
, () => "PLAYGAMA", () => "FLAG", () => "show", () => "GAME_RATED", () => "DELETE_FEEDBACK_RESTART", () => "MESSAGE_LAYER", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("MESSAGE_LAYER")
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("MESSAGE_LAYER") - 50
}
, () => "REVIEW_ALREADY_REQUESTED", () => "LEAVE_FEEDBACK", () => "RESTART_GAME_FEEDBACK", () => "NO_AUTH", () => "YOU_NO_AUTH", () => "true", () => "setting.feedback_review.value", () => "setting.feedback_review.button_create", () => "feedback_review", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => and("buy_", b.ExpObject(subtract$jscomp$1(c.ExpObject("UnlockedCharacter.index"), 1)))
}
, () => "THANKS_FOR_FEEDBACK", a => {
    const b = a._GetNode(0);
    return () => and("towers.open.", subtract$jscomp$1(b.ExpObject("UnlockedCharacter.index"), 3))
}
, a => {
    const b = a._GetNode(0);
    return () => and("towers.open.", subtract$jscomp$1(b.ExpObject("UnlockedCharacter.index"), 2))
}
, a => {
    const b = a._GetNode(0);
    return () => subtract$jscomp$1(b.ExpObject("UnlockedCharacter.index"), 2)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject(subtract$jscomp$1(c.ExpObject("UnlockedCharacter.index"), 1))
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("UnlockedCharacter.index")
}
, () => "false", () => "sdk.tag", () => "show_interstitial", () => "stop", () => "play", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("sdk.tag")
}
, () => "menu_theme", () => "towers_theme", () => "towers_continue_game_room", () => "CONTINUE_TOWERS_BATTLE", () => "ads_coins_menu", () => "UI_ROOM", () => "select_mode", () => "EDUCATION", () => "MESSAGE_SYSTEM", () => "MESSAGE_TEXT", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetVar();
    return () => and("[color=#" + b.ExpInstVar() + "]", c.ExpObject(d.GetValue())) + "[/color]"
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() + 325
}
, () => "Y_start", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2).GetBoundMethod();
    return () => 1 === Math.round(b(0)) % 2 ? Math.round(c(0)) - 1 : Math.round(d(0))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2).GetVar()
      , e = a._GetNode(3).GetVar();
    return () => b() / c() / (d.GetValue() / e.GetValue())
}
, a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2).GetVar()
      , e = a._GetNode(3).GetVar()
      , f = a._GetNode(4).GetVar()
      , h = a._GetNode(5).GetVar();
    return () => 1 < b.GetValue() ? Math.floor(c.GetValue() * d.GetValue()) : 1 > e.GetValue() ? f.GetValue() : h.GetValue()
}
, a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2).GetVar()
      , e = a._GetNode(3).GetVar()
      , f = a._GetNode(4).GetVar()
      , h = a._GetNode(5).GetVar();
    return () => 1 > b.GetValue() ? Math.floor(c.GetValue() / d.GetValue()) : 1 < e.GetValue() ? f.GetValue() : h.GetValue()
}
, () => "resize_canvas", () => "save", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("save")
}
, () => "music/menu_theme", () => 5.9, () => "LOADER_ROOM", () => "UNLOCKED_PANEL", () => "FEEDBACK_PANEL", () => "CHARACTER", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod();
    return () => b.ExpObject() + .2 * (1.6 - Math.pow(1E-4, c()))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod();
    return () => b.ExpObject() - .7 * (1.6 - Math.pow(1E-4, c()))
}
, () => "createButtonModeFightCountPlayer", () => "one_tap_menu", () => "last_mode_games", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("mode_games")
}
, () => "sync_frame_loader_scene", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => b.ExpObject() + 1 > c.ExpObject() ? 0 : d.ExpObject() + 1
}
, a => {
    const b = a._GetNode(0);
    return () => and("scroll_", b.ExpObject("scrollName")) + ".one_open_item"
}
, () => "ad_reward_coins_menu", () => "education", a => {
    const b = a._GetNode(0);
    return () => and("scroll_", b.ExpObject("scrollName")) + ".border.2"
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("Layer 0") + 150
}
, a => {
    const b = a._GetNode(0);
    return () => and("scroll_", b.ExpObject("scrollName")) + ".border.3"
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("Layer 0") - 250
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4)
      , h = a._GetNode(5)
      , l = a._GetNode(6).GetBoundMethod()
      , m = a._GetNode(7)
      , p = a._GetNode(8);
    return () => b(c.ExpObject(and("scroll_", d.ExpObject("scrollName")) + ".layerName"), "Layer 0", e(f.ExpObject(and("scroll_", h.ExpObject("scrollName")) + ".layerName")), l(m.ExpObject(and("scroll_", p.ExpObject("scrollName")) + ".layerName")) + 150)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4)
      , h = a._GetNode(5)
      , l = a._GetNode(6).GetBoundMethod()
      , m = a._GetNode(7)
      , p = a._GetNode(8);
    return () => b(c.ExpObject(and("scroll_", d.ExpObject("scrollName")) + ".layerName"), "Layer 0", e(f.ExpObject(and("scroll_", h.ExpObject("scrollName")) + ".layerName")), l(m.ExpObject(and("scroll_", p.ExpObject("scrollName")) + ".layerName")) - 250)
}
, () => "SELECT FIGHTER", () => 1.23, () => "EDUCATION_ITEM", () => "EDUCATION_BLEND", () => "PLAY", () => "TG_CHANNEL", () => "SELECT_LEVEL_BOTS", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("COINS") - 25
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("COINS") - 100
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() - 7
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod();
    return () => "[color=#" + b.ExpInstVar() + "]" + c() + "[/color]"
}
, () => "speed_animation", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => "[color=#" + b.ExpInstVar() + "]X" + (0 === c.ExpObject("setting.speed_animation") ? "1.0" : "1.5") + "[/color]"
}
, () => "turnSelectCharacter", () => "tap", () => "BUTTON_MENU", () => "BUTTON_PLAY", () => "poki.tap", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => and("character_unlocked.", b.ExpObject(c.ExpInstVar() - 1))
}
, () => "SELECT_MODE", () => "show_tg_channel", () => "https://t.me/tempoplay", () => "NewWindow", () => "CLOSE", () => "DEMONSTRATION", () => "GoToLayouts", () => "sellCharacterBuy", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject(and("UnlockedCharacter.sell.", subtract$jscomp$1(c.ExpObject("UnlockedCharacter.index"), 4)))
}
, () => "Menu/Buy", () => "theTowersCharacterBuy", a => {
    const b = a._GetNode(0);
    return () => subtract$jscomp$1(b.ExpObject("UnlockedCharacter.index"), 3)
}
, () => "towers_room.startLayoutsScroll", () => "SELECT_MODE_FIGHT_COUNT_ITEM", () => "SELECT_COUNT_PLAYER_MODE_FIGHT", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("SETTING")
}
, () => "menu", () => "1_PLAYERS", () => "BG", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(66, 66, 95)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(142, 142, 194)
}
, () => "2_PLAYERS", () => "TOWERS", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(75, 81, 108)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(92, 103, 127)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(142, 172, 194)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(87, 87, 92)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(70, 72, 88)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(152, 182, 194)
}
, () => "ONLINE", () => "BEGIN", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => b.ExpObject("setting.level_bots") > subtract$jscomp$1(c.ExpObject("game_config.max_level_bot"), 1) ? 0 : add$jscomp$4(d.ExpObject("setting.level_bots"), 1)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => 0 >= b.ExpObject("setting.level_bots") ? c.ExpObject("game_config.max_level_bot") : subtract$jscomp$1(d.ExpObject("setting.level_bots"), 1)
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() - 5 + 15
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4)
      , h = a._GetNode(5);
    return () => and(and("[color=#", b.ExpObject(and("select_level_menu_color.", c.ExpObject("setting.level_bots")))) + "]", 0 === d.ExpObject("setting.level_bots") ? e.ExpObject("LEVEL_BOTS_NAME.0") : f.ExpObject(and("LEVEL_BOTS_NAME.", h.ExpObject("setting.level_bots")))) + "[/color]"
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => multiply$jscomp$1(divide$jscomp$1(b.ExpObject("setting.level_bots"), c.ExpObject("game_config.max_level_bot")), 250)
}
, () => "NAME_CHARACTER", () => 230, () => "SELECT_BTN", () => "ArraySelectMode", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("ArraySelectMode")
}
, a => {
    const b = a._GetNode(0);
    return () => "mobile" === b.ExpObject("device") ? 15 : 0
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2).GetVar()
      , e = a._GetNode(3).GetVar()
      , f = a._GetNode(4).GetBoundMethod()
      , h = a._GetNode(5).GetVar();
    return () => b("UI_ROOM") - c.GetValue() * (d.GetValue() / 2) - 5 + e.GetValue() * f() + h.GetValue() / 2
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar();
    return () => b("UI_ROOM") + 30 + c.GetValue()
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod();
    return () => b.ExpObject(and("ArraySelectMode.", c()))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetVar();
    return () => b.ExpObject() - c.GetValue() / 2
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => and("ArraySelectMode.", b())
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod();
    return () => and("Alert.", b.ExpObject(and("ArraySelectMode.", c())))
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() + 85
}
, () => "NEW", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => and("[color=#FFFFFF]", b.ExpObject(c.ExpObject(and("ArraySelectMode.", d.ExpInstVar_Family())))) + "[/color]"
}
, a => {
    const b = a._GetNode(0);
    return () => and("ScaleText_", b.ExpInstVar_Family())
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("select_mode")
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(62, 254, 65)
}
, () => "FFFFFF", () => "LoadEducationStart", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => and("Alert.", b.ExpObject(and("ArraySelectMode.", c.ExpInstVar_Family())))
}
, a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3);
    return () => and("[color=#" + b.GetValue() + "]", c.ExpObject(d.ExpObject(and("ArraySelectMode.", e.ExpInstVar_Family())))) + "[/color]"
}
, () => "TRAINING", () => "Training", () => "Online", () => "Character Avatar", () => "KEYBOARD_CONTROL_SELECT_", () => "keyboard_key_select_character", a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1).GetVar();
    return () => b.GetValue() + "." + c.GetValue()
}
, () => "select_character_param.c.p1", () => "select_character_param.c.p2", () => "select_character_param.r.p1", () => "select_character_param.r.p2", a => {
    const b = a._GetNode(0).GetVar();
    return () => and("select_character_param.c.p", b.GetValue())
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetVar()
      , f = a._GetNode(4).GetVar()
      , h = a._GetNode(5)
      , l = a._GetNode(6).GetVar()
      , m = a._GetNode(7)
      , p = a._GetNode(8).GetVar();
    return () => add$jscomp$4(b.ExpObject(and("select_character_param.c.p", c.GetValue())), d.ExpObject(and("keyboard_key_select_character.", e.GetValue()) + ".0")) > f.GetValue() ? 0 : add$jscomp$4(h.ExpObject(and("select_character_param.c.p", l.GetValue())), m.ExpObject(and("keyboard_key_select_character.", p.GetValue()) + ".0"))
}
, a => {
    const b = a._GetNode(0).GetVar();
    return () => and("select_character_param.r.p", b.GetValue())
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetVar()
      , f = a._GetNode(4).GetVar()
      , h = a._GetNode(5)
      , l = a._GetNode(6).GetVar()
      , m = a._GetNode(7)
      , p = a._GetNode(8).GetVar();
    return () => add$jscomp$4(b.ExpObject(and("select_character_param.r.p", c.GetValue())), d.ExpObject(and("keyboard_key_select_character.", e.GetValue()) + ".1")) > f.GetValue() ? 0 : add$jscomp$4(h.ExpObject(and("select_character_param.r.p", l.GetValue())), m.ExpObject(and("keyboard_key_select_character.", p.GetValue()) + ".1"))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetVar();
    return () => b.ExpObject(and("select_character_param.c.p", c.GetValue()))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetVar();
    return () => b.ExpObject(and("select_character_param.r.p", c.GetValue()))
}
, a => {
    const b = a._GetNode(0);
    return () => "character_unlocked." + b.ExpInstVar()
}
, () => 83, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3);
    return () => b.ExpObject("education.index") < C3$jscomp$399.clamp(subtract$jscomp$1(c.ExpObject("education.open"), 1), 1, subtract$jscomp$1(d.ExpObject("education.max"), 1)) ? add$jscomp$4(e.ExpObject("education.index"), 1) : 0
}
, () => 87, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3);
    return () => 0 < b.ExpObject("education.index") ? subtract$jscomp$1(c.ExpObject("education.index"), 1) : C3$jscomp$399.clamp(subtract$jscomp$1(d.ExpObject("education.open"), 1), 1, subtract$jscomp$1(e.ExpObject("education.max"), 1))
}
, a => {
    const b = a._GetNode(0);
    return () => add$jscomp$4(b.ExpObject("education.index"), 1)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => and("keyboard_key_select_character.", b())
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod();
    return () => b.ExpObject(and("keyboard_key_select_character.", c()) + ".2")
}
, () => "Grayscale", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2).GetVar();
    return () => b(c.GetValue() / d.GetValue())
}
, a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2).GetVar()
      , e = a._GetNode(3).GetVar()
      , f = a._GetNode(4).GetVar();
    return () => b.GetValue() === c.GetValue() ? d.GetValue() % e.GetValue() : f.GetValue() - 1
}
, a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1).GetVar();
    return () => b.GetValue() % c.GetValue()
}
, a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2).GetVar()
      , e = a._GetNode(3).GetVar()
      , f = a._GetNode(4).GetVar();
    return () => b.GetValue() - c.GetValue() * (d.GetValue() / 2) + e.GetValue() * f.GetValue()
}
, () => "EndPos", () => .18, () => -225, () => -224, () => -576, a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2).GetVar()
      , e = a._GetNode(3).GetVar()
      , f = a._GetNode(4).GetVar()
      , h = a._GetNode(5).GetVar();
    return () => 5 > Math.ceil(b.GetValue() / c.GetValue()) ? d.GetValue() : e.GetValue() * (4 / Math.ceil(f.GetValue() / h.GetValue()))
}
, a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2).GetVar()
      , e = a._GetNode(3).GetVar();
    return () => 5 > Math.ceil(b.GetValue() / c.GetValue()) ? 1 : 4 / Math.ceil(d.GetValue() / e.GetValue())
}
, a => {
    const b = a._GetNode(0).GetVar();
    return () => and("CHARACTER_ICON_", b.GetValue() - 1)
}
, a => {
    const b = a._GetNode(0);
    return () => "mobile" === b.ExpObject("device") ? 30 : 0
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2).GetVar()
      , e = a._GetNode(3).GetVar();
    return () => b(c() / d.GetValue()) * e.GetValue()
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2).GetVar()
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4).GetBoundMethod()
      , h = a._GetNode(5).GetVar()
      , l = a._GetNode(6).GetVar();
    return () => b(c.GetValue() - 1, d.GetValue(), e(), f(h.GetValue()), l.GetValue())
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2).GetVar()
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4).GetVar()
      , h = a._GetNode(5).GetVar()
      , l = a._GetNode(6).GetVar()
      , m = a._GetNode(7).GetVar()
      , p = a._GetNode(8).GetVar()
      , r = a._GetNode(9).GetVar()
      , v = a._GetNode(10).GetVar()
      , x = a._GetNode(11).GetVar();
    return () => b(c.GetValue()) + 80 - d.GetValue() - e(f.GetValue() / h.GetValue()) * l.GetValue() * (5 > Math.ceil(m.GetValue() / p.GetValue()) ? 1 : 4 / Math.ceil(r.GetValue() / v.GetValue())) / 2 + x.GetValue()
}
, () => "CHARACTER_ICON", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3)
      , f = a._GetNode(4)
      , h = a._GetNode(5).GetBoundMethod()
      , l = a._GetNode(6).GetBoundMethod()
      , m = a._GetNode(7).GetBoundMethod()
      , p = a._GetNode(8)
      , r = a._GetNode(9)
      , v = a._GetNode(10).GetBoundMethod()
      , x = a._GetNode(11).GetBoundMethod()
      , B = a._GetNode(12).GetBoundMethod()
      , A = a._GetNode(13)
      , D = a._GetNode(14)
      , F = a._GetNode(15).GetBoundMethod();
    return () => b(c(d(e.ExpObject(and("character.", f.ExpObject(h())) + ".color_fon"), 0, ",")), l(m(p.ExpObject(and("character.", r.ExpObject(v())) + ".color_fon"), 1, ",")), x(B(A.ExpObject(and("character.", D.ExpObject(F())) + ".color_fon"), 2, ",")))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar();
    return () => b() % (c.GetValue() / 2)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2).GetVar();
    return () => b(c() / (d.GetValue() / 2))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod();
    return () => b.ExpObject(c())
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2).GetVar();
    return () => b(c() / d.GetValue())
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() - 32
}
, () => "LockedSprite", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4).GetVar()
      , h = a._GetNode(5).GetVar();
    return () => and("[color=#" + b.ExpInstVar() + "]", c.ExpObject(and("character.", d.ExpObject(subtract$jscomp$1(e.ExpObject(and("select_character.player_", f.GetValue())), 1))) + ".name." + h.GetValue())) + "[/color]"
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2).GetVar()
      , e = a._GetNode(3).GetVar()
      , f = a._GetNode(4).GetVar()
      , h = a._GetNode(5).GetVar()
      , l = a._GetNode(6).GetVar();
    return () => b.ExpObject() - (c(d.GetValue()) - 2 * (e.GetValue() + 12)) + (f.GetValue() + 8) * (h.GetValue() / 2) * 2 * (l.GetValue() - 1)
}
, a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2).GetVar()
      , e = a._GetNode(3).GetVar();
    return () => 5 > Math.ceil(b.GetValue() / c.GetValue()) ? 1.05 : 1.05 * (4 / Math.ceil(d.GetValue() / e.GetValue()))
}
, () => "Start", () => 95, () => "w1", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject(and("select_character.player_", c.ExpInstVar()))
}
, a => {
    const b = a._GetNode(0);
    return () => and("select_character.player_", b.ExpObject("turnSelectCharacter"))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject(and("select_character.player_", c.ExpObject("turnSelectCharacter")))
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("turnSelectCharacter")
}
, a => {
    const b = a._GetNode(0);
    return () => and("select_character_param.c.p", b.ExpInstVar())
}
, a => {
    const b = a._GetNode(0);
    return () => and("select_character_param.r.p", b.ExpInstVar())
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4)
      , h = a._GetNode(5).GetVar();
    return () => and("[color=#" + b.ExpInstVar() + "]", c.ExpObject(and("character.", d.ExpObject(subtract$jscomp$1(e.ExpObject(and("select_character.player_", f.ExpObject("turnSelectCharacter"))), 1))) + ".name." + h.GetValue())) + "[/color]"
}
, () => "Menu/ButClick_10", () => "game_config.load_character", () => "mode_towers", a => {
    const b = a._GetNode(0);
    return () => subtract$jscomp$1(b.ExpObject("towers.progress.win"), 2)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetBoundMethod();
    return () => b.ExpObject(and(and("towers_array.", c.ExpObject("towers.select")) + ".", d())).toString()
}
, () => "mode_1_player", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("select_character.player_2").toString()
}
, () => "mode_2_players", () => "open_demo", () => "mode_training", () => "mode_modeFight", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => and("fighter_", b.ExpObject(subtract$jscomp$1(c.ExpObject("select_character.player_1"), 1)))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpInstVar() - c.ExpInstVar() / 3
}
, () => "Panel_Open", () => 60, a => {
    const b = a._GetNode(0);
    return () => "mobile" === b.ExpObject("device") ? 1.3 : 1
}
, a => {
    const b = a._GetNode(0);
    return () => "Menu" === b.ExpObject("lastRoom") ? 111 : 85
}
, a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetVar();
    return () => multiply$jscomp$1(b.GetValue(), subtract$jscomp$1(1, c.ExpObject("setting." + d.GetValue())))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetVar();
    return () => multiply$jscomp$1(20, subtract$jscomp$1(1, b.ExpObject("setting." + c.GetValue())))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetVar();
    return () => multiply$jscomp$1(100, subtract$jscomp$1(1, b.ExpObject("setting." + c.GetValue())))
}
, a => {
    const b = a._GetNode(0).GetVar();
    return () => "setting." + b.GetValue()
}
, () => "Select Character", () => "Towers Lobby", () => "Panel_Closed", () => "EDUCATION LIST", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4).GetBoundMethod()
      , h = a._GetNode(5)
      , l = a._GetNode(6);
    return () => b("BG", "Layer 0", c(d.ExpObject(and("scroll_", e.ExpObject("scrollName")) + ".layerName")), f(h.ExpObject(and("scroll_", l.ExpObject("scrollName")) + ".layerName")) + 180)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4).GetBoundMethod()
      , h = a._GetNode(5)
      , l = a._GetNode(6);
    return () => b("BG", "Layer 0", c(d.ExpObject(and("scroll_", e.ExpObject("scrollName")) + ".layerName")), f(h.ExpObject(and("scroll_", l.ExpObject("scrollName")) + ".layerName")) - 250)
}
, () => "top", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => b(c.ExpObject(and("scroll_", d.ExpObject("scrollName")) + ".layerName")) + 180
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4)
      , h = a._GetNode(5);
    return () => C3$jscomp$399.distanceTo(b.ExpObject(), c.ExpObject(), d.ExpObject(), e(f.ExpObject(and("scroll_", h.ExpObject("scrollName")) + ".layerName")) - 150)
}
, () => "buttom", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => b(c.ExpObject(and("scroll_", d.ExpObject("scrollName")) + ".layerName")) - 250
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4)
      , h = a._GetNode(5);
    return () => -C3$jscomp$399.distanceTo(b.ExpObject(), c.ExpObject(), d.ExpObject(), e(f.ExpObject(and("scroll_", h.ExpObject("scrollName")) + ".layerName")) + 150)
}
, () => "ItemBorderEdication", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4)
      , h = a._GetNode(5).GetBoundMethod()
      , l = a._GetNode(6)
      , m = a._GetNode(7)
      , p = a._GetNode(8)
      , r = a._GetNode(9);
    return () => C3$jscomp$399.clamp(C3$jscomp$399.distanceTo(b.ExpObject(), c(d.ExpObject(and("scroll_", e.ExpObject("scrollName")) + ".layerName")) + 160, f.ExpObject(), h(l.ExpObject(and("scroll_", m.ExpObject("scrollName")) + ".layerName")) - 225), 0, add$jscomp$4(p.ExpObject(and("scroll_", r.ExpObject("scrollName")) + ".maxSize"), 65))
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("education.open")
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("education.max")
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => b(c.ExpObject(and("scroll_", d.ExpObject("scrollName")) + ".layerName"))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4)
      , h = a._GetNode(5)
      , l = a._GetNode(6)
      , m = a._GetNode(7)
      , p = a._GetNode(8)
      , r = a._GetNode(9)
      , v = a._GetNode(10)
      , x = a._GetNode(11)
      , B = a._GetNode(12)
      , A = a._GetNode(13).GetVar();
    return () => add$jscomp$4(add$jscomp$4(add$jscomp$4(add$jscomp$4(b(c.ExpObject(and("scroll_", d.ExpObject("scrollName")) + ".layerName")), e.ExpObject(and("scroll_", f.ExpObject("scrollName")) + ".offset.top")), h.ExpObject(and("scroll_", l.ExpObject("scrollName")) + ".offset.centerstep")), divide$jscomp$1(m.ExpObject(and("scroll_", p.ExpObject("scrollName")) + ".elementH"), 2)), multiply$jscomp$1(add$jscomp$4(r.ExpObject(and("scroll_", v.ExpObject("scrollName")) + ".elementH"), x.ExpObject(and("scroll_", B.ExpObject("scrollName")) + ".offset.centerstep")), A.GetValue()))
}
, a => {
    const b = a._GetNode(0);
    return () => and("scroll_", b.ExpObject("scrollName")) + ".countItem"
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject(and("scroll_", c.ExpObject("scrollName")) + ".elementW")
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject(and("scroll_", c.ExpObject("scrollName")) + ".elementH")
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(90, 107, 140)
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() - 38
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetBoundMethod();
    return () => and("[color=#" + b.ExpInstVar() + "]", c.ExpObject(and("EDUCATION_NAME_ARRAY.", d()))) + "[/color]"
}
, () => "EDUCATION_DESC", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetBoundMethod();
    return () => and("[color=#" + b.ExpInstVar() + "]", c.ExpObject(and("EDUCATION_DESC_ARRAY.", d()))) + "[/color]"
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetVar();
    return () => b.ExpObject() - c.GetValue() - 7
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() - 4
}
, () => "EDUCATION_REWARD", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b() % 2
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() - 30
}
, () => "EDUCATION_REWARD_TEXT", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetVar();
    return () => b.ExpObject() - (c.GetValue() - 10)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3);
    return () => and(and("[offsetY=-7][color=#" + b.ExpInstVar() + "]", c.ExpObject(and("education.reward.", d()))) + "[/offsetY][/color][scale=", e.ExpObject() + .05) + "]\u2600\ufe0f[/scale]"
}
, a => {
    const b = a._GetNode(0);
    return () => and("[color=#00FF00]", b.ExpObject("COMPLETED")) + "[/color]"
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4);
    return () => add$jscomp$4(b.ExpObject(), add$jscomp$4(c.ExpObject(and("scroll_", d.ExpObject("scrollName")) + ".offset.centerstep"), e.ExpObject(and("scroll_", f.ExpObject("scrollName")) + ".elementH")))
}
, a => {
    const b = a._GetNode(0);
    return () => add$jscomp$4(b.ExpObject("education.open"), 1)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => and("[color=#" + b.ExpInstVar() + "]", c.ExpObject("EDUCATION_UNLOCK_DESC")) + "[/color]"
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => and("[color=#" + b.ExpInstVar() + "]", c.ExpObject("BLOCKED")) + "[/color]"
}
, a => {
    const b = a._GetNode(0);
    return () => and("scroll_", b.ExpObject("scrollName")) + ".maxSize"
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4)
      , h = a._GetNode(5)
      , l = a._GetNode(6)
      , m = a._GetNode(7);
    return () => divide$jscomp$1(add$jscomp$4(add$jscomp$4(b.ExpObject(and("scroll_", c.ExpObject("scrollName")) + ".offset.centerstep"), d.ExpObject(and("scroll_", e.ExpObject("scrollName")) + ".elementH")), add$jscomp$4(f.ExpObject(and("scroll_", h.ExpObject("scrollName")) + ".elementH"), l.ExpObject(and("scroll_", m.ExpObject("scrollName")) + ".offset.centerstep"))), 2)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => b(c.ExpObject(and("scroll_", d.ExpObject("scrollName")) + ".layerName")) + 160
}
, () => "select_education", () => "UnlockedCharacter.index", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar();
    return () => b(c.GetValue()) + 145
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetVar();
    return () => and("CharacterPreviewLoad.", b.ExpObject(c.GetValue() - 1))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetVar();
    return () => b.ExpObject(c.GetValue() - 1)
}
, () => 340, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetVar();
    return () => and("CharacterPreview/character_", b.ExpObject(c.GetValue() - 1)) + ".png"
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar();
    return () => b(c.GetValue()) + 25
}
, () => "ELSE", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() + 260
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpInstVar() - c.ExpInstVar() / 10
}
, () => "UNLOCKED_CHARACTER", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4)
      , h = a._GetNode(5).GetVar()
      , l = a._GetNode(6).GetVar();
    return () => "[color=#" + b.ExpInstVar() + "]" + c(d.ExpObject("UNLOCKED_CHARACTER"), e.ExpObject(and("character.", f.ExpObject(h.GetValue() - 1)) + ".name." + l.GetValue())) + "[/color]"
}
, () => "UNLOCKED_CHARACTER_DESC_TOWERS", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4)
      , h = a._GetNode(5).GetVar()
      , l = a._GetNode(6).GetVar();
    return () => "[color=#" + b.ExpInstVar() + "]" + c(d.ExpObject("UNLOCKED_CHARACTER_DESC_TOWERS"), e.ExpObject(and("character.", f.ExpObject(h.GetValue() - 1)) + ".name." + l.GetValue())) + "[/color]"
}
, () => "SELL", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetVar()
      , e = a._GetNode(3);
    return () => and(and("[offsetY=-7][color=#" + b.ExpInstVar() + "]", c.ExpObject(and("UnlockedCharacter.sell.", d.GetValue() - 4))) + "[/offsetY][/color][scale=", e.ExpObject() + .05) + "]\u2600\ufe0f[/scale]"
}
, a => {
    const b = a._GetNode(0);
    return () => "CharacterPreviewLoad." + b.ExpInstVar()
}
, () => "character_unlocked.nox", () => "ZoomLayerMenu", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("UI_ROOM")
}
, () => "Unlocked Character ", () => "UnlockedCoinsCountBuffer", () => "UnlockedCharacterCountBuffer", () => "UnlockedCharacter.skip_animation_buy", () => "UnlockedCharacterPanelEnd", () => "UnlockedCharacterPanelEnd SKIP", () => "towers_room.locked_reward_animation", () => "Menu/TowerSuccess", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(113, 167, 254)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2).GetVar()
      , e = a._GetNode(3)
      , f = a._GetNode(4).GetVar()
      , h = a._GetNode(5).GetVar();
    return () => add$jscomp$4(subtract$jscomp$1(b("COINS"), multiply$jscomp$1(c.GetValue(), divide$jscomp$1(subtract$jscomp$1(d.GetValue(), e.ExpObject("UnlockedCoinsCountBuffer")), 2))), f.GetValue() * h.GetValue())
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("COINS") + 100
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod();
    return () => subtract$jscomp$1(b.ExpObject(c(), 1), 1)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod();
    return () => b.ExpObject(c(), 1)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("COINS")
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b("COINS") + (0 < c.ExpObject("UnlockedCharacterCountBuffer") ? 250 : 0)
}
, () => "COINS_ADD", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2);
    return () => and(and("[offsetY=-7][color=#" + b.ExpInstVar() + "]+", c.GetValue()) + "[/offsetY][/color][scale=", d.ExpObject() + .05) + "]\u2600\ufe0f[/scale]"
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("COINS") + 200
}
, () => "Unlocked", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => and("[color=#" + b.ExpInstVar() + "]", c.ExpObject("CONGRATULATIONS")) + "[/color]"
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(115, 255, 97)
}
, () => "UI_ROOM_INTERACTIVE", () => "FEEDBACK REVIEW", a => {
    const b = a._GetNode(0);
    return () => -1 * b.ExpObject()
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() - c.ExpObject() / 2 - 6
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() + c.ExpObject() / 2 - 15
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => and("[color=#" + b.ExpInstVar() + "]", c.ExpObject("FREE")) + "[/color]"
}
, () => "NAME_CHARACTER_FEEDBACK", () => "REWARD_FEEDBACK_DESC", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => and("[color=#" + b.ExpInstVar() + "]", c.ExpObject("REWARD_FEEDBACK_DESC")) + "[/color]"
}
, () => "MODE_FIGHT_GROUP", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar();
    return () => b(c.GetValue()) + 220
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar();
    return () => b(c.GetValue()) - 98
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3);
    return () => and("[color=#" + b.ExpInstVar() + "]", c.ExpObject(d(e.ExpInstVar() - 1, "1_PLAYERS", "2_PLAYERS"))) + "[/color]"
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar();
    return () => b(c.GetValue()) - 220
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(25, 25, 25)
}
, a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4).GetBoundMethod()
      , h = a._GetNode(5);
    return () => and("[color=#" + (b.GetValue() === c.ExpInstVar() ? "FFFFFF" : d.ExpInstVar()) + "]", e.ExpObject(f(h.ExpInstVar() - 1, "1_PLAYERS", "2_PLAYERS"))) + "[/color]"
}
, () => "mode_fight_slot.count_slot", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2).GetVar()
      , e = a._GetNode(3);
    return () => b.ExpObject("mode_fight_slot.count_slot") > c.GetValue() - 1 ? d.GetValue() : add$jscomp$4(e.ExpObject("mode_fight_slot.count_slot"), 1)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => 3 >= b.ExpObject("mode_fight_slot.count_slot") ? 3 : subtract$jscomp$1(c.ExpObject("mode_fight_slot.count_slot"), 1)
}
, () => "MODE_FIGHT_COUNT_ITEM", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2)
      , e = a._GetNode(3);
    return () => "[color=#" + b.ExpInstVar() + "]" + c(d.ExpObject("MODE_FIGHT_TITLE_2"), subtract$jscomp$1(e.ExpObject("mode_fight_slot.count_slot"), 2), 4) + "[/color]"
}
, () => "bar", a => {
    const b = a._GetNode(0);
    return () => multiply$jscomp$1(150, subtract$jscomp$1(b.ExpObject("mode_fight_slot.count_slot"), 2))
}
, () => "index_load_character", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4)
      , h = a._GetNode(5);
    return () => and(and("[color=#" + b.ExpInstVar() + "]", c.ExpObject(d.ExpInstVar())) + " ", e(multiply$jscomp$1(divide$jscomp$1(f.ExpObject("index_load_character"), h.ExpObject()), 100))) + "%[/color]"
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => multiply$jscomp$1(divide$jscomp$1(b.ExpObject("index_load_character"), c.ExpObject()), 1792)
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("index_load_character")
}
, () => "go_to_layer_load_scene_end", () => "TOWERS_ITEM", () => "BG1", () => "BG0", () => "BG2", () => "FLASH", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("Layer 0") + 200
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("Layer 0") - 200
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4).GetBoundMethod()
      , h = a._GetNode(5)
      , l = a._GetNode(6);
    return () => b("BG", "Layer 0", c(d.ExpObject(and("scroll_", e.ExpObject("scrollName")) + ".layerName")), f(h.ExpObject(and("scroll_", l.ExpObject("scrollName")) + ".layerName")) + 150)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4).GetBoundMethod()
      , h = a._GetNode(5)
      , l = a._GetNode(6);
    return () => b("BG", "Layer 0", c(d.ExpObject(and("scroll_", e.ExpObject("scrollName")) + ".layerName")), f(h.ExpObject(and("scroll_", l.ExpObject("scrollName")) + ".layerName")) - 150)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4)
      , h = a._GetNode(5);
    return () => and("[color=#" + b.ExpInstVar() + "]", 0 === c.ExpObject("setting.level_bots") ? d.ExpObject("LEVEL_BOTS.0") : e(f.ExpObject("LEVEL_BOTS.1"), h.ExpObject("setting.level_bots"))) + "[/color]"
}
, () => "education.completed.towers_swipe", () => "Education Towers", () => "towers_room.but_continue_active", () => "towers_room.towers_quality_create", () => "Button Towers lobby", () => "TOWERS_SCROLL", () => "towers_array.7.0", () => "?", a => {
    const b = a._GetNode(0);
    return () => and("towers_array.", b.ExpObject("towers.select"))
}
, () => "TOWERS_QUALITY_BLEND_0", () => "TOWERS_QUALITY_BLEND_1", () => "TOWERS_DESC", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() + c.ExpObject() / 2 - 5
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() - c.ExpObject() / 2 + 5
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("towers.select")
}
, () => "CREATE TOWERS IN QUALITY", () => "towers_room.skip_tween", () => "towers_room.music_control", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("UI_ROOM") + 400
}
, () => 52.2, () => "A1", () => "Y1", () => "A2", () => "X1", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() - 700
}
, () => "Y2", () => "Character Towers", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() - .5
}
, () => 240, () => "Theme", () => "music/towers_theme", () => 3.48, () => "TowersSelectItem", a => {
    const b = a._GetNode(0);
    return () => b.ExpInstVar_Family() - 1
}
, () => "CLOSE_PANEL", () => "AD_CONTINUE_TOWERS", () => "START_OVER_TOWERS", () => "closed_ad_continue_towers", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => b.ExpObject("towers.select") >= c.ExpObject("towers_array") - 1 ? 0 : add$jscomp$4(d.ExpObject("towers.select"), 1)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => 0 >= b.ExpObject("towers.select") ? c.ExpObject("towers_array") - 1 : subtract$jscomp$1(d.ExpObject("towers.select"), 1)
}
, a => {
    const b = a._GetNode(0);
    return () => and("towers_array.", b.ExpObject("towers.select")) + ".0"
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod();
    return () => b(c(11, 16))
}
, () => "Menu/LvUp", a => {
    const b = a._GetNode(0);
    return () => add$jscomp$4(b.ExpObject("towers.select"), 1)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b(c.ExpObject() / 83.1)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod();
    return () => b.ExpObject() + 42 + 83.1 * c()
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() / 20
}
, () => "start_scrollY", () => "start_create_towers_quality", () => 1.75, () => "zoom_towers", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("TOWERS")
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("TOWERS") + 1.5
}
, () => "scrollY", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b("TOWERS") - c.ExpObject()
}
, () => "scrollY2", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("BG0")
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b("BG0") - c.ExpObject()
}
, () => "scrollY3", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("BG2")
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b("BG2") - c.ExpObject()
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpBehavior("scrollY")
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("TOWERS_ITEM")
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("BG1")
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpBehavior("scrollY2")
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpBehavior("scrollY3")
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpBehavior("zoom_towers")
}
, () => "zoom_towers_quality", () => "TOWERS_QUALITY", a => {
    const b = a._GetNode(0);
    return () => b.ExpBehavior("zoom_towers_quality")
}
, () => "TOWERS_QUALITY_UI", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("TOWERS_QUALITY")
}
, a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => b.GetValue() * c.ExpObject(and("towers_array.", d.ExpObject("towers.select")))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() - c.ExpObject() / 2 + 30
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b("TOWERS_QUALITY") + c.ExpObject() + 200
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetVar();
    return () => subtract$jscomp$1(add$jscomp$4(b("TOWERS_QUALITY"), multiply$jscomp$1(c.GetValue(), d.ExpObject("towers_room.win"))), 2 * e.GetValue())
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() + (c.ExpObject() / 2 + 40)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("COINS") - 200
}
, () => "progressBarTowers_border", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => C3$jscomp$399.clamp(multiply$jscomp$1(divide$jscomp$1(subtract$jscomp$1(b.ExpObject("towers_room.win"), 2), c.ExpObject(and("towers_array.", d.ExpObject("towers.select")))), 590), 10, 590)
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() - 45
}
, () => "front", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(121, 88, 254)
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() + 91
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() + 73
}
, () => "NAME_CHARACTER_TOWERS", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b("TOWERS_QUALITY") + c.ExpObject() + 124
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetVar()
      , f = a._GetNode(4).GetVar()
      , h = a._GetNode(5);
    return () => subtract$jscomp$1(subtract$jscomp$1(add$jscomp$4(b("TOWERS_QUALITY"), multiply$jscomp$1(c.GetValue(), d.ExpObject("towers_room.win"))), e.GetValue()), multiply$jscomp$1(f.GetValue(), h.ExpObject("towers_room.win")))
}
, () => 1.85, a => {
    const b = a._GetNode(0).GetVar()
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3);
    return () => b.GetValue() * C3$jscomp$399.clamp(c.ExpObject("towers_room.win"), 1, d.ExpObject(and("towers_array.", e.ExpObject("towers.select"))))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2).GetBoundMethod();
    return () => b.ExpObject() - c.GetValue() * d()
}
, () => "towers_item_1", a => {
    const b = a._GetNode(0);
    return () => subtract$jscomp$1(b.ExpObject("towers_room.win"), 1)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4);
    return () => C3$jscomp$399.distanceTo(b.ExpObject(), c.ExpObject(), d.ExpObject(), e.ExpObject() + f.ExpObject()) / 270
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("UI_ROOM") - 400
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar();
    return () => b("TOWERS_QUALITY") + c.GetValue()
}
, () => "StartSkipTowers", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2).GetVar();
    return () => b.ExpObject() + (c.GetValue() + d.GetValue() / 2)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => C3$jscomp$399.clamp(multiply$jscomp$1(divide$jscomp$1(subtract$jscomp$1(b.ExpObject("towers_room.win"), 1), c.ExpObject(and("towers_array.", d.ExpObject("towers.select")))), 590), 10, 590)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4);
    return () => and("[color=#" + b.ExpInstVar() + "]", c(C3$jscomp$399.clamp(multiply$jscomp$1(divide$jscomp$1(subtract$jscomp$1(d.ExpObject("towers_room.win"), 1), e.ExpObject(and("towers_array.", f.ExpObject("towers.select")))), 100), 0, 100))) + "%[/color]"
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetVar();
    return () => C3$jscomp$399.clamp(b("TOWERS_QUALITY") + 1.15, .7, c.GetValue())
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetVar();
    return () => b(c.ExpObject(and(and("towers_array.", d.ExpObject("towers.select")) + ".", e.GetValue())), ",")
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4).GetVar()
      , h = a._GetNode(5).GetBoundMethod();
    return () => b(c(d.ExpObject(and(and("towers_array.", e.ExpObject("towers.select")) + ".", f.GetValue())), h(), ","))
}
, a => {
    const b = a._GetNode(0).GetVar();
    return () => and("TOWERS_QUALITY_BLEND_", b.GetValue() % 2)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod();
    return () => b.ExpObject() + 60 * c()
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetVar()
      , d = a._GetNode(2).GetVar()
      , e = a._GetNode(3).GetBoundMethod();
    return () => b.ExpObject() - c.GetValue() * d.GetValue() + 20 * e()
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetVar()
      , e = a._GetNode(3)
      , f = a._GetNode(4).GetVar()
      , h = a._GetNode(5).GetBoundMethod();
    return () => b.ExpObject() - c.ExpObject() / (2 * d.GetValue()) + e.ExpObject() / (f.GetValue() + 1) * h()
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3).GetBoundMethod()
      , f = a._GetNode(4).GetBoundMethod();
    return () => b(c(), d(255, 255, 255), e(173, 173, 173), f(117, 117, 117))
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => and("TOWERS_QUALITY_BLEND_", b() % 2)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetBoundMethod();
    return () => b(c.ExpObject(and(and("towers_array.", d.ExpObject("towers.select")) + ".", e())), ",")
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2).GetBoundMethod();
    return () => b.ExpObject(and(and("towers_array.", c.ExpObject("towers.select")) + ".", d()))
}
, () => "start_towers_game", a => {
    const b = a._GetNode(0);
    return () => 0 === b.ExpObject("towers_room.player_end_towers") ? 1 : .1
}
, () => "BrightnessCharacter", () => "Menu/LoadingTowers", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4);
    return () => add$jscomp$4(b.ExpObject(), multiply$jscomp$1(c.ExpObject(and("character.", d.ExpObject(e.ExpInstVar() - 1)) + ".param.offset.x"), f.ExpInstVar()))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3);
    return () => add$jscomp$4(b.ExpObject(), c.ExpObject(and("character.", d.ExpObject(e.ExpInstVar() - 1)) + ".param.offset.y"))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => and("[color=#" + b.ExpInstVar() + "]", c.ExpObject("VS")) + "[/color]"
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpBehavior("BrightnessCharacter")
}
, () => "end_flash_layer", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4)
      , h = a._GetNode(5)
      , l = a._GetNode(6)
      , m = a._GetNode(7).GetBoundMethod();
    return () => C3$jscomp$399.lerp(b("TOWERS"), C3$jscomp$399.lerp(c.ExpObject(), d.ExpObject() - 90, multiply$jscomp$1(divide$jscomp$1(Math.abs(e.ExpObject(and("scroll_", f.ExpObject("scrollName")) + ".scroll")), divide$jscomp$1(h.ExpObject(and("scroll_", l.ExpObject("scrollName")) + ".scrollM"), 2)), 1)), 5 * m())
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4)
      , h = a._GetNode(5)
      , l = a._GetNode(6)
      , m = a._GetNode(7).GetBoundMethod();
    return () => C3$jscomp$399.lerp(b("TOWERS_ITEM"), C3$jscomp$399.lerp(c.ExpObject(), d.ExpObject() - 90, multiply$jscomp$1(divide$jscomp$1(Math.abs(e.ExpObject(and("scroll_", f.ExpObject("scrollName")) + ".scroll")), divide$jscomp$1(h.ExpObject(and("scroll_", l.ExpObject("scrollName")) + ".scrollM"), 2)), 1)), 5 * m())
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4)
      , h = a._GetNode(5).GetBoundMethod();
    return () => C3$jscomp$399.lerp(b("TOWERS"), C3$jscomp$399.lerp(1, .8, multiply$jscomp$1(divide$jscomp$1(Math.abs(c.ExpObject(and("scroll_", d.ExpObject("scrollName")) + ".scroll")), divide$jscomp$1(e.ExpObject(and("scroll_", f.ExpObject("scrollName")) + ".scrollM"), 2)), 1)), 5 * h())
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4)
      , h = a._GetNode(5).GetBoundMethod();
    return () => C3$jscomp$399.lerp(b("TOWERS_ITEM"), C3$jscomp$399.lerp(1, .8, multiply$jscomp$1(divide$jscomp$1(Math.abs(c.ExpObject(and("scroll_", d.ExpObject("scrollName")) + ".scroll")), divide$jscomp$1(e.ExpObject(and("scroll_", f.ExpObject("scrollName")) + ".scrollM"), 2)), 1)), 5 * h())
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4)
      , h = a._GetNode(5)
      , l = a._GetNode(6)
      , m = a._GetNode(7).GetBoundMethod();
    return () => C3$jscomp$399.lerp(b("BG0"), C3$jscomp$399.lerp(c.ExpObject(), d.ExpObject() - 225, multiply$jscomp$1(divide$jscomp$1(Math.abs(e.ExpObject(and("scroll_", f.ExpObject("scrollName")) + ".scroll")), divide$jscomp$1(h.ExpObject(and("scroll_", l.ExpObject("scrollName")) + ".scrollM"), 2)), 1)), 5 * m())
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4)
      , h = a._GetNode(5).GetBoundMethod();
    return () => C3$jscomp$399.lerp(b("BG0"), C3$jscomp$399.lerp(0, -15, multiply$jscomp$1(divide$jscomp$1(Math.abs(c.ExpObject(and("scroll_", d.ExpObject("scrollName")) + ".scroll")), divide$jscomp$1(e.ExpObject(and("scroll_", f.ExpObject("scrollName")) + ".scrollM"), 2)), 1)), 5 * h())
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4)
      , h = a._GetNode(5)
      , l = a._GetNode(6)
      , m = a._GetNode(7).GetBoundMethod();
    return () => C3$jscomp$399.lerp(b("BG2"), C3$jscomp$399.lerp(c.ExpObject(), d.ExpObject() - 250, multiply$jscomp$1(divide$jscomp$1(Math.abs(e.ExpObject(and("scroll_", f.ExpObject("scrollName")) + ".scroll")), divide$jscomp$1(h.ExpObject(and("scroll_", l.ExpObject("scrollName")) + ".scrollM"), 2)), 1)), 5 * m())
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4)
      , h = a._GetNode(5).GetBoundMethod();
    return () => C3$jscomp$399.lerp(b("BG2"), C3$jscomp$399.lerp(0, -5, multiply$jscomp$1(divide$jscomp$1(Math.abs(c.ExpObject(and("scroll_", d.ExpObject("scrollName")) + ".scroll")), divide$jscomp$1(e.ExpObject(and("scroll_", f.ExpObject("scrollName")) + ".scrollM"), 2)), 1)), 5 * h())
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4)
      , h = a._GetNode(5)
      , l = a._GetNode(6)
      , m = a._GetNode(7)
      , p = a._GetNode(8)
      , r = a._GetNode(9)
      , v = a._GetNode(10)
      , x = a._GetNode(11)
      , B = a._GetNode(12)
      , A = a._GetNode(13).GetVar();
    return () => add$jscomp$4(add$jscomp$4(add$jscomp$4(add$jscomp$4(b(c.ExpObject(and("scroll_", d.ExpObject("scrollName")) + ".layerName")), e.ExpObject(and("scroll_", f.ExpObject("scrollName")) + ".offset.left")), h.ExpObject(and("scroll_", l.ExpObject("scrollName")) + ".offset.centerstep")), divide$jscomp$1(m.ExpObject(and("scroll_", p.ExpObject("scrollName")) + ".elementW"), 2)), multiply$jscomp$1(add$jscomp$4(r.ExpObject(and("scroll_", v.ExpObject("scrollName")) + ".elementW"), x.ExpObject(and("scroll_", B.ExpObject("scrollName")) + ".offset.centerstep")), A.GetValue()))
}
, () => "LoadTowersStart", () => "open", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4);
    return () => add$jscomp$4(add$jscomp$4(add$jscomp$4(50, multiply$jscomp$1(25, b.ExpObject("towers.select"))), 20 * c.ExpObject(and("towers_array.", d.ExpObject("towers.select")))), 2 < e.ExpObject("setting.level_bots") ? multiply$jscomp$1(25, subtract$jscomp$1(f.ExpObject("setting.level_bots"), 2)) : 0)
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1);
    return () => b(c.ExpObject()) - 250
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetVar()
      , f = a._GetNode(4);
    return () => and("[offsetY=-5][color=#" + b.ExpInstVar() + "]" + c(d.ExpObject("TOWERS_WIN_FULL_DESC"), e.GetValue()) + "[/offsetY][/color][scale=", f.ExpObject() + .05) + "]\u2600\ufe0f[/scale]"
}
, a => {
    const b = a._GetNode(0);
    return () => subtract$jscomp$1(b.ExpObject("select_character.max_character"), 2)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4)
      , h = a._GetNode(5)
      , l = a._GetNode(6).GetVar();
    return () => "[color=#" + b.ExpInstVar() + "]" + c(d.ExpObject("TOWERS_UNLOCKED_CHARACTER_DESC"), e.ExpObject(and("character.", f.ExpObject(add$jscomp$4(h.ExpObject("towers.select"), 2))) + ".name." + l.GetValue())) + "[/color]"
}
, a => {
    const b = a._GetNode(0);
    return () => add$jscomp$4(b.ExpObject("towers.select"), 2)
}
, () => "unlocked", () => 93, a => {
    const b = a._GetNode(0);
    return () => and("towers.open.", subtract$jscomp$1(b.ExpObject("towers.select"), 1))
}
, a => {
    const b = a._GetNode(0);
    return () => and("[color=#FFFFFF]", b.ExpObject("TOWERS_UNLOCKED_DESC")) + "[/color]"
}
, a => {
    const b = a._GetNode(0);
    return () => and("[color=#FF0000]", b.ExpObject("BLOCKED")) + "[/color]"
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() - (60 - c.ExpObject() / 600 * 60)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() - (c.ExpObject() + 45)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject(and("towers_array.", c.ExpInstVar() - 1))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod();
    return () => b.ExpObject() - 9 - 83.5 * c()
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() - 12
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetBoundMethod();
    return () => b(c.ExpObject(and(and("towers_array.", d.ExpInstVar() - 1) + ".", e())), ",")
}
, () => "Animation 2", a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetBoundMethod();
    return () => b(c.ExpObject(and(and("towers_array.", d.ExpInstVar() - 1) + ".", e()))) - 1
}
, a => {
    const b = a._GetNode(0).GetBoundMethod()
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => b(c.ExpObject(and("scroll_", d.ExpObject("scrollName")) + ".layerName")) - 100
}
, () => "TowersItem", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetBoundMethod();
    return () => 83.1 * ("?" === b.ExpObject(and("towers_array.", c()) + ".0") ? 10 : d.ExpObject(and("towers_array.", e())))
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() - c.ExpObject() / 2 + 4
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() - (c.ExpObject() + 150)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1).GetBoundMethod()
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4);
    return () => and("[color=#" + b.ExpInstVar() + "]", c(C3$jscomp$399.clamp(multiply$jscomp$1(divide$jscomp$1(subtract$jscomp$1(d.ExpObject("towers.progress.win"), 1), e.ExpObject(and("towers_array.", f.ExpObject("towers.progress.select")))), 100), 0, 100))) + "%[/color]"
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => and("towers.open.", b())
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() + 5 - c.ExpObject() / 2
}
, () => "mini_towers", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(70, 255, 46)
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() + 22
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() - 10 - c.ExpObject()
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => and("towers_array.", b()) + ".0"
}
, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(97, 97, 97)
}
, a => {
    const b = a._GetNode(0).GetVar();
    return () => and("towers.open.", b.GetValue() - 1)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3)
      , f = a._GetNode(4)
      , h = a._GetNode(5)
      , l = a._GetNode(6)
      , m = a._GetNode(7);
    return () => divide$jscomp$1(add$jscomp$4(add$jscomp$4(b.ExpObject(and("scroll_", c.ExpObject("scrollName")) + ".offset.centerstep"), d.ExpObject(and("scroll_", e.ExpObject("scrollName")) + ".elementW")), add$jscomp$4(f.ExpObject(and("scroll_", h.ExpObject("scrollName")) + ".elementW"), l.ExpObject(and("scroll_", m.ExpObject("scrollName")) + ".offset.centerstep"))), 2)
}
, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() - 1200
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => add$jscomp$4(b.ExpObject(and("scroll_", c.ExpObject("scrollName")) + ".maxSize"), 3E3)
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetBoundMethod();
    return () => C3$jscomp$399.distanceTo(b.ExpObject(), c.ExpObject(), d.ExpObject(), e("BG")) + 25
}
, a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2)
      , e = a._GetNode(3).GetBoundMethod();
    return () => C3$jscomp$399.distanceTo(b.ExpObject(), c.ExpObject(), d.ExpObject(), e("BG"))
}
, () => "Animation Reward Towers Win ", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1)
      , d = a._GetNode(2);
    return () => C3$jscomp$399.clamp(multiply$jscomp$1(divide$jscomp$1(subtract$jscomp$1(b.ExpObject("towers.progress.win"), 1), c.ExpObject(and("towers_array.", d.ExpObject("towers.progress.select")))), 870), 10, 870)
}
, () => "ProgressBarText", a => {
    const b = a._GetNode(0)
      , c = a._GetNode(1);
    return () => b.ExpObject() - c.ExpObject() / 2 - 5
}
, () => "reward_ad_continue_towers", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject("towers.progress.win")
}
];
var module$content$working$771029573$c3runtime = {};
const scriptsInEvents$$module$content$working$771029573$scripts$project$scriptsInEvents = {
    async Var_Event402_Act2(a, b) {
        feedback_review(a)
    },
    async ESelectCharacter_Event1_Act3(a, b) {
        window.addEventListener("focus", c => {
            a.callFunction("volume_change", !0)
        }
        , !1);
        window.addEventListener("blur", c => {
            a.callFunction("volume_change", !1)
        }
        , !1)
    },
    async ELoader_Event1_Act1(a, b) {
        window.addEventListener("keydown", c => {
            ["ArrowDown", "ArrowUp", " "].includes(c.key) && c.preventDefault()
        }
        );
        window.addEventListener("wheel", c => c.preventDefault(), {
            passive: !1
        })
    }
};
self.C3.ScriptsInEvents = scriptsInEvents$$module$content$working$771029573$scripts$project$scriptsInEvents;
var module$content$working$771029573$scripts$project$scriptsInEvents = {};
var module$content$working$771029573$__c3root__ = {};
